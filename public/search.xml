<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用 AccountManager 实现系统内共享账号</title>
      <link href="/2020/09/04/AccountManager/"/>
      <url>/2020/09/04/AccountManager/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-AccountManager-实现系统内共享账号"><a href="#使用-AccountManager-实现系统内共享账号" class="headerlink" title="使用 AccountManager 实现系统内共享账号"></a>使用 AccountManager 实现系统内共享账号</h1><p>在开发过程中我们可能遇到自家应用间共享账号的场景。例如 APP1 登录成功后，启动 APP2 时自动完成登录并与 APP1 共享账号信息。</p><p>Android 为我们提供了AccountManager 来管理账号信息。</p><p><a href="https://github.com/Flywith24/AccountManagerDemo" target="_blank" rel="noopener">demo 地址</a></p><a id="more"></a><h2 id="共享前提"><a href="#共享前提" class="headerlink" title="共享前提"></a>共享前提</h2><ol><li>两个 app 在一个用户组内</li><li>使用相同的签名（使用 debug 默认签名也可以共享）</li><li>accountType 相同</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>AccountManager是一个面向应用程序开发的组件，它提供了一套对应于 IAccountManager 协议的应用程序接口；这组接口通过Binder机制与系统服务AccountManagerService进行通信，协作完成帐号相关的操作。同时，AccountManager接收authenticators 提供的回调，以便在帐号操作完成之后向<em>调用此帐号服务的业务</em>返回对应的接口，同时触发这个业务对结果的处理。<br>- authenticators 即注册帐号服务的app；<br>- 业务调用方 即使用authenticators提供的帐号服务的第三方，也可以是authenticator自己</p><p>摘自：<a href="https://blog.csdn.net/dzkdxyx/article/details/78569867" target="_blank" rel="noopener">Android AccountManager帐号管理（一）</a></p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>该项目中有两个 module ，app 对应注册账号服务的app，app1 对应使用账号服务的第三方应用</p><ul><li><p>在两个应用的 manifest 中加入 <code>&lt;uses-permission android:name=&quot;android.permission.GET_ACCOUNTS&quot; /&gt;</code> 权限</p></li><li><p>在 app 中创建 <code>authenticator.xml</code> 文件，注意 accountType 的配置，这里的应用名及 icon 会在设备的 设置 -&gt; 账号 中显示</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904152225.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p></li><li><p>在 app 中注册一个 action 为“android.accounts.AccountAuthenticator”的 authenticator service，引入上一步创建的 xml 文件</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904152006.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904152029.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p></li></ul><ul><li><p>在 app 中创建  authenticator</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904151929.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p></li></ul><h2 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904153019.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h2 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904153112.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h2 id="第三方-app-获取-用户，token-等信息"><a href="#第三方-app-获取-用户，token-等信息" class="headerlink" title="第三方 app 获取 用户，token 等信息"></a>第三方 app 获取 用户，token 等信息</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904154855.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
      
      
      <categories>
          
          <category> ROM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROM </tag>
            
            <tag> framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【折腾Framework】源码编译与烧写</title>
      <link href="/2020/08/18/Framework-Compile/"/>
      <url>/2020/08/18/Framework-Compile/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>环境搭建等内容网上资料很多，这里不再赘述。</p><p>此处以 Pixel 3a &amp; Android 10 为例介绍如何编译 ROM 包并烧录</p><p>手上没有真机的小伙伴可以选择制作模拟器，本文最后提供了基于 Android 10 编译的自定义 AVD 下载链接</p><a id="more"></a><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p><a href="https://source.android.com/setup/build/initializing" target="_blank" rel="noopener">官方文档</a></p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>这里推荐使用 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">清华镜像</a></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200628155443.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>下载 <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="noopener">每月更新的初始化包</a> 并解压</p><h2 id="下载驱动（可选）"><a href="#下载驱动（可选）" class="headerlink" title="下载驱动（可选）"></a>下载驱动（可选）</h2><p>如果要刷到真机上，需要下载相应机型的驱动，进入 <a href="https://developers.google.com/android/drivers" target="_blank" rel="noopener">该链接</a>，选择相应的机型对应的 Android 版本号和驱动</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200628160058.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我这里选择的是 Android 10.0.0（QQ3A.200605.002.A1）</p><p>将两个驱动文件下载并解压，并执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">./extract-qcom-sargo.sh<br>./extract-google_devices-sargo.sh<br></code></pre></td></tr></table></figure><p>点击 Enter 并输入 I ACCEPT 同意 License</p><p>根据 Build 在 <a href="https://source.android.com/setup/start/build-numbers" target="_blank" rel="noopener">该链接</a> 中找到相匹配的分支，本例中对应 <code>android-10.0.0_r39</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200628160259.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="QQ3A.200605.002.A1 对应的分支"></p><h2 id="选择分支"><a href="#选择分支" class="headerlink" title="选择分支"></a>选择分支</h2><p>执行完上述操作如果直接编译的话实际上是编译的 master 分支，我们还需要切换到想要编译的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-10.0.0_r39 --depth=1<br>repo sync -j8<br>repo start android-10.0.0_r39 --all<br></code></pre></td></tr></table></figure><h2 id="编译与烧写"><a href="#编译与烧写" class="headerlink" title="编译与烧写"></a>编译与烧写</h2><p>在源码目录执行</p><p><code>source build/envsetup.sh</code></p><p><code>lunch</code> 进入菜单</p><p>选择相应的版本</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200628162935.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我这里选择的是 19</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>接着便可以进行编译了，可以使用 <code>make -j</code> 命令，其中 j 代表的是编译 job 的数量</p><p>执行（我这里指定了生成 log 文件）</p><p><code>make -j32 2&gt;&amp;1 | tee build_20200628_1635.log</code></p><p>编译成功后会出现一个 out 目录，ROM 镜像文件就在此处</p><p>例如我的路径为：<code>~/aosp/out/target/product/sargo</code></p><h2 id="烧写"><a href="#烧写" class="headerlink" title="烧写"></a>烧写</h2><p>设备进入 bootloader 并执行：<code>fastboot flashall -w</code>，其中 -w 代表清空数据</p><p>烧写成功，开机！</p><h2 id="制作自定义-AVD（Android-Virtual-Devices）-系统镜像"><a href="#制作自定义-AVD（Android-Virtual-Devices）-系统镜像" class="headerlink" title="制作自定义 AVD（Android Virtual Devices） 系统镜像"></a>制作自定义 AVD（Android Virtual Devices） 系统镜像</h2><p>很多小伙伴没有相应的真机，不过可以制作出自定义的 AVD 作为模拟器使用。</p><p><code>lunch</code> 进入菜单时选择相应的模拟器，例如选择上图的 24，64 位的通用设备</p><p>想要制作 AVD 系统镜像需要制作附加 <code>sdk</code> 和 <code>sdk_repo</code> 软件包</p><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span> make -j32 sdk sdk_repo<br></code></pre></td></tr></table></figure><p>该操作可能会出现异常，例如</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200818135050.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这是由于没有编译这些工具导致的，解决办法是依次编译这些工具</p><p>依次输入如下命令，后面工具视情况而定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span> make libaapt2_jni<br><span class="hljs-meta"><br>$</span> make dmtracedump<br><span class="hljs-meta"><br>$</span> make etc1tool<br><span class="hljs-meta"><br>$</span> make deployagent<br><span class="hljs-meta"><br>$</span> make aapt<br><span class="hljs-meta"><br>$</span> make split-select<br><span class="hljs-meta"><br>$</span> make bcc_compat<br><span class="hljs-meta"><br>$</span> make apksigner<br><span class="hljs-meta"><br>$</span> make dx<br><span class="hljs-meta"><br>$</span> make layoutlib-legacy<br></code></pre></td></tr></table></figure><p>编译好相关工具我们再次执行 <code>make -j32 sdk sdk_repo</code></p><p>编译成功后会在 <code>out/host/linux-x86/sdk/aosp_x86_64</code> 目录下生成 <code>sdk-repo-linux-system-images-eng.[username].zip</code> 文件</p><p>按照官方文档中使用镜像的方式我没有成功</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200818135851.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这里我使用了一个取巧的方式</p><p>我们在 Android Studio 创建 AVD 时可选的镜像一般有三种，这里还是以 Android 10 为例</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200818140305.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>Google Play，Google APIs，和默认的</p><p>它们会下载到 SDK/system-images/android-29 中</p><p>Google APIs 版本对应的目录就是 google_apis</p><p>我们可以将我们编译出的 AVD 镜像 copy 到其中的一个目录</p><p>例如，我将自定义的 AVD 镜像放置在了这里：</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200818140734.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我们在创建模拟器时选择自定义的 AVD 镜像即可创建出自己编译 ROM  的模拟器</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200818141020.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这里提供了我编译出来的自定义 AVD，不方便自己编译的小伙伴可以在此处下载</p><p>链接：<a href="https://pan.baidu.com/s/1LIcuycoU4Ou42VsSBM_MuQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1LIcuycoU4Ou42VsSBM_MuQ</a><br>提取码：CAVD</p>]]></content>
      
      
      <categories>
          
          <category> ROM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROM </tag>
            
            <tag> framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【奇技淫巧】使用 ProcessLifecycle 优雅地监听应用前后台切换</title>
      <link href="/2020/07/01/Tips-ProcessLifecycle/"/>
      <url>/2020/07/01/Tips-ProcessLifecycle/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴见到你，又来到了「奇技淫巧」系列，本系列介绍一些「骚操作」，可能不适合用于生产，但可以开拓思路</p><p>前些天在群里看到有人讨论通过维护 activity 栈来监听程序前后台切换的问题。其实单纯监听程序的前后台切换完全不需要维护 activity 栈，而现在比较主流的做法是使用 <code>registerActivityLifecycleCallbacks</code>。而今天我来介绍一下使用 ProcessLifecycleOwner 来实现这一功能</p><a id="more"></a><h2 id="lifecycle-process-库"><a href="#lifecycle-process-库" class="headerlink" title="lifecycle-process 库"></a>lifecycle-process 库</h2><p>Android Jetpack Lifecycle 组件有一个可选库：lifecycle-process，它可以为整个 app 进程提供一个 ProcessLifecycleOwner</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701110431.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="lifecycle-process 引入"></p><p>该库十分简单，只有四个文件</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701110904.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="lifecycle-process"></p><p><code>ProcessLifecycleOwnerInitializer</code> 借助 ContentProvider 拿到 Context，用于初始化操作</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701112017.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="init"></p><p><code>EmptyActivityLifecycleCallbacks</code> 为 <code>Application.ActivityLifecycleCallbacks</code> 的实现类，内部为空实现</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701112219.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="EmptyActivityLifecycleCallbacks"></p><p><code>LifecycleDispatcher</code> 通过 ReportFragment 来 hook 宿主的生命周期事件</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701113143.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>核心逻辑都在 ProcessLifecycleOwner 中</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701113324.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ProcessLifecycleOwner "></p><p>该类提供了整个 app 进程的 lifecycle</p><p>可以将其视为所有 activity 的 LifecycleOwner ，其中 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_CREATE" target="_blank" rel="noopener">Lifecycle.Event.ON_CREATE</a> 只会分发一次，而 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_DESTROY" target="_blank" rel="noopener">Lifecycle.Event.ON_DESTROY</a> 则永远不会分发</p><p>其它的生命周期事件将按以下规则分发：</p><p><code>ProcessLifecycleOwner</code> 会分发 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_START" target="_blank" rel="noopener">Lifecycle.Event.ON_START</a> 和 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_RESUME" target="_blank" rel="noopener">Lifecycle.Event.ON_RESUME</a> 事件（在第一个 activity 移动到这些事件时）</p><p><a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_PAUSE" target="_blank" rel="noopener">Lifecycle.Event.ON_PAUSE</a> 与 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_STOP" target="_blank" rel="noopener">Lifecycle.Event.ON_STOP</a> 会在最后一个 activity 移动到这些状态后 <strong>延迟</strong> 分发，该延迟足够长，以确保由于配置更改等操作重建 activity 后不会分发任何事件</p><p>对于监听应用在前后台切换且不需要毫秒级的精度的场景，这十分有用</p><h2 id="ProcessLifecycleOwner-源码解析"><a href="#ProcessLifecycleOwner-源码解析" class="headerlink" title="ProcessLifecycleOwner  源码解析"></a>ProcessLifecycleOwner  源码解析</h2><p>根据上图我们得知 <code>ProcessLifecycleOwner</code>  实现了 LifecycleOwner 接口</p><p>由于在 <code>ProcessLifecycleOwnerInitializer</code> 中初始化时传入了 Context，因此 <code>ProcessLifecycleOwner</code>  在 attach 方法中借助 Context 拿到了 Application 实例，并调用了 <code>registerActivityLifecycleCallbacks</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>    mHandler = <span class="hljs-keyword">new</span> Handler();<br>    mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);<br>    Application app = (Application) context.getApplicationContext();<br>    app.registerActivityLifecycleCallbacks(<span class="hljs-keyword">new</span> EmptyActivityLifecycleCallbacks() <br>        <span class="hljs-meta">@RequiresApi</span>(<span class="hljs-number">29</span>)<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPreCreated</span><span class="hljs-params">(@NonNull Activity activity,<br>                @Nullable Bundle savedInstanceState)</span> </span>&#123;<br>            <span class="hljs-comment">//我们需要 ProcessLifecycleOwner 刚好在第一个 activity 的 LifecycleOwner started/resumed 之前获取 ON_START 和 ON_RESUME。</span><br>            <span class="hljs-comment">//activity 的 LifecycleOwner 通过在 onCreate() 中添加 activity 注册的 callback 来获取 started/resumed 状态。</span><br>            <span class="hljs-comment">//通过在 onActivityPreCreated() 中添加我们自己的 activity 注册的 callback，我们首先获得了回调，同时与 Activity 的 onStart()/ onResume()回调相比仍具有正确的相对顺序</span><br>     <br>            activity.registerActivityLifecycleCallbacks(<span class="hljs-keyword">new</span> EmptyActivityLifecycl<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPostStarted</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>                    activityStarted();<br>                &#125;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPostResumed</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>                    activityResumed();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(Activity activity, Bundle savedInstanceStat<br>            //仅在API <span class="hljs-number">29</span> 之前使用 ReportFragment，在此之后，我们可以使用在 onActivityPreCreated()</span> 中注册的 onActivityPostStarted 和 onActivityPostResumed 回调<br>            <span class="hljs-title">if</span> <span class="hljs-params">(Build.VERSION.SDK_INT &lt; <span class="hljs-number">29</span>)</span> </span>&#123;<br>                ReportFragment.get(activity).setProcessListener(mInitializationLi<br>            &#125;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPaused</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>            activityPaused();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityStopped</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>            activityStopped();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>内部维护了 Started 和 Resumed 的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mStartedCounter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mResumedCounter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> mPauseSent = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> mStopSent = <span class="hljs-keyword">true</span>;<br></code></pre></td></tr></table></figure><p>并在 activityStarted 和 activityResumed 方法中对 这两个数值进行 ++，并更改 lifecycle 状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activityStarted</span><span class="hljs-params">()</span> </span>&#123;<br>    mStartedCounter++;<br>    <span class="hljs-keyword">if</span> (mStartedCounter == <span class="hljs-number">1</span> &amp;&amp; mStopSent) &#123;<br>        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);<br>        mStopSent = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activityResumed</span><span class="hljs-params">()</span> </span>&#123;<br>    mResumedCounter++;<br>    <span class="hljs-keyword">if</span> (mResumedCounter == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mPauseSent) &#123;<br>            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);<br>            mPauseSent = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mHandler.removeCallbacks(mDelayedPauseRunnable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 activityPaused 和 activityStopped 方法对这两个数值进行 –</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activityPaused</span><span class="hljs-params">()</span> </span>&#123;<br>    mResumedCounter--;<br>    <span class="hljs-keyword">if</span> (mResumedCounter == <span class="hljs-number">0</span>) &#123;<br>        mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activityStopped</span><span class="hljs-params">()</span> </span>&#123;<br>    mStartedCounter--;<br>    dispatchStopIfNeeded();<br>&#125;<br></code></pre></td></tr></table></figure><p>而在这里我们看到了上文提到的延迟操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 handler 进行延迟操作</span><br>mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);<br><br><span class="hljs-comment">// 延迟 700 ms</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> TIMEOUT_MS = <span class="hljs-number">700</span>; <span class="hljs-comment">//mls</span><br><br><span class="hljs-keyword">private</span> Runnable mDelayedPauseRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 根据需要分发事件</span><br>        dispatchPauseIfNeeded();<br>        dispatchStopIfNeeded();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchPauseIfNeeded</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mResumedCounter == <span class="hljs-number">0</span>) &#123;<br>        mPauseSent = <span class="hljs-keyword">true</span>;<br>        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchStopIfNeeded</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mStartedCounter == <span class="hljs-number">0</span> &amp;&amp; mPauseSent) &#123;<br>        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);<br>        mStopSent = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码就解析到这里，接下来我们看看如何使用吧</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先引入该库</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-process:2.3.0-alpha05"</span><br></code></pre></td></tr></table></figure><p>由于我们要自定义 lifecycleObserver，因此还需引入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-common-java8:2.3.0-alpha05"</span><br></code></pre></td></tr></table></figure><p>首先创建 <code>ProcessLifecycleObserver</code> 类，实现 <code>DefaultLifecycleObserver</code> 接口，在相应的生命周期中打印 log</p><p>接着在自定义 Application 中加入</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701121028.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这样便完成了！</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/7/1/173089686a09e8f3?w=1854&h=999&f=gif&s=2823298" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="演示"></p><p><a href="https://github.com/Flywith24/ProcessLifecycle-Demo" target="_blank" rel="noopener">Demo 在这里</a></p><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案</a></li></ul><ul><li><a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></li></ul><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你</a></li></ul><ul><li><a href="https://juejin.im/post/5e967f35f265da47d77cd4c3" target="_blank" rel="noopener">【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转</a></li></ul><ul><li><a href="https://juejin.im/post/5ebdfb0b6fb9a0436153db22" target="_blank" rel="noopener">【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil</a></li></ul><ul><li><a href="https://juejin.im/post/5ec50ae46fb9a047a862124f" target="_blank" rel="noopener">【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化</a></li></ul><ul><li><a href="https://juejin.im/post/5ecde219e51d457841190d08" target="_blank" rel="noopener">【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</a></li></ul><ul><li><a href="https://juejin.im/post/5ed9c92ce51d45789b35afa9" target="_blank" rel="noopener">【奇技淫巧】巧用 kotlin 扩展函数和 typealias 封装 带网络状态和解决「粘性」事件的 LiveData</a></li></ul><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
            <tag> 奇技淫巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化</title>
      <link href="/2020/05/20/Tips-Navagion+DynamicFeatureModule/"/>
      <url>/2020/05/20/Tips-Navagion+DynamicFeatureModule/</url>
      
        <content type="html"><![CDATA[<p><code>androidx navigation 2.3.0</code> 加入了对 <code>dynamic feature module</code> 的导航支持，因此我们利用这个来分离出多个功能 module 来实现模块化</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520170621.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="navigation 2.3.0 更新"></p><a id="more"></a><h2 id="国内基本不用的-dynamic-feature-module"><a href="#国内基本不用的-dynamic-feature-module" class="headerlink" title="国内基本不用的 dynamic feature module"></a>国内基本不用的 dynamic feature module</h2><p><a href="https://developer.android.com/guide/app-bundle" target="_blank" rel="noopener">Android App Bundle</a> 是官方 18 年推出的动态发布方案，类似国内各种插件化方案。不过它需要 Google Play Store 支持，这导致在国内无法使用</p><p>借着 navigation 组件支持 <code>dynamic feature module</code> 间导航的契机，我们可以使用 <code>dynamic feature module</code> 来拆分功能模块以实现模块化</p><p>传统的拆分方案大概是这样，feature module 之间相互隔离，app module 依赖各个 feature module 间接依赖 base 库，公共库</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520165717.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="传统架构"></p><p>而使用 <code>dynamic feature module</code> ，其结构是这样的</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520172609.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="dynamic feature 架构"></p><p><code>dynamic feature module</code> 也可以按需安装，也就是说，它们可能不包含在用户最初下载的 APK 中，而是在运行时安装。而我们可以直接将它们包含到 APK 中</p><h2 id="使用-dynamic-feature-module"><a href="#使用-dynamic-feature-module" class="headerlink" title="使用 dynamic feature module"></a>使用 dynamic feature module</h2><p>首先我们在 base lib 中引入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-keyword">def</span> nav_version = <span class="hljs-string">"2.3.0-alpha06"</span><br><br>    api <span class="hljs-string">"androidx.navigation:navigation-fragment-ktx:$nav_version"</span><br>    api <span class="hljs-string">"androidx.navigation:navigation-ui-ktx:$nav_version"</span><br>    api <span class="hljs-string">"androidx.navigation:navigation-dynamic-features-fragment:$nav_version"</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 app module 中的 res/navigation 目录下创建 main_nav.xml</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520173227.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="main_nav.xml"></p><p>接着我们在 activity_main 中设置默认的 host</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520173336.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="默认 host"></p><blockquote><p>这里不同于正常 navigation 的用法，没有使用 NavHostFragment，而是使用 DynamicNavHostFragment</p></blockquote><h3 id="直接跳转-fragment"><a href="#直接跳转-fragment" class="headerlink" title="直接跳转 fragment"></a>直接跳转 fragment</h3><p>我们创建 dynamic feature module ，取名为 feature1</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520174302.gif" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="创建 dynamic feature module"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520174505.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="包名前部分需保证与 applicationId 相同"></p><blockquote><p>这里 <code>dynamic feature module</code> 的包名前部分要和 applicationId 即 app module 包名相同，否则后续的 include 操作会有问题</p></blockquote><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520174757.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="选择加载模式"></p><p>这里我们选择在安装时集成该 module</p><p>接着我们在该 module 下创建一个 fragment 取名为 <code>Feature1OneFragment</code></p><p>之后我们直接在 main_nav.xml 中引入 该 fragment 并加入 action</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520175351.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="直接引入 fragment"></p><p>接着我们就可以在 app 下的 MainFragment 打开 Feature1OneFragment</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520175841.gif" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="启动 fragment"></p><blockquote><p>我的 demo 中 feature2 是直接引入 fragment，因此跳转的是 Feature2OneFragment</p></blockquote><h3 id="直接跳转-activity"><a href="#直接跳转-activity" class="headerlink" title="直接跳转 activity"></a>直接跳转 activity</h3><p>在 feature1 中创建 activity (demo 中为 feature2)</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520180201.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="跳转 activity"></p><p>同样需要指定 moduleName</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520180434.gif" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="启动activity"></p><h3 id="使用-dynamic-feature-module-内部的-graph"><a href="#使用-dynamic-feature-module-内部的-graph" class="headerlink" title="使用 dynamic feature module 内部的 graph"></a>使用 dynamic feature module 内部的 graph</h3><p>我们可以为 dynamic feature module 单独配置 navigation graph，这样就可以处理 dynamic feature module 内部的跳转了</p><p>在 feature1 中创建 feature1_nav.xml ，其中 startDestination 为 Feature1OneFragment</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520181021.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="feature1_nav.xml"></p><p>在 main_nav.xml 我们需要使用另外一种方式来使用该 graph</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520181145.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="include-dynamic"></p><p>我们使用了一个新的标签 <code>include-dynamic</code>，同时我们看到了几个没用过的属性</p><ul><li><code>graphPackage</code> 为 <code>dynamic feature module</code> 的包名</li><li><code>graphResName</code> 为 <code>dynamic feature module</code> 内部 graph 的名字</li><li><code>moduleName</code> 为 module 名</li></ul><blockquote><p>注意：这里的 graphPackage 可以省略</p><ol><li>如果 module 的包名没用按照前文的格式配置会导致无法找到 graphId 的异常</li><li>include-dynamic 标签的 id 要与 <code>feature1_nav.xml</code> navigation 标签下的 id 一致，或者后者不设置 id</li></ol></blockquote><p>这样从 app module 导航到 feature1 的 startDestination 后便可使用其内部的逻辑进行后续的导航了</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520182339.gif" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="include 跳转"></p><h2 id="feature-module-间跳转"><a href="#feature-module-间跳转" class="headerlink" title="feature module 间跳转"></a>feature module 间跳转</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520182529.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="暂不支持 deep link"></p><p>Navigation 组件暂不支持 Dynamic include graph 的 deep link</p><p>因此我目前也没有找到特别优雅的方式，已知的方案如下</p><ul><li>反射</li><li>使用 <a href="https://developer.android.com/reference/java/util/ServiceLoader" target="_blank" rel="noopener">ServiceLoader</a></li><li>使用依赖注入</li></ul><p><a href="https://github.com/Flywith24/DynamicFeatureDemo" target="_blank" rel="noopener">demo</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
            <tag> 奇技淫巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil</title>
      <link href="/2020/05/18/Tips-Coil/"/>
      <url>/2020/05/18/Tips-Coil/</url>
      
        <content type="html"><![CDATA[<h2 id="新的图片加载库——Coil"><a href="#新的图片加载库——Coil" class="headerlink" title="新的图片加载库——Coil"></a>新的图片加载库——Coil</h2><p><a href="https://coil-kt.github.io/coil/" target="_blank" rel="noopener">Coil</a> 是 <a href="https://www.instacart.com/" target="_blank" rel="noopener">Instacart</a> 团队研发的新的的图片加载库，它使用了很多高级功能，例如协程，<code>Okhttp</code>，<code>androidx.lifecycle</code>。<code>Coil</code> 还包括一些高级功能，例如图像采样，有效的内存使用以及请求的自动取消/暂停</p><p>默认情况下 <code>Coil</code> 与 R8 完全兼容，开箱即用，不需要添加额外的规则。如果使用 Proguard ，您可能需要为 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/resources/META-INF/proguard/coroutines.pro" target="_blank" rel="noopener">Coroutines</a>, <a href="https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro" target="_blank" rel="noopener">OkHttp</a> 和 <a href="https://github.com/square/okio/blob/master/okio/src/jvmMain/resources/META-INF/proguard/okio.pro" target="_blank" rel="noopener">Okio</a> 添加规则</p><a id="more"></a><h2 id="Coil-的优势"><a href="#Coil-的优势" class="headerlink" title="Coil 的优势"></a>Coil 的优势</h2><ul><li>快速：<code>Coil</code> 进行了很多优化，包括内存和磁盘缓存，对内存中的图像进行采样，重新使用位图，自动暂停/取消请求等等</li><li>轻量：<code>Coil</code> 在您的APK中添加了约 2000 种方法（对于已经使用 <code>OkHttp</code> 和 <code>Coroutines</code> 的应用程序），与 <code>Picasso</code> 相当，远少于 <code>Glide</code> 和 <code>Fresco</code></li><li>易用：<code>Coil</code> 的 API 利用 Kotlin 的特性简化了样板代码</li><li>现代：<code>Coil</code> 是 <code>Kotlin-first</code>，使用现代化的库，例如 <code>Coroutines</code>, <code>OkHttp</code>, <code>Okio</code>, 以及 <code>AndroidX Lifecycles</code></li></ul><p><code>Coil</code> 是以下名称的缩写：<strong>Coroutine Image Loader</strong></p><h2 id="Artifacts"><a href="#Artifacts" class="headerlink" title="Artifacts"></a>Artifacts</h2><p><code>Coil</code> 拥有 5 个 artifact 并发布在 <code>mavenCentral()</code></p><ul><li><code>io.coil-kt:coil</code>：依赖于  <code>io.coil-kt:coil-base</code> 并且包含了 <code>Coil</code> 的单例和  <code>ImageView.load</code> 的扩展函数</li><li><code>io.coil-kt:coil-base</code>：base 库，<strong>不包含</strong> <code>Coil</code> 的单例和  <code>ImageView.load</code> 的扩展函数，如果使用依赖注入，则可以使用该库</li><li><code>io.coil-kt:coil-gif</code>：引入一系列解码器以支持解码 gif</li><li><code>io.coil-kt:coil-svg</code>：引入一系列解码器以支持 svg</li><li><code>io.coil-kt:coil-video</code>：包括两个 <a href="https://coil-kt.github.io/coil/api/coil-base/coil.fetch/-fetcher" target="_blank" rel="noopener">fetchers</a> ，以支持从 Android 支持的任何视频格式中提取和解码帧</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 普通使用引用</span><br>implementation <span class="hljs-string">"io.coil-kt:coil:0.11.0"</span><br><span class="hljs-comment">// 使用依赖注入时或者制作基于 coil 的库引用</span><br>implementation <span class="hljs-string">"io.coil-kt:coil-base:0.11.0"</span><br></code></pre></td></tr></table></figure><h2 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h2><p><code>Coil</code> 要求 Java 8，要通过 D8 启用 Java 8 调试，请将以下内容添加到 Gradle 脚本</p><p>Gradle (<code>.gradle</code>)</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    compileOptions &#123;<br>        sourceCompatibility JavaVersion.VERSION_1_8<br>        targetCompatibility JavaVersion.VERSION_1_8<br>    &#125;<br>&#125;<br><br>tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all &#123;<br>    kotlinOptions &#123;<br>        jvmTarget = <span class="hljs-string">"1.8"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Gradle Kotlin DSL (<code>.gradle.kts</code>)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">android &#123;<br>    compileOptions &#123;<br>        sourceCompatibility = JavaVersion.VERSION_1_8<br>        targetCompatibility = JavaVersion.VERSION_1_8<br>    &#125;<br>&#125;<br><br>tasks.withType&lt;KotlinCompile&gt; &#123;<br>    kotlinOptions &#123;<br>        jvmTarget = <span class="hljs-string">"1.8"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="ImageView-扩展函数"><a href="#ImageView-扩展函数" class="headerlink" title="ImageView 扩展函数"></a>ImageView 扩展函数</h3><p><code>io.coil-kt:coil</code> 提供了 类型安全的 ImageView 扩展函数</p><p>在 ImageView 中加载图片，只需调用 load 扩展函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// URL</span><br>imageView.load(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br><br><span class="hljs-comment">// Resource</span><br>imageView.load(R.drawable.image)<br><br><span class="hljs-comment">// File</span><br>imageView.load(File(<span class="hljs-string">"/path/to/image.jpg"</span>))<br><br><span class="hljs-comment">// And more...</span><br></code></pre></td></tr></table></figure><p>上面的请求等价于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = Coil.imageLoader(context)<br><span class="hljs-keyword">val</span> request = LoadRequest.Builder(imageView.context)<br>    .<span class="hljs-keyword">data</span>(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br>    .target(imageView)<br>    .build()<br>imageLoader.execute(request)<br></code></pre></td></tr></table></figure><p>可选的请求配置可以通过 lambda 来操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">imageView.load(<span class="hljs-string">"https://www.example.com/image.jpg"</span>) &#123;<br>    crossfade(<span class="hljs-literal">true</span>)<br>    placeholder(R.drawable.image)<br>    transformations(CircleCropTransformation())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Image-Loaders¶"><a href="#Image-Loaders¶" class="headerlink" title="Image Loaders¶"></a>Image Loaders<a href="https://coil-kt.github.io/coil/#image-loaders" target="_blank" rel="noopener">¶</a></h3><p><code>ImageLoader</code> 是执行请求的服务类。 他们处理缓存，数据获取，图像解码，请求管理，bitmap pool，内存管理等。 可以使用 builder 来创建和配置新实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = ImageLoader.Builder(context)<br>    .availableMemoryPercentage(<span class="hljs-number">0.25</span>)<br>    .crossfade(<span class="hljs-literal">true</span>)<br>    .build()<br></code></pre></td></tr></table></figure><p>imageView.load 使用单例 <code>ImageLoader</code> 执行 <code>LoadRequest</code> 。 可以使用以下方式访问单例 <code>ImageLoader</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = Coil.imageLoader(context)<br></code></pre></td></tr></table></figure><p>（可选）您可以创建自己的ImageLoader实例，并通过依赖项注入将它们注入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = ImageLoader(context)<br></code></pre></td></tr></table></figure><p>当您创建单个 <code>ImageLoader</code> 并在整个应用程序中共享时，<code>Coil</code> 的性能最佳。 这是因为每个 <code>ImageLoader</code> 都有自己的内存缓存，bitmap pool 和网络监听</p><h3 id="Requests¶"><a href="#Requests¶" class="headerlink" title="Requests¶"></a>Requests<a href="https://coil-kt.github.io/coil/#requests" target="_blank" rel="noopener">¶</a></h3><p>有两种 Request 类型</p><ul><li><a href="https://coil-kt.github.io/coil/api/coil-base/coil.request/-load-request/" target="_blank" rel="noopener"><code>LoadRequest</code></a> 是一个生命周期范围的 request，支持 <a href="https://coil-kt.github.io/coil/api/coil-base/coil.target/-target/" target="_blank" rel="noopener"><code>Target</code></a>，<a href="https://coil-kt.github.io/coil/api/coil-base/coil.transition/-transition/" target="_blank" rel="noopener"><code>Transition</code></a> 等等</li><li><a href="https://coil-kt.github.io/coil/api/coil-base/coil.request/-get-request/" target="_blank" rel="noopener"><code>GetRequest</code></a> 挂起并返回  <a href="https://coil-kt.github.io/coil/api/coil-base/coil.request/-request-result/" target="_blank" rel="noopener"><code>RequestResult</code></a></li></ul><p>如果要加载到自定义 target 中，可以执行 <code>LoadRequest</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> request = LoadRequest.Builder(context)<br>    .<span class="hljs-keyword">data</span>(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br>    .target &#123; drawable -&gt;<br>        <span class="hljs-comment">// Handle the result.</span><br>    &#125;<br>    .build()<br>imageLoader.execute(request)<br></code></pre></td></tr></table></figure><p>要强制获取图像，请执行GetRequest：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> request = GetRequest.Builder(context)<br>    .<span class="hljs-keyword">data</span>(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br>    .build()<br><span class="hljs-keyword">val</span> drawable = imageLoader.execute(request).drawable<br></code></pre></td></tr></table></figure><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>如果您使用的是 <code>io.coil-kt:coil</code> ，您可以使用以下任意方式设置 <code>ImageLoader</code> 的实例</p><p>在 Application 中实现 <code>ImageLoaderFactory</code>（推荐）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> : <span class="hljs-type">Application</span></span>(), ImageLoaderFactory &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newImageLoader</span><span class="hljs-params">()</span></span>: ImageLoader &#123;<br>        <span class="hljs-keyword">return</span> ImageLoader.Builder(context)<br>            .crossfade(<span class="hljs-literal">true</span>)<br>            .okHttpClient &#123;<br>                OkHttpClient.Builder()<br>                    .cache(CoilUtils.createDefaultCache(context))<br>                    .build()<br>            &#125;<br>            .build()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 Coil.setImageLoader</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = ImageLoader.Builder(context)<br>    .crossfade(<span class="hljs-literal">true</span>)<br>    .okHttpClient &#123;<br>        OkHttpClient.Builder()<br>            .cache(CoilUtils.createDefaultCache(context))<br>            .build()<br>    &#125;<br>    .build()<br>Coil.setImageLoader(imageLoader)<br></code></pre></td></tr></table></figure><p>默认的 <code>ImageLoader</code> 可以通过这样取回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = Coil.imageLoader(context)<br></code></pre></td></tr></table></figure><p>设置默认的 <code>ImageLoader</code> 是可选的。 如果未设置，则 <code>Coil</code> 会延迟创建具有默认值的 <code>ImageLoader</code></p><p>如果您使用的是 <code>io.coil-kt:coil-base</code>，您应创建自己的 <code>ImageLoader</code> 实例并通过依赖注入将它注入到 app 中</p><blockquote><p>注意：如果设置自定义OkHttpClient，则必须设置缓存实现，否则ImageLoader将没有磁盘缓存。 可以使用CoilUtils.createDefaultCache 创建默认的 Coil 缓存实例</p></blockquote><h2 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h2><p>ImageLoader 支持的数据类型为</p><ul><li>String (mapped to a Uri)</li><li>HttpUrl</li><li>Uri (<code>android.resource</code>, <code>content</code>, <code>file</code>, <code>http</code>, and <code>https</code> schemes only)</li><li>File</li><li>@DrawableRes Int</li><li>Drawable</li><li>Bitmap</li></ul><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>如果要预加载到内存中，执行一个不带 target 的 <code>LoadRequest</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> request = LoadRequest.Builder(context)<br>    .<span class="hljs-keyword">data</span>(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br>    <span class="hljs-comment">// 可选的，但是设置 ViewSizeResolver 可以通过限制预加载的大小来节省内存</span><br>    .size(ViewSizeResolver(imageView))<br>    .build()<br>imageLoader.execute(request)<br></code></pre></td></tr></table></figure><p>如果只想将网络图片预加载到磁盘中，可以为 request 关闭内存缓存</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> request = LoadRequest.Builder(context)<br>    .<span class="hljs-keyword">data</span>(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br>    .memoryCachePolicy(CachePolicy.DISABLED)<br>    .build()<br>imageLoader.execute(request)<br></code></pre></td></tr></table></figure><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><p><code>LoadRequest</code> 会自动取消在以下几种情况下</p><ul><li><p>关联的 view detached，</p></li><li><p>关联的 lifecycle destroyed</p></li><li><p>另一个 request  在相同的 view 中开启</p></li></ul><p>此外，每个 <code>LoadRequest</code> 返回一个 <code>RequestDisposable</code>，可用于检查请求是否在运行中或处理该请求（有效地取消请求并释放其关联资源）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> disposable = imageView.load(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br><br><span class="hljs-comment">// Cancel the request.</span><br>disposable.dispose()<br></code></pre></td></tr></table></figure><p><code>GetRequest</code> 仅当协程的上下文被取消时才会取消</p><h2 id="图片采样"><a href="#图片采样" class="headerlink" title="图片采样"></a>图片采样</h2><p>假设磁盘上有一个 500x500 的映像，但是只需要以 100x100 的大小将其加载到内存中即可在视图中显示。 <code>Coil</code> 会将图像加载到内存中，但是如果您需要 500x500 的图像会怎样呢？ 从磁盘读取还有更好的「质量」，但是图像已经以 100x100 加载到内存中。 理想情况下，当我们从磁盘以 500x500 读取图像时，我们将使用 100x100 图像作为占位符。</p><p>这正是 <code>Coil</code> 所做的，并且 <code>Coil</code> 自动为所有 <code>BitmapDrawables</code> 处理此过程。 与 <code>crossfade(true)</code> 搭配使用时，可以创建视觉效果，使图像细节看起来像淡入淡出，类似于渐进式 JPEG</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/5/15/1721615615eb45ef?w=600&h=1067&f=gif&s=4714987" src="/2020/05/18/Tips-Coil/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h2 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h2><ul><li>AndroidX</li><li>Min SDK 14+</li><li>Compile SDK: 29+</li><li><a href="https://coil-kt.github.io/coil/getting_started/#java-8" target="_blank" rel="noopener">Java 8+</a></li></ul><p>详细内容移步 <a href="https://coil-kt.github.io/coil/" target="_blank" rel="noopener">官方文档</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/05/18/Tips-Coil/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
            <tag> 奇技淫巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Jetpack更新之Fragment】setRetainInstance 被弃用，那么 fragment 是如何保存状态的？</title>
      <link href="/2020/04/30/Jetpack-fragment-savestate/"/>
      <url>/2020/04/30/Jetpack-fragment-savestate/</url>
      
        <content type="html"><![CDATA[<p>我们都知道 fragment 中的 <code>setRetainInstance</code> 用于控制是否在 activity 保留 fragment 实例，具体内容可参见 <a href="https://www.wanandroid.com/wenda/show/12574" target="_blank" rel="noopener">WanAndroid 的每日一问：Fragment 是如何被存储与恢复的？</a></p><p>但是该方法已于 <code>androidx fragment 1.3.0-alpha01</code> 弃用了</p><a id="more"></a><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200422093129.png" src="/2020/04/30/Jetpack-fragment-savestate/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>老规矩，我们查看一下 commit log</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200422094533.png" src="/2020/04/30/Jetpack-fragment-savestate/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>简单概况一下</p><p><code>SetRetainInstance</code> 尝试在 activity 重建时保存状态。但它带来了很多副作用。</p><p>随着 <code>ViewModel</code> 的引入，开发者拥有一个特定的 API，用于保留与 Activity，Fragments 和 Navigation 相关联的状态。 这使开发者可以使用正常的，不需要保留 fragment ，从而在保存单个需要的属性时避免了常见的泄漏源，并且可以销毁保存的状态（即 <code>ViewModel</code> 的构造器和 <code>onCleared</code> 回调）</p><p>详情可参见 <a href="https://juejin.im/post/5e738d12518825495d69cfb9" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a> 和 <a href="https://juejin.im/post/5e786d415188255e00661a4e" target="_blank" rel="noopener">【背上Jetpack之ViewModel】即使您不使用MVVM也要了解ViewModel ——ViewModel 的职能边界</a></p><p>从这个改动可以看出官方正致力于保证逻辑的单一性，状态保存交给 <code>ViewModel</code> ，减少这种特殊的例外情况，从而消除一些不符合预期的问题</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg" src="/2020/04/30/Jetpack-fragment-savestate/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></div>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
            <tag> Fragment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Jetpack更新之Fragment】1.3.0-alpha04 来袭，Fragment 间通信的新姿势</title>
      <link href="/2020/04/30/Jetpack-fragment-ResultAPI/"/>
      <url>/2020/04/30/Jetpack-fragment-ResultAPI/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>fragment 1.3.0-alpha04</code> 发布了，其中有很多变动，其中提供了 fragment 间传递数据的新方式</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430090529.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="1.3.0-alpha04 更新"></p><a id="more"></a><h3 id="API-更改"><a href="#API-更改" class="headerlink" title="API 更改"></a>API 更改</h3><p>首先我们介绍一下 API 更改</p><ul><li><code>startActivityForResult()</code>/<code>onActivityResult()</code> 和 <code>requestPermissions()</code>/<code>onRequestPermissionsResult()</code> 弃用</li><li><code>prepareCall()</code> 重命名为 <code>registerForActivityResult()</code> </li><li><code>target fragment API</code> 被弃用</li></ul><h3 id="Activity-Result-API-上位"><a href="#Activity-Result-API-上位" class="headerlink" title="Activity Result API 上位"></a>Activity Result API 上位</h3><p>由于官方提供了 <strong>Activity Result API</strong> 来替换 <strong>onActivityResult</strong>  机制，因此 fragment 的  <code>startActivityForResult()</code>/<code>onActivityResult()</code> 和 <code>requestPermissions()</code>/<code>onRequestPermissionsResult()</code> 方法被标记弃用了</p><p><strong>Activity Result API</strong> 详情可参考 <a href="https://juejin.im/user/586eff908d6d81005879507d" target="_blank" rel="noopener">秉心说</a> 的 <a href="https://juejin.im/post/5e80cb1ee51d45471654fae7" target="_blank" rel="noopener">是时候丢掉 onActivityResult 了 ！</a></p><p>文章介绍的很详尽，这里不再赘述</p><h3 id="prepareCall-重命名"><a href="#prepareCall-重命名" class="headerlink" title="prepareCall 重命名"></a>prepareCall 重命名</h3><p>值得注意的地方是 <code>prepareCall()</code> 被命名为 <code>registerForActivityResult()</code> </p><blockquote><p>注意：在版本处于 Alpha 版状态时，可以添加、移除或更改 API。因此 Alpha 版本不适合在生产上使用</p></blockquote><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430091418.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="来自我的另一篇博客"></p><h3 id="target-fragment-API-被弃用"><a href="#target-fragment-API-被弃用" class="headerlink" title="target fragment API 被弃用"></a>target fragment API 被弃用</h3><p>其实 <code>target fragment API</code> 早已被弃用</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430092548.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="setTargetFragment 被弃用"></p><p><code>target fragment</code> 需要直接访问另一个 fragment 的实例，这是十分危险的，因为你不知道目标 fragment 处于什么状态。而且 <code>target fragment</code> 不支持 Navigation</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430092824.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="弃用 target fragment API"></p><p>那么，fragment 之间传递数据更干净的方式是什么呢？</p><h3 id="fragment-之间传递数据的新方式"><a href="#fragment-之间传递数据的新方式" class="headerlink" title="fragment 之间传递数据的新方式"></a>fragment 之间传递数据的新方式</h3><p>前文提到，在相同的 FragmentManager 中可以使用 target fragment API 来在 fragment 间传递数据，但这种方式需要直接访问目标fragment 的实例，这很危险，因为目标 fragment 的状态是未知的</p><p>因此官方提供了这样的 API，它允许在一个 fragment 上设置结果，并将该结果在 fragment 的适当的生命周期中使用。</p><p>这种传递数据的方式适用于 DialogFragment ，Navigation 中的 fragment</p><p>此更改还包括 -ktx 扩展功能以确保 kotlin 用户可以将 FragmentResultListener 作为 lambda 传递</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430105343.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="FragmentA 源码"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430105411.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="FragmentB 源码"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430105045.gif" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="demo"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>老规矩，我们沿着官方的 commit log 来看看官方实现该功能的思路</p><p>首先，添加了 FragmentResultOwner 这样的的抽象，用于处理 fragment result，其内部有两个方法</p><ul><li>setResult</li><li>setResultListener</li></ul><p>前者用于发送数据，后者用于接收数据</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430110206.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="FragmentResultOwner"></p><p>而其实现类为 FragmentManager</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430110412.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="FragmentManager implement FragmentResultOwner "></p><p>我们来看看 FragmentManager 两个方法的具体实现</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430111003.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFragmentResultListener</span><span class="hljs-params">(@NonNull <span class="hljs-keyword">final</span> String requestKey,<br>        @NonNull <span class="hljs-keyword">final</span> LifecycleOwner lifecycleOwner,<br>        @Nullable <span class="hljs-keyword">final</span> FragmentResultListener listener)</span> </span>&#123;<br>    <span class="hljs-comment">// 设置的 listener 为空时将 requestKey 对应的 listener 移除</span><br>    <span class="hljs-keyword">if</span> (listener == <span class="hljs-keyword">null</span>) &#123;<br>        mResultListeners.remove(requestKey);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 当fragment 处于DESTROYED 状态时 直接 return ，避免了异常</span><br>    <span class="hljs-keyword">final</span> Lifecycle lifecycle = lifecycleOwner.getLifecycle();<br>    <span class="hljs-keyword">if</span> (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 观察生命周期，fragment started 后接收回调，destroyed 移除回调</span><br>    LifecycleEventObserver observer = <span class="hljs-keyword">new</span> LifecycleEventObserver() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(@NonNull LifecycleOwner source,<br>                @NonNull Lifecycle.Event event)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (event == Lifecycle.Event.ON_START) &#123;<br>                <span class="hljs-comment">// once we are started, check for any stored results</span><br>                Bundle storedResult = mResults.get(requestKey);<br>                <span class="hljs-keyword">if</span> (storedResult != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// if there is a result, fire the callback</span><br>                    listener.onFragmentResult(requestKey, storedResult);<br>                    <span class="hljs-comment">// and clear the result</span><br>                    setFragmentResult(requestKey, <span class="hljs-keyword">null</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;<br>                lifecycle.removeObserver(<span class="hljs-keyword">this</span>);<br>                mResultListeners.remove(requestKey);<br>            &#125;<br>        &#125;<br>    &#125;;<br>    lifecycle.addObserver(observer);<br>    mResultListeners.put(requestKey, <span class="hljs-keyword">new</span> LifecycleAwareResultListener(lifecycle, listener));<br>&#125;<br></code></pre></td></tr></table></figure><p>以上便是这部分的源码</p><blockquote><p>这里要注意一点的是 <code>fragment result api</code> 是基于同一 <code>FragmentManager</code> 的</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>官方一直致力于将 fragment 的 api 变得更好用</p><p><a href="https://medium.com/@ianhlake" target="_blank" rel="noopener">Ian Lake</a> 在 <a href="https://www.youtube.com/watch?v=RS1IACnZLy4" target="_blank" rel="noopener">Fragments: Past, Present, and Future (Android Dev Summit ‘19)</a> 中提到了 fragment 间通信的问题，未来 fragment 会整合 fragment 自身和其内部 view 的生命周期，提供同一 FragmentManager 多返回栈的支持</p><p>看到 <code>fragment result API</code> ，我突然有个想法，如果将其应用到 Navigation 中是否是解决 Navigation 跳转返回后状态重置的一个方法呢？</p><p>各位小伙伴有什么想法欢迎评论区留言</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></div>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
            <tag> Fragment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Jetpack更新之Fragment】setMaxLifecycle 上位，setUserVisibleHint 被弃用</title>
      <link href="/2020/04/29/Jetpack-fragment-setMaxLifecycle/"/>
      <url>/2020/04/29/Jetpack-fragment-setMaxLifecycle/</url>
      
        <content type="html"><![CDATA[<p>很多情况下，fragment 的生命周期上限应该低于 FragmentManager/Activity。例如，<code>ViewPager</code> 屏幕外的界面不应被 <code>resumed</code></p><p>理想状态下，可以通过以下 API 实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">supportFragmentManager<br>  .beginTransaction()<br>      .setMaxLifecycle(fragment, Lifecycle.State.RESUMED)<br>      .commit()<br></code></pre></td></tr></table></figure><p>将最大生命周期设置为 <code>Lifecycle.State.RESUMED</code> 将有效地消除限制（因为这是最高生命周期状态）</p><p>这将允许废弃 <code>setUserVisibleHint()</code> API</p><a id="more"></a><h2 id="setMaxLifecycle-出现始末"><a href="#setMaxLifecycle-出现始末" class="headerlink" title="setMaxLifecycle 出现始末"></a>setMaxLifecycle 出现始末</h2><p>该功能应如何实现的？我们沿着 <code>commit log</code> 来理一下官方的思路</p><p>将 <code>BackStackRecord</code> 的部分逻辑转移至父类 <code>FragmentTransaction</code> 中</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423094356.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423101522.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>在 <code>FragmentTransaction</code> 中添加 <code>setMaxLifecycle</code> API</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423101908.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423102052.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>保存 fragment <code>maxState</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423103245.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423103057.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>弃用 <code>setUserVisibleHint</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423103528.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><code>FragmentPagerAdapter</code> 构造器新增参数，使用 <code>setMaxLifecycle()</code> API 确保 fragment <code>resumed</code> 时对用户可见</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423104355.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423104634.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>弃用 <code>FragmentStatePagerAdapter</code> 原来的单参构造器，推荐使用新的构造</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423105038.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423105144.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><strong>随着 <code>ViewPager2 1.0.0</code> 正式版发布，与 <code>ViewPager</code> 交互的<code>FragmentPagerAdapter</code> 和 <code>FragmentStatePagerAdapter</code> 被弃用了</strong></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423111201.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>至此我们捋顺了 <code>setMaxLifecycle</code> 的出现，<code>setUserVisibleHint</code> 的弃用以及与<code>ViewPager</code> 相关的 <code>FragmentPagerAdapter</code> 和 <code>FragmentStatePagerAdapter</code> 的弃用</p><h2 id="setMaxLifecycle-内部逻辑"><a href="#setMaxLifecycle-内部逻辑" class="headerlink" title="setMaxLifecycle 内部逻辑"></a>setMaxLifecycle 内部逻辑</h2><p>接下来我们看看 <code>setMaxLifecycle</code>  是如何发挥作用的</p><p>首先我们要研究一下 fragment 的状态管理，为了更好的管理 fragment 的状态，官方添加了 <code>FragmentStateManager</code> 类来专门管理 fragment 的状态，职能单一原则哈</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423113312.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423113509.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>接着在该类中添加了计算 fragment 最大生命周期的方法 <code>computeMaxState()</code> </p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423114557.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423114615.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>后来该方法改名为 <code>computeExpectedState()</code> 并加入了 <code>moveToExpectedState()</code> 方法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423115055.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><code>computeExpectedState()</code>  方法会根据 fragment <code>mMaxState</code> 计算 fragment 应该所处的生命周期</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423115521.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>而 fragment 的 <code>mMaxState</code> 是通过 <code>FragmentManager</code> 的 <code>setMaxLifecycle()</code> 方法设置的 ，而该方法是 <code>BackStackRecord</code> 执行 OP 时调用的，而 OP 值正是通过 <code>FragmentTransaction</code> 的 <code>setMaxLifecycle()</code> 设置的</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423115744.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423115928.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>至此，我们理清了 <code>setMaxLifecycle()</code> 的内部逻辑</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以看到官方为了使 fragment 能够在正确的生命周期上，引入了 <code>setMaxLifecycle()</code> 方法，同时为了更好的管理 fragment 的状态，抽象出了 <code>FragmentStateManager</code> 。<em>更少的代码，更少的职责</em>，fragment 的内部逻辑会越来越清晰</p><ul><li><p>关于如何迁移至 ViewPager2 ，请移步 <a href="https://www.bilibili.com/video/BV1uJ411C7S4?from=search&seid=7755962876168902731" target="_blank" rel="noopener">官方视频</a></p></li><li><p>关于新的 API 下懒加载实现，请移步 <a href="https://juejin.im/post/5e232d01e51d455801624c06" target="_blank" rel="noopener">Androidx 下 Fragment 懒加载的新实现</a></p></li></ul><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></div>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
            <tag> Fragment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转</title>
      <link href="/2020/04/15/Tips-Components-Jump/"/>
      <url>/2020/04/15/Tips-Components-Jump/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>越来越多的项目使用了组件化，组件之间的通信是一个比较重要的问题。<code>ARouter</code> 等路由方案为我们提供了解决办法。那么如果不使用 Router 如何实现组件间的界面跳转呢？</p><a id="more"></a><h2 id="万能的-setClassName"><a href="#万能的-setClassName" class="headerlink" title="万能的 setClassName"></a>万能的 <code>setClassName</code></h2><p>从一个 Activity 跳转到另一个Activity 的最直接方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, TestActivity::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span><br>startActivity(intent)<br></code></pre></td></tr></table></figure><p>但是，采用这种方法，当原 activity 位于一个 module（例如 <code>FeatureA</code> ）中，而目标 activity 位于另一个 module（<code>FeatureB</code>）中时，该怎么办？</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200415110401.png" src="/2020/04/15/Tips-Components-Jump/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我们可以使用 Intent 的 <code>setClassName</code> 方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent()<br>intent.setClassName(<span class="hljs-keyword">this</span>, “com.flywith24.demo.TestActivity”)<br>startActivity(intent)<br></code></pre></td></tr></table></figure><p>但是这种方式硬编码目标 activity 的完整类名，如果 activity 的类名被更改或者移动，而且没有更改硬编码，则编译可以通过，但是运行时崩溃</p><p>如果可以自动生成 activity 完整类名就好了</p><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>我们知道 activity 作为 Android 的组件之一需要在 Manifest 文件中声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">”com.flywith24.demo.MainActivity”</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">”com.flywith24.demo.TestActivity”</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>如果我们的数据是从 Manifest 中获得的，那么就解决了硬编码的问题了</p><p>有这样一个<a href="https://github.com/gaelmarhic/Quadrant" target="_blank" rel="noopener">插件</a> ，在 build 时会将所有在 Manifest 中声明的 activity 的完整类名以静态常量的形式罗列到一个静态类中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> QuadrantConstants &#123;<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MAIN_ACTIVITY: String = <span class="hljs-string">"com.gaelmarhic.quadrant.MainActivity"</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SECONDARY_ACTIVITY: String = <span class="hljs-string">"com.gaelmarhic.quadrant.SecondaryActivity"</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> TERTIARY_ACTIVITY: String = <span class="hljs-string">"com.gaelmarhic.quadrant.TertiaryActivity"</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样在使用时就避免了硬编码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent()<br>intent.setClassName(context, QuadrantConstants.MAIN_ACTIVITY)<br>startActivity(intent)<br></code></pre></td></tr></table></figure><h2 id="使用依赖注入"><a href="#使用依赖注入" class="headerlink" title="使用依赖注入"></a>使用依赖注入</h2><p>组件化中 <code>app</code> module 会依赖所有的功能 module ，因此如果我们使用依赖注入在 <code>app</code> 中将所有的目标 activity 的完整类名声明出来，也能达到解决硬编码的问题</p><p>这里以 <a href="https://insert-koin.io/" target="_blank" rel="noopener">koin</a> 为例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> : <span class="hljs-type">Application</span></span>() &#123;<br>    <span class="hljs-keyword">val</span> myModule = module &#123;<br>        single &#123; Feature2Activity::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>.<span class="hljs-title">name</span> &#125;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate()<br>        startKoin &#123;<br>            androidContext(<span class="hljs-keyword">this</span><span class="hljs-symbol">@MyApplication</span>)<br>            modules(myModule)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样通过 get() 方法即可拿到 <code>Feature2Activity</code> 的完整类名</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent()<br>    .setClassName(<span class="hljs-keyword">this</span><span class="hljs-symbol">@Feature1Activity</span>, <span class="hljs-keyword">get</span>())<br>    .putExtra(<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>)<br>startActivity(intent)<br></code></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/Flywith24/MultitableModuleApp" target="_blank" rel="noopener">Demo 地址</a></p><p>各位有什么想法欢迎在评论区留言</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/04/15/Tips-Components-Jump/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
            <tag> 奇技淫巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【奇技淫巧】巧用 kotlin 扩展函数和 typealias 封装 LiveData</title>
      <link href="/2020/04/15/Tips-StateLiveData/"/>
      <url>/2020/04/15/Tips-StateLiveData/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-LiveData-两个常用的姿势"><a href="#关于-LiveData-两个常用的姿势" class="headerlink" title="关于 LiveData 两个常用的姿势"></a>关于 LiveData 两个常用的姿势</h2><h3 id="使用包装类传递事件"><a href="#使用包装类传递事件" class="headerlink" title="使用包装类传递事件"></a>使用包装类传递事件</h3><p>我们在使用 LiveData 时可能会遇到「粘性」事件的问题，该问题可以使用包装类的方式解决。解决方案见 <a href="https://juejin.im/post/5b2b1b2cf265da5952314b63#heading-7" target="_blank" rel="noopener">[译] 在 SnackBar，Navigation 和其他事件中使用 LiveData（SingleLiveEvent 案例）</a></p><a id="more"></a><p>使用时是这样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListViewModel</span> : <span class="hljs-type">ViewModel &#123;</span></span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;()<br><br>    <span class="hljs-keyword">val</span> navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt;<br>        <span class="hljs-keyword">get</span>() = _navigateToDetails<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">userClicksOnButton</span><span class="hljs-params">(itemId: <span class="hljs-type">String</span>)</span></span> &#123;<br>        _navigateToDetails.value = Event(itemId)  <span class="hljs-comment">// Trigger the event by setting a new Event as a new value</span><br>    &#125;<br>&#125;<br><br>myViewModel.navigateToDetails.observe(<span class="hljs-keyword">this</span>, Observer &#123;<br>    it.getContentIfNotHandled()?.let &#123; <span class="hljs-comment">// Only proceed if the event has never been handled</span><br>        startActivity(DetailsActivity...)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>不过这样写甚是繁琐，我们可以使用更优雅的方式解决该问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//为 LiveData&lt;Event&lt;T&gt;&gt;提供类型别名，使用 EventLiveData&lt;T&gt; 即可</span><br><span class="hljs-keyword">typealias</span> EventMutableLiveData&lt;T&gt; = MutableLiveData&lt;Event&lt;T&gt;&gt;<br><br><span class="hljs-keyword">typealias</span> EventLiveData&lt;T&gt; = LiveData&lt;Event&lt;T&gt;&gt;<br></code></pre></td></tr></table></figure><p>使用 <code>typealias</code> 关键字，我们可以提供一个类型别名，可以这样使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//等价于 MutableLiveData&lt;Event&lt;Boolean&gt;&gt;(Event(false))</span><br><span class="hljs-keyword">val</span> eventContent = EventMutableLiveData&lt;<span class="hljs-built_in">Boolean</span>&gt;(Event(<span class="hljs-literal">false</span>))<br></code></pre></td></tr></table></figure><p>现在声明时不用多加一层泛型了，那么使用时还是很繁琐</p><p>我们可以借助 kotlin 的 扩展函数更优雅的使用</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605115649.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="event 扩展函数"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605121030.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="使用"></p><p>demo 中封装了两种形式的 LiveData，一种为 <code>LiveData&lt;Boolean&gt;</code>，一种为 <code>EventLiveData&lt;Boolean&gt;</code>，当屏幕旋转时，前者会再次回调结果，而后者由于事件已被处理而不执行 onChanged，我们通过 Toast 可观察到这一现象</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605121634.gif" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><a href="https://github.com/KunMinX/Jetpack-MVVM-Best-Practice" target="_blank" rel="noopener">java 版的可参考</a></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605122206.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h3 id="封装带网络状态的数据"><a href="#封装带网络状态的数据" class="headerlink" title="封装带网络状态的数据"></a>封装带网络状态的数据</h3><p>很多时候我们在获取网络数据时要封装一层网络状态，例如：加载中，成功，失败</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605115950.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>在使用时我们遇到了和上面一样的问题，多层泛型用起来很麻烦</p><p>我们依然可以使用 typealias + 扩展函数来优雅的处理该问题</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605120336.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="typealias"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605120400.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="扩展函数"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605120455.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="使用"></p><p>demo 截图</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605120721.gif" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="demo"></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>demo <a href="https://github.com/Flywith24/WrapperLiveDataDemo" target="_blank" rel="noopener">在这</a>，如果感觉这个思路对你有帮助的话，点一颗小星星吧～ 😉</p><p>另外我还将它传到了 JitPack 上，引入姿势如下：</p><p><a href="https://jitpack.io/#Flywith24/WrapperLiveData" target="_blank" rel="noopener"><img class="lazyload" data-original="https://jitpack.io/v/Flywith24/WrapperLiveData.svg" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></a></p><ol><li><p>在项目根目录的 <code>build.gradle</code> 加入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">allprojects &#123;<br>  repositories &#123;<br>    <span class="hljs-comment">//...</span><br>    maven &#123; url <span class="hljs-string">'https://jitpack.io'</span> &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>添加依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  implementation <span class="hljs-string">'com.github.Flywith24:WrapperLiveData:$version'</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="往期文章"><a href="#往期文章" class="headerlink" title="往期文章"></a>往期文章</h2><p>该系列主要介绍一些「骚操作」，它未必适合生产环境使用，但是是一些比较新颖的思路</p><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案</a></li></ul><ul><li><a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></li></ul><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你</a></li></ul><ul><li><a href="https://juejin.im/post/5e967f35f265da47d77cd4c3" target="_blank" rel="noopener">【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转</a></li></ul><ul><li><a href="https://juejin.im/post/5ebdfb0b6fb9a0436153db22" target="_blank" rel="noopener">【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil</a></li></ul><ul><li><p><a href="https://juejin.im/post/5ec50ae46fb9a047a862124f" target="_blank" rel="noopener">【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化</a></p></li><li><p><a href="https://juejin.im/post/5ecde219e51d457841190d08" target="_blank" rel="noopener">【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</a></p></li></ul><p>我的其他系列文章 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
            <tag> 奇技淫巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</title>
      <link href="/2020/04/15/Tips-includeBuild/"/>
      <url>/2020/04/15/Tips-includeBuild/</url>
      
        <content type="html"><![CDATA[<h2 id="buildSrc-的缺陷"><a href="#buildSrc-的缺陷" class="headerlink" title="buildSrc 的缺陷"></a>buildSrc 的缺陷</h2><p>Android 开发中统一不同 module 的依赖版本十分重要，传统的方式是使用 ext 的方式</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200527111409.png" src="/2020/04/15/Tips-includeBuild/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ext"></p><p>之前我发过关于使用 buildSrc 简化项目中 gradle 代码的译文：<a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></p><p>该种方式可以很好的管理 gradle 的公共配置，这其中当然包括依赖版本</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200527111722.gif" src="/2020/04/15/Tips-includeBuild/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="配置依赖"></p><p>如图，在使用依赖时有代码提示，而且可以点击进入查看</p><p>但是由于 buildSrc 是对全局的所有 module 的配置，因此在构建速度上会慢一些。那么有没有一个更纯净的方式来配置依赖版本呢？</p><p>今天我们来介绍一种新的方式</p><a id="more"></a><h2 id="自定义-plugin-includeBuild"><a href="#自定义-plugin-includeBuild" class="headerlink" title="自定义 plugin + includeBuild"></a>自定义 plugin + includeBuild</h2><p>使用 <a href="https://docs.gradle.org/current/userguide/composite_builds.html" target="_blank" rel="noopener">Gradle Composite builds</a> 可以很容易解决这一问题</p><p>我们新建一个 module，命名为 version ，并将原来的 buildSrc 的代码转移过来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependencyVersionPlugin</span> : <span class="hljs-type">Plugin</span>&lt;<span class="hljs-type">Project</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>)</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 version 的 build.gradle 文件加入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">gradlePlugin &#123;<br>    plugins &#123;<br>        version &#123;<br>            id = <span class="hljs-string">'com.flywith24.version'</span><br>            implementationClass = <span class="hljs-string">'com.flywith24.version.DependencyVersionPlugin'</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 settings.gradle 加入 <code>includeBuild(&quot;version&quot;)</code> （<strong>重点</strong>）</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">includeBuild(<span class="hljs-string">"version"</span>)<br><br>rootProject.name=<span class="hljs-string">'VersionControlDemo'</span><br>include <span class="hljs-string">':app'</span><br>include <span class="hljs-string">':lib'</span><br></code></pre></td></tr></table></figure><p>接下来在需要引用的 module 中引入该插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">"com.flywith24.version"</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们就可以使用了</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200527113952.png" src="/2020/04/15/Tips-includeBuild/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="demo代码截图"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200527114023.png" src="/2020/04/15/Tips-includeBuild/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="demo代码截图"></p><p><a href="https://github.com/Flywith24/VersionControlDemo" target="_blank" rel="noopener">demo 在这</a></p><h2 id="往期文章"><a href="#往期文章" class="headerlink" title="往期文章"></a>往期文章</h2><p>该系列主要介绍一些「骚操作」，它未必适合生产环境使用，但是是一些比较新颖的思路</p><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案</a></li></ul><ul><li><a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></li></ul><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你</a></li></ul><ul><li><a href="https://juejin.im/post/5e967f35f265da47d77cd4c3" target="_blank" rel="noopener">【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转</a></li></ul><ul><li><a href="https://juejin.im/post/5ebdfb0b6fb9a0436153db22" target="_blank" rel="noopener">【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil</a></li></ul><ul><li><a href="https://juejin.im/post/5ec50ae46fb9a047a862124f" target="_blank" rel="noopener">【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化</a></li></ul><p>我的其他系列文章 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/04/15/Tips-includeBuild/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
            <tag> 奇技淫巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【背上Jetpack之DataBinding】数据驱动魔法师 何时迎来翻身日？</title>
      <link href="/2020/04/09/Jetpack-DataBinding/"/>
      <url>/2020/04/09/Jetpack-DataBinding/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://juejin.im/post/5e834bb5f265da480d61668d" target="_blank" rel="noopener">LiveData 篇</a> 我们提到 Android 开发的主要工作内容是将数据转换为 UI ，同时我们也介绍了数据驱动 UI 的思想，使用 ViewModel + LiveData，可以安全地在订阅者的生命周期内分发正确的数据。但是 activity 和 fragment 充斥着大量的模板代码，铺天盖地的 findViewById，以及各种 set （根据数据设置 UI）。如果能够消灭掉这些模板代码就好了</p></blockquote><a id="more"></a><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402101708.gif" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="他来了他来了"></p><p>他来了他来了，他欢快地走来了</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402101727.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="DataBinding"></p><p>然而，很多开发者对 DataBinding 存在偏见，「DataBinding 不是个好东西，在声明式编程中书写 UI 逻辑，既不可调试，也不便于察觉和追踪，万一出现问题就麻烦了。」</p> <img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402165235.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" style="zoom:200%;"><p>本文主要介绍 DataBinding 的解决的问题以及其背后的逻辑，带您对 DataBinding 有一个感性的认识。本文末尾会对各个 findViewById 的替代方案进行对比</p><p>DataBinding 的相关资源</p><ul><li><a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://codelabs.developers.google.com/codelabs/android-databinding/#0" target="_blank" rel="noopener">codelab</a></li><li><a href="https://github.com/android/databinding-samples" target="_blank" rel="noopener">官方示例</a></li></ul><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 数据驱动魔法师</span></h2><p>DataBinding 允许使用声明性格式而不是通过编程方式将布局中的 UI 组件与数据源绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// before</span><br>TextView textView = findViewById(R.id.sample_text);<br>textView.setText(viewModel.getUserName());<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span><br>    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@&#123;viewmodel.userName&#125;"</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>通过在布局文件中绑定组件，您可以删除 activity 中的许多设置 UI 调用，从而使它们更易于维护。 这也可以提高应用程序的性能，并有助于防止内存泄漏和空指针异常</p><blockquote><p>如果仅替换 findViewById 而不需要数据的绑定，可以使用 ViewBinding，它使用起来更简单，性能也更好。</p><p>使用方法参见 <a href="https://juejin.im/post/5e4806f3e51d4526c550a2ef" target="_blank" rel="noopener">[译]深入研究ViewBinding 在 include, merge, adapter, fragment, activity 中使用</a></p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> DataBinding 基础</span></h2><p>详细内容参见 <a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">官方文档</a> ，这里只简单介绍 DataBinding</p><h3 id="DataBinding-引入"><a href="#DataBinding-引入" class="headerlink" title="DataBinding 引入"></a>DataBinding 引入</h3><p>app build.gradle 中加入 </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    ...<br>    dataBinding &#123;<br>        enabled = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Android Studio 4.0</span><br>android &#123;<br>    ...<br>    buildFeatures &#123;<br>        dataBinding = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>必须在 app module 中声明，声明后其他子 module 可直接使用 DataBinding</p></blockquote><p>使用 DataBinding 无需开发者手动引入库，android build gradle plugin 内部已经引入了</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402115116.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>DataBinding 中使用了注解，因此在构建速度上比 ViewBinding 差些（不过功能这么强大要啥自行车）</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>DataBinding 布局文件略有不同，它们以 layout 的根标记开始，后跟一个 data 元素和一个 view 根元素。 view 元素是您的根将位于非绑定布局文件中的元素。 以下代码显示了一个示例布局文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span><br>        <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span><br>            <span class="hljs-attr">name</span>=<span class="hljs-string">"viewmodel"</span><br>            <span class="hljs-attr">type</span>=<span class="hljs-string">"com.myapp.data.ViewModel"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ConstraintLayout...</span> /&gt;</span> <span class="hljs-comment">&lt;!-- UI layout's root element --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="生成绑定类"><a href="#生成绑定类" class="headerlink" title="生成绑定类"></a>生成绑定类</h3><p>DataBinding 会为每个在布局声明 layout 标签的 xml 布局文件生成一个绑定类。 默认情况下，类的名称基于布局文件的名称。 上面的布局文件名是 activity_main.xml，因此相应的生成类是 ActivityMainBinding。 此类包含从布局属性（例如，viewmodel 变量）到布局视图的所有绑定，并且知道如何为绑定表达式分配值</p><h3 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    <span class="hljs-comment">// before</span><br>    <span class="hljs-comment">// setContentView(R.layout.activity_main)</span><br>    <br>    <span class="hljs-comment">// after</span><br>    val binding : ActivityMainBinding =<br>    DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_main)<br>&#125;<br></code></pre></td></tr></table></figure><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 使用DataBinding 解决的问题及实现原理</span></h2><p>不知道你是否有这些烦恼：activity 和 fragment 中有着大量的模板代码，即使使用 ButterKnife 等工具写起代码来也很繁琐。而且 View id 与 View 的类型不匹配时，只有在运行期才能发现；旋转屏幕后如果新的布局中不存在之前 id 的 view ，可能还导致空指针异常；项目中使用各类 bus 通知 UI 刷新，但是有时 UI 的显示并不符合预期，而排查起来特别困难，因为数据源很多…</p><p>不要慌，DataBinding 可以解决以下问题</p><ul><li><p>替换 findViewById ，减少模板代码</p></li><li><p>解决类型安全问题</p></li><li><p>解决空安全问题</p></li><li><p>保证了数据的一致性</p></li></ul><h3 id="魔法的背后"><a href="#魔法的背后" class="headerlink" title="魔法的背后"></a>魔法的背后</h3><p>com.android.tools.build:gradle 插件中封装了 DataBinding 的魔法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402162010.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>查看 com.android.tools.build:gradle:3.6.2 的源码，找到 DataBinding 配置项的类 DataBindingOptions</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DataBindingOptions.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// DataBinding 是否开启，对应上面在 build.gradle 中的配置</span><br>    <span class="hljs-keyword">return</span> enabled;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的调用者很多，在 TaskManager 中的 createDataBindingTasksIfNecessary</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TaskManager </span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createDataBindingTasksIfNecessary</span><span class="hljs-params">(@NonNull VariantScope scope)</span> </span>&#123;<br>    <span class="hljs-comment">// 是否开启 DataBinding</span><br>    <span class="hljs-keyword">boolean</span> dataBindingEnabled = extension.getDataBinding().isEnabled();<br>    <span class="hljs-keyword">boolean</span> viewBindingEnabled = extension.getViewBinding().isEnabled();<br>    <span class="hljs-keyword">if</span> (!dataBindingEnabled &amp;&amp; !viewBindingEnabled) &#123;<br>        <span class="hljs-comment">// DataBinding 和 ViewBinding 均未开启则直接 return</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    createDataBindingMergeBaseClassesTask(scope);<br>    createDataBindingMergeArtifactsTask(scope);<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">// 构建 DataBinding 相应绑定类</span><br>    taskFactory.register(<span class="hljs-keyword">new</span> DataBindingGenBaseClassesTask.CreationAction(scope));<br>&#125;<br><span class="hljs-comment">// CreationAction</span><br><span class="hljs-function">override fun <span class="hljs-title">handleProvider</span><span class="hljs-params">(taskProvider: TaskProvider&lt;out DataBindingGenBaseClassesTask&gt;)</span> </span>&#123;<br>    variantScope.artifacts.producesDir(<br>        <span class="hljs-comment">// DATA_BINDING_BASE_CLASS_SOURCE_OUT</span><br>        InternalArtifactType.DATA_BINDING_BASE_CLASS_SOURCE_OUT,<br>        BuildArtifactsHolder.OperationType.INITIAL,<br>        taskProvider,<br>        DataBindingGenBaseClassesTask::sourceOutFolder<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到生成 DataBinding 绑定类的 task 为 DataBindingGenBaseClassesTask，而InternalArtifactType.DATA_BINDING_BASE_CLASS_SOURCE_OUT 则对应着 build 目录生成的 DataBinding 类的</p><p>data_binding_base_class_source_out 目录</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402161451.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这里可以简单看一下，感兴趣的小伙伴可以自己查看源码</p><h3 id="DataBinding-如何解决上述问题的"><a href="#DataBinding-如何解决上述问题的" class="headerlink" title="DataBinding 如何解决上述问题的"></a>DataBinding 如何解决上述问题的</h3><p>我们可以查看 DataBinding 生成的绑定类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FragmentSingleChildBinding</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewBinding</span> </span>&#123;<br>  <span class="hljs-comment">// NonNull 注解标记</span><br>  <span class="hljs-comment">// 如果存在不同配置的不同布局文件（如横竖屏）且该控件不是存在于所有布局，该处使用 Nullable注解标记</span><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> MaterialButton button;<br>    <br>  <span class="hljs-comment">// 省略...</span><br>    <br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FragmentSingleChildBinding <span class="hljs-title">bind</span><span class="hljs-params">(@NonNull View rootView)</span> </span>&#123;<br>    String missingId;<br>    missingId: &#123;<br>      <span class="hljs-comment">//其内部也是使用 findViewById</span><br>      MaterialButton button = rootView.findViewById(R.id.button);<br>      <span class="hljs-keyword">if</span> (button == <span class="hljs-keyword">null</span>) &#123;<br>        missingId = <span class="hljs-string">"button"</span>;<br>        <span class="hljs-keyword">break</span> missingId;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FragmentSingleChildBinding((MaterialButton) rootView, button);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"Missing required view with ID: "</span>.concat(missingId));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Binding 类内部的也是使用 findViewById ，因此 DataBinding 可以代替 findViewById ，并且减少模板代码</p></li><li><p>View 控件变量类型是固定的，因此不会出现类型安全问题</p></li><li><p>View 控件变量由空/非空注解修饰，（如果为 Nullable java 中会有 lint 警告，而 kotlin 直接调用时无法通过编译的）因此 不会出现空安全问题</p></li><li><p>通过声明式的配置，UI 完全来自唯一可信的数据源配置，保证了数据的一致性</p></li></ul><blockquote><p>注意：以上分析同样适用于 ViewBinding</p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 感受魔法的魅力</span></h2><p>这里简单展示一下 DataBinding 的「魔法」</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br>      <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span><br>       <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span><br>       <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>       <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span><br>           <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/firstName"</span><br>           <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span><br>           /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span><br>           <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/lastName"</span><br>           <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span><br>           /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br><br><span class="hljs-comment">// Before Data Binding</span><br><span class="hljs-comment">//setContentView(R.layout.activity_main);</span><br>        <br><span class="hljs-comment">//TextView firstName = (TextView) findViewById(R.id.firstName);</span><br><span class="hljs-comment">//TextView lastName = (TextView) findViewById(R.id.lastName);</span><br><br><span class="hljs-comment">//firstName.setText("xxx");</span><br><span class="hljs-comment">//lastName.setText("xxx");</span><br><br><br><span class="hljs-comment">// After Data Binding</span><br>        ActivityMainBinding binding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_main);<br><br>        binding.firstName.setText(<span class="hljs-string">"xxx"</span>);<br>        binding.lastName.setText(<span class="hljs-string">"xxx"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面展示了 DataBinding 的基础操作（单纯的替换 findViewById），如果仅使用 DataBinding 这部分功能，可以考虑使用 ViewBinding</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409114053.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p>在之前的布局的基础上绑定数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.example.User"</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span><br>       <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span><br>       <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>       <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <br>           <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/firstName"</span>      <br>           <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@&#123;user.firstName&#125;"</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <br>           <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/lastName"</span>      <br>           <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@&#123;user.lastName&#125;"</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        ActivityMainBinding binding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_main);<br>binding.user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"xxx"</span>,<span class="hljs-string">"xxx"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式也可以用在 recyclerview adapter 中，adapter 中的代码大大减少</p><h3 id="Binding-Adapter"><a href="#Binding-Adapter" class="headerlink" title="Binding Adapter"></a>Binding Adapter</h3><p>您可能会好奇配置 <code>android:text=&quot;@{user.firstName}</code> 后内部发生了什么</p><p>DataBinding 中使用 <code>Binding Adapter</code> 来处理，它主要处理「属性」和「事件」，前者如  <code>setText()</code> ，后者如 <code>setOnClickListener()</code>。上面的 <code>android:text</code> 实际上调用的是下面的方法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409145551.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>DataBinding 中提供了很多 <code>Binding Adapter</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200410160031.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>如果官方提供的 <code>Binding Adapter</code> 不满足您的需求，您还可以自定义 <code>Binding Adapter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingAdapter</span>(&#123;<span class="hljs-string">"imageUrl"</span>, <span class="hljs-string">"error"</span>&#125;)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadImage</span><span class="hljs-params">(ImageView view, String url, Drawable error)</span> </span>&#123;<br>  Glide.with(view).load(url).error(error).into(view);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span> <span class="hljs-attr">app:imageUrl</span>=<span class="hljs-string">"@&#123;venue.imageUrl&#125;"</span> <span class="hljs-attr">app:error</span>=<span class="hljs-string">"@&#123;@drawable/venueError&#125;"</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="DadaBinding-LiveData"><a href="#DadaBinding-LiveData" class="headerlink" title="DadaBinding + LiveData"></a>DadaBinding + LiveData</h3><p>要将 LiveData 与 DataBinding 一起使用，需要指定生命周期所有者来定义 LiveData 对象的范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        UserBinding binding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.user);<br><br>        binding.setLifecycleOwner(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>使用单向 DataBinding，可以在属性上设置一个值，并设置一个对该属性的更改做出反应的监听器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">CheckBox</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/rememberMeCheckBox"</span><br>    <span class="hljs-attr">android:checked</span>=<span class="hljs-string">"@&#123;viewmodel.rememberMe&#125;"</span><br>    <span class="hljs-attr">android:onCheckedChanged</span>=<span class="hljs-string">"@&#123;viewmodel.rememberMeChanged&#125;"</span><br>/&gt;</span><br></code></pre></td></tr></table></figure><p>使用双向绑定可以简化该过程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">CheckBox</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/rememberMeCheckBox"</span><br>    <span class="hljs-attr">android:checked</span>=<span class="hljs-string">"@=&#123;viewmodel.rememberMe&#125;"</span><br>/&gt;</span><br></code></pre></td></tr></table></figure><p>使用 <code>@={}</code> 接收对该属性的数据更改，并同时监听用户更新（注意，这里有 <code>=</code> ）</p><p>那么究竟什么是双向绑定呢？</p><p>所谓的「数据驱动」就是数据驱动视图的变化，而 DataBinding 的单向绑定就是如此。反过来讲，有些时候我们需要视图来驱动数据的变化（例如当我们在 EditText 上输入了文字，我们希望对应的 ViewModel 的 LiveData 的值能够及时响应该变化）</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409161036.jpg" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409110254.gif" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>如图，绿色部分为独立的 fragment ，内部存在两个 TextView，用于显示外部 fragment EditText 输入的文字</p><p>如果实现上述功能，传统做法可能是使用 activity 级别的 ViewModel 进行两个 fragment 之间的通信，通过监听 EditText 文字的变化改变 ViewModel 中 LiveData 的值，并在绿色 fragment 中观察 LiveData 并显示到 TextView 中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NormalViewModel</span> : <span class="hljs-type">ViewModel</span></span>() &#123;<br>    <span class="hljs-keyword">val</span> firstName = MutableLiveData&lt;String&gt;()<br>    <span class="hljs-keyword">val</span> lastName = MutableLiveData&lt;String&gt;()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NormalDetailFragment</span> : <span class="hljs-type">Fragment</span></span>(R.layout.fragment_normal_detail) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mViewModel <span class="hljs-keyword">by</span> activityViewModels&lt;NormalViewModel&gt;()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        mViewModel.firstName.observe(viewLifecycleOwner) &#123;<br>            tvFirstName.text = it<br>        &#125;<br>        mViewModel.lastName.observe(viewLifecycleOwner) &#123;<br>            tvLastName.text = it<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NormalFragment</span> : <span class="hljs-type">Fragment</span></span>(R.layout.fragment_normal) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mViewModel <span class="hljs-keyword">by</span> activityViewModels&lt;NormalViewModel&gt;()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        etFirstName.addTextChangedListener &#123;<br>            mViewModel.firstName.value = it.toString()<br>        &#125;<br>        etLastName.addTextChangedListener &#123;<br>            mViewModel.lastName.value = it.toString()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得益于 kotlin ，上面的代码以及很简洁了，如果使用 java 代码片段只会更长。</p><p>不过使用 DataBinding，还可以更简洁</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.textview.MaterialTextView</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/tvFirstName"</span><br>    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@&#123;vm.firstName&#125;"</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.textview.MaterialTextView</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/tvLastName"</span><br>    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@&#123;vm.lastName&#125;"</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.textfield.TextInputEditText</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/etFirstName"</span><br>    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@=&#123;vm.firstName&#125;"</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.textfield.TextInputEditText</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/etLastName"</span><br>    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@=&#123;vm.lastName&#125;"</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>只需配置好双向绑定（EditText 驱动 ViewModel 的 LiveData 的值变化，ViewModel 再驱动 TextView 显示数据），并在 fragment 通过固定的模板代码设置好 ViewModel 即可</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409112128.jpg" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这里的魔法还是来自 Binding Adapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TextViewBindingAdapter.java</span><br><span class="hljs-meta">@BindingAdapter</span>(value = &#123;<span class="hljs-string">"android:beforeTextChanged"</span>, <span class="hljs-string">"android:onTextChanged"</span>,<br>        <span class="hljs-string">"android:afterTextChanged"</span>, <span class="hljs-string">"android:textAttrChanged"</span>&#125;, requireAll = <span class="hljs-keyword">false</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTextWatcher</span><span class="hljs-params">(TextView view, <span class="hljs-keyword">final</span> BeforeTextChanged before,<br>        <span class="hljs-keyword">final</span> OnTextChanged on, <span class="hljs-keyword">final</span> AfterTextChanged after,<br>        <span class="hljs-keyword">final</span> InverseBindingListener textAttrChanged)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> TextWatcher newValue;<br>    <span class="hljs-keyword">if</span> (before == <span class="hljs-keyword">null</span> &amp;&amp; after == <span class="hljs-keyword">null</span> &amp;&amp; on == <span class="hljs-keyword">null</span> &amp;&amp; textAttrChanged == <span class="hljs-keyword">null</span>) &#123;<br>        newValue = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        newValue = <span class="hljs-keyword">new</span> TextWatcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeTextChanged</span><span class="hljs-params">(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">int</span> after)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (before != <span class="hljs-keyword">null</span>) &#123;<br>                    before.beforeTextChanged(s, start, count, after);<br>                &#125;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTextChanged</span><span class="hljs-params">(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> before, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (on != <span class="hljs-keyword">null</span>) &#123;<br>                    on.onTextChanged(s, start, before, count);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (textAttrChanged != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//通知发生变化</span><br>                    textAttrChanged.onChange();<br>                &#125;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterTextChanged</span><span class="hljs-params">(Editable s)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (after != <span class="hljs-keyword">null</span>) &#123;<br>                    after.afterTextChanged(s);<br>                &#125;<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">final</span> TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);<br>    <span class="hljs-keyword">if</span> (oldValue != <span class="hljs-keyword">null</span>) &#123;<br>        view.removeTextChangedListener(oldValue);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newValue != <span class="hljs-keyword">null</span>) &#123;<br>        view.addTextChangedListener(newValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用 InverseBindingListener （调用 <code>textAttrChanged.onChange()</code>）来通知 LiveData 数据发生变化</p><p>而变化后的值 通过 @InverseBindingAdapter 注解标记的方法处理，这里的 event 与上面的标记匹配（<code>android:textAttrChanged</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TextViewBindingAdapter.java</span><br><span class="hljs-meta">@InverseBindingAdapter</span>(attribute = <span class="hljs-string">"android:text"</span>, event = <span class="hljs-string">"android:textAttrChanged"</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getTextString</span><span class="hljs-params">(TextView view)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> view.getText().toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>view 层变化通知数据变化，数据变化再通知 view 层变化，仿佛是个套娃</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409163420.jpg" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>因此避免这种死循环十分重要，setText 方法判断了新旧值是否相等来避免死循环</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409163541.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 总结</span></h2><p>DataBinding 主要提供两部分功能</p><ul><li>替换 findViewById ，如果只用这部分功能可以使用 ViewBinding</li><li>进行 data 和 UI 的绑定，使用「数据驱动」的思想解决了视图的一致性问题</li></ul><h3 id="各种-findViewById-替代方案对比"><a href="#各种-findViewById-替代方案对比" class="headerlink" title="各种 findViewById 替代方案对比"></a>各种 findViewById 替代方案对比</h3><ul><li>findViewById </li><li>Butterknife</li><li>Kotlin Synthetics</li><li>Data Binding</li><li>View Binding</li></ul><h4 id="findViewById"><a href="#findViewById" class="headerlink" title="findViewById"></a>findViewById</h4><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409170514.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>findViewById 有两个问题</p><ol><li>当不能在 Activity/Fragment/ViewGroup 中定位到指定 id 的 View，会在运行期间崩溃，即非空安全</li><li>如果某个 view 为 TextView 类型，而在使用中将其指定为其他类型不会在编译器报错，即非类型安全</li></ol><p>在 compileSdk 的 API 级别 26 中，对该方法的定义稍作更改以消除强制类型转换问题</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409171139.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>现在，开发人员无需在代码中手动转换 view 类型。 如果您引用 id 指向类型 TextView 的 View 并将其指定为 Button，则 Android SDK 会尝试查找具有提供的 id 的 Button，并且它将返回 Null，因为它将无法找到它</p><p>但是在 Kotlin 中，您仍然需要提供诸如 findViewById<textview>(R.id.txtUsername) 之类的类型。 如果您不检查视图是否具有 null 安全，则可能出现 NullPointerException，但是此方法不会像以前那样抛出ClassCastException</textview></p><h4 id="Butterknife"><a href="#Butterknife" class="headerlink" title="Butterknife"></a>Butterknife</h4><p><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">Butterknife</a> 是 <a href="https://medium.com/u/8ddd94878165?source=post_page-----98b8ef5b9249----------------------" target="_blank" rel="noopener">Jake Wharton</a> 大神写的替代 findViewById 的库，该库使用注解处理并生成 findViewById 代码</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409171316.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>它具有与 findViewById 几乎相似的问题。 但是，它在运行时添加了null 安全检查以避免 NullPointerException</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409171554.jpg" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>由于 DataBinding 和 ViewBinding 的出现，沃神已经宣布弃用该库</p><h4 id="Kotlin-Synthetics"><a href="#Kotlin-Synthetics" class="headerlink" title="Kotlin Synthetics"></a>Kotlin Synthetics</h4><p>Kotlin 引入的最大功能之一是 Kotlin 扩展方法。 在它的帮助下，Kotlin Synthetics 诞生了。 Kotlin Synthetics 通过自动生成的 Kotlin 扩展方法，使开发人员可以从 xml 布局直接访问其内部的 view</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409171843.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>Kotlin Synthetics 第一次调用 findViewById 方法，然后默认情况下将 view 实例缓存在 HashMap 中。 可以通过Gradle 设置将此缓存配置更改为 SparseArray 或不缓存</p><p>总体而言，Kotlin Synthetics 是一种很好的选择，因为它类型安全，并且通过 Kotlin 的 ？进行空检查。 它不需要开发人员的额外代码。 但这仅适用于 Kotlin 项目</p><p>但是，在使用 Kotlin Synthetics 时遇到了一个小问题。 例如，如果将内容视图设置为布局，然后使用仅存在于其他布局中的 id ，则 IDE 可让您自动完成并添加新的 import 语句。 除非您专门检查以确保其 import 语句仅导入正确的 view，否则没有安全的方法来验证这不会导致运行时问题</p><h4 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h4><p>DataBinding 在功能上比其他方法优越得多，因为它不仅为您提供类型安全和空安全的 view 引用，而且还允许您直接在 xml 布局内使用数据驱动视图变化</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409172613.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h4 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h4><p>最近在 Android Studio 3.6 中引入的 ViewBinding 是 DataBinding 库的子集。 由于不需要注解处理，因此可以缩短构建时间。详细的使用可以参见 <a href="https://juejin.im/post/5e4806f3e51d4526c550a2ef" target="_blank" rel="noopener">这篇文章</a></p><table><thead><tr><th align="center"></th><th align="center">findViewById</th><th align="center">Butterknife</th><th align="center">Kotlin Synthetics</th><th align="center">DataBinding</th><th align="center">ViewBinding</th></tr></thead><tbody><tr><td align="center">一直空安全</td><td align="center">❌</td><td align="center">部分</td><td align="center">部分</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td align="center">类型安全</td><td align="center">❌</td><td align="center">❌</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td align="center">样板代码</td><td align="center"><font color="#CA0C16">多</font></td><td align="center"><font color="#0DD613">少</font></td><td align="center"><font color="#0DD613">少</font></td><td align="center"><font color="#B77441">中等</font></td><td align="center"><font color="#0DD613">少</font></td></tr><tr><td align="center">构建时间</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td></tr><tr><td align="center">支持语音</td><td align="center">java/kotlin</td><td align="center">java/kotlin</td><td align="center">kotlin</td><td align="center">java/kotlin</td><td align="center">java/kotlin</td></tr></tbody></table><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 关于我</span></h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Jetpack更新之Fragment】终于动手了，onActivityCreated 被弃用</title>
      <link href="/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/"/>
      <url>/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章介绍 Jetpack 组件库的更新<br><br>一直以来， fragment 的 api 都非常难用，官方也承认这一点。一个月前，fragment 中的 <code>onActivityCreated()</code> 被弃用了</p></blockquote><a id="more"></a><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p><code>fragment 1.3.0-alpha02</code> 中 <code>onActivityCreated()</code> 方法被弃用了</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200421095145.png" src="/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>让我们来看一下提交 log </p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200421092105.png" src="/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>简单翻译一下</p><p><code>onActivityCreated()</code> 最初的目的是让 fragment 的逻辑与其宿主 activity 创建建立关联，我们不鼓励这种耦合</p><p>我们应该传递外部依赖来作为 <code>FragmentFactory</code> 参数。view 相关的代码应该放置在 <code>onViewCreated()</code> 完成，其他的初始化代码应该在 <code>onCreate()</code> 中完成。为了在 <code>activity onCreate()</code> 完成后接收回调，可以添加一个 activity 生命周期的 <code>LifecycleObserver</code> ，并且接收到 <code>Lifecycle.State#CREATED</code> 回调时将其移除</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttach</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onAttach(context)<br>    requireActivity().lifecycle.addObserver(<span class="hljs-keyword">object</span> : DefaultLifecycleObserver &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(owner: <span class="hljs-type">LifecycleOwner</span>)</span></span> &#123;<br>            <span class="hljs-comment">// 想做啥做点啥</span><br>            owner.lifecycle.removeObserver(<span class="hljs-keyword">this</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DialogFragment"><a href="#DialogFragment" class="headerlink" title="DialogFragment"></a>DialogFragment</h2><p>那么 <code>DialogFragment</code> 怎么办？其 <code>onActivityCreated</code> 变为可选的</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200421101629.png" src="/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>简单翻译一下</p><p><code>DialogFragment</code> 使用 <code>onActivityCreated</code>() 帮助创建 dialog。onActivityCreated() 弃用后我们应当寻找一个更好的方式来执行这部分逻辑</p><p>关于 view 相关的代码已经转移至 <code>DialogFragment</code></p><p> 的 <code>viewLifecycleOwnerLiveData</code> ，其他初始化逻辑可以放在 <code>onGetLayoutInflater</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200421103420.png" src="/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我们仍支持为自定义 dialog 在 <code>onActivityCreated()</code> 中配置 dialog</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>查看 <code>Jetpack fragment</code> 的变动，不难看出官方正致力于为 fragment 「减负」，将小的，独立的功能从 fragment 中抽离出去，降低耦合，后续文章我们介绍其他的改动</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg" src="/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></div>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
            <tag> Fragment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Jetpack更新之Recyclerview】更优雅地恢复 recyclerview 的滚动位置</title>
      <link href="/2020/04/09/Jetpack-Recyclerview-Scoroll/"/>
      <url>/2020/04/09/Jetpack-Recyclerview-Scoroll/</url>
      
        <content type="html"><![CDATA[<h2 id="被我忽视的更新"><a href="#被我忽视的更新" class="headerlink" title="被我忽视的更新"></a>被我忽视的更新</h2><p><code>androidx recyclerview 1.2.0-alpha02</code> 版本添加了新功能 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" target="_blank" rel="noopener">MergeAdapter</a>，帮助开发者更容易地为 RecyclerView 添加 Header 和 Footer。详情参见 <a href="https://juejin.im/post/5e86ffea51882573ba207a19" target="_blank" rel="noopener">【译】MergeAdapter 的使用 使用官方 API 为 Recyclerview 添加 Header 和 Footer</a></p><p>该版本中还有一个改动：<strong><code>RecyclerView.Adapter</code> lazy state restoration</strong>，帮助开发者恢复 RecyclerView 的状态</p><a id="more"></a><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512105548.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="recyclerview update"></p><p>我对这个功能并没有什么感觉。众所周知，Android 中的 View 内部是有着状态保存和恢复的方法的。RecyclerView 也是如此，它可以恢复自身已滚动的位置</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512110411.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="View 内部恢复状态"></p><p>有关状态保存的内容可以参见 <a href="https://juejin.im/post/5e738d12518825495d69cfb9" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a></p><p>真实情况也是如此</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512111315.gif" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="RecyclerView 内部可以恢复滚动位置"></p><h2 id="意外发现"><a href="#意外发现" class="headerlink" title="意外发现"></a>意外发现</h2><p>最近看到 <a href="https://medium.com/@florina.muntenescu?source=post_page-----a8fbdc9a9334----------------------" target="_blank" rel="noopener">Florina Muntenescu</a> 的 <a href="https://medium.com/androiddevelopers/restore-recyclerview-scroll-position-a8fbdc9a9334" target="_blank" rel="noopener">Restore RecyclerView scroll position</a> ，其中介绍了 <strong><code>RecyclerView.Adapter</code> lazy state restoration</strong>，这勾起了我的兴趣</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512111720.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="意外发现"></p><p>如文中描述，RecyclerView 在 activity/fragment 重建时失去滚动位置是因为 Adapter 中的数据是 <strong>异步</strong> 加载的，当 RecyclerView layout 时数据并没有加载，因此也恢复不了之前的位置状态。一个比较简单的例子是使用 Navigation 组件进行导航，返回时 fragment 中的 RecyclerView 由于再次调用接口获取数据，导致其滑动位置失去</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512113141.gif" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="延迟加载数据，无法恢复滚动位置"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有几种方法可以保证 RecyclerView 恢复到正确的滚动位置，最好的办法是借助缓存，ViewModel 或 Repository 中缓存要显示的数据，确保始终在第一个布局传入前在 Adapter 上设置数据。也有一些其他的方案，这些方案要么太复杂，要么不够优雅</p><p><code>recyclerview:1.2.0-alpha02</code> 中的解决方案是提供一个新的 Adapter 方法，该方法允许设置状态恢复策略，它有三个选项</p><ul><li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter.StateRestorationPolicy#ALLOW" target="_blank" rel="noopener">ALLOW</a></li><li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter.StateRestorationPolicy#PREVENT_WHEN_EMPTY" target="_blank" rel="noopener">PREVENT_WHEN_EMPTY</a></li><li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter.StateRestorationPolicy#PREVENT" target="_blank" rel="noopener">PREVENT</a></li></ul><h3 id="ALLOW"><a href="#ALLOW" class="headerlink" title="ALLOW"></a>ALLOW</h3><p>这是 <strong>默认</strong> 的状态，它会立即恢复 RecyclerView 的状态，该种策略无法解决延迟加载的数据的问题，可以使用 <code>PREVENT_WHEN_EMPTY</code></p><h3 id="PREVENT-WHEN-EMPTY"><a href="#PREVENT-WHEN-EMPTY" class="headerlink" title="PREVENT_WHEN_EMPTY"></a>PREVENT_WHEN_EMPTY</h3><p>仅当 Adapter 不为空（adapter.getItemCount() &gt; 0）时，才恢复 RecyclerView 状态。 如果您的数据是异步加载的，那么 RecyclerView 会一直等到数据加载完毕，然后状态才能恢复。 如果您有默认 item（例如 Header 或 加载指示器）作为适配器的一部分，则应该使用<code>PREVENT</code> 选项，除非使用 MergeAdapter 添加了默认 item。 MergeAdapter 等待所有适配器准备就绪，然后才恢复状态</p><h3 id="PREVENT"><a href="#PREVENT" class="headerlink" title="PREVENT"></a>PREVENT</h3><p>状态不会恢复，直到配置了 <code>ALLOW</code> 或者 <code>PREVENT_WHEN_EMPTY</code></p><p>使用方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">adapter.stateRestorationPolicy = PREVENT_WHEN_EMPTY<br></code></pre></td></tr></table></figure><p><strong>加入了上面的配置后即使是异步加载数据也能恢复 RecyclerView 的位置</strong></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512114332.gif" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="设置 PREVENT_WHEN_EMPTY"></p><h2 id="追踪引入过程"><a href="#追踪引入过程" class="headerlink" title="追踪引入过程"></a>追踪引入过程</h2><p>老规矩，我们沿着官方的 commit log 来看看其实现原理</p><p>首先我们看看 <a href="https://issuetracker.google.com/issues/146365793" target="_blank" rel="noopener">IssueTracker 上提的 Feature</a></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512115048.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="IssueTracker"></p><p>表达的意思也很简单，就是当加载异步数据时 RecyclerView 的位置状态无法恢复，Adapter 应该提供相关的解决方案</p><p>有意思的是，实现该功能时还重新实现了前一个版本的逻辑，我在 git commit log 中看到了 revert 操作</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512140140.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="revert操作"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512120004.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>为了防止 <code>LayoutManager#onRestore</code> 执行多次，没有采用最开始的实现方式。但 Yigit Boyar (这个提交的开发者) 仍然希望使用最开始的实现方式，但是  <code>LayoutManager#onRestoreInstance</code> 的状态时 public ，因此只能选取一个折中的方案</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512141210.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="新的实现方案"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512141445.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="无奈之举"></p><p>过去，开发者会无意间调用 <code>onRestoreInstanceState(State)</code> 方法。例如，一些开发者已使用它来手动设置自己更新的状态，这样即使在此状态之前已恢复，在此处传递状态也将导致 LayoutManager 接收它并相应地更新其内部状态。因此，即使看起来好像很奇怪，也必须始终调用 <code>requestLayout</code> 来保留功能</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>接下来我们来分析这部分源码，内容很少，所以我们详细看下</p><p>首先是引入 <code>StateRestorationPolicy</code>的枚举</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512143600.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>然后需要提供 <code>setStateRestorationPolicy</code> 和 <code>getStateRestorationPolicy</code> 方法，此时我们还需要一个方法来判断是否要将 SavedState 传递给 LayoutManager</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512143459.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>前面的 <code>setStateRestorationPolicy</code> 方法中 调用了 <code>notifyStateRestorationPolicyChanged</code>，而 <code>notifyStateRestorationPolicyChanged</code> 为静态类 <code>AdapterDataObservable</code> 中的方法，该类中的其他方法我们也很熟悉，均是刷新 Adapter 中数据的方法。</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512143858.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="notifyStateRestorationPolicyChanged"></p><p>而 <code>notifyStateRestorationPolicyChanged</code> 中调用了 mObservers list 中元素的 <code>onStateRestorationPolicyChanged</code> 方法，通过源码我们得知该 list 中的元素类型为 <code>AdapterDataObserver</code>，因此还需要在 <code>AdapterDataObserver</code> 中加入 <code>onStateRestorationPolicyChanged</code> 方法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512144501.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="onStateRestorationPolicyChanged "></p><p>该方法是个空实现，而 <code>RecyclerViewDataObserver</code> 重写了该方法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512144716.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="RecyclerViewDataObserver "></p><p>配置恢复策略以及恢复策略变化时的监听都有了，接下来要做的就是如果之前有待恢复的装则恢复之前的状态</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512145152.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="恢复状态"></p><blockquote><p>注意：发布之前 <code>StateRestorationPolicy</code> 叫做 <code>StateRestorationStrategy</code>，后来命名为 <code>StateRestorationPolicy</code>，alpha 版本的库可能随时更改 API 的命名和删除 API，因此查看这部分源码的同学请注意</p></blockquote><p>至此，相关的源码都在这里了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>StateRestorationPolicy</code> 提供了 RecyclerView 异步加载数据恢复滚动位置的解决方案。原理就是通过配置 <code>StateRestorationPolicy</code> 来改变恢复策略，同时在策略改变时调用 <code>requestLayout</code> 方法。在 <code>dispatchLayoutStep2()</code> (该方法会在 onLayout 和 measure 方法中调用) 方法中恢复状态(如果 <code>canRestoreState()</code> 返回 true)</p><p><a href="https://github.com/Flywith24/Flywith24-Jetpack-Demo/tree/master/demo_recyclerview_scroll" target="_blank" rel="noopener">demo 地址</a></p><p><strong>一点思考：我们都知道 ViewPager2 是使用 RecyclerView 实现的，那么借助本文介绍的 API 可以做点什么吗？</strong></p><p>欢迎各位小伙伴在评论区留言，说说你的想法</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200508153754.jpg" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【背上Jetpack之LiveData】ViewModel的左膀右臂 数据驱动真的香</title>
      <link href="/2020/03/31/Jetpack-LiveData/"/>
      <url>/2020/03/31/Jetpack-LiveData/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>之前我们讨论过 <a href="https://juejin.im/post/5e786d415188255e00661a4e" target="_blank" rel="noopener">ViewModel 的职能边界</a> ，得益于 ViewModel 的生命周期更长，我们可以在 activity 重建后将数据传递给 activity ，也可以避免内存泄漏。但是如果不是每次需要就获取数据，而是当每次有新数据时通知我们，应该怎么办？</p></blockquote><p>本文介绍 <code>LiveData</code> ，一个 <strong>生命周期感知的，可观察的，数据持有者</strong>。同时还会简单分析 <code>LiveData</code> 的源码实现</p><a id="more"></a><h2 id="我们都是-Adapter"><a href="#我们都是-Adapter" class="headerlink" title="我们都是 Adapter"></a>我们都是 Adapter</h2><p>在谈 <code>LiveData</code> 前我们来思考一个问题</p><p><strong>Android 开发（亦或者说前端开发）的本质工作内容是什么？</strong></p><p>对于应用层 app 开发者，开发者的工作主要工作就是 Adapter </p><p>什么是 Adapter ，下图可能比较直观</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330153727.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Adapter"></p><blockquote><p>图片来自 google image</p></blockquote><p>我们的工作本质是 <strong>将数据转换成 UI</strong> </p><p>数据可能来自网络，来自本地数据库，来自内存，而 UI 可能是 activity 或 fragment。</p><h2 id="理想的数据模型"><a href="#理想的数据模型" class="headerlink" title="理想的数据模型"></a>理想的数据模型</h2><p>上面我们提到 Android 开发者的核心工作就是将数据转换为 UI 。这个过程比较理想的状态是：当数据发生变化时，UI 跟随变化。我们还可以进一步展开：当 UI 对用户可见时，数据发生变化时 UI 跟随变化；当 UI 对用户不可见时，我们希望数据变化时什么都不做，当 UI 再次对用户可见时根据最新的数据进行 UI 的处理。</p><p>而 <code>LiveData</code> 就是我们理想中的数据模型</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330160205.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="LiveData"></p><blockquote><p>图片来自 <a href="https://www.youtube.com/watch?v=2rO4r-JOQtA&list=PLWz5rJ2EKKc_dskHzXdKHB2ZvAlMyFwZe&index=2&t=0s" target="_blank" rel="noopener">Android Dev Summit ‘18-Fun with LiveData</a></p></blockquote><p> LiveData 可以三个关键词概括</p><ul><li><p>lifecycle-aware</p></li><li><p>observable</p></li><li><p>data holder</p></li></ul><h3 id="observable"><a href="#observable" class="headerlink" title="observable"></a>observable</h3><p>Android 中不同的组件有着不同的生命周期，不同的存活时间</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321140641.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ViewModel"></p><p>因此我们不会在 <code>ViewModel</code> 中持有 <code>Activity</code> 的引用，因为这会导致当 <code>Activity</code> 重建时内存泄漏，甚至出现空指针的情况</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330161100.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="observable"></p><p>通常我们会在 <code>Activity</code> 中持有 <code>ViewModel</code> 的引用，那么如何进行二者间的通信，如何向 <code>Activity</code> 发送 <code>ViewModel</code> 中的数据？</p><p>答案是让 <code>Activity</code> 观察 <code>ViewModel</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330161411.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><code>LiveData</code> 是 <code>observable</code></p><h3 id="lifecycle-aware"><a href="#lifecycle-aware" class="headerlink" title="lifecycle-aware"></a>lifecycle-aware</h3><p>当观察者观察着某个数据时，该数据必须保留对观察者的引用才能调用它，为了解决这个问题，<code>LiveData</code> 被设计成可感知生命周期</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330162126.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>当 activity / fragment 被销毁后，它会自动的取消订阅</p><h3 id="data-holder"><a href="#data-holder" class="headerlink" title="data holder"></a>data holder</h3><p><code>LiveData</code> 仅持有 <strong>单个且最新</strong> 的数据</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330214220.gif" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="data holder"></p><p>上图中，最右侧是在 <code>ViewModel</code> 中的 <code>LiveData</code>，左侧为观察这个 <code>LiveData</code> 的 activity / fragment 。一旦我们为 <code>LiveData</code> 设值，该值会传递到 activity。简而言之，<code>LiveData</code> 值改变，activity 收到最新的值的变化。但是当观察者不再处于活动状态（STARTED 到 RESUMED ），数据 C 不会被发送到 activity 。当 activity 回到前台，它将收到最新的值，数据 D。<strong>LiveData 仅持有单个且最新的数据</strong>。当 activity 执行销毁流程时，此时的数据 E 也不会产生任何影响</p><h2 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h2><p><code>LiveData</code> 提供 两种 transformation ，<code>map</code> 和 <code>switch map</code>。开发者也可以创建自定义的  <code>MediatorLiveData</code> </p><p>我们都知道 <code>LiveData</code> 可以为 View 和 ViewModel 提供通信，但如果有一个第三方组件（例如 repository ）也持有 <code>LiveData</code>。那么它应该如何在 <code>ViewModel</code> 中订阅？该组件并没有 lifecycle </p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331090310.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>一旦我们的应用愈发复杂，repository 可能会观察数据源</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331090412.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>那么 view 如何获取 repository 中的 <code>LiveData</code>？</p><h3 id="一对一的静态转换（map）"><a href="#一对一的静态转换（map）" class="headerlink" title="一对一的静态转换（map）"></a>一对一的静态转换（map）</h3><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331090941.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="one-to-one static transformation"></p><p>在上面的示例中，<code>ViewModel</code> 仅将数据从 repository 转发到 view，然后将其转换为 UI Model。 每当 repository 中有新数据时，<code>ViewModel</code> 只需 <code>map</code> </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainViewModel</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> viewModelResult = Transformations.map(repository.getDataForUser()) &#123; <span class="hljs-keyword">data</span> -&gt;<br>     convertDataToMainUIModel(<span class="hljs-keyword">data</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个参数为 <code>LiveData</code> 源（来自 repository ），第二个参数是一个转换函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这里的转换为将 X 转换为 Y</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;X, Y&gt;</span> LiveData<span class="hljs-type">&lt;X&gt;</span>.<span class="hljs-title">map</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> transform: (<span class="hljs-type">X</span>)</span></span> -&gt; Y): LiveData&lt;Y&gt; =<br>        Transformations.map(<span class="hljs-keyword">this</span>) &#123; transform(it) &#125;<br></code></pre></td></tr></table></figure><h3 id="一对一的动态转换（switchMap）"><a href="#一对一的动态转换（switchMap）" class="headerlink" title="一对一的动态转换（switchMap）"></a>一对一的动态转换（switchMap）</h3><p>假如您正在观察一个提供用户的用户管理器，并且需要提供用户的 id 才能开始观察 repository </p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331091954.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>您不能将其写到 <code>ViewModel</code> 初始化的过程中，因为此时用户的 id 还不可用</p><p>这时 <code>switchMap</code> 就派上用场了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainViewModel</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> repositoryResult = Transformations.switchMap(userManager.userId) &#123; userId -&gt;<br>     repository.getDataForUser(userId)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>switchMap</code> 在内部使用 <code>MediatorLiveData</code>，因此了解它非常重要，因为当您要组合多个 <code>LiveData</code> 源时需要使用它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这里的转换为将 X 转换为 LiveData&lt;Y&gt;</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;X, Y&gt;</span> LiveData<span class="hljs-type">&lt;X&gt;</span>.<span class="hljs-title">switchMap</span><span class="hljs-params">(<br>    <span class="hljs-keyword">crossinline</span> transform: (<span class="hljs-type">X</span>)</span></span> -&gt; LiveData&lt;Y&gt;<br>): LiveData&lt;Y&gt; = Transformations.switchMap(<span class="hljs-keyword">this</span>) &#123; transform(it) &#125;<br></code></pre></td></tr></table></figure><h3 id="一对多依赖（MediatorLiveData）"><a href="#一对多依赖（MediatorLiveData）" class="headerlink" title="一对多依赖（MediatorLiveData）"></a>一对多依赖（MediatorLiveData）</h3><p><code>MediatorLiveData</code> 允许您将一个或多个数据源添加到单个可观察的 <code>LiveData</code> 中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> liveData1: LiveData&lt;<span class="hljs-built_in">Int</span>&gt; = ...<br><span class="hljs-keyword">val</span> liveData2: LiveData&lt;<span class="hljs-built_in">Int</span>&gt; = ...<br><br><span class="hljs-keyword">val</span> result = MediatorLiveData&lt;<span class="hljs-built_in">Int</span>&gt;()<br><br>result.addSource(liveData1) &#123; value -&gt;<br>    result.setValue(value)<br>&#125;<br>result.addSource(liveData2) &#123; value -&gt;<br>    result.setValue(value)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，当任何一个数据源变化时，result 会更新。</p><blockquote><p>注意：数据并不是合并，MediatorLiveData 只是处理通知</p></blockquote><p>为了实现示例中的转换，我们需要将两个不同的 LiveData 组合为一个</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331094815.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>图片来自 <a href="https://medium.com/androiddevelopers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7" target="_blank" rel="noopener">LiveData beyond the ViewModel — Reactive patterns using Transformations and MediatorLiveData</a></p></blockquote><p>使用 <code>MediatorLiveData</code> 合并数据的一种方法是添加源并以其他方法设置值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">blogpostBoilerplateExample</span><span class="hljs-params">(newUser: <span class="hljs-type">String</span>)</span></span>: LiveData&lt;UserDataResult&gt; &#123;<br><br>    <span class="hljs-keyword">val</span> liveData1 = userOnlineDataSource.getOnlineTime(newUser)<br>    <span class="hljs-keyword">val</span> liveData2 = userCheckinsDataSource.getCheckins(newUser)<br><br>    <span class="hljs-keyword">val</span> result = MediatorLiveData&lt;UserDataResult&gt;()<br><br>    result.addSource(liveData1) &#123; value -&gt;<br>        result.value = combineLatestData(liveData1, liveData2)<br>    &#125;<br>    result.addSource(liveData2) &#123; value -&gt;<br>        result.value = combineLatestData(liveData1, liveData2)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>数据的实际组合是在 <code>combineLatestData</code> 方法中完成的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">combineLatestData</span><span class="hljs-params">(<br>        onlineTimeResult: <span class="hljs-type">LiveData</span>&lt;<span class="hljs-type">Long</span>&gt;,<br>        checkinsResult: <span class="hljs-type">LiveData</span>&lt;<span class="hljs-type">CheckinsResult</span>&gt;<br>)</span></span>: UserDataResult &#123;<br><br>    <span class="hljs-keyword">val</span> onlineTime = onlineTimeResult.value<br>    <span class="hljs-keyword">val</span> checkins = checkinsResult.value<br><br>    <span class="hljs-comment">// Don't send a success until we have both results</span><br>    <span class="hljs-keyword">if</span> (onlineTime == <span class="hljs-literal">null</span> || checkins == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> UserDataLoading()<br>    &#125;<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Check for errors and return UserDataError if any.</span><br><br>    <span class="hljs-keyword">return</span> UserDataSuccess(timeOnline = onlineTime, checkins = checkins)<br>&#125;<br></code></pre></td></tr></table></figure><p>检查值是否准备好并发出结果（加载中，失败或成功）</p><h2 id="LiveData-的错误用法"><a href="#LiveData-的错误用法" class="headerlink" title="LiveData 的错误用法"></a>LiveData 的错误用法</h2><h3 id="错误地使用-var-LiveData"><a href="#错误地使用-var-LiveData" class="headerlink" title="错误地使用 var LiveData"></a>错误地使用 var LiveData</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> <span class="hljs-keyword">lateinit</span> randomNumber: LiveData&lt;<span class="hljs-built_in">Int</span>&gt;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onGetNumber</span><span class="hljs-params">()</span></span> &#123;<br>   randomNumber = Transformations.map(numberGenerator.getNumber()) &#123;<br>       it<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个重要的问题需要理解：转换会在调用时（<code>map</code> 和 <code>switchMap</code>）会创建一个新的 <code>LiveData</code>。 在此示例中，randomNumber 公开给 View ，但是每次用户单击按钮时都会对其进行重新赋值。 观察者只会在订阅时收到分配给 var 的 <code>LiveData</code> 更新的信息</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 只会收到第一次分配的值</span><br>viewmodel.randomNumber.observe(<span class="hljs-keyword">this</span>, Observer &#123; number -&gt;<br>    numberTv.text = resources.getString(R.string.random_text, number)<br>&#125;)<br></code></pre></td></tr></table></figure><p>如果 viewmodel.randomNumber <code>LiveData</code> 实例发生更改，这里永远不会回调。而且这里泄漏了之前的 <code>LiveData</code> ，这些 <code>LiveData</code> 不会再发送更新</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331111630.gif" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>一言以蔽之，<strong>不要在 var 中使用 Livedata</strong></p><p>正确示例见  <a href="https://github.com/Flywith24/Flywith24-Jetpack-Demo/tree/master/demo_livedata" target="_blank" rel="noopener">demo</a></p><h3 id="LiveData-粘性事件"><a href="#LiveData-粘性事件" class="headerlink" title="LiveData 粘性事件"></a>LiveData 粘性事件</h3><p>一般来说我们使用 LiveData 持有 UI 数据和状态，但是如果通过它来发送事件，可能会出现一些问题。这些问题及解决方案 <a href="https://juejin.im/post/5b2b1b2cf265da5952314b63" target="_blank" rel="noopener">在这</a></p><h3 id="fragment-中错误地传入-LifecycleOwner"><a href="#fragment-中错误地传入-LifecycleOwner" class="headerlink" title="fragment 中错误地传入 LifecycleOwner"></a>fragment 中错误地传入 LifecycleOwner</h3><p><code>androidx fragment 1.2.0</code> 起，添加了新的 Lint 检查，以确保您在从 onCreateView()、onViewCreated() 或 onActivityCreated() 观察 <code>LiveData</code> 时使用 getViewLifecycleOwner()</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331152505.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331205402.gif" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="bug"></p><p>如图，我们有一个 fragment ，onCreate 观察 <code>LiveData</code>，通过正常的生命周期创建了 View ，接着进入了 resume 状态。此时你使用了 <code>LiveData</code>，UI 将开始展示它。之后，用户点击了按钮，由于跳转了另一个 fragment，所以要 detach 该 fragment，一旦 fragment stop 我们就不需要其中的 view 了，因此 destroyView 。之后用户点击了返回按钮回到了上一个 fragment，由于我们已经 destroyView，因此我们需要创建一个新的 view ，接着进入正常的生命周期，但此时，出现了一个 bug 。这个新 View 不会恢复 <code>LiveData</code> 的状态，因为我们使用的是 fragment 的 lifecycle observe 的 <code>LiveData</code></p><p>我们有两种选择，在 onCreate 或者在 onCreateView 中使用 fragment 的 lifecycle observe LiveData</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331171844.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>前者的优点是一次注册，缺点是当 recreate 时有bug；后者优点是能够解决 recreate 的 bug，但会导致重复注册</p><p><strong>该问题的核心是 fragment 拥有两个生命周期：fragment 自身和 fragment 内部 view 的生命周期</strong></p><p><code>androidx fragment 1.0</code> 和 <code>support library 28</code> 了 viewLifecycle</p><p><strong>因此，当需要观察 view 相关的 LiveData ，可以在 onCreateView()、onViewCreated() 或 onActivityCreated()  中 LiveData observe 方法中传入 viewLifecycleOwner 而不是传入 this</strong></p><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p>首先来看 <code>LiveData</code> 主要的源码结构</p><ul><li>LiveData </li><li>MutableLiveData</li><li>Observer</li></ul><h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p><code>LiveData</code> 是可以在给定生命周期内观察到的数据持有者类。 这意味着可以将一个<code>Observer</code> 与 <code>LifecycleOwner</code> 成对添加，并且只有在配对的 <code>LifecycleOwner</code> 处于活动状态时，才会向该观察者通知有关包装数据的修改。 如果 LifecycleOwner 的状态为 <code>Lifecycle.State.STARTED</code> 或 <code>Lifecycle.State.RESUMED</code>，则将其视为活动状态。 通过 <code>observeForever</code>（Observer）添加的观察者被视为始终处于活动状态，因此将始终收到有关修改的通知。 对于那些观察者，需要手动调用 <code>removeObserver</code>（Observer）</p><p>如果相应的生命周期移至 <code>Lifecycle.State.DESTROYED</code> 状态，则添加了生命周期的观察者将被自动删除。 这对于 activity 和 fragment 可以安全地观察 <code>LiveData</code> 而不用担心泄漏</p><p>此外，<code>LiveData</code> 具有 onActive() 和 onInactive() 方法，以便在活动观察者的数量在 0 到 1 之间变化时得到通知。这使 <code>LiveData</code> 在没有任何活动观察者的情况下可以释放大量资源。</p><p>主要方法有：</p><ul><li>T getValue() 获取LiveData 包装的数据</li><li>observe(LifecycleOwner owner, Observer&lt;? super T&gt; observer) 设置观察者（主线程调用）</li><li>setValue(T value)  设值（主线程调用），可见性为 protected 无法直接使用</li><li>postValue(T value) 设置（其他线程调用），可见性为 protected 无法直接使用</li></ul><h3 id="MutableLiveData"><a href="#MutableLiveData" class="headerlink" title="MutableLiveData"></a>MutableLiveData</h3><p><code>LiveData</code> 实现类，公开了 <code>setValue</code> 和 <code>postValue</code> 方法</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>接口，内部只有 onChanged(T t) 方法，在数据变化时该方法会被调用</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们通过源码来看看 <code>LiveData</code> 如何实现它的特性的</p><ul><li><ol><li>如何控制在 activity 或 fragment 活动状态时接收回调，否则不接收？</li></ol></li><li><ol start="2"><li>如何在 activity 或 fragment 销毁时自动取消注册观察者？</li></ol></li><li><ol start="3"><li>如何保证 <code>LiveData</code> 持有最新的数据？</li></ol></li></ul><p>我们查看 <code>LiveData</code> 的 observe 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LiveData.java</span><br><span class="hljs-meta">@MainThread</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">observe</span><span class="hljs-params">(LifecycleOwner owner, Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;<br>        <span class="hljs-comment">// 如果 owner 已经是 DESTROYED 状态，则忽略</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 使用 LifecycleBoundObserver 包装 owner 和 observer</span><br>    LifecycleBoundObserver wrapper = <span class="hljs-keyword">new</span> LifecycleBoundObserver(owner, observer);<br>    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);<br>    <span class="hljs-comment">// 如果已经添加过直接 return </span><br>    <span class="hljs-keyword">if</span> (existing != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>    owner.getLifecycle().addObserver(wrapper);<br>&#125;<br><br><span class="hljs-comment">// LifecycleBoundObserver.java</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifecycleBoundObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ObserverWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LifecycleEventObserver</span> </span>&#123;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-keyword">final</span> LifecycleOwner mOwner;<br>    LifecycleBoundObserver(LifecycleOwner owner, Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer) &#123;<br>        <span class="hljs-keyword">super</span>(observer);<br>        mOwner = owner;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过源码我们知道，当我们调用 observe 方法时，内部是通过 <code>LifecycleBoundObserver</code> 将 owner 和 observer 包裹起来并通过 <code>addObserver</code> 方法添加观察者的，因而当数据变化时，会调用 <code>LifecycleBoundObserver</code> 的 <code>onStateChanged</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LiveData.LifecycleBoundObserver.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(@NonNull LifecycleOwner source,<br>        @NonNull Lifecycle.Event event)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;<br>        <span class="hljs-comment">// 自动移除观察者，问题 2 得到解释</span><br>        removeObserver(mObserver);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    activeStateChanged(shouldBeActive());<br>&#125;<br></code></pre></td></tr></table></figure><p>当什么周期所有者处于 <code>DESTROYED</code> 状态时，会调用 <code>removeObserver</code> 方法，因此问题 2  得到解释</p><p>我们继续向下看，<code>activeStateChanged</code> 方法调用时传入了 <code>shouldBeActive()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldBeActive</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 至少是 STARTED 状态 返回 true</span><br>    <span class="hljs-keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activeStateChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> newActive)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (newActive == mActive) &#123;<br>        <span class="hljs-comment">// 与上次值相同，则直接 return （两次均为活动状态或均为非活动状态）</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    mActive = newActive;<br>    <span class="hljs-keyword">boolean</span> wasInactive = LiveData.<span class="hljs-keyword">this</span>.mActiveCount == <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 根据 mActive 修改活动状态观察者的数量（加 1 或减 1 ）</span><br>    LiveData.<span class="hljs-keyword">this</span>.mActiveCount += mActive ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;<br>        onActive();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (LiveData.<span class="hljs-keyword">this</span>.mActiveCount == <span class="hljs-number">0</span> &amp;&amp; !mActive) &#123;<br>        onInactive();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mActive) &#123;<br>        <span class="hljs-comment">// 如果是活动状态，则发送数据，问题 1 得到解释</span><br>        dispatchingValue(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里牵扯了 <code>Lifecycle State</code> 比较的知识，<a href="https://juejin.im/post/5e8348bef265da47e02a6ce2#heading-11" target="_blank" rel="noopener">详情在这</a></p><p>只有 <code>STARTED</code> 和 <code>RESUMED</code> 状态 <code>shouldBeActive()</code> 才返回 true，至此问题 1 得到解释</p><p><code>dispatchingValue</code> 方法内部调用了 <code>considerNotify</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">considerNotify</span><span class="hljs-params">(ObserverWrapper observer)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!observer.mActive) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 再次判断生命周期所有者状态</span><br>    <span class="hljs-keyword">if</span> (!observer.shouldBeActive()) &#123;<br>        observer.activeStateChanged(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 比较版本号</span><br>    <span class="hljs-keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    observer.mLastVersion = mVersion;<br>    <span class="hljs-comment">// 调用我们传入的 mObserver 的 onChanged 方法</span><br>    observer.mObserver.onChanged((T) mData);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>considerNotify</code> 中比较了 observer 的版本号，如果是最新的数据，直接 return</p><p>而 <code>mVersion</code> 在 <code>setValue</code> 方法中 进行更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MainThread</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-comment">// 每次设置对 mVersion 进行++</span><br>    mVersion++;<br>    mData = value;<br>    dispatchingValue(<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此 <code>LiveData</code> 每次都持有最新的数据，问题 3 得到解释</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到本文开头的思考，Android 开发者的主要工作是将数据转换成 UI ，而 <code>LiveData</code> 本质上是一种「数据驱动」，即通过改变状态数据，来驱动视图树中绑定了相应状态数据的控件重新发生绘制。Flutter 和未来的  Jetpack Compose 采用的都是这种机制。使用 ViewModel + LiveData，可以 <strong>安全地在订阅者的生命周期内分发正确的数据</strong>，使开发者不知不觉中完成了 <code>UI -&gt; ViewModel -&gt; Data</code> 的单向依赖。</p><p><strong>所谓架构，很多时候不是使用它能做什么，更多的是不要做什么，使用它时开发者能够得到约束，以便产出更健壮的代码</strong></p><p>各位小伙伴如果有什么想法欢迎在评论区留言</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【背上Jetpack之Lifecycle】万物基于Lifecycle 默默无闻大作用</title>
      <link href="/2020/03/30/Jetpack-Lifecycle/"/>
      <url>/2020/03/30/Jetpack-Lifecycle/</url>
      
        <content type="html"><![CDATA[<blockquote><p> Android 中有一个比较重要的概念：「生命周期」。刚毕业去面试，总会被问到「四大组件的生命周期」这类的问题。17年的 IO 大会上，Google 推出了 Lifecycle-Aware Components（生命周期感知组件），帮助开发者组织更好，更轻量，易于维护的代码</p></blockquote><p>本文介绍 <code>Lifecycle</code> 的职责以及简单分析 lifecycle 如何感知 activity 和 fragment ，帮助您对 <code>Lifecycle</code> 有一个感性的认识</p><a id="more"></a><h2 id="万物基于-Lifecycle"><a href="#万物基于-Lifecycle" class="headerlink" title="万物基于 Lifecycle"></a>万物基于 <strong>Lifecycle</strong></h2><h3 id="手动管理生命周期的痛苦你不懂"><a href="#手动管理生命周期的痛苦你不懂" class="headerlink" title="手动管理生命周期的痛苦你不懂"></a>手动管理生命周期的痛苦你不懂</h3><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/30/1712bbbbf69f3b1e?w=2407&h=5062&f=jpeg&s=2270014" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="lifecycles"></p><blockquote><p> 鲁迅曾说过：万物基于 Lifecycle</p></blockquote><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331214314.jpeg" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>哦不对</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331214054.jpeg" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>Android 中的视图控制器就有这么多生命周期的情况，所以处理好生命周期十分重要，否则会导致内存泄漏甚至是程序崩溃。这里引用 <a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">官方文档</a> 的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLocationListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyLocationListener</span><span class="hljs-params">(Context context, Callback callback)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 连接系统的定位服务</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 与系统的定位服务断开连接</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> MyLocationListener myLocationListener;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(...)</span> </span>&#123;<br>        myLocationListener = <span class="hljs-keyword">new</span> MyLocationListener(<span class="hljs-keyword">this</span>, (location) -&gt; &#123;<br>            <span class="hljs-comment">// 更新 UI</span><br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onStart();<br>        myLocationListener.start();<br>        <span class="hljs-comment">//管理其他需要响应 activity 生命周期的组件</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onStop();<br>        myLocationListener.stop();<br>        <span class="hljs-comment">//管理其他需要响应 activity 生命周期的组件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此示例看起来不错，在实际的应用程序中，您仍然会响应生命周期的当前状态而进行过多的调用来管理 UI 和其他组件。 管理多个组件会在生命周期方法中放置大量代码，例如 onStart() 和 onStop()，这使它们难以维护</p><p>而且，不能保证组件在 activity 或 fragment 停止之前就已启动。 如果我们需要执行长时间运行的操作（例如onStart() 中的某些配置检查），则可能会导致争用情况，其中onStop() 方法在 onStart() 之前完成，从而使组件的生存期超过了所需的生存期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> MyLocationListener myLocationListener;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(...)</span> </span>&#123;<br>        myLocationListener = <span class="hljs-keyword">new</span> MyLocationListener(<span class="hljs-keyword">this</span>, location -&gt; &#123;<br>            <span class="hljs-comment">// 更新 UI</span><br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onStart();<br>        Util.checkUserStatus(result -&gt; &#123;<br>            <span class="hljs-comment">// 如果在 activity 停止后调用此回调怎么办？</span><br>            <span class="hljs-keyword">if</span> (result) &#123;<br>                myLocationListener.start();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onStop();<br>        myLocationListener.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有所有的组件，都能感知外部的生命周期，能在相应的时机释放资源，并且在错过生命周期时能及时叫停异步的任务就好了，</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200326095005.gif" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我们不妨先思考一下，如果实现这样的想法，应该如何做</p><h3 id="按照惯例的思考"><a href="#按照惯例的思考" class="headerlink" title="按照惯例的思考"></a>按照惯例的思考</h3><p>首先我们先来整理一下我们的需求</p><ul><li>内部组件能够感知外部的生命周期</li><li>能够统一地管理，做到一处修改，处处生效</li><li>能够及时叫停错过的任务</li></ul><p>针对需求1，可以用观察者模式，内部组件能够在外部生命周期变化时做出相应</p><p>针对需求2，可以将依赖组件的代码移出生命周期方法内，然后移入组件本身，这样只需修改组件内部逻辑即可</p><p>针对需求3，可以在合适的时机移除观察者</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>关于开发者模式，我第一次比较详细的了解是在 <a href="https://juejin.im/user/552f20a7e4b060d72a89d87f" target="_blank" rel="noopener">扔物线</a> 的 <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a>。</p><blockquote><p>观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者（例如 A 不需要每过 2ms 就检查一次 B 的状态），而是采用<strong>注册</strong>(Register)<strong>或者称为</strong>订阅<strong>(Subscribe)</strong>的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 <code>OnClickListener</code> 。对设置 <code>OnClickListener</code> 来说， <code>View</code> 是被观察者， <code>OnClickListener</code> 是观察者，二者通过 <code>setOnClickListener()</code> 方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 <code>OnClickListener</code> 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷『你在作案的时候务必通知我』。</p></blockquote><p>OnClickListener 的模式大致如下图：</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200326103024.jpg" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>上述描述及图片均来自 <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></p></blockquote><p><strong>因此在生命周期组件的生命周期发生变化时告诉观察者，内部组件即可感知外部的生命周期</strong></p><h3 id="引入-Lifecycle-后"><a href="#引入-Lifecycle-后" class="headerlink" title="引入 Lifecycle 后"></a>引入 Lifecycle 后</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LifecycleObserver</span> </span>&#123;<br>    <span class="hljs-meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectListener</span><span class="hljs-params">()</span> </span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">disconnectListener</span><span class="hljs-params">()</span> </span>&#123;<br>        ...<br>    &#125;<br>&#125;<br><br>myLifecycleOwner.getLifecycle().addObserver(<span class="hljs-keyword">new</span> MyObserver());<br></code></pre></td></tr></table></figure><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200326134237.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这是 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>  的结构，抽象类，其内部有两个枚举，分别代表着「事件」和「状态」，此外还有三个方法，添加/移除观察者，获取当前状态</p><blockquote><p><strong>注意，这里 State 中的枚举顺序是有意义的，后文详细介绍</strong></p></blockquote><p>其实现类为  <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleRegistry" target="_blank" rel="noopener">LifecycleRegistry</a> ，可以处理多个观察者</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200326135029.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="LifecycleRegistry"></p><p>其内部持有当前的状态 mState ，LifecycleOwner 以及观察者的自定义列表，同时重写了父类的添加/删除观察者的方法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200326135636.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="LifecycleOwner"></p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a> ，具有 Android 的生命周期，定制组件可以使用这些事件来处理生命周期更改，而无需在 Activity 或 Fragment 中实现任何代码</p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="noopener">LifecycleObserver</a> ，将一个类标记为 <code>LifecycleObserver</code>。 它没有任何方法，而是依赖于 OnLifecycleEvent 注解的方法</p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver" target="_blank" rel="noopener">LifecycleEventObserver</a> ，可以接收任何生命周期更改并将其分派给接收方。</p><p><strong>如果一个类实现此接口并同时使用 OnLifecycleEvent，则注解将被忽略</strong></p><p><a href="https://developer.android.com/reference/androidx/lifecycle/DefaultLifecycleObserver" target="_blank" rel="noopener">DefaultLifecycleObserver</a> ，用于监听 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a> 状态更改的回调接口。</p><p>如果一个类同时实现了此接口和 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver" target="_blank" rel="noopener">LifecycleEventObserver</a>，则将首先调用<code>DefaultLifecycleObserver</code> 的方法，然后再调用LifecycleEventObserver.onStateChanged（LifecycleOwner，Lifecycle.Event）</p><blockquote><p>注意：使用 <a href="https://developer.android.com/reference/androidx/lifecycle/DefaultLifecycleObserver" target="_blank" rel="noopener">DefaultLifecycleObserver</a> 需引入</p><p> implementation “androidx.lifecycle:lifecycle-common-java8:$lifecycle_version”</p></blockquote><h2 id="简单的源码分析"><a href="#简单的源码分析" class="headerlink" title="简单的源码分析"></a>简单的源码分析</h2><h3 id="activity-生命周期处理"><a href="#activity-生命周期处理" class="headerlink" title="activity 生命周期处理"></a>activity 生命周期处理</h3><p>首先我们还是来看 <strong>androidx.activity.ComponentActivity</strong> ，这个类我们这个系列的文章里提到多次，第一次提及是在 <a href="https://juejin.im/post/5e738d12518825495d69cfb9#heading-2" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a> ，感兴趣的小伙伴可以看看。</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200327104836.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ComponentActivity"></p><p>其实现的接口大多数我们都已经探讨过了，今天我们来看看 LifecycleOwner</p><blockquote><p>ActivityResultCaller 为 activity 1.2.0-alpha02 推出的，旨在统一 onActivityResult ，这里暂时不讨论它</p></blockquote><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200327105352.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>既然实现了 <code>LifecycleOwner</code> 接口，必定重写 getLifecycle() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// androidx.activity.ComponentActivity.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LifecycleRegistry mLifecycleRegistry = <span class="hljs-keyword">new</span> LifecycleRegistry(<span class="hljs-keyword">this</span>);<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Lifecycle <span class="hljs-title">getLifecycle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mLifecycleRegistry;<br>&#125;<br></code></pre></td></tr></table></figure><p>其返回的 <code>Lifecycle</code> 为 实现类 <code>LifecycleRegistry</code> 的实例</p><p>而 activity 操作生命周期是通过 <code>ReportFragment</code> 处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// androidx.activity.ComponentActivity.java</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    ReportFragment.injectIfNeededIn(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// ReportFragment</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injectIfNeededIn</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">29</span>) &#123;<br>        <span class="hljs-comment">// api 29 及以上 直接注册正确的生命周期回调</span><br>        activity.registerActivityLifecycleCallbacks(<br>                <span class="hljs-keyword">new</span> LifecycleCallbacks());<br>    &#125;<br>    android.app.FragmentManager manager = activity.getFragmentManager();<br>    <span class="hljs-keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="hljs-keyword">null</span>) &#123;<br>        manager.beginTransaction().add(<span class="hljs-keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();<br>        manager.executePendingTransactions();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200327113340.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ReportFragment.java</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(@NonNull Activity activity, @NonNull Lifecycle.Event event)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">instanceof</span> LifecycleRegistryOwner) &#123;<br>        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">instanceof</span> LifecycleOwner) &#123;<br>        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();<br>        <span class="hljs-keyword">if</span> (lifecycle <span class="hljs-keyword">instanceof</span> LifecycleRegistry) &#123;<br>            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(@NonNull Lifecycle.Event event)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">29</span>) &#123;<br>        dispatch(getActivity(), event);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onActivityCreated(savedInstanceState);<br>    dispatch(Lifecycle.Event.ON_CREATE);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onStart();<br>    dispatch(Lifecycle.Event.ON_START);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onResume();<br>    dispatch(Lifecycle.Event.ON_RESUME);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onPause();<br>    dispatch(Lifecycle.Event.ON_PAUSE);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onStop();<br>    dispatch(Lifecycle.Event.ON_STOP);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onDestroy();<br>    dispatch(Lifecycle.Event.ON_DESTROY);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LifecycleCallbacks</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifecycleCallbacks</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Application</span>.<span class="hljs-title">ActivityLifecycleCallbacks</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPostCreated</span><span class="hljs-params">(@NonNull Activity activity,<br>            @Nullable Bundle savedInstanceState)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_CREATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPostStarted</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_START);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPostResumed</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_RESUME);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPrePaused</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_PAUSE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPreStopped</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_STOP);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPreDestroyed</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_DESTROY);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 activity 的 onCreate 方法中，调用了 <code>ReportFragment</code> 中的静态方法 <code>injectIfNeededIn()</code> 。而其内部，<strong>如果 api 29 及以上的设备上直接注册正确的生命周期回调，低版本通过启动 ReportFragment ，借助 fragment 各个生命周期来处理生命周期回调</strong></p><h3 id="fragment-生命周期处理"><a href="#fragment-生命周期处理" class="headerlink" title="fragment 生命周期处理"></a>fragment 生命周期处理</h3><p>在 fragment 内部，每个生命周期节点调用 <code>handleLifecycleEvent</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Fragment.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fragment</span><span class="hljs-params">()</span> </span>&#123;<br>    initLifecycle();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initLifecycle</span><span class="hljs-params">()</span> </span>&#123;<br>    mLifecycleRegistry = <span class="hljs-keyword">new</span> LifecycleRegistry(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Lifecycle <span class="hljs-title">getLifecycle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mLifecycleRegistry;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    onCreate(savedInstanceState);<br>mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performStart</span><span class="hljs-params">()</span> </span>&#123;<br>    onStart();<br>    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performResume</span><span class="hljs-params">()</span> </span>&#123;<br>    onResume();<br>    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performPause</span><span class="hljs-params">()</span> </span>&#123;<br>    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);<br>    onPause();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performStop</span><span class="hljs-params">()</span> </span>&#123;<br>    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);<br>    onStop();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);<br>    onDestroy();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Lifecycle-State-大小比较"><a href="#Lifecycle-State-大小比较" class="headerlink" title="Lifecycle State 大小比较"></a>Lifecycle State 大小比较</h3><p><code>Lifecycle.State</code>  中有一个 <code>isAtLeast</code> 方法，用于判断当前状态是否不小于传入的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lifecycle.State</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAtLeast</span><span class="hljs-params">(@NonNull State state)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> compareTo(state) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>枚举的 compareTo 方法其实是比较的枚举声明的顺序</strong></p><p>而 State 的顺序为 DESTROYED -&gt; INITIALIZED -&gt; CREATED -&gt; STARTED -&gt; RESUMED</p><blockquote><p>如果传入的 state 为 STARTED，则当前状态为 STARTED 或 RESUMED 时返回 true ，否则返回 false</p><p>LiveData 篇会用到这个知识点</p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 关于我</span></h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【背上Jetpack之ViewModel】即使您不使用MVVM也要了解ViewModel ViewModel的职能边界</title>
      <link href="/2020/03/23/Jetpack-ViewModel/"/>
      <url>/2020/03/23/Jetpack-ViewModel/</url>
      
        <content type="html"><![CDATA[<p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200324083031.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="目录"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Android 开发时，我们使用 activity 和 fragment 作为视图控制器， 可能还会使用有一些类可以存储和提供 UI 数据（例如MVP中的 <code>Presenter</code> ）</p></blockquote><p>但是 当配置更改时（如旋转屏幕），activity 会重建，但对于 UI 数据的持有者呢？</p><ul><li>开发者需要重新保存相关的信息并传递给重建的 activity ，否则开发者必须再次获取数据（通过网络请求或本地数据库）</li><li>由于 UI 数据的持有者的生命周期可能比 activity 长，因此开发者还需要避免出现内存泄漏的问题</li></ul><p>如何解决上述问题？ViewModel</p><p><strong>本文重点介绍 ViewModel 的职责（what）以及重点功能的实现原理（how），即使您不使用 <code>Jetpack MVVM</code> 架构，也要了解一下 ViewModel</strong></p><p>ViewModel 的原理部分要求您了解 activity 的启动流程，这部分内容网上文章很多，本文不再赘述</p><a id="more"></a><h2 id="ViewModel-的职责"><a href="#ViewModel-的职责" class="headerlink" title="ViewModel 的职责"></a>ViewModel 的职责</h2><p>我先上个 <a href="https://www.bilibili.com/video/av97794796/" target="_blank" rel="noopener">视频</a> ，这个小姐姐表述的比文字更形象</p><p><a href="https://www.bilibili.com/video/av97794796/" target="_blank" rel="noopener"><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321135602.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></a></p><p><code>ViewModel</code> 主要用于存储 UI 数据以及生命周期感知的数据</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321140300.gif" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>图片来自 <a href="https://android.jlelse.eu/android-architecture-components-viewmodel-e74faddf5b94" target="_blank" rel="noopener">Android Architecture Components: ViewModel</a></p></blockquote><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321140641.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ViewModel生命周期"></p><blockquote><p><code>ViewModel</code> 的生命周期 ，图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#lifecycle" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="作为数据持有者"><a href="#作为数据持有者" class="headerlink" title="作为数据持有者"></a>作为数据持有者</h3><p><code>ViewModel</code> 能够实时进行配置更改。 这意味着即使在手机旋转后销毁并重新创建 activity 之后，您仍然拥有相同的 <code>ViewModel</code> 和相同的数据。 因此：</p><ul><li>您无需担心 UI 数据持有者的生命周期。 <code>ViewModel</code> 将由工厂自动创建，您无需自行创建和销毁</li><li>数据将始终更新，旋转手机后，您将获得与以前相同的数据。 因此，您无需手动将数据传递给新的 activity 实例或再次调用网络或数据库来获取数据。 </li></ul><h3 id="Fragment-间共享数据"><a href="#Fragment-间共享数据" class="headerlink" title="Fragment 间共享数据"></a>Fragment 间共享数据</h3><p>一个 activity 中的两个或更多 fragment 需要相互通信是很常见的。例如您有一个片段，用户在其中从列表中选择一个 item，另一个片段显示了所选 item 的内容。 传统做法两个 fragment 都需要定义一些接口，并且宿主 activity 必须将两者绑定在一起。 此外，两个 fragment 都必须处理另一个 fragment 尚未创建或不可见的情况。</p><p>可以通过使用 <code>ViewModel</code> 对象解决此问题。 这些 fragment 可以使用 activity 范围内共享一个 <code>ViewModel</code> 来处理此通信，如以下示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModel</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="hljs-keyword">new</span> MutableLiveData&lt;Item&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(Item item)</span> </span>&#123;<br>        selected.setValue(item);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LiveData&lt;Item&gt; <span class="hljs-title">getSelected</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> selected;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MasterFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> SharedViewModel model;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(@NonNull View view, Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState);<br>        model = <span class="hljs-keyword">new</span> ViewModelProvider(requireActivity()).get(SharedViewModel.class);<br>        itemSelector.setOnClickListener(item -&gt; &#123;<br>            model.select(item);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(@NonNull View view, Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState);<br>        SharedViewModel model = <span class="hljs-keyword">new</span> ViewModelProvider(requireActivity()).get(SharedViewModel.class);<br>        model.getSelected().observe(getViewLifecycleOwner(), &#123; item -&gt;<br>           <span class="hljs-comment">// Update the UI.</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于 两个 fragment 使用的都是 activity 范围的 <code>ViewModel</code> （<code>ViewModelProvider</code> 构造器传入的 activity ），因此它们获得了相同的 ViewModel 实例，自然其持有的数据也是相同的，这也 <strong>保证了数据的一致性</strong></p></blockquote><p>这种方法具有以下优点：</p><ul><li><p>宿主 activity 无需执行任何操作，也无需了解此通信。</p></li><li><p>除 <code>SharedViewModel</code> 外，fragment 不需要彼此了解。 如果其中一个 fragment 消失了，则另一个继续照常工作。</p></li><li><p>每个 fragment 都有其自己的生命周期，并且不受另一个 fragment 的生命周期影响。 如果一个 fragment 替换了另一个 fragment，则 UI 可以继续正常工作而不会出现任何问题。</p></li></ul><h3 id="代替-Loader"><a href="#代替-Loader" class="headerlink" title="代替 Loader"></a>代替 Loader</h3><p><code>CursorLoader</code> 这样的 Loader 类经常用于使应用程序 UI 中的数据与数据库保持同步。您可以使用 <code>ViewModel</code> 和其他一些类来替换 Loader。 使用 <code>ViewModel</code> 可将视图控制器与数据加载操作分开，这意味着您在类之间的强引用较少。</p><p>在使用 Loader 的一种常见方法中，应用程序可能会使用 <code>CursorLoader</code> 来观察数据库的内容。 当数据库中的值更改时，加载程序会自动触发数据的重新加载并更新 UI</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321144832.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#loaders" target="_blank" rel="noopener">官方文档</a></p></blockquote><p><code>ViewModel</code> 与 <code>Room</code> 和 <code>LiveData</code> 一起使用以替换 Loader。 <code>ViewModel</code> 确保数据在设备配置更改后仍然存在。 当数据库发生更改时，<code>Room</code> 会通知 <code>LiveData</code> ，然后 <code>LiveData</code> 会使用修改后的数据更新 UI</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321144949.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#loaders" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>ViewModel 可作为 UI 数据的持有者，在 activity/fragment 重建时 ViewModel 中的数据不受影响，同时可以避免内存泄漏</strong></li><li><strong>可以通过 ViewModel 来进行 activity 和 fragment ，fragment 和 fragment 之间的通信，无需关心通信的对方是否存在，使用 application 范围的 ViewModel 可以进行全局通信</strong></li><li><strong>可以代替 Loader</strong></li></ul><h2 id="ViewModel-源码分析"><a href="#ViewModel-源码分析" class="headerlink" title="ViewModel 源码分析"></a>ViewModel 源码分析</h2><p>分析源码时我们可以不计较细枝末节，只分析主要的逻辑即可。因此我们来思考几个问题，并从源码中寻找答案</p><ul><li><p>如何做到 activity 重建后 <code>ViewModel</code> 仍然存在？</p></li><li><p>如何做到 fragment 重建后 <code>ViewModel</code> 仍然存在？</p></li><li><p>如何控制作用域？（即保证相同作用域获取的 <code>ViewModel</code> 实例相同）</p></li><li><p>如何避免内存泄漏？</p></li></ul><p>维持我们一贯的风格，我们先来大胆地猜一猜</p><p>对于问题1 ：activity 有着 <code>saveInstanceState</code> 机制，因此可能通过该机制来处理（<strong>事实证明不是</strong>）</p><p>对于问题2：可能 fragment 通过 宿主 activity 或 父 fragment 的帮助来确保 <code>ViewModel</code> 实例在重建后仍然存在</p><p>对于问题3：实现一个类似单例的效果，相同作用域获取的对象是相同的</p><p>对于问题4：避免 <code>ViewModel</code> 持有 view 或 context 的引用</p><p>首先我们要先了解一下 <code>ViewModel</code> 的结构</p><ul><li><p><code>ViewModel</code>：抽象类，主要有 clear 方法，它是 final 级，不可修改，clear 方法中包含 onClear 钩子，开发者可重写 onClear 方法来自定义数据的清空</p></li><li><p><code>ViewModelStore</code>：内部维护一个 HashMap 以管理 <code>ViewModel</code></p></li><li><p><code>ViewModelStoreOwner</code>：接口，<code>ViewModelStore</code> 的作用域，实现类为 <code>ComponentActivity</code> 和 <code>Fragment</code>，此外还有 <code>FragmentActivity.HostCallbacks</code></p></li><li><p><code>ViewModelProvider</code>：用于创建 <code>ViewModel</code>，其构造方法有两个参数，第一个参数传入 <code>ViewModelStoreOwner</code> ，确定了 <code>ViewModelStore</code> 的作用域，第二个参数为 <code>ViewModelProvider.Factory</code>，用于初始化 <code>ViewModel</code> 对象，默认为 <code>getDefaultViewModelProviderFactory()</code> 方法获取的 factory</p></li></ul><p>简单来说 <strong>ViewModelStoreOwner 持有 ViewModelStore 持有 ViewModel</strong></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321152406.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h3 id="1-如何做到-activity-重建后-ViewModel-仍然存在？"><a href="#1-如何做到-activity-重建后-ViewModel-仍然存在？" class="headerlink" title="1. 如何做到 activity 重建后 ViewModel 仍然存在？"></a>1. 如何做到 activity 重建后 ViewModel 仍然存在？</h3><p>在 <a href="https://juejin.im/post/5e738d12518825495d69cfb9" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a> 中我们提到了 androidx.core.app.ComponentActivity 的引入并探讨了其作为中间层的作用</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321155215.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我们已经讲过 <code>SavedStateRegistryOwner</code> 和 <code>OnBackPressedDispatcherOwner</code> 这两种角色，而今天我们来聊一下</p><p><code>ViewModelStoreOwner</code> 和 <code>HasDefaultViewModelProviderFactory</code> 。其中前者代表着 <code>ViewModelStore</code> 的作用域，后者来标记 <code>ViewModelStoreOwner</code> 拥有默认的 <code>ViewModelProvider.Factory</code></p><p>那么 <code>ViewModel</code> 的逻辑肯定就在该类了</p><p><code>ComponentActivity</code> 实现了 <code>ViewModelStoreOwner</code>  接口，意味着需要重写 <code>getViewModelStore()</code> 方法，该方法为 <code>ComponentActivity</code>  的 <code>mViewModelStore</code> 变量赋值。<strong>activity 重建后 ViewModel 仍然存在，只要保证 activity 重建后 mViewModelStore 变量值不变即可</strong></p><p>顺着这个思路，我们来看一下 <code>getViewModelStore()</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ViewModelStore <span class="hljs-title">getViewModelStore</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mViewModelStore == <span class="hljs-keyword">null</span>) &#123;<br>        NonConfigurationInstances nc =<br>                (NonConfigurationInstances) getLastNonConfigurationInstance();<br>        <span class="hljs-keyword">if</span> (nc != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//核心，在该位置重置 mViewModelStore</span><br>            mViewModelStore = nc.viewModelStore;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mViewModelStore == <span class="hljs-keyword">null</span>) &#123;<br>            mViewModelStore = <span class="hljs-keyword">new</span> ViewModelStore();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mViewModelStore;<br>&#125;<br></code></pre></td></tr></table></figure><p>即 <code>mViewModelStore</code> 的值由 <code>getLastNonConfigurationInstance()</code> 返回的 <code>NonConfigurationInstances</code> 对象中的 <code>viewModelStore</code> 赋值，如果此时还为空才去 new ViewModelStore 对象。因此我们只需找到 </p><p><code>getLastNonConfigurationInstance</code> 中的 <code>NonConfigurationInstances</code> 在哪里保存的即可</p><p><code>getLastNonConfigurationInstance</code> 为平台 activity 中的方法，返回 <code>mLastNonConfigurationInstances.activity</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getLastNonConfigurationInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mLastNonConfigurationInstances != <span class="hljs-keyword">null</span><br>            ? mLastNonConfigurationInstances.activity : <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们看一下 <code>mLastNonConfigurationInstances</code> 的赋值位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//省略其他参数</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(NonConfigurationInstances lastNonConfigurationInstances)</span></span>&#123;<br>mLastNonConfigurationInstances = lastNonConfigurationInstances;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>了解过 activity 的启动流程的小伙伴肯定知道，这个 attach 方法是 <code>ActivityThread</code> 中的 <code>performLaunchActivity</code> 调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;<br>    Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);<br>    <span class="hljs-comment">//省略其他参数</span><br>    activity.attach(r.lastNonConfigurationInstances);<br>    r.lastNonConfigurationInstances = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>深入追踪源码我们整理一下调用流程</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200323114334.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>由于 <code>ActivityThread</code> 中的 <code>ActivityClientRecord</code> 不受 activity 重建的影响，所以 activity 重建时 <code>mLastNonConfigurationInstances</code> 能够得到上一次的值，使得 <code>ViewModelStore</code> 值不变 ，问题1就解决了</p><h3 id="2-如何做到-fragment-重建后-ViewModel-仍然存在？"><a href="#2-如何做到-fragment-重建后-ViewModel-仍然存在？" class="headerlink" title="2. 如何做到 fragment 重建后 ViewModel 仍然存在？"></a>2. 如何做到 fragment 重建后 ViewModel 仍然存在？</h3><p>对于问题2，有了上面的思路我们可以认定 fragment 重建后其内部的 <code>getViewModelStore()</code> 方法返回的对象是相同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Fragment.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ViewModelStore <span class="hljs-title">getViewModelStore</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mFragmentManager.getViewModelStore(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>getViewModelStore()</code> 内部调用的是 <code>mFragmentManager</code>（普通fragment 对应 activity 中的 <code>FragmentManager</code>，子 fragment 则对应父 fragment 的 <code>childFragmentManager</code>）的 <code>getViewModelStore()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FragmentManager.java</span><br><span class="hljs-keyword">private</span> FragmentManagerViewModel mNonConfig;<br><br><span class="hljs-function">ViewModelStore <span class="hljs-title">getViewModelStore</span><span class="hljs-params">(@NonNull Fragment f)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mNonConfig.getViewModelStore(f);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>而 FragmentManager 中的 getViewModelStore 使用的是 mNonConfig ，mNonConfig 竟然是个 ViewModel！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FragmentManagerViewModel.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashMap&lt;String, ViewModelStore&gt; mViewModelStores = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br></code></pre></td></tr></table></figure><p><code>FragmentManagerViewModel</code> 管理着内部的 <code>ViewModelStore</code> 和 child 的 <code>FragmentManagerViewModel</code> 。因此保证 mNonConfig   值不变即能确保 fragment 中的 <code>getViewModelStore()</code>  不变。那么看看 mNonConfig  赋值的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FragmentManager.java</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attachController</span><span class="hljs-params">(@NonNull FragmentHostCallback&lt;?&gt; host, @NonNull FragmentContainer container, @Nullable <span class="hljs-keyword">final</span> Fragment parent)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 嵌套 fragment 的情况，有父 fragment</span><br>        mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (host <span class="hljs-keyword">instanceof</span> ViewModelStoreOwner) &#123;<br>        <span class="hljs-comment">// host 是 FragmentActivity.HostCallbacks</span><br>        ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();<br>        mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mNonConfig = <span class="hljs-keyword">new</span> FragmentManagerViewModel(<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// FragmentManagerViewModel.java</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> FragmentManagerViewModel <span class="hljs-title">getInstance</span><span class="hljs-params">(ViewModelStore viewModelStore)</span> </span>&#123;<br>    ViewModelProvider viewModelProvider = <span class="hljs-keyword">new</span> ViewModelProvider(viewModelStore,<br>            FACTORY);<br>    <span class="hljs-keyword">return</span> viewModelProvider.get(FragmentManagerViewModel.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先看 fragment 的直接宿主是 activity （即没有嵌套）的情况，mNonConfig 由<code>FragmentManagerViewModel.getInstance(viewModelStore)</code> 赋值，而 getInstance 中使用的是 <code>ViewModelProvider</code> 获取 <code>ViewModel</code> ，根据我们上面的分析，<strong>只要保证作用域（viewModelStore）相同，即可获取相同的 <code>ViewModel</code> 实例</strong>，因此我们需要看一下 host 的 getViewModelStore 方法。经过一番寻找，host 是 <code>FragmentActivity.HostCallbacks</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FragmentActivity.java 内部类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HostCallbacks</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FragmentHostCallback</span>&lt;<span class="hljs-title">FragmentActivity</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewModelStoreOwner</span>, <span class="hljs-title">OnBackPressedDispatcherOwner</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewModelStore <span class="hljs-title">getViewModelStore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 宿主 activity 的 getViewModelStore</span><br>    <span class="hljs-keyword">return</span> FragmentActivity.<span class="hljs-keyword">this</span>.getViewModelStore();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>host 的 getViewModelStore 方法返回的是宿主 activity 的 <code>getViewModelStore()</code> ，而 activity 重建后其内部的 <code>mViewModelStore</code> 是不变的，因此即使 activity 重建，其内部的 FragmentManager 对象变化，但 FragmentManager 内部的  FragmentManagerViewModel 的实例（<code>mNonConfig</code>）不变，mNonConfig.getViewModelStore 不变，fragment 的 <code>getViewModelStore()</code> 亦不变，fragment 重建后其内部的 <code>ViewModel</code> 仍然存在</p><p>对于嵌套 fragment ，mNonConfig 通过 parent.mFragmentManager.getChildNonConfig(parent) 获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FragmentManager.java</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> FragmentManagerViewModel <span class="hljs-title">getChildNonConfig</span><span class="hljs-params">(@NonNull Fragment f)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mNonConfig.getChildNonConfig(f);<br>&#125;<br></code></pre></td></tr></table></figure><p>上文提到 <code>FragmentManagerViewModel</code> 管理着 mChildNonConfigs Map，因此子 fragment 重置后其内部的 mNonConfig 对象也是相同的</p><p>至此问题 2 就解决了</p><h3 id="3-如何控制作用域？"><a href="#3-如何控制作用域？" class="headerlink" title="3. 如何控制作用域？"></a>3. 如何控制作用域？</h3><p>对于问题3，我们知道 <code>ViewModelStoreOwner</code> 代表着作用域，其内部唯一的方法返回 <code>ViewModelStore</code> 对象，也即不同的作用域对应不同的 <code>ViewModelStore</code> ，而 <code>ViewModelStore</code>  内部维护着 <code>ViewModel</code> 的 HashMap ，因此只要保证相同作用域的 <code>ViewModelStore</code> 对象相同就能保证相同作用域获取到相同的 <code>ViewModel</code> 对象，而问题1我们已经解释了重建时如何保证 <code>ViewModelStore</code>  对象不变。</p><p>因此问题3也解决了。</p><h3 id="4-如何避免内存泄漏？"><a href="#4-如何避免内存泄漏？" class="headerlink" title="4. 如何避免内存泄漏？"></a>4. 如何避免内存泄漏？</h3><p>对于问题4，由于 <code>ViewModel</code> 的设计，使得 activity/fragment 依赖它，而 <code>ViewModel</code> 不依赖视图控制器。因此只要不让 <code>ViewModel</code> 持有 context 或 view 的引用，就不会造成内存泄漏</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>简单的总结一下：</p><ul><li><p><strong>activity 重建后 mViewModelStore 通过 ActivityThread 的一系列方法能够保持不变，从而当 activity 重建时 ViewModel 中的数据不受影响</strong></p></li><li><p><strong>通过宿主 activity 范围内共享的 FragmentManagerViewModel 来存储 fragment 的 ViewModelStore 和子fragment 的 FragmentManagerViewModel ，而 activity 重建后 FragmentManagerViewModel  中的数据不受影响，因此 fragment 内部的 ViewModel 的数据也不受影响</strong></p></li><li><p><strong>通过同一 ViewModelStoreOwner 获取的 ViewModelStore 相同，从而保证同一作用域通过 ViewModelProvider 获取的ViewModel 对象是相同的</strong></p></li><li><p><strong>通过单向依赖（视图控制器持有 ViewModel ）来解决内存泄漏的问题</strong></p></li></ul><h2 id="ViewModel-和-onSaveInstanceState"><a href="#ViewModel-和-onSaveInstanceState" class="headerlink" title="ViewModel 和 onSaveInstanceState"></a>ViewModel 和 onSaveInstanceState</h2><p><code>ViewModel</code> 和 <code>onSaveInstanceState</code> 的功能有些类似，但它们也有很多差异</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200323160417.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>从存储位置上来说，<code>ViewModel</code> 是在内存中，因此其读写速度更快，但当进程被系统杀死后，<code>ViewModel</code> 中的数据也不存在了。从数据存储的类型上来看，<code>ViewModel</code> 适合存储相对较重的数据，例如网络请求到的 list 数据，而 <code>onSaveInstanceState</code> 适合存储轻量可序列化的数据</p><p>那么我们该如何使用呢？可以使用 <code>viewmodel-savedstate</code> 库，详情参考 <a href="https://juejin.im/post/5e738d12518825495d69cfb9#heading-10" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a></p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【背上Jetpack之ViewModel】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</title>
      <link href="/2020/03/19/Jetpack-ViewModel-SaveState/"/>
      <url>/2020/03/19/Jetpack-ViewModel-SaveState/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>大家都知道 activity 有着一套 <code>onSaveInstanceState-onRestoreInstanceState</code> 状态保存机制，旨在「系统资源回收」或「配置发生变化」保存状态，为用户提供更好的体验</p><p>在 androidx 下，提供了 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 库帮助 activity 和 fragment 处理状态保存和恢复</p></blockquote><p>本文默认您对状态保存机制有一定了解，这部分内容请移步 <a href="https://developer.android.com/topic/libraries/architecture/saving-states" target="_blank" rel="noopener">Saving UI States</a></p><p>此外，关于 android 下的进程管理，推荐 Ian Lake 的 <a href="https://medium.com/androiddevelopers/who-lives-and-who-dies-process-priorities-on-android-cb151f39044f" target="_blank" rel="noopener">Who lives and who dies? Process priorities on Android</a></p><p>本文介绍了 androidx 下 <code>SavedState</code> 如何帮助 activity 和 fragment 处理状态的保存和恢复，同时介绍 <code>viewmodel-savedstate</code> 库，以及在开发过程中正确使用状态保存的姿势</p><a id="more"></a><h2 id="软件工程中没有什么是中间层解决不了的"><a href="#软件工程中没有什么是中间层解决不了的" class="headerlink" title="软件工程中没有什么是中间层解决不了的"></a>软件工程中没有什么是中间层解决不了的</h2><p>在分析 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 库之前我们需要简单聊一聊 <code>ComponentActivity</code></p><p>androidx activity 1.0.0 时，<code>ComponentActivity</code> 成为了 <code>FragmentActivity</code> 和 <code>AppCompatActivity</code> 的基类。</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318211230.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="androidx activity 1.0.0 "></p><p>俗话说「百因必有果」，带着强烈的好奇心，我查了一下 ComponentActivity 引入的原因。</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318211823.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318211806.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>可以看到 <code>ComponentActivity</code> 继承了 androidx.core.app.ComponentActivity(在fragment库中)，并且最初仅实现了<code>LifecycleOwner</code> 接口</p><p>我们创建的 activity 的继承关系现在变成了这样：</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318213053.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>那么回到最初的问题，为什么要引入 <code>ComponentActivity</code> ？其实看看现在 <code>ComponentActivity</code> 的类结构答案就很清楚了</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318213151.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><code>ComponentActivity</code> 实现了五个接口，代表着其除了 activity 还充当着五种角色。本着职能单一原则，官方通过建立一个中间层将部分功能分别交于专门的类来负责，OnBackPressedDispatcherOwner 就是我们讲 fragment 返回栈（<a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇</a>）时提到的结构，而其中的 <code>SavedStateRegistryOwner</code> 则是我们今天要讲的主角  <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 中的成员</p><h2 id="SavedState"><a href="#SavedState" class="headerlink" title="SavedState"></a>SavedState</h2><p>引入 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">"androidx.savedstate:savedstate:1.0.0"</span><br></code></pre></td></tr></table></figure><p>其实您不需要显示地声明，因为 activity 库内部已经引入了。jetpack 组件依赖关系可参考 <a href="https://juejin.im/post/5e567ee1518825494466a938" target="_blank" rel="noopener">【背上Jetpack】Jetpack 主要组件的依赖及传递关系</a></p><p>这是一个很小的库</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318215718.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318215746.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>图片来自 <a href="https://proandroiddev.com/viewmodels-state-persistence-savedstate-54d015acad82" target="_blank" rel="noopener">Android ViewModels: State persistence — SavedState</a></p></blockquote><h3 id="SavedStateProvider"><a href="#SavedStateProvider" class="headerlink" title="SavedStateProvider"></a>SavedStateProvider</h3><p>保存状态的组件，此状态将在以后恢复并使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SavedStateProvider</span> </span>&#123;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-function">Bundle <span class="hljs-title">saveState</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SavedStateRegistry"><a href="#SavedStateRegistry" class="headerlink" title="SavedStateRegistry"></a>SavedStateRegistry</h3><p>管理 <code>SavedStateProvider</code> 列表的组件，此注册表绑定了其所有者的生命周期（即 activity 或 fragment）。每次创建生命周期所有者都会创建一个新的实例</p><p>创建注册表的所有者后（例如，在调用 activity 的 <code>onCreate(savedInstanceState)</code> 方法之后），将调用其 <code>performRestore(state)</code> 方法，以恢复系统杀死其所有者之前保存的任何状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performRestore</span><span class="hljs-params">(@NonNull Lifecycle lifecycle, @Nullable Bundle savedState)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (savedState != <span class="hljs-keyword">null</span>) &#123;<br>        mRestoredState = savedState.getBundle(SAVED_COMPONENTS_KEY);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每个注册表的 <code>SavedStateProvider</code> 都由用于注册它的唯一密钥标识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> SafeIterableMap&lt;String, SavedStateProvider&gt; mComponents = <span class="hljs-keyword">new</span> SafeIterableMap&lt;&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerSavedStateProvider</span><span class="hljs-params">(@NonNull String key, @NonNull SavedStateProvider provider)</span> </span>&#123;<br>    SavedStateProvider previous = mComponents.putIfAbsent(key, provider);<br>    <span class="hljs-keyword">if</span> (previous != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"SavedStateProvider with the given key is already registered"</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unregisterSavedStateProvider</span><span class="hljs-params">(@NonNull String key)</span> </span>&#123;<br>    mComponents.remove(key);<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦完成注册，就可以通过<code>consumeRestoredStateForKey(key)</code> 来使用特定密钥的还原状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Bundle <span class="hljs-title">consumeRestoredStateForKey</span><span class="hljs-params">(@NonNull String key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mRestoredState != <span class="hljs-keyword">null</span>) &#123;<br>        Bundle result = mRestoredState.getBundle(key);<br>        <span class="hljs-comment">//调用后就会清空，第二次调用返回null</span><br>        mRestoredState.remove(key);<br>        <span class="hljs-keyword">if</span> (mRestoredState.isEmpty()) &#123;<br>            mRestoredState = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>请注意，此方法检索保存的状态，然后清除其内部引用，这意味着用相同的键调用它两次将在第二次调用中返回 null</p><p>一旦注册表恢复了其保存状态，则由提供者决定是否要求其恢复的数据。 如果没有，下次注册表的所有者被系统杀死时，未使用的还原数据将再次保存到保存状态</p></blockquote><p>已注册的 provider 能够在其所有者被系统杀死之前保存状态。 发生这种情况时，将调用其 <code>Bundle saveState()</code> 方法。 对于每个已注册的 <code>SavedStateProvider</code>，都可以像这样保存状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">savedState.putBundle(savedStateProviderKey, savedStateProvider.saveState());<br></code></pre></td></tr></table></figure><p><code>performSave(outBundle)</code> 方法的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performSave</span><span class="hljs-params">(@NonNull Bundle outBundle)</span> </span>&#123;<br>    Bundle components = <span class="hljs-keyword">new</span> Bundle();<br>    <br>    <span class="hljs-comment">// 1.保存未使用的状态</span><br>    <span class="hljs-keyword">if</span> (mRestoredState != <span class="hljs-keyword">null</span>) &#123;<br>        components.putAll(mRestoredState);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 通过 SavedStateProvider 保存状态</span><br>    <span class="hljs-keyword">for</span> (Iterator&lt;Map.Entry&lt;String, SavedStateProvider&gt;&gt; it = mComponents.iteratorWithAdditions(); it.hasNext(); ) &#123;<br>        Map.Entry&lt;String, SavedStateProvider&gt; entry1 = it.next();<br>        components.putBundle(entry1.getKey(), entry1.getValue().saveState());<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 将bundle 保存到 outBundle 对象中</span><br>    outBundle.putBundle(SAVED_COMPONENTS_KEY, components);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行状态保存将所有未使用的状态与注册表提供的状态合并。 此 outBundle 是 activity 的 <code>onSaveInstanceState</code> 中传入的 bundle 。</p><h3 id="SavedStateRegistryController"><a href="#SavedStateRegistryController" class="headerlink" title="SavedStateRegistryController"></a>SavedStateRegistryController</h3><p>一个包装 <code>SavedStateRegistry</code> 并允许通过其2个主要方法对其进行控制的组件：performRestore(savedState) 和 <code>performSave(outBundle )</code>。 这两个方法将内部通过 <code>SavedStateRegistry</code> 中的方法处理 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SavedStateRegistryController</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SavedStateRegistryOwner mOwner;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SavedStateRegistry mRegistry;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performRestore</span><span class="hljs-params">(@Nullable Bundle savedState)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        mRegistry.performRestore(lifecycle, savedState);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performSave</span><span class="hljs-params">(@NonNull Bundle outBundle)</span> </span>&#123;<br>        mRegistry.performSave(outBundle);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SavedStateRegistryOwner"><a href="#SavedStateRegistryOwner" class="headerlink" title="SavedStateRegistryOwner"></a>SavedStateRegistryOwner</h3><p>持有 <code>SavedStateRegistry</code> 的组件。 默认情况下，androidx 包中的<code>ComponentActivity</code> 和 <code>Fragment</code> 都实现此接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SavedStateRegistryOwner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LifecycleOwner</span> </span>&#123;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-function">SavedStateRegistry <span class="hljs-title">getSavedStateRegistry</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Activity-的状态保存"><a href="#Activity-的状态保存" class="headerlink" title="Activity 的状态保存"></a>Activity 的状态保存</h2><p>这里我们要明确一件事情，activity 保存的状态究竟都有什么？</p><p>这部分内容可以参见 <a href="https://developer.android.com/guide/components/activities/activity-lifecycle.html#saras" target="_blank" rel="noopener">官方文档</a> </p><p>简单来说，<strong>activity 的状态保存分为 view 状态和成员状态</strong></p><p>默认情况下，系统使用 Bundle 实例状态来保存有关 activity 布局中每个 View 对象的信息（例如，输入到 EditText 中的文本值或 recyclerview 的滚动位置）。 因此，如果 activity 实例被销毁并重新创建，则布局状态将恢复为之前的状态，而无需您执行任何代码。（<strong>注意，需要恢复状态的 view 需要配置 id</strong> ）</p><p>这部分逻辑在 activity 中的 <code>onSaveInstanceState</code> 方法内实现</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319115543.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="onSaveInstanceState "></p><blockquote><p>不同平台 <code>onSaveInstanceState</code>  方法的执行时机稍有不同，android P 之前 <code>onSaveInstanceState</code> 执行在 <code>onStop</code> 之前，但不限于在 <code>onPause</code> 之前或之后。android P 及之后该方法在 <code>onStop</code> 后执行</p></blockquote><p>前面我们提到 <code>ComponentActivity</code> 实现了 <code>SavedStateRegistryOwner</code> ，下面我们来看一看 activity 如何利用该库来实现状态的保存与恢复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">androidx</span>.<span class="hljs-title">core</span>.<span class="hljs-title">app</span>.<span class="hljs-title">ComponentActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SavedStateRegistryOwner</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SavedStateRegistryController mSavedStateRegistryController = SavedStateRegistryController.create(<span class="hljs-keyword">this</span>);<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        mSavedStateRegistryController.performRestore(savedInstanceState);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(@NonNull Bundle outState)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">//这里先调用父类的 onSaveInstanceState 保存 view 状态</span><br>        <span class="hljs-keyword">super</span>.onSaveInstanceState(outState);<br>        mSavedStateRegistryController.performSave(outState);<br>    &#125;<br>  <br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> SavedStateRegistry <span class="hljs-title">getSavedStateRegistry</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mSavedStateRegistryController.getSavedStateRegistry();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其内部持有 <code>SavedStateRegistryController</code> 的实例 <code>mSavedStateRegistryController</code> ，在 activity 的 <code>onCreate</code> 方法中 通过 controller 的 <code>performRestore</code> 方法来查询已保存的状态，在 <code>onSaveInstanceState</code> 中 使用 controller  的 <code>performSave</code> 方法来保存状态</p><p><strong>除了 view 状态和成员状态，activity 还负责保存其内部的 fragment 的状态</strong>。<code>FragmentActivity</code> 的 <code>onSaveInstanceState</code> 方法有对其内部 fragment 的状态进行保存，并在 onCreate 方法中对已保存的 fragment 进行恢复。这解释了如果操作不当会导致 fragment 重叠的问题</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319140343.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319140801.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h2 id="Fragment-的状态保存"><a href="#Fragment-的状态保存" class="headerlink" title="Fragment 的状态保存"></a>Fragment 的状态保存</h2><p>androidx fragment 使用 <code>FragmentStateManager</code> 来处理 fragment 的状态保存</p><p>其内部有四个保存相关的方法</p><ul><li><code>saveState</code></li><li><code>saveBasicState</code></li><li><code>saveViewState</code></li><li><code>saveInstanceState</code></li></ul><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319142729.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="FragmentStateManager"></p><p>其调用链为 activity 通过 <code>FragmentController</code> 间接 调用 <code>FragmentManager</code> 的 <code>saveAllState</code>，接着依次调用后面的save 方法</p><p>Fragment 的状态保存可分为 view 状态，成员状态，child fragment 状态</p><p>关于 view 状态 , <code>FragmentStateManager</code> 提供了 <code>saveViewSate</code> 方法，它的调用有两处：</p><ol><li>在 activity 或父 fragment 触发状态保存时调用，即上述流程</li><li>在 fragment 即将进入 <code>onDestroyView</code> 生命周期时调用，其位置在 <code>FragmentManager</code> moveToState 方法内部，这解释了为什么加入返回栈的 replace 操作在返回时 view 状态可以自动恢复</li></ol><p>关于成员状态，由 activity 中的状态机制处理，即上节内容</p><p>关于 child  fragment 状态，fragment 的 <code>onCreate</code> 方法会调用 <code>restoreChildFragmentState</code> 来恢复 child  fragment 的状态，并在 <code>FragmentStateManager</code>  中的 <code>saveBasicState</code> 方法中 调用 <code>performSaveInstanceState</code> 来保存 child  fragment 的状态</p><h2 id="Viewmodel-SavedState"><a href="#Viewmodel-SavedState" class="headerlink" title="Viewmodel-SavedState"></a>Viewmodel-SavedState</h2><p>2020-01-22，<code>ViewModel-SavedState 1.0.0</code> 正式版发布，02-05 发布了 <code>2.2.0</code> 正式版</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-viewmodel-savedstate:2.2.0"</span><br></code></pre></td></tr></table></figure><blockquote><p>您不需要手动引入该库，因为 fragment 库以及内部引入该库</p></blockquote><p><code>Jetpack MVVM</code> 下 UI State 通常被 <code>ViewModel</code> 持有并存储，因此该模块出现了，配置该模块后，<code>ViewModel</code> 对象将通过其构造函数接收 <code>SavedStateHandle</code> 对象（键值映射），可让您保存状态并查询已保存的状态。 这些值将在系统终止进程后继续存在，并可以通过同一对象使用。</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319165450.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ViewModel-SavedState"></p><blockquote><p>图片来自 <a href="https://proandroiddev.com/viewmodels-state-persistence-savedstate-54d015acad82" target="_blank" rel="noopener">Android ViewModels: State persistence — SavedState</a></p></blockquote><h3 id="SavedStateHandle"><a href="#SavedStateHandle" class="headerlink" title="SavedStateHandle"></a>SavedStateHandle</h3><p>内部持有已保存状态 key-value 的 map，允许读取和写入状态，这些状态在应用进程被杀死后仍然存在</p><p><code>SavedStateHandle</code> 通过 <code>ViewModel</code> 的构造器传入，下面是其主要的主要的几个方法</p><ul><li>T get(String key)</li><li>MutableLiveData<t> getLiveData(String key)</t></li><li>void set(String key, T value)</li></ul><p><code>SavedStateHandle</code> 还包含 <code>SavedStateProvider</code> 的实例，用于帮助 <code>ViewModel</code> 的 owner 保存状态</p><h3 id="AbstractSavedStateViewModelFactory"><a href="#AbstractSavedStateViewModelFactory" class="headerlink" title="AbstractSavedStateViewModelFactory"></a>AbstractSavedStateViewModelFactory</h3><p>一个实现 <code>ViewModelFactory.KeyedFactory</code> 的 <code>ViewModel Factory</code>，它会创建一个与实例化的请求的 ViewModel 关联的 <code>SavedStateHandle</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractSavedStateViewModelFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModelProvider</span>.<span class="hljs-title">KeyedFactory</span> </span>&#123;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SavedStateRegistry mSavedStateRegistry;<br>  <br>    <span class="hljs-comment">// Default state used when the saved state is empty</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bundle mDefaultArgs;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;T extends ViewModel&gt; <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;<br>        <span class="hljs-comment">// 读取保存的状态</span><br>        Bundle restoredState = mSavedStateRegistry.consumeRestoredStateForKey(key);<br>      <br>        <span class="hljs-comment">// 创建保存状态的 handle</span><br>        SavedStateHandle handle = SavedStateHandle.createHandle(restoredState, mDefaultArgs);<br>        <br>        <span class="hljs-comment">// ... </span><br>      <br>        <span class="hljs-comment">// 创建 viewModel</span><br>        T viewmodel = create(key, modelClass, handle);<br>      <br>        <span class="hljs-comment">// ... </span><br><br>        <span class="hljs-keyword">return</span> viewmodel;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SavedStateViewModelFactory"><a href="#SavedStateViewModelFactory" class="headerlink" title="SavedStateViewModelFactory"></a>SavedStateViewModelFactory</h3><p><code>AbstractSavedStateViewModelFactory</code> 的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SavedStateViewModelFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSavedStateVMFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavedStateViewModelFactory</span><span class="hljs-params">(@NonNull Application application,<br>            @NonNull SavedStateRegistryOwner owner)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(application, owner, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavedStateViewModelFactory</span><span class="hljs-params">(@NonNull Application application, @NonNull SavedStateRegistryOwner owner, @Nullable Bundle defaultArgs)</span> </span>&#123;<br>        mSavedStateRegistry = owner.getSavedStateRegistry();<br>        mLifecycle = owner.getLifecycle();<br>        mDefaultArgs = defaultArgs;<br>        mApplication = application;<br>        mFactory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);<br>    &#125;<br>    <br><span class="hljs-keyword">public</span> &lt;T extends ViewModel&gt; <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);<br>        Constructor&lt;T&gt; constructor;<br>        <span class="hljs-keyword">if</span> (isAndroidViewModel) &#123;<br>            constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);<br>        &#125;<br>        <span class="hljs-comment">// doesn't need SavedStateHandle</span><br>        <span class="hljs-keyword">if</span> (constructor == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> mFactory.create(modelClass);<br>        &#125;<br><br>        SavedStateHandleController controller = SavedStateHandleController.create(<br>                mSavedStateRegistry, mLifecycle, key, mDefaultArgs);        <br>        T viewmodel;<br>        <span class="hljs-keyword">if</span> (isAndroidViewModel) &#123;<br>            viewmodel = constructor.newInstance(mApplication, controller.getHandle());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            viewmodel = constructor.newInstance(controller.getHandle());<br>        &#125;<br>        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);<br>        <span class="hljs-keyword">return</span> viewmodel;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319174431.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewModelProvider(<span class="hljs-keyword">this</span>).get(MyViewModel::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span><br></code></pre></td></tr></table></figure><p>在 activity 中创建 ViewModel 实例，传入 this （<code>SavedStateRegistryOwner</code> ）作为参数，该参数可以访问其 <code>SavedStateRegistry</code>，如果没有传入 factory 会通过 activity 重写的 <code>getDefaultViewModelProviderFactory</code> 方法来获取默认的 factory 。然后 factory 将使用保存的状态， 将其包装在 <code>SavedStateHandle</code> 中，并将其传递给 ViewModel。 ViewModel 可以读取和写入该 handle</p><p>当 activity 的 <code>onSaveInstanceState(outState)</code> 方法被调用，其 <code>SavedStateRegistry</code> 的 <code>performSave(outState)</code> 方法将被执行，其内部的所有 <code>SavedStateProvider</code> 的 <code>saveState</code> 方法均被执行，一旦执行完毕，<code>outState</code> 就包含了已保存的状态</p><p>当 app 被重启后，activity 和新的 registry  将被创建，activity 的 <code>onCreate(savedInstanceState)</code> 方法会被调用，然后 registry 的 <code>performRestore(savedInstanceState)</code> 将被调用以便恢复之前保存的状态</p><h2 id="状态保存的正确姿势"><a href="#状态保存的正确姿势" class="headerlink" title="状态保存的正确姿势"></a>状态保存的正确姿势</h2><p><code>ViewModel</code> 构造器加入 <code>SavedStateHandle</code> 参数，并将想要保存的数据使用该 handle 保存</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithSavedStateViewModel</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> state: SavedStateHandle) : ViewModel() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> key = <span class="hljs-string">"key"</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span> = state.<span class="hljs-keyword">set</span>(key, value)<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>: LiveData&lt;String&gt; = state.getLiveData(key)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>无需重写 <code>onSaveInstanceState/onRestoreInstanceState</code>  方法</strong></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319231231.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319231451.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="运行示意图"></p><p><a href="https://github.com/Flywith24/Flywith24-Jetpack-Demo" target="_blank" rel="noopener">Demo 地址</a></p><blockquote><p>SavedState 仅适合保存轻量级的数据，重量级操作请考虑持sp，数据库等持久化方案</p></blockquote><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="http://www.yangyunzhao.com" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【背上Jetpack之Fragment】从源码的角度看Fragment 返回栈</title>
      <link href="/2020/03/16/Jetpack-fragment-back-stack/"/>
      <url>/2020/03/16/Jetpack-fragment-back-stack/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p><a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">上一篇</a> 我们介绍了 <code>OnBackPressedDispather</code> ，那么今天我们来正式地从源码的角度看看 fragment 的返回栈吧。由于其主流程和生命周期差不多，因此本文将详细地分析返回栈相关的源码，并插入大量源码。建议将生命周期流程熟悉后阅读本文。文末提供单返回栈和多返回栈的 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">demo</a></p></blockquote><p>如果您对 activity 对任务栈和返回栈不是很了解，可以移步  <a href="https://medium.com/androiddevelopers/tasks-and-the-back-stack-dbb7c3b0f6d4" target="_blank" rel="noopener">Tasks and the Back Stack</a></p><a id="more"></a><h2 id="小问号你是否有很多朋友？"><a href="#小问号你是否有很多朋友？" class="headerlink" title="小问号你是否有很多朋友？"></a>小问号你是否有很多朋友？</h2><p>在分析源码之前，我们先来思考几个问题。</p><ul><li>返回栈中的元素是什么？</li><li>谁来管理 fragment 的返回栈？</li><li>如何返回？</li></ul><h3 id="返回栈中的元素是什么？"><a href="#返回栈中的元素是什么？" class="headerlink" title="返回栈中的元素是什么？"></a>返回栈中的元素是什么？</h3><p>返回栈，顾名思义，是一个栈结构。所以我们要搞清楚，这个栈结构到底存的是什么。</p><p>我们都知道，使用 fragment 的返回栈需要调用 <code>addToBackStack(&quot;&quot;)</code> 方法</p><p>在 <a href="https://juejin.im/post/5e67523551882549003d2c4f" target="_blank" rel="noopener">从源码角度看 Fragment 生命周期</a> 一文中，我们提到了 FragmentTransaction ，它是一个「事务」的模型，事务可以回滚到之前的状态。所以当触发返回操作时，就是将之前提交的事务进行回滚。</p><p><code>FragmentTransaction</code> 的实现类为 <code>BackStackRecord</code> ，所以 <strong>fragment 的返回栈其实存放的就是 BackStackRecord</strong> </p><p>作为返回栈的元素，BackStackRecord 实现了FragmentManager.BackStackEntry 接口</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0e912bd4?w=748&h=171&f=png&s=27904" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="BackStackRecord"></p><p>从 <code>BackStackRecord</code> 的定义我们可以发现 <code>BackStackRecord</code> 有三种身份</p><ul><li>继承了 <code>FragmentTransaction</code>，即是事务，保存了整个事务的全部操作</li><li>实现了 <code>FragmentManager.BackStackEntry</code> ，作为回退栈的元素</li><li>实现了<code>OpGenerator</code> ，可以生成 <code>BackStackRecord</code> 列表，后文详细介绍</li></ul><h3 id="谁来管理-fragment-的返回栈？"><a href="#谁来管理-fragment-的返回栈？" class="headerlink" title="谁来管理 fragment 的返回栈？"></a>谁来管理 fragment 的返回栈？</h3><p>我们已经知道 fragment 的返回栈其实存放的是 BackSrackRecord , 那么谁来管理 fragment 的返回栈？</p><p><code>FragmentManager</code> 用于管理 fragment ，所以 <strong>fragment 返回栈也应该由 FragmentManager 管理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//FragmentManager.java</span><br>ArrayList&lt;BackStackRecord&gt; mBackStack;<br></code></pre></td></tr></table></figure><p>其实触发 fragment 的返回逻辑有两种途径</p><ul><li><p>开发主动调用 fragment 的返回方法</p></li><li><p>用户按返回键触发</p></li></ul><p>后文我们会从这两个角度分析一下 fragment 中的返回栈逻辑究竟是怎样的</p><h3 id="如何返回？"><a href="#如何返回？" class="headerlink" title="如何返回？"></a>如何返回？</h3><p>我们已经知道返回栈中的元素是 <code>BackStackRecord</code> ，也清楚了是 <code>FragmentManager</code> 来管理返回栈。那么如果让我们来实现「返回」逻辑，应该如何做？</p><p>首先我们要清楚所谓的「返回」是对事务的回滚，即 <strong>对 commit 事务的内部逻辑执行相应的「逆操作」</strong>。</p><p>例如</p><p>addFragment←→removeFragment</p><p>showFragment←→hideFragment</p><p>attachFragment←→detachFragment</p><p>有的小伙伴可能会疑惑 replace 呢？</p><p><code>expandReplaceOps</code> 方法会把 replace 替换(目标 fragment 已经被 add )成相应的 remove 和 add 两个操作，或者(目标 fragment 没有被 add )只替换成 add 操作</p><h2 id="popBackStack-系列方法"><a href="#popBackStack-系列方法" class="headerlink" title="popBackStack 系列方法"></a>popBackStack 系列方法</h2><p><code>FragmentManager</code> 中提供了<code>popBackStack</code> 系列方法</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0f7fecec?w=523&h=207&f=png&s=41693" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="popBackStack系列方法"></p><p>是否觉得很眼熟？提交事务也有类似的api，commit 系列方法</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0f5fe236?w=425&h=116&f=png&s=19768" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="commit系列方法"></p><p>这里分别提供了同步和异步的方法，可能有读者会疑惑，同样是对事务的操作，一个为提交，一个为回滚，为什么一个封装到了 <code>FragmentManager</code> 中，一个却在 <code>FragmentTransaction</code> 中。既然都是对事务的操作，应该都放在FragmentManager 中。我认为可能为了api使用的方便，使得 <code>FragmentManager</code> 开启事务的链式调用一气呵成。各位有什么想法欢迎在评论区留言。</p><p>这里主要介绍一下 popBackStack(String name, int flag)</p><p>name 为 addToBackStack(String name) 的参数，通过 name 能找到回退栈的特定元素，flag可以为 0 或者<code>FragmentManager.POP_BACK_STACK_INCLUSIVE</code>，0 表示只弹出该元素以上的所有元素，<code>POP_BACK_STACK_INCLUSIVE</code> 表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。如果这么说比较抽象的话，看图</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//flag 传入0，弹出 ♥2 上的所有元素</span><br>childFragmentManager.popBackStack(<span class="hljs-string">"♥"</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf111e4eca?w=544&h=968&f=gif&s=332027" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="flag为0"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//flag 为 POP_BACK_STACK_INCLUSIVE 弹出包括该元素及及以上的元素</span><br>childFragmentManager.popBackStack(<span class="hljs-string">"♥"</span>,  androidx.fragment.app.FragmentManager.POP_BACK_STACK_INCLUSIVE)<br></code></pre></td></tr></table></figure><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf11573c7e?w=544&h=968&f=gif&s=307357" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="flag为1"></p><h2 id="走进源码"><a href="#走进源码" class="headerlink" title="走进源码"></a>走进源码</h2><h3 id="1-popBackStack-逻辑"><a href="#1-popBackStack-逻辑" class="headerlink" title="1. popBackStack() 逻辑"></a>1. popBackStack() 逻辑</h3><p>在分析返回栈源码之前我们回顾一下 FragmentManager 提交事务到 fragment 各个生命周期的流程</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf128028ab?w=1137&h=1745&f=png&s=148227" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="异步"></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf3c14d698?w=1078&h=1232&f=png&s=120922" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="commitNow"></p><p>下面我们看看 popBackStack 的源码</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf3e264529?w=1111&h=744&f=png&s=152765" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="popBackStack源码"></p><p>等等，这个 enqueueAction 有些眼熟…</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf4261e2a2?w=582&h=144&f=png&s=16887" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="commit"></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf43057f36?w=792&h=404&f=png&s=74980" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="commitInternal"></p><p>看来提交事务和回滚事务的流程基本是相同的，只是传递的 action 不同</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf463c7504?w=818&h=722&f=png&s=108117" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="enqueueAction"></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170df028ee01dd57?w=1081&h=713&f=png&s=131939" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="OpGenerator"></p><p>由源码可知，<code>OpGenerator</code> 是一个接口，其内只有一个 <code>generateOps</code> 方法，用于生成事务列表以及对应的该事务是否是弹出的。有两个实现类</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf5579b571?w=1319&h=139&f=png&s=46323" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="OpGenerator实现类"></p><p>由此可见 commit 调用的为 <code>BackStackRecord</code> 的 <code>generateOps</code> 方法，<code>popBackStack</code> 调用的是 <code>PopBackStackState</code> 中的  <code>generateOps</code> </p><p>前者的逻辑很简单，向 records list 中添加数据， isRecordPop list 全部传入 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">records.add(<span class="hljs-keyword">this</span>);<br>isRecordPop.add(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>后者的逻辑稍微复杂些，其内部调用了 <code>popBackStackState</code> 方法</p><p>如果是 <code>popBackStack</code> 方法 ，则将 <code>FragmentManager</code> 的返回栈列表（<code>mBackStack</code>）的栈顶移除， <code>isRecordPop</code> list 全部传入 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> last = mBackStack.size() - <span class="hljs-number">1</span>;<br>records.add(mBackStack.remove(last));<br>isRecordPop.add(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>如果传入的 name 或 id 有值，且 flag 为 0，则找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置，并将该位置上方的所有 <code>BackStackRecord</code> 并添加到 <code>record</code> list 中，同时 <code>isRecordPop</code> list 全部传入 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">index = mBackStack.size() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>    BackStackRecord bss = mBackStack.get(index);<br>    <span class="hljs-keyword">if</span> (name != <span class="hljs-keyword">null</span> &amp;&amp; name.equals(bss.getName())) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span> &amp;&amp; id == bss.mIndex) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    index--;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mBackStack.size() - <span class="hljs-number">1</span>; i &gt; index; i--) &#123;<br>  records.add(mBackStack.remove(i));<br>  isRecordPop.add(<span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果传入的 name 或 id 有值，且 flag 为 <code>POP_BACK_STACK_INCLUSIVE</code>，则在上一条获取位置的基础上继续遍历，直至栈底或者遇到不匹配的跳出循环，接着出栈所有 <code>BackStackRecord</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//index 操作与上方相同，先找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置</span><br><span class="hljs-keyword">if</span> ((flags &amp; POP_BACK_STACK_INCLUSIVE) != <span class="hljs-number">0</span>) &#123;<br>    index--;<br>    <span class="hljs-comment">// 继续遍历 mBackStack 直至栈底或者遇到不匹配的跳出循环</span><br>    <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>        BackStackRecord bss = mBackStack.get(index);<br>        <span class="hljs-keyword">if</span> ((name != <span class="hljs-keyword">null</span> &amp;&amp; name.equals(bss.getName()))<br>                || (id &gt;= <span class="hljs-number">0</span> &amp;&amp; id == bss.mIndex)) &#123;<br>            index--;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//后续出栈逻辑与上方相同</span><br></code></pre></td></tr></table></figure><p>可以配合上面的动图理解</p><p>入栈和出栈后续的逻辑大体是相同的，只是根据 isPop 的正负出现了分支，出栈调用的是 executePopOps</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170df06c04191fff?w=972&h=682&f=png&s=132928" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>上文我们有提到，「返回」逻辑实际上就是执行提交事务内部操作逻辑的「逆操作」</p><p>那么接下的逻辑就很清晰了，根据不同的 mCmd 执行相应的逆操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">executePopOps</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> moveToState)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> opNum = mOps.size() - <span class="hljs-number">1</span>; opNum &gt;= <span class="hljs-number">0</span>; opNum--) &#123;<br>        <span class="hljs-keyword">final</span> Op op = mOps.get(opNum);<br>        Fragment f = op.mFragment;<br>        <span class="hljs-keyword">switch</span> (op.mCmd) &#123;<br>            <span class="hljs-keyword">case</span> OP_ADD:<br>                mManager.removeFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_REMOVE:<br>                mManager.addFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_HIDE:<br>                mManager.showFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_SHOW:<br>                mManager.hideFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_DETACH:<br>                mManager.attachFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_ATTACH:<br>                mManager.detachFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_SET_PRIMARY_NAV:<br>                mManager.setPrimaryNavigationFragment(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_UNSET_PRIMARY_NAV:<br>                mManager.setPrimaryNavigationFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_SET_MAX_LIFECYCLE:<br>                mManager.setMaxLifecycle(f, op.mOldMaxState);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unknown cmd: "</span> + op.mCmd);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!mReorderingAllowed &amp;&amp; op.mCmd != OP_REMOVE &amp;&amp; f != <span class="hljs-keyword">null</span>) &#123;<br>            mManager.moveFragmentToExpectedState(f);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!mReorderingAllowed &amp;&amp; moveToState) &#123;<br>        mManager.moveToState(mManager.mCurState, <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面的逻辑就完全一样了</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf65e331c7?w=1137&h=1585&f=png&s=127564" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="popBackStack"></p><h3 id="2-fragment-是怎样拦截-activity-的返回逻辑的？"><a href="#2-fragment-是怎样拦截-activity-的返回逻辑的？" class="headerlink" title="2. fragment 是怎样拦截 activity 的返回逻辑的？"></a>2. fragment 是怎样拦截 activity 的返回逻辑的？</h3><p>在 <a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇</a> 一文中我们介绍了 <code>OnBackPressedDispatcher</code> </p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf6fd444f6?w=1138&h=544&f=png&s=96482" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ComponetActivity"></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf70da7341?w=642&h=512&f=png&s=71452" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>activity 的 <code>onBackPressed</code> 的逻辑主要分为两部分，判断所有注册的 <code>OnBackPressedCallback</code> 是否有 enabled 的，如果有则拦截，不执行后续逻辑；</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170df0d07750776b?w=801&h=765&f=png&s=137606" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="fragment 拦截返回逻辑"></p><p>否则着执行 mFallbackOnBackPressed.run() ，其内部逻辑为调用 ComponentActivity 父类的 <code>onBackPressed</code> 方法</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf7443eb77?w=715&h=275&f=png&s=39938" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><strong>所以我们只需看 mOnBackPressedCallbacks（ArrayDeque&lt;OnBackPressedCallback） 是怎样被添加的以及 isEnabled 何时赋值为 true</strong></p><p>经过查找我们发现它是在 FragmentManager 的 attachController 调用 <code>addCallback</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mOnBackPressedDispatcher.addCallback(owner,mOnBackPressedCallback)<br></code></pre></td></tr></table></figure><p>进而执行了</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170df099d16ae502?w=1000&h=425&f=png&s=75605" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt><br><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf7c970039?w=822&h=233&f=png&s=41860" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>而 <code>mOnBackPressedCallback</code> 在初始化时 enabled 赋值为 false </p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf8362798b?w=954&h=194&f=png&s=42041" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="mOnBackPressedCallback"></p><p><code>isEnadbled</code> 会在返回栈数量大于 0 且其 mParent 为 <code>PrimaryNavigation</code> 时赋值为true</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9805eb1e?w=796&h=555&f=png&s=94237" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>而返回栈（<code>mBackStack</code>）的赋值在 <code>BackStackRecord</code> 的 <code>generateOps</code> 方法中，且是否添加到返回栈由 <code>mAddToBackStack</code> 这个布尔类型的属性控制</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170df0f5d77e3c7f?w=891&h=544&f=png&s=94633" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9a0dfa56?w=548&h=215&f=png&s=28095" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><strong>mAddToBackStack 的赋值在 addToBackStack 方法中，这也解释了为何调用 addToBackStack 方法就能将事务加入返回栈</strong></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9eb75bde?w=841&h=306&f=png&s=47458" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p> 我们来总结一下，fragment 拦截 activity 返回栈是通过 <code>OnBackPressedDispatcher</code> 实现的，如果开启事务调用了 <code>addToBackStack</code> 方法，则 <code>mOnBackPressedCallback</code> 的 <code>isEnabled</code> 属性会赋值为 true，进而起到拦截 activity 返回逻辑的作用。拦截后执行 <code>popBackStackImmediate</code> 方法</p><p>而 popBackStack系列方法会调用 popBackStackState 构造 <code>records</code> 和 <code>isRecordPop</code> 列表，<code>isRecordPop</code> 的内部元素的值均为true 后续流程和提交事务是一样的，根据 <code>isRecordPop</code> 值的不同选择执行 <code>executePopOps</code> 或 <code>executeOps</code> 方法</p></blockquote><h2 id="单返回栈和多返回栈的实现"><a href="#单返回栈和多返回栈的实现" class="headerlink" title="单返回栈和多返回栈的实现"></a>单返回栈和多返回栈的实现</h2><p><a href="https://medium.com/@ianhlake" target="_blank" rel="noopener">Ian Lake</a> 在 <a href="https://www.youtube.com/watch?v=RS1IACnZLy4" target="_blank" rel="noopener">Fragments: Past, Present, and Future (Android Dev Summit ‘19)</a> </p><p>有提到未来会提供多返回栈的 api</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeafa780da77?w=1844&h=948&f=png&s=634511" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>那么以现有的 api 如何实现多返回栈呢？</p><p>首先我要弄清楚怎样才会有多返回栈，根据上文我们知道 <code>FragmentManager</code> 内部持有<code>mBackStack</code> list，这对应着一个返回栈，<strong>如果想要实现多返回栈，则需要多个 FragmentManager</strong>，而多 <code>FragmentManager</code> 则对应多个 fragment</p><p>因此我们可以创建多个宿主 frament 作为导航 fragment 这样就可以用不同的宿主 fragment 的 独立的<code>FragmentManager</code> 分别管理各自的返回栈，如果这样说比较抽象，可以参考下图</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170defa88bc0e5f9?w=488&h=750&f=gif&s=4633102" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>图中有四个返回栈，其中最外部有一个宿主 fragment ，内部有四个负责导航的 fragment 管理其内部的返回栈，外部的宿主负责协调各个返回栈为空后如何切换至其他返回栈</p><p>单返回栈就很容易了，我们只需在同一个 <code>FragmentManager</code> 上添加返回栈即可</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200312175950" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>详情参照 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">demo</a></p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【背上Jetpack】Fragment返回栈预备篇 OnBackPressedDispatcher</title>
      <link href="/2020/03/14/Jetpack-OnBackPressedDispatcher/"/>
      <url>/2020/03/14/Jetpack-OnBackPressedDispatcher/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这两天在准备写 fragment 返回栈的文章，但是发现必须先介绍一下 OnBackPressedDispatcher ，所以这是一篇介绍 what 的文章，喜欢一手资料的可以移步 <a href="https://developer.android.google.cn/reference/kotlin/androidx/activity/OnBackPressedDispatcher" target="_blank" rel="noopener">官方文档</a></p></blockquote><a id="more"></a><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><blockquote><p><a href="https://juejin.im/post/5e567ee1518825494466a938" target="_blank" rel="noopener">【背上Jetpack】Jetpack 主要组件的依赖及传递关系</a><br></p><p><a href="https://juejin.im/post/5e5a0c316fb9a07cd248d29e" target="_blank" rel="noopener">【背上Jetpack】AdroidX下使用Activity和Fragment的变化</a><br></p><p><a href="https://juejin.im/post/5e5cd8686fb9a07cbc269d10" target="_blank" rel="noopener">【背上Jetpack之Fragment】你真的会用Fragment吗？Fragment常见问题以及androidx下Fragment的使用新姿势</a><br></p><p><a href="https://juejin.im/post/5e67523551882549003d2c4f" target="_blank" rel="noopener">【背上Jetpack之Fragment】从源码角度看 Fragment 生命周期 AndroidX Fragment1.2.2源码分析</a></p></blockquote><h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><p><code>OnBackPressedDispatcher</code> 在 <code>androidx activity 1.0.0</code> 加入，旨在处理返回逻辑。您不仅可以获得在 <code>Activity</code> 之外处理返回键的便捷方式。 根据您的需要，您可以在任意位置定义 <code>OnBackPressedCallback</code>，使其可复用，或根据应用程序的架构进行任何操作。 您不再需要重写<code>Activity</code> 中的 <code>onBackPressed</code> 方法，也不必提供自己的抽象的来实现需求的代码。</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/14/170d4a399942581f?w=1778&h=1246&f=png&s=339228" src="/2020/03/14/Jetpack-OnBackPressedDispatcher/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="OnBackPressedDispatcher"></p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p><code>ComponentActivity</code> 是 <code>FragmentActivity</code> 和 <code>AppCompatActivity</code> 的基类，它使您可以通过使用其 <code>OnBackPressedDispatcher</code>（可以通过调用 <code>getOnBackPressedDispatcher()</code> ）来控制返回按钮的行为。</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/14/170d4a9d225a9575?w=2168&h=1150&f=png&s=238889" src="/2020/03/14/Jetpack-OnBackPressedDispatcher/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ComponentActivity-onBackPressed"></p><p><code>OnBackPressedDispatcher</code> 控制如何将返回按钮事件分配给一个或多个<code>OnBackPressedCallback</code> 对象。 <code>OnBackPressedCallback</code> 的构造函数将布尔值用于初始启用状态。 仅当启用了回调（即 <code>isEnabled()</code> 返回true）时，调度程序才会调用回调的<code>handleOnBackPressed()</code> 来处理返回按钮事件。 您可以通过调用 <code>setEnabled()</code> 来更改启用状态。</p><p>回调是通过 <code>addCallback</code> 方法添加的。 强烈建议使用采用 LifecycleOwner 的<code>addCallback()</code> 方法。 这样可以确保仅在 LifecycleOwner 为 Lifecycle.State.STARTED 时才添加<code>OnBackPressedCallback</code>。 当关联的 LifecycleOwner 被销毁时，该 activity 会删除已注册的回调，以防止内存泄漏，并使其适用于寿命比该 <code>activity</code> 短的 <code>fragment</code> 或其他生命周期所有者。</p><p>下面是一个示例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br><br>        <span class="hljs-comment">//此 callback 仅当 MyFragment 至少是 Started 状态下调用</span><br>        <span class="hljs-keyword">val</span> callback = requireActivity().onBackPressedDispatcher.addCallback(<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">//拦截返回事件</span><br>        &#125;<br><br>        <span class="hljs-comment">//此 callback 可以在这里或者上面的 lambda 中开启和关闭</span><br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>您可以通过 <code>addCallback()</code> 提供多个回调。 这样做时，将按照添加回调的相反顺序调用回调，即最后添加的回调是第一个给予处理返回按钮事件的机会的回调。 例如，如果您依次添加了三个分别名为1、2和3的回调，则将分别以3、2和1的顺序调用它们。</p><p>回调遵循“责任链”模式。 仅当未启用前一个回调时，才调用链中的每个回调。 这意味着在前面的示例中，仅当未启用回调3时，才会调用回调2。 仅当未启用回调2时，才调用回调1，依此类推。</p><p>请注意，通过 <code>addCallback()</code> 添加回调时，直到 LifecycleOwner 进入Lifecycle.State.STARTED 状态，才将回调添加到责任链中。</p><p>强烈建议更改 <code>OnBackPressedCallback</code> 的启用状态以进行临时更改(即更改 isEnabled 的值)，因为它可以保持上述顺序，如果您在多个不同的嵌套生命周期所有者上注册了回调，这尤其重要。</p><p>但是，如果要完全删除 <code>OnBackPressedCallback</code>，则应调用 remove()。 但是，这通常不是必需的，因为在销毁关联的 <code>LifecycleOwner</code> 时会自动删除其回调。</p><h2 id="Activity-onBackPressed"><a href="#Activity-onBackPressed" class="headerlink" title="Activity onBackPressed()"></a>Activity onBackPressed()</h2><p>如果您使用 <code>onBackPressed()</code> 处理返回按钮事件，建议您改用 <code>OnBackPressedCallback</code> 。 但是，如果您无法进行此更改，则适用以下规则：</p><ul><li><p>当您调用 <code>super.onBackPressed()</code> 时，将通过 <code>addCallback</code> 注册的所有回调。</p></li><li><p>无论 <code>OnBackPressedCallback</code> 的任何注册实例，始终会调用 <code>onBackPressed</code>。</p></li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>关于 fragment 返回栈的 demo 已经写好了，感兴趣的小伙伴可以 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">在这</a> 找到它。</p><p>我们下一篇再见。</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【背上Jetpack之Fragment】从源码角度看Fragment的启动流程及生命周期 基于AndroidX Fragment1.2.2</title>
      <link href="/2020/03/10/Jetpack-fragment-lifecycle/"/>
      <url>/2020/03/10/Jetpack-fragment-lifecycle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>笔者看过不少源码分析类的文章，动辄贴上大段代码，这种方式很容易打断读者的思路，所以很多时候看过这类文章感叹好文好文，却感觉什么都没记住，亦或者默默加入收藏却不知何时能去细心地研读。</p><p>所以本文不会过多介绍源码的细节，更多地是抛砖引玉，如果您看过本文后能够跟着本文的思路自己翻一下源码相信您就不会有我上述的体验了。</p><p>本文默认您已对 fragment 的生命周期有所了解，并清楚fragment的缘起与职责。这部分基础内容可移步 <a href="https://developer.android.com/guide/components/fragments" target="_blank" rel="noopener">fragment 官方文档</a> </p><p><strong>也即本文不会介绍 “what”，而是介绍 “how” 并且探讨一下 “why”</strong></p></blockquote><a id="more"></a><p>这里贴一下 androidx fragment 源码地址</p><p><a href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/fragment/" target="_blank" rel="noopener">androidx fragment 官方源码地址</a></p><p>本文基于 androidx fragment 1.2.2 源码分析</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">"androidx.fragment:fragment-ktx:1.2.2"</span><br></code></pre></td></tr></table></figure><p>本文主要介绍fragment的启动流程，其他内容例如返回栈，会后续更新，敬请关注。欢迎在评论区下讨论。<a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">本文demo</a></p><p>既然我们都知道 “what”，不妨我们来思考一下 “how”</p><h2 id="分析前的思考"><a href="#分析前的思考" class="headerlink" title="分析前的思考"></a>分析前的思考</h2><p>请大家思考一个问题，我们知道fragment 的生命周期是与其宿主 activity 的生命周期息息相关的，也即 activity 的每次生命周期回调都会引发每个fragment的类似回调。</p><p>那么，如果让我们来实现这样的操作，应该怎么做？</p><blockquote><p> 猜测：在activity每个生命周期的节点，去操作fragment，让其执行相应的生命周期方法。</p></blockquote><p>思路有了，下面进行一些细节的确认。</p><ol><li>activity 要能操作 fragment，fragment 亦可操作 fragment，所以需要抽象出一个管理 fragment 的模型</li><li>activity 操作 fragment 的一系列动作，应该是互为可逆一组操作。例如添加 fragment 后，也应能移除 fragment</li><li>activity 对 fragment 的每组操作不应是单一的，例如可以在一次操作中在 activity 不同位置添加两个 fragment，同时该操作还应满足 2 ，具有可逆性</li></ol><p>对于第一条，我们抽象出一个可以管理 fragment 的模型，加入上下级的关系，即 activity 可管理其内部的 fragment，fragment 亦可管理其内部的 fragment。因此 fragment 同时充当着管理者与被管理者两种角色</p><p>对于后两条，相信在大学学过数据库的人会想到一种结构：<strong>事务（Transaction）</strong></p><blockquote><p> 事务是指一组原子性的操作，这些操作是不可分割的整体，要么全完成，要么全不完成，完成后可以回滚到完成前的状态</p></blockquote><p>因此，fragment 中两个最重要的概念出现了，<code>FragmentManager</code> 和 <code>FragmentTransaction</code></p><p><code>FragmentManager</code>  封装着对 fragment 操作的各种方法，<code>addFragment</code> <code>removeFragment</code> 等等，而 <code>FragmentActivity</code> 通过 <code>FragmentController</code> 来操作 <code>FragmentManager</code>  </p><p><code>FragmentTransaction</code> 封装对 fragment 容器进行的 fragment 操作，例如在容器1内添加一个 fragment，同时在容器2内替换fragment。</p><p>它们均为抽象类，需要具体的实现类。</p><p><code>FragmentManager</code> 的实现类为 <code>FragmentManagerImpl</code>，其内部逻辑已全部移至 <code>FragmentManager</code>  中，是个空实现。</p><p><code>FragmentTransaction</code> 的实现类为 <code>BackStackRecord</code> ，其内部引用了 <code>FragmentManager</code> 的实例 ，同时重写了父类的 四个 <code>commit</code> 相关的方法。</p><h2 id="看似最简单的启动流程"><a href="#看似最简单的启动流程" class="headerlink" title="看似最简单的启动流程"></a>看似最简单的启动流程</h2><p>现在让我们看一部分代码，平时在activity中我们是这样填充一个fragment的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>       <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>       <span class="hljs-comment">//避免旋转屏幕等场景 fragment 重叠的问题</span><br>       <span class="hljs-keyword">if</span> (savedInstanceState == <span class="hljs-literal">null</span>) &#123;<br>           supportFragmentManager<span class="hljs-comment">//步骤1</span><br>               .beginTransaction()<span class="hljs-comment">//步骤2</span><br>               .add(R.id.container, BlankFragment.newInstance())<span class="hljs-comment">//步骤3</span><br>               .commitNow()<span class="hljs-comment">//步骤4</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>步骤1，实例化 <code>FragmentManagerImpl</code> 对象 (内部经历了一些转换，详情参见源码或查看demo注释)</p></li><li><p>步骤2，实例化 <code>BackStackRecord</code>对象，并在构造器中传入 <code>FragmentManager</code> 实例</p></li><li><p>步骤3，调用事务方法，对 fragment 容器进行相应的操作，本例表示在 id 为 <code>container</code> 容器内添加 <code>BlankFragment</code></p></li><li><p>步骤4，提交事务，交于 <code>FragmentManager</code> 处理</p></li></ul><p>在 terminal 敲入 <code>adb shell setprop log.tag.FragmentManager VERBOSE</code> 可开启<code>FragmentManager</code>的日志功能，过滤 <code>FragmentManager</code> ，日志如下：</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200324084150.png" src="/2020/03/10/Jetpack-fragment-lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="单fragment启动日志"></p><p>绿色部分为笔者手动添加的log，灰色和蓝色部分为 fragment 源码中的log</p><p>根据日志显示的流程，我们的猜测看似是正确的，“在 activity 每个生命周期的节点，去操作 fragment ，让其执行相应的生命周期方法”</p><p>其实这里是有干扰的，因为我们是在activity 的 <code>onCreate</code> 方法里 创建并提交 <code>FragmentTransaction</code> ，如果在 <code>onResume</code> 里调用呢？</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200324084240.png" src="/2020/03/10/Jetpack-fragment-lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="单fragment启动日志2"></p><p>WTF！</p><p>或许，我们的猜测有问题？看似调用 <code>commitNow</code> 后 fragment 的生命流程是自发进行的</p><p>那如果我们把调用挪到 <code>onPause</code> 呢？</p><p>打开 activity 并按下 home 键</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200324084122.png" src="/2020/03/10/Jetpack-fragment-lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="单fragment启动日志-onPause"></p><p>我知道好奇的读者会尝试在 <code>onStop</code> 中尝试一下，有惊喜。手动滑稽。</p><p>从这几段日志上来看，fragment 在提交事务后会自发进入自己的生命周期流程，而当其宿主 activity  生命周期发生变化时，fragment 的生命周期也跟随变化。</p><p>如果这么说比较抽象的话，我们可以看在 onPause 中显示fragment 的日志，当 Fragment 进入 onStart 生命周期后，如果是正常流程应该进入 onResume，但由于按下 home 键 activity进入onStop，fragment 也进入了 onStop 状态</p><p>因此，我们将之前的猜测进行扩展：</p><blockquote><ol><li>在activity每个生命周期的节点，去操作fragment，让其执行相应的生命周期方法</li><li>FragmentTransaction  被提交后 fragment 会进入自己的生命周期流程，但受 1 约束</li></ol></blockquote><p>那么我们的源码解读就从两个方向入手</p><h2 id="Activity-操作-Fragment-生命周期"><a href="#Activity-操作-Fragment-生命周期" class="headerlink" title="Activity 操作 Fragment 生命周期"></a>Activity 操作 Fragment 生命周期</h2><p>activity 是通过 <code>FragmentController</code>  操作  <code>FragmentManager</code>  进而操作 fragment 的。</p><p>具体点就是在 activity 各个生命周期节点通过调用 <code>FragmentController</code> 中的各个 <code>dispatch-</code> 方法进而调用 <code>FragmentManager</code> 中的各个 <code>dispatch-</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//FragmentActivity.java</span><br><span class="hljs-keyword">final</span> FragmentController mFragments = FragmentController.createController(<span class="hljs-keyword">new</span> HostCallbacks());<br><br><span class="hljs-comment">//以下代码省略部分逻辑</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;<br>    mFragments.dispatchCreate();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>    mFragments.dispatchStart();<br>&#125;<br><br><span class="hljs-comment">//onResume 彻底执行完毕的回调</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPostResume</span><span class="hljs-params">()</span> </span>&#123;<br>    mFragments.dispatchResume();<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;<br>    mFragments.dispatchPause();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;<br>    mFragments.dispatchStop();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onDestroy();<br>    mFragments.dispatchDestroy();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样猜测 1 就被证实了</p><p><strong>activity 会在各个生命周期节点通过 <code>FragmentController</code> 间接调用 <code>FragmentManager</code>  中的 各种 <code>dispatch-</code> 方法，进而影响 fragment 的生命周期</strong></p><p>那么嵌套 fragment 呢？</p><p>嵌套 fragment 也应该是宿主使用 <code>FragmentManager</code>  中的各种 <code>dispatch-</code> 方法，基于这个想法我们可以看一下 <code>FragmentManager</code>  中 <code>dispatch-</code> 方法的调用</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200324084349.png" src="/2020/03/10/Jetpack-fragment-lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="dispatch-方法的引用"></p><p>可以看到这里有两处调用，第二处为activity 通过 <code>FragmentController</code> 间接调用，第一处使用的是 <code>mChildFragmentManager</code></p><p><strong>这里引出 fragment 中另外两个比较重要的概念，<code>getParentFragmentManager()</code> 和 <code>getChildFragmentManager()</code></strong></p><blockquote><p>注意：<code>requireFragmentManager()</code> 和 <code>getFragmentManager</code> 已弃用</p></blockquote><p><code>getChildFragmentManager()</code>获取的是fragment 中的 <code>mChildFragmentManager</code></p><p><code>getParentFragmentManager()</code> 获取的是fragment 中的 <code>mFragmentManager</code></p><p><code>mChildFragmentManager</code> 为fragment内部的 <code>fragmentManager</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Private fragment manager for child fragments inside of this one.</span><br><span class="hljs-meta">@NonNull</span><br>FragmentManager mChildFragmentManager = <span class="hljs-keyword">new</span> FragmentManagerImpl();<br></code></pre></td></tr></table></figure><p><code>mFragmentManager</code> 稍显复杂，</p><ol><li>如果 fragment 的直接宿主是 activity ，则返回的是 activity 中的<code>getSupportFragmentManager()</code> 返回的 <code>fragmentManager</code></li><li>如果 fragment 的直接宿主是 fragment，即该 fragment 是其他 fragment 的子 fragment，则返回的是其父 fragment 的 <code>getChildFragmentManager</code></li></ol><p><strong>所以 嵌套fragment 的生命周期是父 fragment 在各个生命周期节点上通过 <code>mChildFragmentManager</code> 调用 <code>dispatch-</code>  以影响其子 fragment 的生命周期</strong></p><p>这样我们第一部分的解读就告一段落了, 这里点到为止,一些细节需要您自己亲自看看源码</p><h2 id="Fragment-的生命周期自治"><a href="#Fragment-的生命周期自治" class="headerlink" title="Fragment 的生命周期自治"></a>Fragment 的生命周期自治</h2><p>在 <code>看似最简单的启动流程</code> 一节中我们分别在 activity 的 onCreate ，onResume，onPause 中分别开启并提交事务，来观察 fragment 的生命周期日志。</p><p>在没有 activity 干扰的情况下，fragment 的生命周期是自治的。</p><p>那么我们继续思考一个问题</p><p>Fragment 的生命周期是如何一环扣一环的执行的？</p><p>从上面的日志，我们看到很多 “moveto-” 的日志，</p><p><strong>我们可以继续大胆地猜测，一个生命周期节点结束后调用进入另一个生命周期节点的方法</strong></p><p>基于这个猜测，我们确认一些细节</p><p>fragment 应该有自己的状态，它可能自己管理内部的状态，也可能会有封装着状态转移的逻辑的专门管理状态的抽象</p><p>这里引出另外一个概念 <code>FragmentStateManager</code></p><p><code>FragmentStateManager</code> 中持有 fragment 的引用 <code>mFragment</code> 以及 <code>FragmentManager</code> 的状态 <code>mFragmentManagerState</code></p><p>这里fragment的状态值为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INITIALIZING = -<span class="hljs-number">1</span>;    <span class="hljs-comment">// Not yet attached.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ATTACHED = <span class="hljs-number">0</span>;         <span class="hljs-comment">// Attached to the host.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CREATED = <span class="hljs-number">1</span>;          <span class="hljs-comment">// Created.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ACTIVITY_CREATED = <span class="hljs-number">2</span>; <span class="hljs-comment">// Fully created, not started.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STARTED = <span class="hljs-number">3</span>;          <span class="hljs-comment">// Created and started, not resumed.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RESUMED = <span class="hljs-number">4</span>;          <span class="hljs-comment">// Created started and resumed.</span><br></code></pre></td></tr></table></figure><p><code>FragmentStateManager</code> 还封装着 fragment 状态转移的方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activityCreated</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123;<br>        Log.d(TAG, <span class="hljs-string">"moveto ACTIVITY_CREATED: "</span> + mFragment);<br>    &#125;<br>    mFragment.performActivityCreated(mFragment.mSavedFragmentState);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123;<br>        Log.d(TAG, <span class="hljs-string">"moveto STARTED: "</span> + mFragment);<br>    &#125;<br>    mFragment.performStart();<br>&#125;<br></code></pre></td></tr></table></figure><p>fragment 生命周期自治的核心逻辑封装在 <code>FragmentManager</code> 中的 <code>void moveToState(@NonNull Fragment f, int newState)</code>  内，主要代码为(精简后)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveToState</span><span class="hljs-params">(@NonNull Fragment f, <span class="hljs-keyword">int</span> newState)</span> </span>&#123;<br>    FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho);<br><br>    newState = Math.min(newState, fragmentStateManager.computeMaxState());<br>    <span class="hljs-keyword">if</span> (f.mState &lt;= newState) &#123;<br>        <span class="hljs-keyword">switch</span> (f.mState) &#123;<br>            <span class="hljs-keyword">case</span> Fragment.INITIALIZING:<br>                <span class="hljs-keyword">if</span> (newState &gt; Fragment.INITIALIZING) &#123;<br>                    fragmentStateManager.attach(mHost, <span class="hljs-keyword">this</span>, mParent);<br>                &#125;<br>            <span class="hljs-keyword">case</span> Fragment.ATTACHED:<br>                <span class="hljs-keyword">if</span> (newState &gt; Fragment.ATTACHED) &#123;<br>                    fragmentStateManager.create();<br>                &#125;<br>            <span class="hljs-keyword">case</span> Fragment.CREATED:<br>                <span class="hljs-keyword">if</span> (newState &gt; Fragment.INITIALIZING) &#123;<br>                    fragmentStateManager.ensureInflatedView();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (newState &gt; Fragment.CREATED) &#123;<br>                    fragmentStateManager.createView(mContainer);<br>                    fragmentStateManager.activityCreated();<br>                    fragmentStateManager.restoreViewState();<br>                &#125;<br>            <span class="hljs-keyword">case</span> Fragment.ACTIVITY_CREATED:<br>                <span class="hljs-keyword">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;<br>                    fragmentStateManager.start();<br>                &#125;<br>            <span class="hljs-keyword">case</span> Fragment.STARTED:<br>                <span class="hljs-keyword">if</span> (newState &gt; Fragment.STARTED) &#123;<br>                    fragmentStateManager.resume();<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：这里的switch 没有 break</p></blockquote><p>细心的读者可能发现了，fragment 中的状态怎么只到 resume ，后续的状态呢？</p><p>我们可以看一下 <code>FragmentManager</code> 中的 <code>dispatchPause</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchPause</span><span class="hljs-params">()</span> </span>&#123;<br>    dispatchStateChange(Fragment.STARTED);<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么 dispatch 了 <code>STARTED</code> 的状态？其实刚刚 <code>moveToState</code> 方法我精简掉了一部分代码，留下的只有 <code>f.mState &lt;= newState</code> 的逻辑，即 <strong>dispatch 的新状态大于等于当前的状态</strong></p><p>而现在dispatch 的新状态比当前状态值小，则走了下面的逻辑，例如当前状态为 RESUMED ，新传递的状态为 STARTED，执行了 <code>fragmentStateManager.pause();</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveToState</span><span class="hljs-params">(@NonNull Fragment f, <span class="hljs-keyword">int</span> newState)</span> </span>&#123;<br>    FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho);<br><br>    newState = Math.min(newState, fragmentStateManager.computeMaxState());<br>    <span class="hljs-keyword">if</span> (f.mState &lt;= newState) &#123;<br>    <span class="hljs-comment">//省略...   </span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f.mState &gt; newState) &#123;<br>        <span class="hljs-keyword">switch</span> (f.mState) &#123;<br>            <span class="hljs-keyword">case</span> Fragment.RESUMED:<br>                <span class="hljs-keyword">if</span> (newState &lt; Fragment.RESUMED) &#123;<br>                    fragmentStateManager.pause();<br>                &#125;<br>                <br>            <span class="hljs-keyword">case</span> Fragment.STARTED:<br>                <span class="hljs-keyword">if</span> (newState &lt; Fragment.STARTED) &#123;<br>                    fragmentStateManager.stop();<br>                &#125;<br>                <br>            <span class="hljs-keyword">case</span> Fragment.ACTIVITY_CREATED:<br>                <span class="hljs-keyword">if</span> (newState &lt; Fragment.ACTIVITY_CREATED) &#123;<br>                    <span class="hljs-keyword">if</span> (isLoggingEnabled(Log.DEBUG)) &#123;<br>                        Log.d(TAG, <span class="hljs-string">"movefrom ACTIVITY_CREATED: "</span> + f);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (f.mView != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (mHost.onShouldSaveFragmentState(f) &amp;&amp; f.mSavedViewState == <span class="hljs-keyword">null</span>) &#123;<br>                            fragmentStateManager.saveViewState();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (mExitAnimationCancellationSignals.get(f) == <span class="hljs-keyword">null</span>) &#123;<br>                        destroyFragmentView(f);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        f.setStateAfterAnimating(newState);<br>                    &#125;<br>                &#125;<br>            <span class="hljs-keyword">case</span> Fragment.CREATED:<br>                <span class="hljs-keyword">if</span> (newState &lt; Fragment.CREATED) &#123;<br>                    <span class="hljs-keyword">boolean</span> beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack();<br>                    <span class="hljs-keyword">if</span> (beingRemoved || mNonConfig.shouldDestroy(f)) &#123;<br>                        makeInactive(fragmentStateManager);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> (f.mTargetWho != <span class="hljs-keyword">null</span>) &#123;<br>                            Fragment target = findActiveFragment(f.mTargetWho);<br>                            <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; target.getRetainInstance()) &#123;<br>                                f.mTarget = target;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (mExitAnimationCancellationSignals.get(f) != <span class="hljs-keyword">null</span>) &#123;<br>                        f.setStateAfterAnimating(newState);<br>                        newState = Fragment.CREATED;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        fragmentStateManager.destroy(mHost, mNonConfig);<br>                    &#125;<br>                &#125;<br>            <span class="hljs-keyword">case</span> Fragment.ATTACHED:<br>                <span class="hljs-keyword">if</span> (newState &lt; Fragment.ATTACHED) &#123;<br>                    fragmentStateManager.detach(mNonConfig);<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：这里的switch 还是没有 break</p></blockquote><p>这里有个细节，由于activity没有 onDestroyView 的生命周期，所以 <code>FragmentController</code> 中的 <code>dispatchDestroyView</code> 是没有调用的</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200324084417.png" src="/2020/03/10/Jetpack-fragment-lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="dispatchOnDestroyView"></p><p> 在 activity 中的 destroy 方法中通过 <code>fragmentController</code> 调用了 <code>dispatchDestroy</code> 内部调用 <code>dispatchStateChange(Fragment.INITIALIZING)</code> ，而此时的fragment 的 mState 为 <code>ACTIVITY_CREATED</code>，所以 <code>moveToState</code> 方法会走到 <code>ACTIVITY_CREATED</code> 的 case 并执行到底</p><p>这样 fragment 最简单场景的生命周期就结束了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们做一个总结：activity 和 fragment 会在各个生命周期节点通过被调用 fragment 的 <code>parentFragmentManager</code>（或者说父 fragment 的 <code>childFragmentManager</code> 和 activity 的 <code>supportFragmentManager</code>）中的各种 <code>dispatch-</code> 方法以影响子 fragment 的 生命周期，同时子 fragment 也拥有自己生命周期的调用链（从状态A转移至状态B）</p><p>不得不说 fragment 的很多 API 并不是很好用，从 androidx fragment 的更新频率也可以看出。比如 fragment 中的 view 和 fragment本身的生命周期是不一致的，存在onDestroyView 但 fragment没有销毁的情况</p><p><a href="https://medium.com/@ianhlake" target="_blank" rel="noopener">Ian Lake</a> 在 <a href="https://www.youtube.com/watch?v=RS1IACnZLy4" target="_blank" rel="noopener">Fragments: Past, Present, and Future (Android Dev Summit ‘19)</a> 中提到未来官方会将二者合并，届时 fragment 的使用会更加简洁</p><p>这里引用 <a href="https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iii-fragments-afc87d4f37fd" target="_blank" rel="noopener">The Android Lifecycle cheat sheet — part III : Fragments</a> 文中的图片 ，和我画的commit <code>FragmentTransaction</code>  的脑图（略简陋），帮您更好的理解</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200324084444.png" src="/2020/03/10/Jetpack-fragment-lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt=" [The Android Lifecycle cheat sheet — part III : Fragments](https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iii-fragments-afc87d4f37fd)"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200324084515.png" src="/2020/03/10/Jetpack-fragment-lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="fragment脑图"></p><p>强烈建议您自己亲自看一看源码，不然就变为我文章开头时说的状态了。</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【背上Jetpack之Fragment】你真的会用Fragment吗？Fragment常见问题以及androidx下Fragment的使用新姿势</title>
      <link href="/2020/03/02/Jetpack-fragment/"/>
      <url>/2020/03/02/Jetpack-fragment/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在 <code>Android Jetpack</code> 组件中，<code>fragment</code>作为视图控制器之一占有很重要的位置。但由于其bug众多，暗坑无数，以至于 Square 有这样一篇博客：<a href="https://developer.squareup.com/blog/advocating-against-android-fragments/" target="_blank" rel="noopener">Advocating Against Android Fragments</a>。github上的 <a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="noopener">Fragmentation</a> 有着 9.4k 的star。</p><p>而现在，<code>androidx fragment</code> 稳定版已来到 1.2.2，让我们总结一下<code>fragment</code>有哪些常见问题以及有哪些使用<code>fragment</code>的新姿势</p></blockquote><a id="more"></a><h2 id="Fragment-常见的问题"><a href="#Fragment-常见的问题" class="headerlink" title="Fragment 常见的问题"></a>Fragment 常见的问题</h2><ul><li><p>getSupportFragmentManager ， getParentFragmentManager 和 getChildFragmentManager</p></li><li><p>FragmentStateAdapter 和 FragmentPagerAdapter</p></li><li><p>add 和 replace </p></li><li><p>observe LiveData时传入 this 还是 viewLifecycleOwner</p></li><li><p>使用 simpleName 作为 fragment 的 tag 有何风险？</p></li><li><p>在 BottomBarNavigation 和 drawer 中如何使用Fragment多次添加？</p></li><li><p>返回栈</p></li></ul><h3 id="getSupportFragmentManager-getParentFragmentManager和getChildFragmentManager"><a href="#getSupportFragmentManager-getParentFragmentManager和getChildFragmentManager" class="headerlink" title="getSupportFragmentManager , getParentFragmentManager和getChildFragmentManager"></a>getSupportFragmentManager , getParentFragmentManager和getChildFragmentManager</h3><blockquote><p><code>FragmentManager</code>是 <code>androidx.fragment.app</code>(已弃用的不考虑)下的抽象类，创建用于 添加，移除，替换 <code>fragment</code> 的事务（<code>transaction</code>）  </p></blockquote><p>首先要确认一件事，<code>getSupportFragmentManager()</code>是 <code>FragmentActivity</code>下的方法</p><p><code>getParentFragmentManager</code> 和 <code>getChildFragmentManager</code> 是 <code>androidx.fragment.app.Fragment</code> 下的方法，<strong>其中  <code>androidx.fragment 1.2.0</code> 后 <code>getFragmentManager</code> 与  <code>requireFragmentManager</code> 已弃用</strong></p><p>明确了这件事，接下来的就很清晰了</p><ul><li><code>getSupportFragmentManager</code>与 <code>activity</code>关联，可以将其视为 <code>activity</code> 的 <code>FragmentManager</code></li><li><code>getChildFragmentManager</code> 与 <code>fragment</code>关联，可以将其视为<code>fragment</code>的<code>FragmentManager</code></li><li><code>getParentFragmentManager</code>情况稍微复杂，正常情况返回的是该<code>fragment</code> 依附的<code>activity</code>的<code>FragmentManager</code>。如果该fragment是另一个<code>fragment</code> 的子 <code>fragment</code>，则返回的是其父<code>fragment</code>的 <code>getChildFragmentManager</code></li></ul><p>如果这么说还不明白的话，我们可以做一个实践。</p><p>创建一个 <code>activity</code>,一个父<code>fragment</code> ，一个子<code>fragment</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// activity</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>(R.layout.activity_main) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        supportFragmentManager.commit &#123;<br>            add&lt;ParentFragment&gt;(R.id.content)<br>        &#125;<br>        Log.i(<span class="hljs-string">"MyActivity"</span>, <span class="hljs-string">"supportFragmentManager <span class="hljs-variable">$supportFragmentManager</span>"</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParentFragment</span> : <span class="hljs-type">Fragment</span></span>(R.layout.fragment_parent) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)<br>        childFragmentManager.commit &#123;<br>            add&lt;ChildFragment&gt;(R.id.content)<br>        &#125;<br>        Log.i(<span class="hljs-string">"ParentFragment"</span>, <span class="hljs-string">"parentFragmentManager <span class="hljs-variable">$parentFragmentManager</span>"</span>)<br>        Log.i(<span class="hljs-string">"ParentFragment"</span>, <span class="hljs-string">"childFragmentManager <span class="hljs-variable">$childFragmentManager</span>"</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildFragment</span> : <span class="hljs-type">Fragment</span></span>(R.layout.fragment_child) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)<br>        Log.i(<span class="hljs-string">"ChildFragment"</span>, <span class="hljs-string">"parentFragmentManager <span class="hljs-variable">$parentFragmentManager</span>"</span>)<br>        Log.i(<span class="hljs-string">"ChildFragment"</span>, <span class="hljs-string">"childFragmentManager <span class="hljs-variable">$childFragmentManager</span>"</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">//log<br>I/MyActivity: supportFragmentManager FragmentManager&#123;825dcef in HostCallbacks&#123;14a13fc&#125;&#125;&#125;<br>I/ParentFragment: parentFragmentManager FragmentManager&#123;825dcef in HostCallbacks&#123;14a13fc&#125;&#125;&#125;<br>I/ParentFragment: childFragmentManager FragmentManager&#123;df5de83 in ParentFragment&#123;7cdd800&#125;&#125;&#125;<br>I/ChildFragment: parentFragmentManager FragmentManager&#123;df5de83 in ParentFragment&#123;7cdd800&#125;&#125;&#125;<br>I/ChildFragment: childFragmentManager FragmentManager&#123;aba9afb in ChildFragment&#123;5cea718&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><p>因此</p><ul><li><p>在 <code>activity</code> 中使用 <code>ViewPager</code>，<code>BottomSheetFragment</code> 和<code>DialogFragment</code> 时，都应使用 <code>getSupportFragmentManager</code></p></li><li><p>在<code>fragment</code> 中使用 <code>ViewPager</code> 时应该使用<code>getChildFragmentManager</code></p></li></ul><p>错误的在 <code>fragment</code> 中使用 <code>activity</code> 的 <code>FragmentManager</code> 会引发内存泄露。 为什么呢？假如您的fragment中有一些依靠 <code>ViewPager</code> 管理的子 <code>fragment</code>，并且所有这些 <code>fragment</code>  都在 <code>activity</code> 中，因为您使用的是<code>activity</code> 的<code>FragmentManager</code> 。 现在，如果关闭您的父<code>fragment</code>，它将被关闭，但不会被销毁，因为所有子<code>fragment</code>都处于活动状态，并且它们仍在内存中，从而导致泄漏。 它不仅会泄漏父<code>fragment</code>，还会泄漏所有子<code>fragment</code>，因为它们都无法从堆内存中清除。 </p><h3 id="FragmentStateAdapter-和-FragmentPagerAdapter"><a href="#FragmentStateAdapter-和-FragmentPagerAdapter" class="headerlink" title="FragmentStateAdapter 和 FragmentPagerAdapter"></a>FragmentStateAdapter 和 FragmentPagerAdapter</h3><p><code>FragmentPagerAdapter</code>将整个 <code>fragment</code>存储在内存中，如果<code>ViewPager</code>中使用了大量  <code>fragment</code>，则可能导致内存开销增加。 <code>FragmentStatePagerAdapter</code>仅存储片段的<code>savedInstanceState</code>，并在失去焦点时销毁所有  <code>fragment</code>。</p><p>让我们看看常见的两个问题</p><h4 id="1-刷新ViewPager不生效"><a href="#1-刷新ViewPager不生效" class="headerlink" title="1. 刷新ViewPager不生效"></a>1. 刷新ViewPager不生效</h4><p><code>ViewPager</code> 中的 <code>fragment</code> 是通过 <code>activity</code>或 <code>fragment</code>的 <code>FragmentManager</code> 管理的，<code>FragmentManager</code> 包含了<code>viewpager</code>的所有<code>fragment</code>的实例</p><p>因此，当<code>ViewPager</code>没有刷新时，它只是<code>FragmentManager</code>仍保留的旧 <code>fragment</code> 实例。 您需要找出为什么<code>FragmentManger</code>持有<code>fragment</code>实例的原因。</p><h4 id="2-在Viewpager中访问当前fragment"><a href="#2-在Viewpager中访问当前fragment" class="headerlink" title="2. 在Viewpager中访问当前fragment"></a>2. 在Viewpager中访问当前fragment</h4><p>这也是我们遇到的一个非常普遍的问题。 如果遇到这种情况，我们一般在 <code>adapter</code> 内部创建 <code>fragment</code> 的数组列表，或者尝试使用某些标签访问<code>fragment</code>。 不过还有另一种选择。 <code>FragmentStateAdapter</code> 和<code>FragmentPagerAdapter</code>都提供方法<code>setPrimaryItem</code>。 可以用来设置当前<code>fragment</code>，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-keyword">var</span> fragment: ChildFragment? = <span class="hljs-literal">null</span><br> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setPrimaryItem</span><span class="hljs-params">(container: <span class="hljs-type">ViewGroup</span>, position: <span class="hljs-type">Int</span>, any: <span class="hljs-type">Any</span>)</span></span> &#123;<br>   <span class="hljs-keyword">if</span> (getChildFragment() != any)<br>   fragment = any <span class="hljs-keyword">as</span> ChildFragment<br>   <span class="hljs-keyword">super</span>.setPrimaryItem(container, position, any)<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getChildFragment</span><span class="hljs-params">()</span></span>: ChildFragment? = fragment<br><br><span class="hljs-comment">//use</span><br>mAapter.getChildFragment()<br></code></pre></td></tr></table></figure><h3 id="add-和-replace-如何选择？"><a href="#add-和-replace-如何选择？" class="headerlink" title="add 和 replace 如何选择？"></a>add 和 replace 如何选择？</h3><p>在我们的<code>activity</code>中，我们有一个容器，其中装有<code>fragment</code>。</p><p><code>add</code>只会将一个<code>fragment</code>添加到容器中。 假设您将<code>FragmentA</code>和<code>FragmentB</code>添加到容器中。 容器将具有<code>FragmentA</code>和<code>FragmentB</code>，如果容器是<code>FrameLayout</code>，则将<code>fragment</code>一个添加在另一个之上。</p><p><code>replace</code>将简单地替换容器顶部的一个<code>fragment</code>，因此，如果我创建了 <code>FragmentC</code>并 <code>replace</code> 顶部的 <code>FragmentB</code>，则<code>FragmentB</code>将被从容器中删除（执行<code>onDestroy</code>，除非您调用<code>addToBackStack</code>，仅执行<code>onDestroyView</code>），而<code>FragmentC</code>将位于顶部。</p><p>那么如何选择呢？ <code>replace</code>删除现有<code>fragment</code>并添加一个新<code>fragment</code>。 这意味着当您按下返回按钮时，将创建被替换的<code>fragment</code>，并调用其<code>onCreateView</code>。 另一方面，<code>add</code>保留现有<code>fragment</code>，并添加一个新<code>fragment</code>，这意味着现有<code>fragment</code>将处于活动状态，并且它们不会处于 “paused” 状态。 因此，按下返回按钮时，现有<code>fragment</code>（添加新<code>fragment</code>之前的<code>fragment</code>）不会调用<code>onCreateView</code>。 就<code>fragment</code>的生命周期事件而言，在<code>replace</code>的情况下将调用<code>onPause</code>，<code>onResume</code>，<code>onCreateView</code>和其他生命周期事件，在<code>add</code>的情况下则不会。</p><p>如果不需要重新访问当前<code>fragment</code>并且不再需要当前<code>fragment</code>，请使用<code>replace</code>。 另外，如果您的应用有内存限制，请考虑使用<code>replace</code>。</p><h3 id="observe-LiveData时传入-this-还是-viewLifecycleOwner"><a href="#observe-LiveData时传入-this-还是-viewLifecycleOwner" class="headerlink" title="observe LiveData时传入 this 还是 viewLifecycleOwner"></a>observe LiveData时传入 this 还是 viewLifecycleOwner</h3><p><code>androidx fragment 1.2.0</code> 起，添加了新的 Lint 检查，以确保您在从 <code>onCreateView()</code>、<code>onViewCreated()</code> 或 <code>onActivityCreated()</code> 观察 <code>LiveData</code> 时使用 <code>getViewLifecycleOwner()</code></p><h3 id="使用-simpleName-作为-fragment-的-tag-有何风险？"><a href="#使用-simpleName-作为-fragment-的-tag-有何风险？" class="headerlink" title="使用 simpleName 作为 fragment 的 tag 有何风险？"></a>使用 simpleName 作为 fragment 的 tag 有何风险？</h3><p>一般情况下我们会使用calss的<code>simpleName</code> 作为<code>fragment</code> 的tag</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">supportFragmentManager.commit &#123;<br>replace(R.id.content,MyFragment.newInstance(<span class="hljs-string">"Fragment"</span>),<br>            MyFragment::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>.<span class="hljs-title">simpleName</span>)</span><br>    addToBackStack(<span class="hljs-literal">null</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做不会出现什么问题，但是…</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> fragment = supportFragmentManager.findFragmentByTag(tag)<br></code></pre></td></tr></table></figure><p>这样获取到的fragment可能不是想要的结果。</p><p>为什么呢？</p><p>加入有两个 fragment，经过混淆，它们变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">com.mypackage.FragmentA → com.mypackage.c.a<br>com.mypackage.FragmentB → com.mypackage.c.a.a<br></code></pre></td></tr></table></figure><p>上面是混淆了 full name，如果是simpleName 呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">com.mypackage.FragmentA → a<br>com.mypackage.FragmentB → a<br></code></pre></td></tr></table></figure><p>WTF！</p><p><strong>所以在设置tag时尽量用全名或者常量</strong></p><h3 id="在-BottomBarNavigation-和-drawer-中如何使用Fragment多次添加？"><a href="#在-BottomBarNavigation-和-drawer-中如何使用Fragment多次添加？" class="headerlink" title="在 BottomBarNavigation 和 drawer 中如何使用Fragment多次添加？"></a>在 BottomBarNavigation 和 drawer 中如何使用Fragment多次添加？</h3><p>当我们使用<code>BottomBarNavigation</code>和 <code>NavigationDrawer</code>时，通常会看到诸如<code>fragment</code> 重建或多次添加相同<code>fragment</code>之类的问题。</p><p>在这种情况下，您可以使用<code>show / hide</code> 而不是 <code>add</code> 或 <code>replace</code>。</p><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>如果您想在<code>fragment</code>的一系列跳转中按返回键返回上一个<code>fragment</code>，应该在<code>commit</code> <code>transaction</code>之前调用<code>addToBackStack</code>方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//使用该扩展 androidx.fragment:fragment-ktx:1.2.0 以上</span><br>parentFragmentManager.commit &#123;<br>addToBackStack(<span class="hljs-literal">null</span>)<br>  add&lt;SecondFragment&gt;(R.id.content)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Fragment的使用新姿势"><a href="#Fragment的使用新姿势" class="headerlink" title="Fragment的使用新姿势"></a>Fragment的使用新姿势</h2><ul><li><p>fragment-ktx 有哪些好用的扩展函数</p></li><li><p>fragment 之间和与 activity 通信</p></li><li><p>使用 FragmentContainerView 作为 fragment 容器</p></li><li><p>FragmentFactory 的使用</p></li><li><p>Fragment 返回键拦截</p></li><li><p>Fragment 使用 ViewBinding</p></li><li><p>Fragment 使用 ViewPager2</p></li><li><p>不需要重写 onCreateView 了？</p></li><li><p>使用require_()方法</p></li></ul><h3 id="fragment-ktx-有哪些好用的扩展函数"><a href="#fragment-ktx-有哪些好用的扩展函数" class="headerlink" title="fragment-ktx 有哪些好用的扩展函数"></a>fragment-ktx 有哪些好用的扩展函数</h3><h4 id="1-FragmentManagerKt"><a href="#1-FragmentManagerKt" class="headerlink" title="1. FragmentManagerKt"></a>1. FragmentManagerKt</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//before</span><br>supportFragmentManager<br>    .beginTransaction()<br>    .add(R.id.content,Fragment1())<br>    .commit()<br><br><span class="hljs-comment">//after</span><br>supportFragmentManager.commit &#123;<br>add&lt;Fragment1&gt;(R.id.content)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-FragmentViewModelLazyKt"><a href="#2-FragmentViewModelLazyKt" class="headerlink" title="2. FragmentViewModelLazyKt"></a>2. FragmentViewModelLazyKt</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//before</span><br><span class="hljs-comment">//共享范围activity</span><br><span class="hljs-keyword">val</span> mViewMode1l = ViewModelProvider(requireActivity()).<span class="hljs-keyword">get</span>(UpdateAppViewModel::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span><br><span class="hljs-comment">//共享范围fragment 内部</span><br><span class="hljs-keyword">val</span> mViewMode1l = ViewModelProvider(<span class="hljs-keyword">this</span>).<span class="hljs-keyword">get</span>(UpdateAppViewModel::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span><br><br><span class="hljs-comment">//after</span><br><span class="hljs-comment">//共享范围activity</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mViewModel <span class="hljs-keyword">by</span> activityViewModels&lt;MyViewModel&gt;()<br><span class="hljs-comment">//共享范围fragment 内部</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mViewModel <span class="hljs-keyword">by</span> viewModel&lt;MyViewModel&gt;()<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：ViewModelProviders.of(this).get(MyViewModel.class); 的方式已弃用</strong> </p><p><strong><code>lifecycle-extensions</code> 依赖包已弃用</strong></p></blockquote><h3 id="fragment-之间和与-activity-通信"><a href="#fragment-之间和与-activity-通信" class="headerlink" title="fragment 之间和与 activity 通信"></a>fragment 之间和与 activity 通信</h3><p>fragment 和 fragment之间，fragment 和 activity 之间的通信有很多方法，android jetpack 推荐我们使用 ViewModel + LiveData 处理</p><p>同一个activity 内的 fragment 之间通信，可以使用作用范围为activity的ViewModel，activity与 fragment通信同理。详情可移步 <a href="https://developer.android.com/jetpack/docs/guide" target="_blank" rel="noopener">Android官方应用架构指南</a></p><h3 id="使用-FragmentContainerView-作为-fragment-容器"><a href="#使用-FragmentContainerView-作为-fragment-容器" class="headerlink" title="使用 FragmentContainerView 作为 fragment 容器"></a>使用 FragmentContainerView 作为 fragment 容器</h3><p>过去我们使用 <code>FrameLayout</code> 作为 <code>Fragment</code> 的容器，在 <code>AndroidX Fragment 1.2.0</code> 后，可以使用 <code>FragmentContainerView</code> 代替 <code>Fragment</code> 。</p><p>它修复了一些动画 z轴索引顺序问题和窗口插入调度，这意味着两个<code>fragment</code>之间的退出和进入过渡不会互相重叠。使用<code>FragmentContainerView</code>将先开启退出动画然后才是进入动画。</p><p><code>FragmentContainerView</code>  是专门为 fragment设计的自定义View，它继承自 FrameLayout</p><p><code>android:name</code> 属性允许您添加<code>fragment</code>，<code>android:tag</code> 属性可以为<code>fragment</code>设置tag</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.fragment.app.FragmentContainerView</span><br>       <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span><br>       <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span><br>       <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/fragment_container_view"</span><br>       <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>       <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span><br>       <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.example.MyFragment"</span><br>       <span class="hljs-attr">android:tag</span>=<span class="hljs-string">"my_tag"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.fragment.app.FragmentContainerView</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="FragmentFactory-的使用"><a href="#FragmentFactory-的使用" class="headerlink" title="FragmentFactory 的使用"></a>FragmentFactory 的使用</h3><p>过去，我们只能使用其默认的空构造函数实例化Fragment实例。 这是因为在某些情况下，例如配置更改和应用程序的流程重新创建，系统需要重新初始化。 如果不是默认的构造方法，系统将不知道如何重新初始化Fragment实例。</p><p>创建FragmentFactory来解决此限制。 通过向其提供实例化Fragment所需的必要参数/依赖关系，它可以帮助系统创建Fragment实例。</p><p>过去我们实例化fragment并传递参数会使用类似下面的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> arg: String<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        arguments?.getString(ARG) ?: <span class="hljs-string">""</span><br>    &#125;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newInstance</span><span class="hljs-params">(arg: <span class="hljs-type">String</span>)</span></span> =<br>            MyFragment().apply &#123;<br>                arguments = Bundle().apply &#123;<br>                    putString(ARG, arg)<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//use</span><br><span class="hljs-keyword">val</span> fragment = MyFragment.newInstance(<span class="hljs-string">"my argument"</span>)<br></code></pre></td></tr></table></figure><p>如果您的Fragment有一个非空的构造函数，则需要创建一个FragmentFactory来处理它的初始化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragmentFactory</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> arg: String) : FragmentFactory() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">instantiate</span><span class="hljs-params">(classLoader: <span class="hljs-type">ClassLoader</span>, className: <span class="hljs-type">String</span>)</span></span>: Fragment &#123;<br>        <span class="hljs-keyword">if</span> (className == MyFragment::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>.<span class="hljs-title">name</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> MyFragment(arg)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.instantiate(classLoader, className)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>fragment</code>由<code>FragmentManager</code> 管理，因此很自然，<code>FragmentFactory</code>需要添加到<code>FragmentManager</code>才能使用。</p><p>那么什么时候把<code>FragmentFactory</code> 添加到<code>FragmentManager</code>呢？</p><p><strong>父类调用 <code>Activity#onCreate()</code>  和 <code>Fragment#onCreate()</code>之前</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HostActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> customFragmentFactory = CustomFragmentFactory(Dependency())<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        supportFragmentManager.fragmentFactory = customFragmentFactory<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParentFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> customFragmentFactory = CustomFragmentFactory(Dependency())<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        childFragmentManager.fragmentFactory = customFragmentFactory<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您的<code>Fragment</code>具有默认的空构造函数，则无需使用<code>FragmentFactory</code>。 但是，如果您的<code>Fragment</code>在其构造函数中接受参数，则必须使用<code>FragmentFactory</code>，否则将抛出<code>Fragment.InstantiationException</code>，因为将使用的默认<code>FragmentFactory</code>将不知道如何实例化<code>Fragment</code>的实例。</p><h3 id="Fragment-返回键拦截"><a href="#Fragment-返回键拦截" class="headerlink" title="Fragment 返回键拦截"></a>Fragment 返回键拦截</h3><p>有时候，您需要阻止用户返回上一级。 在这种情况下，您需要在 <code>Activity</code> 中重写 <code>onBackPressed()</code> 方法。 但是，当您使用 <code>Fragment</code> 时，没有直接的方法来拦截返回。 在 <code>Fragment</code> 类中没有可用的 <code>onBackPressed()</code> 方法，这是为了防止同时存在多个 <code>Fragment</code> 时发生意外行为。</p><p>但是，从 <code>AndroidX</code> <code>Activity 1.0.0</code> 开始，您可以使用 <code>OnBackPressedDispatcher</code> 在您可以访问该 <code>Activity</code> 的代码的任何位置（例如，在 <code>Fragment</code> 中）注册 <code>OnBackPressedCallback</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttach</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onAttach(context)<br>    <span class="hljs-keyword">val</span> callback = <span class="hljs-keyword">object</span> : OnBackPressedCallback(<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleOnBackPressed</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// Do something</span><br>      &#125;<br>    &#125;<br>    requireActivity().onBackPressedDispatcher.addCallback(<span class="hljs-keyword">this</span>, callback)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Fragment-使用-ViewBinding"><a href="#Fragment-使用-ViewBinding" class="headerlink" title="Fragment 使用 ViewBinding"></a>Fragment 使用 ViewBinding</h3><p><code>Android Studio 3.6.0</code> 后提供了 <code>ViewBindind</code>的支持，完整使用流程参见 <a href="https://juejin.im/post/5e4806f3e51d4526c550a2ef" target="_blank" rel="noopener">[译]深入研究ViewBinding 在 include, merge, adapter, fragment, activity 中使用</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _binding: FragmentHomeBinding? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> binding <span class="hljs-keyword">get</span>() = _binding!!<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(inflater: <span class="hljs-type">LayoutInflater</span>, container: <span class="hljs-type">ViewGroup</span>?, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span>: View? &#123;<br>        _binding = FragmentHomeBinding.inflate(inflater, container, <span class="hljs-literal">false</span>)<br>        <span class="hljs-keyword">return</span> binding.root<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span></span> &#123;<br>        _binding = <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Fragment-使用-ViewPager2"><a href="#Fragment-使用-ViewPager2" class="headerlink" title="Fragment 使用 ViewPager2"></a>Fragment 使用 ViewPager2</h3><p><code>ViewPager</code>使用了三个<code>adapter</code>的抽象类，而<code>ViewPager2</code>中只有两个</p><ul><li>ViewPager 中使用 <code>PagerAdaper</code>，ViewPager2 中使用 <strong><code>Recyclerview.Adapter</code></strong></li><li>ViewPager 中使用 <code>FragmentPagerAdapter</code> ，ViewPager2中使用 <strong><code>FragmentStateAdapter</code></strong></li><li>ViewPager 中使用 <code>FragmentStatePagerAdapter</code> ，ViewPager2中使用 <strong><code>FragmentStateAdapter</code></strong></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// A simple ViewPager adapter class for paging through fragments</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScreenSlidePagerAdapter</span></span>(fm: FragmentManager) : FragmentStatePagerAdapter(fm) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = NUM_PAGES<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItem</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: Fragment = ScreenSlidePageFragment()<br>&#125;<br><br><span class="hljs-comment">// An equivalent ViewPager2 adapter class</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScreenSlidePagerAdapter</span></span>(fa: FragmentActivity) : FragmentStateAdapter(fa) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = NUM_PAGES<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createFragment</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: Fragment = ScreenSlidePageFragment()<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>TabLayout</code>的变化，<code>TabLayout</code> 已从<code>ViewPager2</code>中解耦，如果使用<code>TabLayout</code>，需要引入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">"com.google.android.material:material:1.1.0"</span><br></code></pre></td></tr></table></figure><p>对于<code>ViewPager2</code> ，<code>TabLayout</code>布局应与<code>ViewPager2</code>在同一级别</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- A ViewPager element with a TabLayout --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.viewpager.widget.ViewPager</span><br>    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/pager"</span><br>    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.tabs.TabLayout</span><br>        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/tab_layout"</span><br>        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.viewpager.widget.ViewPager</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- A ViewPager2 element with a TabLayout --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span><br>    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span><br>    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.tabs.TabLayout</span><br>        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/tab_layout"</span><br>        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.viewpager2.widget.ViewPager2</span><br>        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/pager"</span><br>        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"0dp"</span><br>        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">"1"</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用<code>ViewPager</code>时，<code>TabLayout</code>与<code>ViewPager</code>联动需要调用 <code>setupWithViewPager</code>，并重写<code>getPageTitle</code>方法，而<code>ViewPager2</code>改为使用<code>TabLayoutMediator</code>对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Integrating TabLayout with ViewPager</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionDemoFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br>    ...<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> tabLayout = view.findViewById(R.id.tab_layout)<br>        tabLayout.setupWithViewPager(viewPager)<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoCollectionPagerAdapter</span></span>(fm: FragmentManager) : FragmentStatePagerAdapter(fm) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span>  = <span class="hljs-number">4</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPageTitle</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: CharSequence &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"OBJECT <span class="hljs-subst">$&#123;(position + <span class="hljs-number">1</span>)&#125;</span>"</span><br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// Integrating TabLayout with ViewPager2</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionDemoFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br>    ...<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> tabLayout = view.findViewById(R.id.tab_layout)<br>        TabLayoutMediator(tabLayout, viewPager) &#123; tab, position -&gt;<br>            tab.text = <span class="hljs-string">"OBJECT <span class="hljs-subst">$&#123;(position + <span class="hljs-number">1</span>)&#125;</span>"</span><br>        &#125;.attach()<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不需要重写-onCreateView-了？"><a href="#不需要重写-onCreateView-了？" class="headerlink" title="不需要重写 onCreateView 了？"></a>不需要重写 onCreateView 了？</h3><p><code>androidx fragment 1.1.0</code> 后，您可以使用将 <code>layoutId</code> 作为参数的构造函数，这样就无需重写 <code>onCreateView</code> 方法了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>(R.layout.my_activity)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragmentActivity</span>: <span class="hljs-type">FragmentActivity</span></span>(R.layout.my_fragment_activity)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragment</span> : <span class="hljs-type">Fragment</span></span>(R.layout.my_fragment)<br></code></pre></td></tr></table></figure><h3 id="使用require-方法"><a href="#使用require-方法" class="headerlink" title="使用require_()方法"></a>使用require_()方法</h3><p><code>androidx fragment 1.2.2</code> 起，新增了一项lint检查，<code>fragment</code> 建议使用关联的<code>require_()</code>方法获取更多描述性错误消息，而不是使用<code>checkNotNull(get_())</code>，<code>requireNonNull(get_())</code> 或<code>get()！</code> 适用于所有包含 get 和 require Fragment API</p><p>例如：使用 <code>requireActivity()</code> 替代 <code>getActivity()</code></p>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【背上Jetpack】Jetpack 主要依赖关系</title>
      <link href="/2020/03/01/Jetpack-dependencies/"/>
      <url>/2020/03/01/Jetpack-dependencies/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在学习和使用 <code>jetpack</code> 组件时，总是被其 gradle 依赖搞的晕头转向，故在此整理 <code>jetpack</code> 主要组件的依赖，及传递关系</p></blockquote><a id="more"></a><ul><li><a href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev" target="_blank" rel="noopener"><code>jetpcak</code> 组件源码地址</a></li><li>查询 <code>jetpcak</code> 组件 版本: <a href="https://maven.google.com/web/index.html" target="_blank" rel="noopener">Google’s Maven Repository</a></li><li>查看依赖树：在项目根目录下执行<code>./gradlew :app:dependencies</code></li></ul><p><strong>可直接跳过后续内容前往最后一节查看总结</strong></p><p>关于 <code>androidx</code>下 <code>fragment/activity</code>的变化，可查看该文, <a href="https://juejin.im/post/5e5a0c316fb9a07cd248d29e" target="_blank" rel="noopener">【译】AdroidX下使用Activity和Fragment的变化</a></p><h3 id="Appcompat"><a href="#Appcompat" class="headerlink" title="Appcompat"></a>Appcompat</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-keyword">def</span> appcompat_version = <span class="hljs-string">"1.1.0"</span><br><br>    implementation <span class="hljs-string">"androidx.appcompat:appcompat:$appcompat_version"</span><br>    <span class="hljs-comment">// For loading and tinting drawables on older versions of the platform</span><br>    implementation <span class="hljs-string">"androidx.appcompat:appcompat-resources:$appcompat_version"</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="依赖树"><a href="#依赖树" class="headerlink" title="依赖树"></a>依赖树</h4><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200507093256.png" src="/2020/03/01/Jetpack-dependencies/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h4 id="传递依赖"><a href="#传递依赖" class="headerlink" title="传递依赖"></a>传递依赖</h4><p><code>androidx.annotation:annotation:1.1.0</code></p><p><code>androidx.core:core:1.1.0</code></p><p><code>androidx.cursoradapter:cursoradapter:1.0.0</code></p><p><code>androidx.fragment:fragment:1.1.0</code></p><p><code>androidx.appcompat:appcompat-resources:1.1.0</code></p><p><code>androidx.drawerlayout:drawerlayout:1.0.0</code></p><p><code>androidx.collection:collection:1.0.0</code></p><blockquote><p><strong><code>appcompat</code> 中默认引入了 <code>fragment</code> 库，如果想使用更新版本的 <code>fragment</code> 库，可以单独引用</strong></p></blockquote><blockquote><p><a href="https://android.googlesource.com/platform/frameworks/support/+/b0b973c9bc89f9ad3efe3c06e41b72957f032a99/appcompat/build.gradle" target="_blank" rel="noopener">appcompat build.gradle 源码地址</a></p></blockquote><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><h4 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-keyword">def</span> fragment_version = <span class="hljs-string">"1.2.2"</span><br><br>    <span class="hljs-comment">// Java language implementation</span><br>    implementation <span class="hljs-string">"androidx.fragment:fragment:$fragment_version"</span><br>    <span class="hljs-comment">// Kotlin</span><br>    implementation <span class="hljs-string">"androidx.fragment:fragment-ktx:$fragment_version"</span><br>    <span class="hljs-comment">// Testing Fragments in Isolation</span><br>    implementation <span class="hljs-string">"androidx.fragment:fragment-testing:$fragment_version"</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>⚠️ Note: The Kotlin dependant libraries of this version (fragment-ktx,fragment-testing) target Java 8 programming language bytecode. <a href="https://developer.android.com/studio/write/java8-support" target="_blank" rel="noopener">Please read Use Java 8 language features to learn how to use it in your project.</a></p></blockquote><h4 id="依赖树-1"><a href="#依赖树-1" class="headerlink" title="依赖树"></a>依赖树</h4><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200507093455.png" src="/2020/03/01/Jetpack-dependencies/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h4 id="传递依赖-1"><a href="#传递依赖-1" class="headerlink" title="传递依赖"></a>传递依赖</h4><p><code>org.jetbrains.kotlin:kotlin-stdlib:1.3.50</code></p><p><code>androidx.activity:activity-ktx:1.1.0</code></p><p><code>androidx.core:core-ktx:1.1.0</code></p><p><code>androidx.collection:collection-ktx:1.1.0</code></p><p><code>androidx.lifecycle:lifecycle-livedata-core-ktx:2.2.0</code></p><p><code>androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0</code></p><blockquote><p><strong><code>fragment</code> 库默认引入了 <code>activity</code> <code>core-ktx</code> <code>lifecycle-livedata-core-ktx</code> <code>lifecycle-viewmodel-ktx</code> 库</strong>  </p><p><a href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/fragment/fragment-ktx/build.gradle" target="_blank" rel="noopener">fragment build.grdle 源码地址</a></p></blockquote><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><h4 id="引入-2"><a href="#引入-2" class="headerlink" title="引入"></a>引入</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-keyword">def</span> activity_version = <span class="hljs-string">"1.1.0"</span><br><br>    <span class="hljs-comment">// Java language implementation</span><br>    implementation <span class="hljs-string">"androidx.activity:activity:$activity_version"</span><br>    <span class="hljs-comment">// Kotlin</span><br>    implementation <span class="hljs-string">"androidx.activity:activity-ktx:$activity_version"</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>⚠️ Note: The Kotlin dependant libraries of this version (activity-ktx) target Java 8 programming language bytecode. <a href="https://developer.android.com/studio/write/java8-support" target="_blank" rel="noopener">Please read Use Java 8 language features to learn how to use it in your project.</a></p></blockquote><h4 id="依赖树-2"><a href="#依赖树-2" class="headerlink" title="依赖树"></a>依赖树</h4><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200507093743.png" src="/2020/03/01/Jetpack-dependencies/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h4 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h4><p><code>org.jetbrains.kotlin:kotlin-stdlib:1.3.50</code></p><p><code>androidx.core:core-ktx:1.1.0</code></p><p><code>androidx.lifecycle:lifecycle-runtime-ktx:2.2.0</code></p><p><code>androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0</code></p><blockquote><p><a href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/activity/activity-ktx/build.gradle" target="_blank" rel="noopener">activity build.gradle 源码地址</a></p></blockquote><h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><h4 id="引入-3"><a href="#引入-3" class="headerlink" title="引入"></a>引入</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-keyword">def</span> core_version = <span class="hljs-string">"1.2.0"</span><br><br>    <span class="hljs-comment">// Java language implementation</span><br>    implementation <span class="hljs-string">"androidx.core:core:$core_version"</span><br>    <span class="hljs-comment">// Kotlin</span><br>    implementation <span class="hljs-string">"androidx.core:core-ktx:$core_version"</span><br><br>    <span class="hljs-comment">// To use RoleManagerCompat</span><br>    implementation <span class="hljs-string">"androidx.core:core-role:1.0.0-alpha01"</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="依赖树-3"><a href="#依赖树-3" class="headerlink" title="依赖树"></a>依赖树</h4><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200507093859.png" src="/2020/03/01/Jetpack-dependencies/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><h4 id="引入-4"><a href="#引入-4" class="headerlink" title="引入"></a>引入</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-keyword">def</span> lifecycle_version = <span class="hljs-string">"2.2.0"</span><br>    <span class="hljs-keyword">def</span> arch_version = <span class="hljs-string">"2.1.0"</span><br><br>    <span class="hljs-comment">// ViewModel</span><br>    implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"</span><br>    <span class="hljs-comment">// LiveData</span><br>    implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version"</span><br>    <span class="hljs-comment">// Lifecycles only (without ViewModel or LiveData)</span><br>    implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version"</span><br><br>    <span class="hljs-comment">// Saved state module for ViewModel</span><br>    implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version"</span><br><br>    <span class="hljs-comment">// Annotation processor</span><br>    kapt <span class="hljs-string">"androidx.lifecycle:lifecycle-compiler:$lifecycle_version"</span><br>    <span class="hljs-comment">// alternately - if using Java8, use the following instead of lifecycle-compiler</span><br>    implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-common-java8:$lifecycle_version"</span><br><br>    <span class="hljs-comment">// optional - helpers for implementing LifecycleOwner in a Service</span><br>    implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-service:$lifecycle_version"</span><br><br>    <span class="hljs-comment">// optional - ProcessLifecycleOwner provides a lifecycle for the whole application process</span><br>    implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-process:$lifecycle_version"</span><br><br>    <span class="hljs-comment">// optional - ReactiveStreams support for LiveData</span><br>    implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-reactivestreams-ktx:$lifecycle_version"</span><br><br>    <span class="hljs-comment">// optional - Test helpers for LiveData</span><br>    testImplementation <span class="hljs-string">"androidx.arch.core:core-testing:$arch_version"</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>⚠️ <strong><code>lifecycle-extensions</code> 已废弃，如果使用 <code>LifecycleService</code> 请依赖 <code>lifecycle-service</code>；如果使用 <code>ProcessLifecycleOwner</code> 请依赖 <code>lifecycle-process</code>。<code>lifecycle-extensionsl</code>不会有2.3.0版本</strong></li><li><strong>2.1.0 后 <code>ViewModelProviders.of()</code> 被废弃。您可以在 <code>FragmentActivity</code> 或者 <code>Fragment</code> 使用 <code>ViewModelProvider(ViewModelStoreOwner)</code> 构造器来实现相同的功能。（<code>Fragment</code> 库 1.2.0以上）</strong></li></ul></blockquote><h4 id="依赖树-4"><a href="#依赖树-4" class="headerlink" title="依赖树"></a>依赖树</h4><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200507094042.png" src="/2020/03/01/Jetpack-dependencies/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="livedata"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200507094223.png" src="/2020/03/01/Jetpack-dependencies/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="viewmodel"></p><h3 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h3><h4 id="引入-5"><a href="#引入-5" class="headerlink" title="引入"></a>引入</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  <span class="hljs-keyword">def</span> nav_version = <span class="hljs-string">"2.3.0-alpha02"</span><br><br>  <span class="hljs-comment">// Java language implementation</span><br>  implementation <span class="hljs-string">"androidx.navigation:navigation-fragment:$nav_version"</span><br>  implementation <span class="hljs-string">"androidx.navigation:navigation-ui:$nav_version"</span><br><br>  <span class="hljs-comment">// Kotlin</span><br>  implementation <span class="hljs-string">"androidx.navigation:navigation-fragment-ktx:$nav_version"</span><br>  implementation <span class="hljs-string">"androidx.navigation:navigation-ui-ktx:$nav_version"</span><br><br>  <span class="hljs-comment">// Dynamic Feature Module Support</span><br>  implementation <span class="hljs-string">"androidx.navigation:navigation-dynamic-features-fragment:$nav_version"</span><br><br>  <span class="hljs-comment">// Testing Navigation</span><br>  androidTestImplementation <span class="hljs-string">"androidx.navigation:navigation-testing:$nav_version"</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="依赖树-5"><a href="#依赖树-5" class="headerlink" title="依赖树"></a>依赖树</h4><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200507094643.png" src="/2020/03/01/Jetpack-dependencies/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="navigation"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200507094711.png" src="/2020/03/01/Jetpack-dependencies/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="navigation-ui"></p><h3 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h3><h4 id="引入-6"><a href="#引入-6" class="headerlink" title="引入"></a>引入</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  <span class="hljs-keyword">def</span> paging_version = <span class="hljs-string">"2.1.1"</span><br><br>  implementation <span class="hljs-string">"androidx.paging:paging-runtime:$paging_version"</span> <span class="hljs-comment">// For Kotlin use paging-runtime-ktx</span><br><br>  <span class="hljs-comment">// alternatively - without Android dependencies for testing</span><br>  testImplementation <span class="hljs-string">"androidx.paging:paging-common:$paging_version"</span> <span class="hljs-comment">// For Kotlin use paging-common-ktx</span><br><br>  <span class="hljs-comment">// optional - RxJava support</span><br>  implementation <span class="hljs-string">"androidx.paging:paging-rxjava2:$paging_version"</span> <span class="hljs-comment">// For Kotlin use paging-rxjava2-ktx</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="依赖树-6"><a href="#依赖树-6" class="headerlink" title="依赖树"></a>依赖树</h4><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200507094857.png" src="/2020/03/01/Jetpack-dependencies/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="paging"></p><h3 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h3><h4 id="引入-7"><a href="#引入-7" class="headerlink" title="引入"></a>引入</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  <span class="hljs-keyword">def</span> room_version = <span class="hljs-string">"2.2.4"</span><br><br>  implementation <span class="hljs-string">"androidx.room:room-runtime:$room_version"</span><br>  annotationProcessor <span class="hljs-string">"androidx.room:room-compiler:$room_version"</span> <span class="hljs-comment">// For Kotlin use kapt instead of annotationProcessor</span><br><br>  <span class="hljs-comment">// optional - Kotlin Extensions and Coroutines support for Room</span><br>  implementation <span class="hljs-string">"androidx.room:room-ktx:$room_version"</span><br><br>  <span class="hljs-comment">// optional - RxJava support for Room</span><br>  implementation <span class="hljs-string">"androidx.room:room-rxjava2:$room_version"</span><br><br>  <span class="hljs-comment">// optional - Guava support for Room, including Optional and ListenableFuture</span><br>  implementation <span class="hljs-string">"androidx.room:room-guava:$room_version"</span><br><br>  <span class="hljs-comment">// Test helpers</span><br>  testImplementation <span class="hljs-string">"androidx.room:room-testing:$room_version"</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>⚠️ Note: For Kotlin-based apps, make sure you use kapt instead of annotationProcessor. You should also add the kotlin-kapt plugin.</p></blockquote><h4 id="依赖树-7"><a href="#依赖树-7" class="headerlink" title="依赖树"></a>依赖树</h4><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200507094945.png" src="/2020/03/01/Jetpack-dependencies/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="room"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h4><blockquote><p><code>androidx</code>库遵循严格的语义版本控制。版本字符串（例如 1.0.1-beta02）包含三个数字，分别代表 major 级别、minor 级别和问题修复级别。预发布版本也有一个后缀，用于指定预发布阶段（Alpha 版、Beta 版、候选版本）和版本号（01、02 等）。</p></blockquote><p>库的每个版本都要经历三个预发布阶段，才能成为稳定版本。各预发布阶段的标准如下：</p><p><strong>Alpha 版</strong></p><ul><li>Alpha 版功能稳定，但功能可能不完整。</li><li>在版本处于 Alpha 版状态时，可以添加、移除或更改 API。</li></ul><p><strong>Beta 版</strong></p><ul><li>Beta 版功能稳定，并且具有功能完整的 API Surface。<br>它们可以投入实际使用，但可能包含错误。</li><li>Beta 版无法使用实验性编译器功能（例如 @UseExperimental）。</li><li>其他库的依赖项必须为 Beta 版、RC 版或稳定版。不允许使用 Alpha 版依赖项。</li></ul><p><strong>候选版本 (RC)</strong></p><ul><li>候选版本是未来的稳定版。</li><li>此版本可能包含在最后一刻提供的重要修复。</li><li>此版本的 API Surface 无法更改。</li><li>其他库的依赖项只能是 RC 版或稳定版。</li></ul><p>一个库可以同时具有多个版本。每个版本都具有不同的发布阶段。例如，虽然 androidx.activity 的稳定版可以是 1.0.0，但也可能还有 1.1.0-beta02 版本以及 2.0.0-alpha01 版本。</p><h4 id="kotlin-协程的使用"><a href="#kotlin-协程的使用" class="headerlink" title="kotlin 协程的使用"></a>kotlin 协程的使用</h4><blockquote><p><code>ViewModel</code> <code>LiveData</code> <code>Activity</code> <code>Fragment</code> <code>Service</code>等均可使用协程</p></blockquote><ul><li>对于 <code>ViewModelScope</code>，请使用 <code>androidx.lifecycle:lifecycle-viewmodel-ktx:2.1.0-beta01</code> 或更高版本。</li><li>对于 <code>LifecycleScope</code>，请使用 <code>androidx.lifecycle:lifecycle-runtime-ktx:2.2.0-alpha01</code> 或更高版本。</li><li>对于 <code>liveData</code>，请使用 <code>androidx.lifecycle:lifecycle-livedata-ktx:2.2.0-alpha01</code> 或更高版本。 </li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyViewModel</span>: <span class="hljs-type">ViewModel</span></span>() &#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        viewModelScope.launch &#123;<br>            <span class="hljs-comment">// Coroutine that will be canceled when the ViewModel is cleared.</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)<br>        viewLifecycleOwner.lifecycleScope.launch &#123;<br>            <span class="hljs-keyword">val</span> params = TextViewCompat.getTextMetricsParams(textView)<br>            <span class="hljs-keyword">val</span> precomputedText = withContext(Dispatchers.Default) &#123;<br>                PrecomputedTextCompat.create(longTextContent, params)<br>            &#125;<br>            TextViewCompat.setPrecomputedText(textView, precomputedText)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> user: LiveData&lt;User&gt; = liveData &#123;<br>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = database.loadUser() <span class="hljs-comment">// loadUser is a suspend function.</span><br>    emit(<span class="hljs-keyword">data</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><ul><li><p>带有<code>-ktx</code>的库拥有 <code>kotlin</code> 的特性，有很多常用的扩展函数</p></li><li><p>带有<code>-ktx</code>的库依赖 java 版本， 带有<code>-ktx</code>和 java 版本各自单独使用即可</p></li><li><p><code>appcompat</code> 库包含 <code>fragmnet</code>,<code>fragment</code> 包含 <code>activity</code> ，当你引入<code>androidx</code> <code>appcompat</code> 库便可以使用<code>androidx</code> <code>fragment</code> 和 <code>androidx</code> <code>activity</code></p></li><li><p>受限于<code>appcompat</code> 稳定版的更新速度，您可以选择单独使用<code>androidx</code> <code>fragment</code>/<code>activity</code></p></li><li><p><code>AppCompatActivity</code> 继承自 <code>FragmentActivity</code>， <code>AppCompatActivity</code>可以直接使用 <code>fragment</code></p></li><li><p><code>DataBinding</code> <code>ViewBinding</code> 依赖于 <code>android build gradle</code> 插件 ,无需引入其他依赖</p></li><li><p><code>androidx</code> <code>fragment</code>/<code>activity</code>下均依赖的<code>ViewModel</code>和 <code>LiveData</code>，您可以直接使用</p></li><li><p>使用<code>ViewModel</code>和 <code>LiveData</code>完整功能需要单独引入，它们都是<code>lifecycle</code>大家族下的</p></li><li><p><code>lifecycle-extensions</code> 已废弃，不要使用它了</p></li><li><p>如果想使用实现<code>LifecycleOwner</code> 的 <code>Service</code> ，需要引入 <code>lifecycle-service</code></p></li></ul><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/03/01/Jetpack-dependencies/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【背上Jetpack】AdroidX下使用Activity和Fragment的变化</title>
      <link href="/2020/02/29/Jetpack-androidx-activity-fragment/"/>
      <url>/2020/02/29/Jetpack-androidx-activity-fragment/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://medium.com/@miloszlewandowski/how-androidx-changes-the-way-we-work-with-activities-and-fragments-73b88d157678" target="_blank" rel="noopener">How AndroidX changes the way we work with Activities and Fragments</a></p><p>作者：<a href="https://medium.com/@miloszlewandowski" target="_blank" rel="noopener">Miłosz Lewandowski</a></p><p>译者：<a href="http://www.yangyunzhao.com/" target="_blank" rel="noopener">Fly_with24</a></p></blockquote><p>过去的一段时间，<code>AndroidX</code> 软件包下的 <code>Activity/Fragmet</code> 的 API 发生了很多变化。让我们看看它们是如何提升Android 的开发效率以及如何适应当下流行的编程规则和模式。</p><p>本文中描述的所有功能现在都可以在稳定的 <code>AndroidX</code> 软件包中使用，它们在去年均已发布或移至稳定版本。</p><a id="more"></a><h3 id="在构造器中传入布局-ID"><a href="#在构造器中传入布局-ID" class="headerlink" title="在构造器中传入布局 ID"></a>在构造器中传入布局 ID</h3><p>从 <code>AndroidX</code>  <code>AppCompat 1.1.0</code> 和 <code>Fragment 1.1.0</code> ( 译者注：AppCompat 包含 Fragment，且 Fragment 包含 Activity，详情见<a href="https://juejin.im/post/5e567ee1518825494466a938" target="_blank" rel="noopener">【整理】Jetpack 主要组件的依赖及传递关系</a> )开始，您可以使用将 <code>layoutId</code> 作为参数的构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>(R.layout.my_activity)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragmentActivity</span>: <span class="hljs-type">FragmentActivity</span></span>(R.layout.my_fragment_activity)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragment</span> : <span class="hljs-type">Fragment</span></span>(R.layout.my_fragment)<br></code></pre></td></tr></table></figure><p>这种方法可以减少 <code>Activity/Fragment</code> 中方法重写的数量，并使类更具可读性。 无需在 <code>Activity</code> 中重写 <code>onCreate()</code> 即可调用 <code>setContentView()</code> 方法。 另外，无需手动在<code>Fragment</code> 中重写 <code>onCreateView</code> 即可手动调用 <code>Inflater</code> 来扩展视图。</p><h3 id="扩展-Activity-Fragment-的灵活性"><a href="#扩展-Activity-Fragment-的灵活性" class="headerlink" title="扩展 Activity/Fragment 的灵活性"></a>扩展 <code>Activity/Fragment</code> 的灵活性</h3><p>借助 <code>AndroidX</code> 新的 API ，可以减少在 <code>Activity/Fragment</code> 处理某些功能的情况。通常，您可以获取提供某些功能的对象并向其注册您的处理逻辑，而不是重写 <code>Activity / Fragment</code> 中的方法。 这样，您现在可以在屏幕上组成几个独立的类，获得更高的灵活性，复用代码，并且通常在不引入自己的抽象的情况下，对代码结构具有更多控制。 让我们看看这在两个示例中如何工作。</p><h4 id="1-OnBackPressedDispatcher"><a href="#1-OnBackPressedDispatcher" class="headerlink" title="1. OnBackPressedDispatcher"></a>1. OnBackPressedDispatcher</h4><p>有时，您需要阻止用户返回上一级。 在这种情况下，您需要在 <code>Activity</code> 中重写 <code>onBackPressed()</code> 方法。 但是，当您使用 <code>Fragment</code> 时，没有直接的方法来拦截返回。 在 <code>Fragment</code> 类中没有可用的 <code>onBackPressed()</code> 方法，这是为了防止同时存在多个 <code>Fragment</code> 时发生意外行为。</p><p>但是，从 <code>AndroidX</code> <code>Activity 1.0.0</code> 开始，您可以使用 <code>OnBackPressedDispatcher</code> 在您可以访问该 <code>Activity</code> 的代码的任何位置（例如，在 <code>Fragment</code> 中）注册 <code>OnBackPressedCallback</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttach</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onAttach(context)<br>    <span class="hljs-keyword">val</span> callback = <span class="hljs-keyword">object</span> : OnBackPressedCallback(<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleOnBackPressed</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// Do something</span><br>      &#125;<br>    &#125;<br>    requireActivity().onBackPressedDispatcher.addCallback(<span class="hljs-keyword">this</span>, callback)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>您可能会在这里注意到另外两个有用的功能：</p><ul><li><code>OnBackPressedCallback</code> 的构造函数中的布尔类型的参数有助于根据当前状态动态 打开/关闭按下的行为</li><li><code>addCallback()</code> 方法的可选第一个参数是 <code>LifecycleOwner</code>，以确保仅在您的生命周期感知对象（例如，<code>Fragment</code>）至少处于 <code>STARTED</code> 状态时才使用回调。</li></ul><p>通过使用 <code>OnBackPressedDispatcher</code> ，您不仅可以获得在 <code>Activity</code> 之外处理返回键的便捷方式。 根据您的需要，您可以在任意位置定义 <code>OnBackPressedCallback</code>，使其可复用，或根据应用程序的架构进行任何操作。 您不再需要重写<code>Activity</code> 中的 <code>onBackPressed</code> 方法，也不必提供自己的抽象的来实现需求的代码。</p><h4 id="2-SavedStateRegistry"><a href="#2-SavedStateRegistry" class="headerlink" title="2. SavedStateRegistry"></a>2. SavedStateRegistry</h4><p>如果您希望 <code>Activity</code> 在终止并重启后恢复之前的状态，则可能要使用 <code>saved state</code> 功能。 过去，您需要在 <code>Activity</code> 中重写两个方法：<code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code>。 您还可以在 <code>onCreate</code> 方法中访问恢复的状态。 同样，在 <code>Fragment</code> 中，您可以使用<code>onSaveInstanceState</code> 方法（并且可以在 <code>onCreate</code>，<code>onCreateView</code> 和<code>onActivityCreated</code>方法中恢复状态）。</p><p>从 <code>AndroidX</code>  <code>SavedState 1.0.0</code>（它是 <code>AndroidX</code> <code>Activity</code> 和 <code>AndroidX</code>  <code>Fragment</code> 内部的依赖。译者注：您不需要单独声明它）开始，您可以访问 <code>SavedStateRegistry</code>，它使用了与前面描述的 <code>OnBackPressedDispatcher</code> 类似的机制：您可以从 <code>Activity / Fragment</code> 中获取 <code>SavedStateRegistry</code>，然后 注册您的 <code>SavedStateProvider</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MY_SAVED_STATE_KEY = <span class="hljs-string">"my_saved_state"</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SOME_VALUE_KEY = <span class="hljs-string">"some_value"</span><br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> someValue: String<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> savedStateProvider = SavedStateRegistry.SavedStateProvider &#123;    <br>    Bundle().apply &#123;<br>      putString(SOME_VALUE_KEY, someValue)<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;    <br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    savedStateRegistry<br>      .registerSavedStateProvider(MY_SAVED_STATE_KEY, savedStateProvider)<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span></span> &#123;<br>    someValue = savedStateRegistry<br>      .consumeRestoredStateForKey(MY_SAVED_STATE_KEY)<br>      ?.getString(SOME_VALUE_KEY)<br>      ?: <span class="hljs-string">""</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如您所见，<code>SavedStateRegistry</code> 强制您将密钥用于数据。 这样可以防止您的数据被 attach 到同一个 <code>Activity/Fragment</code>的另一个 <code>SavedStateProvider</code> 破坏。 就像在 <code>OnBackPressedDispatcher</code> 中一样，您可以例如将 <code>SavedStateProvider</code> 提取到另一个类，通过使用所需的任何逻辑使其与数据一起使用，从而在应用程序中实现清晰的保存状态行为。</p><p>此外，如果您在应用程序中使用 <code>ViewModel</code>，请考虑使用 <code>AndroidX</code>  <code>ViewModel-SavedState</code> 使你的<code>ViewModel</code> 可以保存其状态。 为了方便起见，从 <code>AndroidX</code>  <code>Activity 1.1.0</code> 和 <code>AndroidX</code> <code>Fragment 1.2.0</code> 开始，启用 <code>SavedState</code> 的<code>SavedStateViewModelFactory</code> 是在获取 <code>ViewModel</code> 的所有方式中使用的默认工厂：委托 <code>ViewModelProvider</code> 构造函数和 <code>ViewModelProviders.of()</code> 方法。</p><h3 id="FragmentFactory"><a href="#FragmentFactory" class="headerlink" title="FragmentFactory"></a>FragmentFactory</h3><p><code>Fragment</code> 最常提及的问题之一是不能使用带有参数的构造函数。 例如，如果您使用 <code>Dagger2</code> 进行依赖项注入，则无法使用 <code>Inject</code> 注解 <code>Fragment</code> 构造函数并指定参数。 现在，您可以通过指定 <code>FragmentFactory</code> 类来减少 <code>Fragment</code> 创建过程中的类似问题。 通过在 <code>FragmentManager</code> 中注册 <code>FragmentFactory</code>，可以重写实例化 <code>Fragment</code> 的默认方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragmentFactory</span> : <span class="hljs-type">FragmentFactory</span></span>() &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">instantiate</span><span class="hljs-params">(classLoader: <span class="hljs-type">ClassLoader</span>, className: <span class="hljs-type">String</span>)</span></span>: Fragment &#123;<br>    <span class="hljs-comment">// Call loadFragmentClass() to obtain the Class object</span><br>    <span class="hljs-keyword">val</span> fragmentClass = loadFragmentClass(classLoader, className)<br>     <br>    <span class="hljs-comment">// Now you can use className/fragmentClass to determine your prefered way </span><br>    <span class="hljs-comment">// of instantiating the Fragment object and just do it here.</span><br>        <br>    <span class="hljs-comment">// Or just call regular FragmentFactory to instantiate the Fragment using</span><br>    <span class="hljs-comment">// no arguments constructor</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.instantiate(classLoader, className)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如您所见，该API非常通用，因此您可以执行想要创建 <code>Fragment</code> 实例的所有操作。 回到 <code>Dagger2</code> 示例，例如，您可以注入<code>FragmentFactory Provider &lt;Fragment&gt;</code> 并使用它来获取 <code>Fragment</code> 对象。</p><h3 id="测试-Fragment"><a href="#测试-Fragment" class="headerlink" title="测试 Fragment"></a>测试 Fragment</h3><p>从<code>AndroidX</code>  <code>Fragment 1.1.0</code> 开始，可以使用 <code>Fragment</code> 测试组件提供 <code>FragmentScenario</code> 类，该类可以帮助在测试中实例化 <code>Fragment</code> 并进行单独测试：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// To launch a Fragment with a user interface:</span><br><span class="hljs-keyword">val</span> scenario = launchFragmentInContainer&lt;FirstFragment&gt;()<br>        <br><span class="hljs-comment">// To launch a headless Fragment:</span><br><span class="hljs-keyword">val</span> scenario = launchFragment&lt;FirstFragment&gt;()<br>        <br><span class="hljs-comment">// To move the fragment to specific lifecycle state:</span><br>scenario.moveToState(CREATED)<br><br><span class="hljs-comment">// Now you can e.g. perform actions using Espresso:</span><br>onView(withId(R.id.refresh)).perform(click())<br><br><span class="hljs-comment">// To obtain a Fragment instance:</span><br>scenario.onFragment &#123; fragment -&gt;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="More-Kotlin"><a href="#More-Kotlin" class="headerlink" title="More Kotlin!"></a>More Kotlin!</h3><p>很高兴看到 <code>-ktx</code> <code>AndroidX</code> 软件包中提供了许多有用的 <code>Kotlin</code> 扩展方法，并且定期添加了新的方法。 例如，在<code>AndroidX</code> <code>Fragment-KTX 1.2.0</code> 中，使用片段化类型的扩展名可用于 <code>FragmentTransaction</code> 上的 <code>replace()</code> 方法。 将其与 <code>commit()</code> 扩展方法结合使用，我们可以获得以下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Before</span><br>supportFragmentManager<br>  .beginTransaction()<br>  .add(R.id.container, MyFragment::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>, <span class="hljs-type">null)</span></span><br>  .commit()<br><br><span class="hljs-comment">// After</span><br>supportFragmentManager.commit &#123;<br>  replace&lt;MyFragment&gt;(R.id.container)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FragmentContainerView"><a href="#FragmentContainerView" class="headerlink" title="FragmentContainerView"></a>FragmentContainerView</h3><p>一件小而重要的事情。 如果您将 <code>FrameLayout</code> 用作 <code>Fragment</code> 的容器，则应改用 <code>FragmentContainerView</code> 。 它修复了一些动画 z轴索引顺序问题和窗口插入调度。 从 <code>AndroidX</code> <code>Fragment 1.2.0</code> 开始可以使用 <code>FragmentContainerView</code>。</p><hr><h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jetpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> androidx </tag>
            
            <tag> Jetpack </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【重学Android读书笔记】Activity的任务栈与返回栈</title>
      <link href="/2019/11/29/relearn-task-back-stack/"/>
      <url>/2019/11/29/relearn-task-back-stack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>订阅 <a href="https://xiaozhuanlan.com/topic/9074561823" target="_blank" rel="noopener">重学安卓</a> 很久了，最近在整理读书笔记，在此记录之。</p><p>在此隆重推荐这位大佬 KunMinX</p><p>本文记录Activity任务栈与返回栈相关内容的疑问与探索</p></blockquote><a id="more"></a><p>该专栏的代码地址： <a href="https://github.com/KunMinX/Relearn-Android" target="_blank" rel="noopener">https://github.com/KunMinX/Relearn-Android</a> </p><h4 id="疑惑产生"><a href="#疑惑产生" class="headerlink" title="疑惑产生"></a>疑惑产生</h4><p>根据大佬的代码以及文章描述，有个地方让我很疑惑。</p><p><img class="lazyload" data-original="%E3%80%90%E9%87%8D%E5%AD%A6Android%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Activity%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88/%E9%97%AE%E9%A2%98.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="问题"></p><p>我这里没有过滤当前使用的app，所以app1和app2产生的日志都显示了出来。</p><p>大佬在评论区关于此的回答</p><blockquote><p><a href="https://xiaozhuanlan.com/u/kunminx" target="_blank" rel="noopener">KunMinX</a></p><p>#40</p><p><a href="https://xiaozhuanlan.com/topic/7812045693#reply2" target="_blank" rel="noopener">#2楼</a> <a href="https://xiaozhuanlan.com/u/2711412979" target="_blank" rel="noopener"><em>@</em>Sky63</a><br>大概明白你提到的、造成困扰的地方了。<br>D 和 C 是由 app1 启动，在 IDE 中可通过 app1 的视角观察到。同理，当 app2 的 B 唤起 D 时，你在回退 D 的时候能在 app2 和 app1 的视角中同时观察到 D 的销毁。而紧随其后再回退一次， 便能在 app1 中观察到 C 被销毁。再下一次才轮到 app2 中 B 被销毁。</p></blockquote><p>但是根据我操作看到的现象，D的销毁不是在不同app视角观察到的同一次销毁。通过上图可以看出两次销毁是有时间差的，而且经过我的二次确认，的确是关闭两次界面才出现了两次销毁Log。</p><h4 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h4><p>通过 <code>adb shell</code> 中的 <code>dumpsys activity activities</code> 命令可以查看 activity 栈信息，故我截取了相关的输出，以下堆栈信息均经过精简。</p><h5 id="1-app1-依次打开-SingleTaskOne-SingleTaskTwo"><a href="#1-app1-依次打开-SingleTaskOne-SingleTaskTwo" class="headerlink" title="1. app1 依次打开 SingleTaskOne SingleTaskTwo"></a>1. <code>app1</code> 依次打开 <code>SingleTaskOne</code> <code>SingleTaskTwo</code></h5><p><img class="lazyload" data-original="%E3%80%90%E9%87%8D%E5%AD%A6Android%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Activity%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88/log1.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="log1"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs json">➜  Relearn-Android (master) adb shell<br>sagit:/ $ dumpsys activity activities<br>ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)<br>Display #0 (activities from top to bottom):<br><br>  Stack #2: type=standard mode=fullscreen<br>    Task id #3<br><br>    Running activities (most recent first):<br>      TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125;<br>        Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;<br>        Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125;<br><br>    mResumedActivity: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;<br>    mLastPausedActivity: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125;<br><br>  Stack #1: type=standard mode=fullscreen<br>    Task id #2<br><br>    Running activities (most recent first):<br>      TaskRecord&#123;d91b3e8 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125;<br>        Run #1: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;<br>        Run #0: ActivityRecord&#123;d76e9a5 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;<br><br>  Stack #0: type=home mode=fullscreen<br><br>    Task id #1<br><br>    Running activities (most recent first):<br>      TaskRecord&#123;94a7a01 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125;<br>        Run #0: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125;<br><br>  ResumedActivity:ActivityRecord&#123;<br>93c0c72u0com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;<br>  <br>  mFocusedStack=ActivityStack&#123;<br>  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks<br>  &#125; <br>  mLastFocusedStack=ActivityStack&#123;<br>  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks<br>  &#125;<br>  mCurTaskIdForUser=&#123;0=3&#125;<br>  mUserStackInFront=&#123;&#125;<br>  displayId=0 stacks=3<br>   mHomeStack=ActivityStack&#123;<br>   76ebae7 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks<br>   &#125;<br>  isHomeRecentsComponent=false  KeyguardController:<br>    mKeyguardShowing=false<br>    mAodShowing=false<br>    mKeyguardGoingAway=false<br>    mOccluded=false<br>    mDismissingKeyguardActivity=null<br>    mDismissalRequested=false<br>    mVisibilityTransactionDepth=0<br>  LockTaskController<br>    mLockTaskModeState=NONE<br>    mLockTaskModeTasks=<br>    mLockTaskPackages (userId:packages)=<br>      u0:[]<br></code></pre></td></tr></table></figure><p>此时看到堆栈顺序为：<strong>Stack #2 -&lt; Stack #1 -&lt; Stack #0</strong> 其中 <code>Stack #0</code> 为 <code>launcher</code></p><p>获取焦点的 <code>ActivityStack</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">mFocusedStack=ActivityStack&#123;<br>  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; <br>mLastFocusedStack=ActivityStack&#123;<br>  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;<br></code></pre></td></tr></table></figure><h5 id="2-按下HOME键，打开-app2-依次打开-StandardOneActivity-StandardTwoActivity"><a href="#2-按下HOME键，打开-app2-依次打开-StandardOneActivity-StandardTwoActivity" class="headerlink" title="2. 按下HOME键，打开 app2 依次打开 StandardOneActivity StandardTwoActivity"></a>2. 按下HOME键，打开 <code>app2</code> 依次打开 <code>StandardOneActivity</code> <code>StandardTwoActivity</code></h5><p><img class="lazyload" data-original="%E3%80%90%E9%87%8D%E5%AD%A6Android%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Activity%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88/log2.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="log2"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs json">Display #0 (activities from top to bottom):<br><br>  Stack #3: type=standard mode=fullscreen<br>    Task id #4<br><br>    Running activities (most recent first):<br>      TaskRecord&#123;718157f #4 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125;<br>        Run #3: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125;<br>        Run #2: ActivityRecord&#123;648188e u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125;<br>        Run #1: ActivityRecord&#123;f39ebe9 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125;<br>        Run #0: ActivityRecord&#123;f02fff8 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t4&#125;<br><br>    mResumedActivity: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125;<br>    mLastPausedActivity: ActivityRecord&#123;648188e u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125;<br><br>  Stack #0: type=home mode=fullscreen<br>    Task id #1<br><br>    Running activities (most recent first):<br>      TaskRecord&#123;2094d95 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125;<br>        Run #0: ActivityRecord&#123;a7fed1a u0 com.miui.home/.launcher.Launcher t1&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;a7fed1a u0 com.miui.home/.launcher.Launcher t1&#125;<br><br>  Stack #2: type=standard mode=fullscreen<br>    Task id #3<br>    <br>    Running activities (most recent first):<br>      TaskRecord&#123;9d79eaa #3 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125;<br>        Run #1: ActivityRecord&#123;15d3e09 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;<br>        Run #0: ActivityRecord&#123;20d177c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;15d3e09 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;<br><br>  Stack #1: type=standard mode=fullscreen<br>  isSleeping=false<br>  mBounds=Rect(0, 0 - 0, 0)<br><br>    Task id #2<br><br>    Running activities (most recent first):<br>      TaskRecord&#123;e526e38 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125;<br>        Run #1: ActivityRecord&#123;19055b2 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;<br>        Run #0: ActivityRecord&#123;5a647a6 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;19055b2 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;<br><br>  ResumedActivity: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125;<br><br>  mFocusedStack=ActivityStack&#123;<br>      dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; <br>mLastFocusedStack=ActivityStack&#123;<br>    dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;<br>  mCurTaskIdForUser=&#123;0=4&#125;<br>  mUserStackInFront=&#123;&#125;<br>  displayId=0 stacks=4<br>   mHomeStack=ActivityStack&#123;968fb76 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125;<br>  isHomeRecentsComponent=false  KeyguardController:<br>    mKeyguardShowing=false<br>    mAodShowing=false<br>    mKeyguardGoingAway=false<br>    mOccluded=false<br>    mDismissingKeyguardActivity=null<br>    mDismissalRequested=false<br>    mVisibilityTransactionDepth=0<br>  LockTaskController<br>    mLockTaskModeState=NONE<br>    mLockTaskModeTasks=<br>    mLockTaskPackages (userId:packages)=<br>      u0:[]<br></code></pre></td></tr></table></figure><p><strong>这里的堆栈顺序为 Stack #3 -&lt; Stack #0 -&lt; Stack #2 -&lt; Stack #1</strong></p><p><code>Stack #0</code> 为home ，这里反应出点击home键，打开app2 的操作。此时 <code>Stack #3</code> 中有 4 个 <code>ActivityRecord</code></p><p>当前获取焦点的 <code>ActivityStack</code> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">  mFocusedStack=ActivityStack&#123;<br>      dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; <br>mLastFocusedStack=ActivityStack&#123;<br>    dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;<br>  mCurTaskIdForUser=&#123;0=4&#125;<br></code></pre></td></tr></table></figure><h5 id="3-接下来启动-SingleTaskTwoActivity"><a href="#3-接下来启动-SingleTaskTwoActivity" class="headerlink" title="3. 接下来启动 SingleTaskTwoActivity"></a>3. 接下来启动 <code>SingleTaskTwoActivity</code></h5><p><img class="lazyload" data-original="%E3%80%90%E9%87%8D%E5%AD%A6Android%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Activity%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88/log3.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="log3"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs json">sagit:/ $ dumpsys activity activities<br>ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)<br>Display #0 (activities from top to bottom):<br><br>  Stack #2: type=standard mode=fullscreen<br>    Task id #3<br><br>    Running activities (most recent first):<br>      TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=3&#125;<br>        Run #2: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;<br>        Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;<br>        Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125;<br><br>    mResumedActivity: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;<br><br>  Stack #3: type=standard mode=fullscreen<br>    Task id #4<br><br>    Running activities (most recent first):<br>      TaskRecord&#123;f14a51a #4 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125;<br>        Run #3: ActivityRecord&#123;1838862 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125;<br>        Run #2: ActivityRecord&#123;bdb3180 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125;<br>        Run #1: ActivityRecord&#123;7b21450 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125;<br>        Run #0: ActivityRecord&#123;ff57abb u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t4&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;1838862 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125;<br><br>  Stack #0: type=home mode=fullscreen<br>    Task id #1<br><br>    Running activities (most recent first):<br>      TaskRecord&#123;94a7a01 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125;<br>        Run #0: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125;<br><br>  Stack #1: type=standard mode=fullscreen<br><br>    Task id #2<br>        <br>    Running activities (most recent first):<br>      TaskRecord&#123;d91b3e8 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125;<br>        Run #1: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;<br>        Run #0: ActivityRecord&#123;d76e9a5 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;<br><br>  ResumedActivity: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;<br><br>  mFocusedStack=ActivityStack&#123;<br>    3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; <br>  mLastFocusedStack=ActivityStack&#123;<br>    3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;<br>  mCurTaskIdForUser=&#123;0=4&#125;<br><br>  mUserStackInFront=&#123;&#125;<br>  displayId=0 stacks=4<br>   mHomeStack=ActivityStack&#123;<br>       76ebae7 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125;<br>  isHomeRecentsComponent=false  KeyguardController:<br>    mKeyguardShowing=false<br>    mAodShowing=false<br>    mKeyguardGoingAway=false<br>    mOccluded=false<br>    mDismissingKeyguardActivity=null<br>    mDismissalRequested=false<br>    mVisibilityTransactionDepth=0<br>  LockTaskController<br>    mLockTaskModeState=NONE<br>    mLockTaskModeTasks=<br>    mLockTaskPackages (userId:packages)=<br>      u0:[]<br></code></pre></td></tr></table></figure><p><strong>当前的堆栈顺序 Stack #2 -&lt; Stack #3 -&lt; Stack #0 -&lt;Stack #1</strong></p><p>当前获取焦点的 <code>ActivityStack</code> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">mFocusedStack=ActivityStack&#123;<br>  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; <br>mLastFocusedStack=ActivityStack&#123;<br>  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;<br>mCurTaskIdForUser=&#123;0=4&#125;<br></code></pre></td></tr></table></figure><p><code>Stack #2</code> 中 <code>TaskRecord</code>信息为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=3&#125;<br>  Run #2: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;<br>  Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;<br>  Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125;<br></code></pre></td></tr></table></figure><h4 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h4><p><strong>关键的地方来了</strong></p><p>的确有两个 <code>SingleTaskTwoActivity</code> 的 <code>ActivityRecord</code> ，栈顶的属于 <code>app2</code> 第二个属于 <code>app1</code></p><p>由此看出这两个<code>ActivityRecord</code> 不是一个实例，所以这里 <code>app2</code> 启动的 <code>SingleTaskTwoActivity</code> 应该是 <code>app2</code> 自己的activity</p><p>废话不说，翻代码！这里截取了 <code>BaseTaskActivity</code> 中的部分代码，<code>app1</code> 和 <code>app2</code>中的 <code>activity</code> 都继承了<code>BaseTaskActivity</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = v.getId();<br>        <span class="hljs-keyword">if</span> (i == R.id.btn_standard_one) &#123;<br>            Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, StandardOneActivity.class);<br>            startActivityWithCheck(intent);<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == R.id.btn_standard_two) &#123;<br>            Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, StandardTwoActivity.class);<br>            startActivityWithCheck(intent);<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == R.id.btn_singletask_one) &#123;<br>            Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, SingleTaskOneActivity.class);<br>            startActivityWithCheck(intent);<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == R.id.btn_singletask_two) &#123;<br>            Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, SingleTaskTwoActivity.class);<br>            startActivityWithCheck(intent);<br><br>            <span class="hljs-comment">//以下测试结果证实：</span><br>            <span class="hljs-comment">//1.在 App2 中启动 App1 的 standard Activity，仍然遵守 standard 的特点：在启动它的 Activity 所在的任务中启动，也即跟随 App2。</span><br>            <span class="hljs-comment">//2.在 App2 中启动 App1 的 singleTop Activity，跟随状况同 standard。</span><br>            <span class="hljs-comment">//3.在 App2 中启动 App1 的 singleTask Activity，仍然处于 App1 的任务中，并不跟随 App2。</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == R.id.btn_singletask_a) &#123;<br>            Intent intent = <span class="hljs-keyword">new</span> Intent();<br>            ComponentName name = <span class="hljs-keyword">new</span> ComponentName(<br>                    <span class="hljs-string">"com.kunminx.relearn_android"</span>,<br>                    <span class="hljs-string">"com.kunminx.relearn_android.SingleTaskAActivity"</span>);<br>            intent.setComponent(name);<br>            startActivityWithCheck(intent);<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == R.id.btn_singletask_b) &#123;<br>            Intent intent = <span class="hljs-keyword">new</span> Intent();<br>            ComponentName name = <span class="hljs-keyword">new</span> ComponentName(<br>                    <span class="hljs-string">"com.kunminx.relearn_android"</span>,<br>                    <span class="hljs-string">"com.kunminx.relearn_android.SingleTaskBActivity"</span>);<br>            intent.setComponent(name);<br>            startActivityWithCheck(intent);<br><br>        &#125;<br></code></pre></td></tr></table></figure><p>可以看出这里 <code>app2</code> 启动<code>SingleTaskTwoActivity</code> 的确是自己的 <code>activity</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200616181623.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200616181658.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><strong>那么它为什么和<code>app1</code> 中的  <code>SingleTaskTwoActivity</code>  是同一个 <code>TaskRecord</code> 呢？</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span><br>    <span class="hljs-attr">android:name</span>=<span class="hljs-string">".test03_task_test.SingleTaskOneActivity"</span><br>    <span class="hljs-attr">android:launchMode</span>=<span class="hljs-string">"singleTask"</span><br>    <span class="hljs-attr">android:taskAffinity</span>=<span class="hljs-string">"com.kunminx.task.c"</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span><br>    <span class="hljs-attr">android:name</span>=<span class="hljs-string">".test03_task_test.SingleTaskTwoActivity"</span><br>    <span class="hljs-attr">android:launchMode</span>=<span class="hljs-string">"singleTask"</span><br>    <span class="hljs-attr">android:taskAffinity</span>=<span class="hljs-string">"com.kunminx.task.c"</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>它们有着共同的 <code>taskAffinity</code>。至此，我的疑惑已经得到了答案。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>我试了以下 <code>app2</code> 中启动 <code>app1</code> 中的Activity的情况</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200616181712.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200616181808.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><code>app1</code> 依次启动 <code>StandardOneActivity</code> -&lt; <code>SingleTaskOneActivity</code>  -&lt; <code>SingleTaskTwoActivity</code>  -&lt; <code>SingleTaskAActivity</code></p><p>其中 <code>SingleTaskOneActivity</code>  与 <code>SingleTaskTwoActivity</code> 设置了相同的 <code>taskAffinity</code> ,<code>StandardOneActivity</code> <code>与 SingleTaskAActivity</code> 未设置 <code>taskAffinity</code></p><p><img class="lazyload" data-original="%E3%80%90%E9%87%8D%E5%AD%A6Android%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Activity%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88/log4.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="log4"></p><p>接着按 HOME 键，打开 <code>app2</code> ，依次打开 <code>StandardOneActivity</code> -&lt; <code>StandardOneActivity</code> -&lt; <code>StandardTwoActivity</code></p><p><img class="lazyload" data-original="%E3%80%90%E9%87%8D%E5%AD%A6Android%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Activity%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88/log5.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="log5"></p><p>此时堆栈信息</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs json">➜  Relearn-Android (master) adb shell<br>sagit:/ $ dumpsys activity activities<br>ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)<br>Display #0 (activities from top to bottom):<br><br>  Stack #3: type=standard mode=fullscreen<br>  isSleeping=false<br>  mBounds=Rect(0, 0 - 0, 0)<br>    Task id #48<br><br>    Running activities (most recent first):<br>      TaskRecord&#123;3b07175 #48 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125;<br>        Run #3: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125;<br>        Run #2: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125;<br>        Run #1: ActivityRecord&#123;71254 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125;<br>        Run #0: ActivityRecord&#123;7c135cf u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t48&#125;<br><br>    mResumedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125;<br>    mLastPausedActivity: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125;<br><br>  Stack #0: type=home mode=fullscreen<br>    Running activities (most recent first):<br>      TaskRecord&#123;185017b #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125;<br>        Run #0: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125;<br><br>  Stack #1: type=standard mode=fullscreen<br>    Task id #46<br>    Running activities (most recent first):<br>      TaskRecord&#123;c374b98 #46 A=com.kunminx.relearn_android U=0 StackId=1 sz=3&#125;<br>        Run #2: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125;<br>        Run #1: ActivityRecord&#123;bb0363c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t46&#125;<br>        Run #0: ActivityRecord&#123;510711c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t46&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125;<br><br>  Stack #2: type=standard mode=fullscreen<br>    Task id #47<br>    Running activities (most recent first):<br>      TaskRecord&#123;3387d6 #47 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125;<br>        Run #1: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125;<br>        Run #0: ActivityRecord&#123;e9850ca u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t47&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125;<br><br>  ResumedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125;<br><br>  mFocusedStack=ActivityStack&#123;ed83a57 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;<br>  mLastFocusedStack=ActivityStack&#123;ed83a57 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;<br>  mCurTaskIdForUser=&#123;0=48&#125;<br><br>  mUserStackInFront=&#123;&#125;<br>  displayId=0 stacks=4<br>   mHomeStack=ActivityStack&#123;a218944 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125;<br>  isHomeRecentsComponent=false  KeyguardController:<br>    mKeyguardShowing=false<br>    mAodShowing=false<br>    mKeyguardGoingAway=false<br>    mOccluded=false<br>    mDismissingKeyguardActivity=null<br>    mDismissalRequested=false<br>    mVisibilityTransactionDepth=0<br>  LockTaskController<br>    mLockTaskModeState=NONE<br>    mLockTaskModeTasks=<br>    mLockTaskPackages (userId:packages)=<br>      u0:[]<br></code></pre></td></tr></table></figure><p>最后在 <code>app2</code> 中启动  <code>app1</code> 的 <code>SingleTaskAActivity</code> </p><p><img class="lazyload" data-original="%E3%80%90%E9%87%8D%E5%AD%A6Android%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Activity%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88/log6.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="log6"></p><p>此时堆栈信息</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs json">➜  Relearn-Android (master) adb shell<br>sagit:/ $ dumpsys activity activities<br>ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)<br>Display #0 (activities from top to bottom):<br><br>  Stack #1: type=standard mode=fullscreen<br>    Task id #46<br>    Running activities (most recent first):<br>      TaskRecord&#123;c374b98 #46 A=com.kunminx.relearn_android U=0 StackId=1 sz=3&#125;<br>        Run #2: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125;<br>        Run #1: ActivityRecord&#123;bb0363c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t46&#125;<br>        Run #0: ActivityRecord&#123;510711c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t46&#125;<br><br>    mResumedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125;<br><br>  Stack #3: type=standard mode=fullscreen<br>    Task id #48<br>    Running activities (most recent first):<br>      TaskRecord&#123;3b07175 #48 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125;<br>        Run #3: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125;<br>        Run #2: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125;<br>        Run #1: ActivityRecord&#123;71254 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125;<br>        Run #0: ActivityRecord&#123;7c135cf u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t48&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125;<br><br>  Stack #0: type=home mode=fullscreen<br>    Task id #1<br>    Running activities (most recent first):<br>      TaskRecord&#123;185017b #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125;<br>        Run #0: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125;<br><br>  Stack #2: type=standard mode=fullscreen<br>    Task id #47<br>    Running activities (most recent first):<br>      TaskRecord&#123;3387d6 #47 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125;<br>        Run #1: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125;<br>        Run #0: ActivityRecord&#123;e9850ca u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t47&#125;<br><br>    mLastPausedActivity: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125;<br><br>  ResumedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125;<br><br>  mFocusedStack=ActivityStack&#123;50922c2 stackId=1 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;<br>  mLastFocusedStack=ActivityStack&#123;50922c2 stackId=1 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;<br><br>  mCurTaskIdForUser=&#123;0=48&#125;<br>  mUserStackInFront=&#123;&#125;<br>  displayId=0 stacks=4<br>   mHomeStack=ActivityStack&#123;a218944 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125;<br>  isHomeRecentsComponent=false  KeyguardController:<br>    mKeyguardShowing=false<br>    mAodShowing=false<br>    mKeyguardGoingAway=false<br>    mOccluded=false<br>    mDismissingKeyguardActivity=null<br>    mDismissalRequested=false<br>    mVisibilityTransactionDepth=0<br>  LockTaskController<br>    mLockTaskModeState=NONE<br>    mLockTaskModeTasks=<br>    mLockTaskPackages (userId:packages)=<br>      u0:[]<br></code></pre></td></tr></table></figure><p>此时 <code>app1</code> 的 <code>taskid</code> 46 的<code>TaskRecord</code> 转移到了 栈顶</p><p>接下来返回销毁的逻辑就很清晰了。</p><p><img class="lazyload" data-original="%E3%80%90%E9%87%8D%E5%AD%A6Android%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Activity%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88/log7.png" src="/2019/11/29/relearn-task-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="log7"></p><p>最后退到 <code>launcher</code> 界面</p><p><strong><code>app1</code> 的 <code>TaskRecord</code> 转移到了 <code>app2</code> 的返回栈中</strong></p>]]></content>
      
      
      <categories>
          
          <category> app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> app </tag>
            
            <tag> 重学Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【流水账】Xposed模块开发</title>
      <link href="/2019/08/30/Xposed/"/>
      <url>/2019/08/30/Xposed/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 <code>how to</code> 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。</p><p>本篇博客是记录一些学习 <code>Xposed</code>模块开发时知识的整理。</p></blockquote><a id="more"></a><h3 id="开发前的准备工作"><a href="#开发前的准备工作" class="headerlink" title="开发前的准备工作"></a>开发前的准备工作</h3><p>查看 <a href="https://github.com/rovo89/XposedBridge/wiki/Using-the-Xposed-Framework-API" target="_blank" rel="noopener">Xposed-Framework-API</a> 根据文档进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">repositories &#123;<br>    jcenter();<br>&#125;<br><br>dependencies &#123;<br>    compileOnly <span class="hljs-string">'de.robv.android.xposed:api:82'</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>AndroidManifest.xml</code> 中 <code>application</code> 标签下加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- 应用为模块 --&gt;<br>&lt;meta-data<br>    android:name=<span class="hljs-string">"xposedmodule"</span><br>    android:value=<span class="hljs-string">"true"</span> /&gt;<br>&lt;!-- 版本信息 该版本号与引用的依赖版本相同--&gt;<br>&lt;meta-data<br>    android:name=<span class="hljs-string">"xposedminversion"</span><br>    android:value=<span class="hljs-string">"82"</span> /&gt;<br>&lt;!-- 模块描述 --&gt;<br>&lt;meta-data<br>    android:name=<span class="hljs-string">"xposeddescription"</span><br>    android:value=<span class="hljs-string">"Xposed Test"</span> /&gt;<br></code></pre></td></tr></table></figure><p>创建 <code>Hook</code> 类，该类是 <code>Xposed</code> 的入口类，用于拦截加载的 <code>package</code> ，实现 <code>IXposedHookLoadPackage</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yyz.xposedtest;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IXposedHookLoadPackage</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLoadPackage</span><span class="hljs-params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> hook逻辑  </span><br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>在 <code>src/main</code> 目录下创建assets目录，在该目录中创建 <code>xposed_ini</code> t文件，写入上面创建的 <code>Xposed</code> 的入口类，如下：</p><p><img class="lazyload" data-original="%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91Xposed%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/%E5%85%A5%E5%8F%A3.png" src="/2019/08/30/Xposed/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Xposed模块入口"></p><h3 id="XposedHelpers-常用方法"><a href="#XposedHelpers-常用方法" class="headerlink" title="XposedHelpers 常用方法"></a>XposedHelpers 常用方法</h3><h3 id="findAndHookMethod"><a href="#findAndHookMethod" class="headerlink" title="findAndHookMethod"></a>findAndHookMethod</h3><blockquote><p>Look up a method and hook it. The last argument must be the callback for the hook.</p></blockquote><p>最后一个参数主要有两种</p><p><code>XC_MethodHook</code> 在原有方法逻辑上添加逻辑，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在原有方法逻辑上添加逻辑</span><br><span class="hljs-comment">/**<br> * 1. 包名 2. classLoader 3. 方法名 4. 参数类型（没有则不添加） 5.Callback<br> */</span><br>XposedHelpers.findAndHookMethod(<span class="hljs-string">"cn.bcbook.kaixuetest.MainActivity"</span>,<br>        lpparam.classLoader, <span class="hljs-string">"printViewId"</span>, View.class, <span class="hljs-keyword">new</span> XC_MethodHook() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                <span class="hljs-keyword">super</span>.beforeHookedMethod(param);<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                <span class="hljs-keyword">super</span>.afterHookedMethod(param);<br>                Log.i(<span class="hljs-string">"yyz"</span>, <span class="hljs-string">"afterHookedMethod hook success!"</span>);<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><p><code>XC_MethodReplacement</code> 替换原有方法逻辑，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//替换原有方法</span><br>XposedHelpers.findAndHookMethod(<span class="hljs-string">"cn.bcbook.kaixuetest.MainActivity"</span>,<br>        lpparam.classLoader, <span class="hljs-string">"printViewId"</span>, View.class, <span class="hljs-keyword">new</span> XC_MethodReplacement() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">replaceHookedMethod</span><span class="hljs-params">(MethodHookParam param)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                Log.i(<span class="hljs-string">"yyz"</span>, <span class="hljs-string">"hook success!"</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Xposed </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流水账 </tag>
            
            <tag> Hook </tag>
            
            <tag> Xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【流水账】iptables 常用指令</title>
      <link href="/2019/08/29/iptabels/"/>
      <url>/2019/08/29/iptabels/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 <code>how to</code> 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。</p><p>该文总结了 <code>iptables</code> 常用的指令。<code>iptables</code> 详细内容请看双印大佬 <a href="http://www.zsythink.net/archives/tag/iptables/page/2/" target="_blank" rel="noopener">iptables 详解系列</a></p></blockquote><a id="more"></a><h2 id="规则查询"><a href="#规则查询" class="headerlink" title="规则查询"></a>规则查询</h2><h3 id="查看指定表中的规则"><a href="#查看指定表中的规则" class="headerlink" title="查看指定表中的规则"></a>查看指定表中的规则</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -L<br></code></pre></td></tr></table></figure><p>使用 <code>-t</code> 选项，指定要操作的表，使用 <code>-L</code> 选项，查看-t选项对应的表的规则， <code>-L</code> 选项的意思是，列出规则。所以，上述命令的含义为列出filter表的所有规则。</p><p><code>filter</code> 可替换为 <code>raw</code> <code>mangle</code> <code>nat</code></p><p>如果仅查看 <code>filter</code> 可以省略 <code>-t filter</code> ，当没有使用 <code>-t</code> 选项指定表时，默认为操作 <code>filter</code> 表，即 <code>iptables -L</code> 表示列出 <code>filter</code> 表中的所有规则。</p><h3 id="查看指定表中的指定链的规则"><a href="#查看指定表中的指定链的规则" class="headerlink" title="查看指定表中的指定链的规则"></a>查看指定表中的指定链的规则</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -L INPUT<br></code></pre></td></tr></table></figure><p>只查看 <code>filter</code> 表中 <code>INPUT</code> 链的规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -vL INPUT<br></code></pre></td></tr></table></figure><p>使用 <code>-v</code> 查看更多，更详细的信息</p><h3 id="不让ip进行反解"><a href="#不让ip进行反解" class="headerlink" title="不让ip进行反解"></a>不让ip进行反解</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -nvL<br></code></pre></td></tr></table></figure><p><code>iptables</code> 默认进行了名称解析，但是在规则非常多的情况下如果进行名称解析，效率会比较低。使用 <code>-n</code> 选项，表示不对 <code>ip</code> 地址进行名称反解，直接显示 <code>ip</code> 地址</p><p>只查看某个链的规则，并且不让 <code>ip</code> 进行反解，<code>iptables -nvL INPUT</code></p><h3 id="显示规则编号"><a href="#显示规则编号" class="headerlink" title="显示规则编号"></a>显示规则编号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables --line-number -nvL INPUT<br>或<br>iptables --line -nvL INPUT<br></code></pre></td></tr></table></figure><h2 id="规则管理"><a href="#规则管理" class="headerlink" title="规则管理"></a>规则管理</h2><h3 id="添加规则"><a href="#添加规则" class="headerlink" title="添加规则"></a>添加规则</h3><p><font color="#ff0000">注意：添加规则时，规则的顺序非常重要</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span> 在指定表的指定链的尾部添加一条规则，-A选项表示在对应链的末尾添加规则<br>命令语法：iptables -t 表名 -A 链名 匹配条件 -j 动作<br>示例：iptables -t filter -A OUTPUT -s 192.168.10.225 -j DROP<br><span class="hljs-meta"><br>#</span> 在指定表的指定链的首部添加一条规则，-I选型表示在对应链的开头添加规则<br>命令语法：iptables -t 表名 -I 链名 匹配条件 -j 动作<br>示例： iptables -t filter -I OUTPUT -s 192.168.10.225 -j ACCEPT<br><span class="hljs-meta"><br>#</span> 在指定表的指定链的指定位置添加一条规则<br>命令语法：iptables -t 表名 -I 链名 规则序号 匹配条件 -j 动作<br>示例： iptables -t filter -I OUTPUT 3 -s 192.168.10.225 -j REJECT<br><span class="hljs-meta"><br>#</span> 设置指定表的指定链的默认策略（默认动作），并非添加规则<br>命令语法：iptables -t 表名 -P 链名 动作<br>示例：iptables -t filter -P FORWARD ACCEPT<br></code></pre></td></tr></table></figure><h3 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h3><p><font color="ff0000">注意：如果没有保存规则，删除规则时请慎重</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span> 按照规则序号删除规则，删除指定表的指定链的指定规则，-D选项表示删除对应链中的规则<br>命令语法：iptables -t 表名 -D 链名 规则序号<br>示例：iptables -t filter -D INPUT 3<br><span class="hljs-meta"><br>#</span> 按照具体的匹配条件与动作删除规则，删除指定表的指定链的指定规则<br>命令语法：iptables -t 表名 -D 链名 匹配条件 -j 动作<br>示例：iptables -t filter -D INPUT -s 192.168.10.225 -j DROP<br><span class="hljs-meta"><br>#</span> 删除指定表的指定链中的所有规则，-F选项表示清空对应链中的规则<br>命令语法：iptables -t 表名 -F 链名<br>示例：iptables -t filter -F INPUT<br><span class="hljs-meta"><br>#</span> 删除指定表中的所有规则<br>命令语法：iptables -t 表名 -F<br>示例：iptables -t filter -F OUTPUT<br></code></pre></td></tr></table></figure><h3 id="修改规则"><a href="#修改规则" class="headerlink" title="修改规则"></a>修改规则</h3><p><font color="ff0000">注意：如果使用-R选项修改规则中的动作，那么必须指明原规则中的原匹配条件，例如源ip，目标ip等</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span> 修改指定表中指定链的指定规则，-R选项表示修改对应链中的规则，使用-R选项时要同时指定对应的链以及规则对应的序号，并且规则中原本的匹配条件不可省略<br>命令语法：iptables -t 表名 -R 链名 规则序号 规则原本的匹配条件 -j 动作<br>示例：iptables -t filter -R INPUT 3 -s 192.168.10.225 -j ACCEPT<br></code></pre></td></tr></table></figure><p>上述示例表示修改 <code>filter</code> 表中 <code>INPUT</code> 链的第3条规则，将这条规则的动作修改为 <code>ACCEPT</code> ， <code>-s</code>  <code>192.168.10.225</code> 为这条规则中原本的匹配条件，如果省略此匹配条件，修改后的规则中的源地址可能会变为 <code>0.0.0.0/0</code></p><p>其他修改规则的方法：先通过编号删除规则，再在原编号位置添加一条规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span> 修改指定表的指定链的默认策略（默认动作），并非修改规则<br>命令语法：iptables -t 表名 -P 链名 动作<br>示例：iptables -t filter -P FORWARD ACCEPT<br></code></pre></td></tr></table></figure><h3 id="保存规则"><a href="#保存规则" class="headerlink" title="保存规则"></a>保存规则</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span> 保存规则命令，表示将iptables规则保存至/etc/sysconfig/iptables文件中<br>service iptables save<br></code></pre></td></tr></table></figure><h2 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h2><h3 id="基本匹配条件"><a href="#基本匹配条件" class="headerlink" title="基本匹配条件"></a>基本匹配条件</h3><p><code>-s</code> 用于匹配报文的源地址,可以同时指定多个源地址，每个 <code>ip</code> 之间用逗号隔开，也可以指定为一个网段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I INPUT -s 192.168.10.111,192.168.10.225 -j DROP<br>iptables -t filter -I INPUT -s 192.168.10.0/24 -j ACCEPT<br>iptables -t filter -I INPUT ! -s 192.168.10.0/24 -j ACCEPT<br></code></pre></td></tr></table></figure><p><code>-d</code> 用于匹配报文的目标地址,可以同时指定多个目标地址，每个 <code>ip</code> 之间用逗号隔开，也可以指定为一个网段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I OUTPUT -d 192.168.10.111,192.168.10.225 -j DROP<br>iptables -t filter -I INPUT -d 192.168.10.0/24 -j ACCEPT<br>iptables -t filter -I INPUT ! -d 192.168.10.0/24 -j ACCEPT<br></code></pre></td></tr></table></figure><p><code>-p</code> 用于匹配报文的协议类型,可以匹配的协议类型 <code>tcp</code> 、<code>udp</code> 、<code>udplite</code> 、<code>icmp</code> 、<code>esp</code> 、<code>ah</code> 、<code>sctp</code> 等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I INPUT -p tcp -s 192.168.10.146 -j ACCEPT<br>iptables -t filter -I INPUT ! -p udp -s 192.168.10.146 -j ACCEPT<br></code></pre></td></tr></table></figure><h3 id="扩展匹配条件"><a href="#扩展匹配条件" class="headerlink" title="扩展匹配条件"></a>扩展匹配条件</h3><ol><li><p><code>tcp</code> 扩展模块</p><p><code>-p tcp -m tcp --sport</code> 用于匹配 <code>tcp</code> 协议报文的源端口，可以使用冒号指定一个连续的端口范围<br><code>-p tcp -m tcp --dport</code> 用于匹配 <code>tcp</code> 协议报文的目标端口，可以使用冒号指定一个连续的端口范围</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp --sport 22 -j REJECT<br>iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 22:25 -j REJECT<br>iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport :22 -j REJECT<br>iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 80: -j REJECT<br>iptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp ! --sport 22 -j ACCEPT<br></code></pre></td></tr></table></figure></li><li><p><code>multiport</code> 扩展模块</p><p><code>-p tcp -m multiport --sports</code> 用于匹配报文的源端口，可以指定离散的多个端口号,端口之间用”逗号”隔开<br><code>-p udp -m multiport --dports</code> 用于匹配报文的目标端口，可以指定离散的多个端口号，端口之间用”逗号”隔开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I OUTPUT -d 192.168.10.225 -p udp -m multiport --sports 137,138 -j REJECT<br>iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80 -j REJECT<br>iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport ! --dports 22,80 -j REJECT<br>iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 80:88 -j REJECT<br>iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80:88 -j REJECT<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><code>udp</code> 模块</p><p><code>--sport</code> 匹配 <code>udp</code> 报文的源地址<br><code>--dport</code> 匹配 <code>udp</code> 报文的目标地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span> 可以结合multiport模块指定多个离散的端口<br>iptables -t filter -I INPUT -p udp -m udp --dport 137 -j ACCEPT<br>iptables -t filter -I INPUT -p udp -m udp --dport 137:157 -j ACCEPT<br></code></pre></td></tr></table></figure></li></ol><ol start="4"><li><p><code>icmp</code> 模块</p><p><code>--icmp-type</code> 匹配 <code>icmp</code> 报文的具体类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECT<br>iptables -t filter -I INPUT -p icmp --icmp-type 8 -j REJECT<br>iptables -t filter -I OUTPUT -p icmp -m icmp --icmp-type 0/0 -j REJECT<br>iptables -t filter -I OUTPUT -p icmp --icmp-type 0 -j REJECT<br>iptables -t filter -I INPUT -p icmp --icmp-type "echo-request" -j REJECT<br></code></pre></td></tr></table></figure></li></ol><ol start="5"><li><p><code>iprange</code> 模块</p><p><code>--src-range</code> 指定连续的源地址范围<br><code>--dst-range</code> 指定连续的目标地址范围</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I INPUT -m iprange --src-range 192.168.10.127-192.168.10.146 -j DROP<br>iptables -t filter -I OUTPUT -m iprange --dst-range 192.168.10.127-192.168.10.146 -j DROP<br>iptables -t filter -I INPUT -m iprange ! --src-range 192.168.10.127-192.168.10.146 -j DROP<br></code></pre></td></tr></table></figure></li><li><p><code>stirng</code> 模块</p><p><code>--algo</code> 指定对应的匹配算法，可用算法为 <code>bm</code> 、<code>kmp</code>，此选项为必需选项。<br><code>--string</code> 指定需要匹配的字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECT<br>iptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECT<br></code></pre></td></tr></table></figure></li></ol><ol start="7"><li><p><code>time</code> 模块 </p><p><code>--timestart</code> 用于指定时间范围的开始时间，不可取反<br><code>--timestop</code> 用于指定时间范围的结束时间，不可取反<br><code>--weekdays</code> 用于指定”星期几”，可取反<br><code>--monthdays</code> 用于指定”几号”，可取反<br><code>--datestart</code> 用于指定日期范围的开始日期，不可取反<br><code>--datestop</code> 用于指定日期范围的结束时间，不可取反</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I OUTPUT -p tcp --dport 80 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECT<br>iptables -t filter -I OUTPUT -p tcp --dport 443 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECT<br>iptables -t filter -I OUTPUT -p tcp --dport 80  -m time --weekdays 6,7 -j REJECT<br>iptables -t filter -I OUTPUT -p tcp --dport 80  -m time --monthdays 22,23 -j REJECT<br>iptables -t filter -I OUTPUT -p tcp --dport 80  -m time ! --monthdays 22,23 -j REJECT<br>iptables -t filter -I OUTPUT -p tcp --dport 80  -m time --timestart 09:00:00 --timestop 18:00:00 --weekdays 6,7 -j REJECT<br>iptables -t filter -I OUTPUT -p tcp --dport 80  -m time --weekdays 5 --monthdays 22,23,24,25,26,27,28 -j REJECT<br>iptables -t filter -I OUTPUT -p tcp --dport 80  -m time --datestart 2017-12-24 --datestop 2017-12-27 -j REJECT<br></code></pre></td></tr></table></figure></li></ol><ol start="8"><li><p><code>connlimit</code> 模块</p><p><code>--connlimit-above</code> 单独使用此选项时，表示限制每个 <code>ip</code> 的链接数量。<br><code>--connlimit-mask</code>  此选项不能单独使用，在使用 <code>--connlimit-above</code> 选项时，配合此选项，则可以针对”某类 <code>ip</code> 段内的一定数量的 <code>ip</code> “进行连接数量的限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT<br>iptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j REJECT<br>iptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 10 --connlimit-mask 27 -j REJECT<br></code></pre></td></tr></table></figure></li></ol><ol start="9"><li><p><code>limit</code> 模块</p><p><code>--limit-burst</code> 此选项用于指定令牌桶中令牌的最大数量<br><code>--limit</code> 此选项用于指定令牌桶中生成新令牌的频率，可用时间单位有second、minute 、hour、day</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">iptables -t filter -I INPUT -p icmp -m limit --limit-burst 3 --limit 10/minute -j ACCEPT<br>iptables -t filter -A INPUT -p icmp -j REJECT<br></code></pre></td></tr></table></figure></li></ol><h2 id="自定义链"><a href="#自定义链" class="headerlink" title="自定义链"></a>自定义链</h2><h3 id="创建自定义链"><a href="#创建自定义链" class="headerlink" title="创建自定义链"></a>创建自定义链</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span> 在filter表中创建yyz自定义链<br>iptables -N yyz<br></code></pre></td></tr></table></figure><h3 id="引用自定义链"><a href="#引用自定义链" class="headerlink" title="引用自定义链"></a>引用自定义链</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span> 在OUTPUT链中引用刚才创建的自定义链<br>iptables -I OUTPUT -j yyz<br></code></pre></td></tr></table></figure><h3 id="重命名自定义链"><a href="#重命名自定义链" class="headerlink" title="重命名自定义链"></a>重命名自定义链</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span> 将yyz自定义链重命名为test<br>iptabels -E yyz test<br></code></pre></td></tr></table></figure><h3 id="删除自定义链"><a href="#删除自定义链" class="headerlink" title="删除自定义链"></a>删除自定义链</h3><p>删除自定义链需要满足两个条件</p><ol><li>自定义链中没有被引用</li><li>自定义链中没有任何规则</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span> 删除引用计数为0且不包含任何规则的test链<br>iptabels -X test<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROM </tag>
            
            <tag> framework </tag>
            
            <tag> 流水账 </tag>
            
            <tag> iptables </tag>
            
            <tag> 网络黑白名单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【流水账】记录Framework开发的常用指令</title>
      <link href="/2019/08/16/Framework-Option/"/>
      <url>/2019/08/16/Framework-Option/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 <code>how to</code> 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。</p><p>本篇博客是记录一些学习 <code>framework</code> 开发时知识的整理。</p></blockquote><a id="more"></a><h3 id="源码全盘编译指令"><a href="#源码全盘编译指令" class="headerlink" title="源码全盘编译指令"></a>源码全盘编译指令</h3><ol><li><code>source build/envsetup.sh</code></li><li>输入 <code>lunch</code> 同时选择欲编译的源码</li><li>编译指令：<code>make -j32 2&gt;&amp;1 | tee build_20190717_1724.log</code></li><li>编译后out目录可查看编译出的镜像</li></ol><p>前两步执行完毕即可执行 <code>mmm</code> 等命令，使用 <code>make clean</code>可以在编译前clean源码，该操作会导致编译时间边长。</p><h3 id="ROM烧录（mtk）"><a href="#ROM烧录（mtk）" class="headerlink" title="ROM烧录（mtk）"></a>ROM烧录（mtk）</h3><ol><li>打开 <code>flash_tool.exe</code></li><li>选择源码的配置文件</li><li>切换下载/全部格式化和下</li><li>点击下载，同时将已关机的设备连接电脑</li><li>等待红条，绿条，黄条走完烧录成功</li></ol><h3 id="ROM写号"><a href="#ROM写号" class="headerlink" title="ROM写号"></a>ROM写号</h3><ol><li>打开 <code>SN Writer.exe</code></li><li>点击 <code>System Config</code> 配置欲写哪些号，点击AP_DB进行配置文件，点击 <code>Save</code></li><li>点击 <code>Start</code> 将关机的设备连入电脑</li></ol><h3 id="源码检出"><a href="#源码检出" class="headerlink" title="源码检出"></a>源码检出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">repo-local init -u git://&#123;ip&#125;/shupai_android7.1/manifests.git &amp;&amp; repo-local sync -j8 &amp;&amp; repo-local start --all master<br></code></pre></td></tr></table></figure><p>{ip} 使用源码地址替换</p><h3 id="开机动画"><a href="#开机动画" class="headerlink" title="开机动画"></a>开机动画</h3><p><code>/system/media/</code></p><h3 id="重新打包-System-生成镜像"><a href="#重新打包-System-生成镜像" class="headerlink" title="重新打包 System 生成镜像"></a>重新打包 <code>System</code> 生成镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">make -j8 snod<br></code></pre></td></tr></table></figure><h3 id="对-Settings-部分的修改"><a href="#对-Settings-部分的修改" class="headerlink" title="对 Settings 部分的修改"></a>对 <code>Settings</code> 部分的修改</h3><ol><li>移除某项（removePreference方法）</li><li>禁用某项 （配置enabled属性）</li><li>隐藏 <code>Settings</code> 主界面选项：<code>TileUtils</code></li></ol><h3 id="三大金刚键"><a href="#三大金刚键" class="headerlink" title="三大金刚键"></a>三大金刚键</h3><ol><li><code>HOME</code> 和  <code>BACK</code><br><code>PhoneWindowManager</code> 类 <code>interceptKeyBeforeDispatching</code> 方法<br>修改 <code>KEYCODE_HOME</code>  <code>KEYCODE_BACK</code> case 中的逻辑 </li><li><code>RECENT</code><br><code>src/com/android/systemui/recents/RecentsImpl</code> 类 <code>startRecentsActivity</code> 方法</li></ol><h3 id="预装应用"><a href="#预装应用" class="headerlink" title="预装应用"></a>预装应用</h3><p><code>device/mediatek/common device.mk</code></p><h3 id="关机-重启操作"><a href="#关机-重启操作" class="headerlink" title="关机 重启操作"></a>关机 重启操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">base/services/core/java/com/android/server/policy/GloablActions PowerAction<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROM </tag>
            
            <tag> framework </tag>
            
            <tag> 流水账 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多个项目添加依赖同一个模块</title>
      <link href="/2019/04/13/multi-project-one-module/"/>
      <url>/2019/04/13/multi-project-one-module/</url>
      
        <content type="html"><![CDATA[<blockquote><p>android Studio  中的项目在正常引用module的时候是用复制到项目中的方式进行，单个项目调用还能适用，但是如果多个项目要引用同一个module的时候，如果module中进行了修改，那么每个项目中的module都要进行修改，这样增加了工作量，并且容易出现bug</p><p>因此我们需要引用module ，而不是复制module，实现方法如下</p></blockquote><a id="more"></a><p>新建项目 <code>TestBase</code>，在其 <code>app build.gradle</code> 中将 <code>apply plugin: &#39;com.android.application&#39;</code> 改为<code>apply plugin: &#39;com.android.library&#39;</code> 删除<code>applicationId</code> 配置项，将<code>module</code>名修改为<code>baselib</code>。</p><p>新建项目 <code>TestA</code> 在其<code>settings.gradle</code> 文件中加入下列代码。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">include</span> <span class="hljs-string">':app'</span><br><span class="hljs-keyword">include</span> <span class="hljs-string">':baselib'</span><br><span class="hljs-keyword">project</span>(<span class="hljs-string">':baselib'</span>).projectDir=<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(<span class="hljs-string">"../TestBase"</span>, <span class="hljs-string">'baselib'</span>)<br></code></pre></td></tr></table></figure><p>引用依赖时正常引用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">implementation project(&apos;:baselib&apos;)<br></code></pre></td></tr></table></figure><p>同步<code>gradle</code> ，此时我们发现<code>baselib</code>出现在<code>TestA</code>项目中。</p><p><img class="lazyload" data-original="%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97/TestA%E7%9B%AE%E5%BD%95.png" src="/2019/04/13/multi-project-one-module/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="TestA目录.png"></p><p>打开<code>TestA</code> 项目文件夹，我们发现了 <code>baselib</code> 文件夹，下面只有一个<code>baselib.iml</code>文件</p><p><img class="lazyload" data-original="%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97/TesA%E5%8E%9F%E7%9B%AE%E5%BD%95.png" src="/2019/04/13/multi-project-one-module/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="TesA原目录.png"></p><p>在<code>baselib</code>中加入<code>Utils</code> 工具类</p><p><img class="lazyload" data-original="%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97/baselib.png" src="/2019/04/13/multi-project-one-module/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="baselib.png"></p><p>切换到<code>TestBase</code>中查看，代码是相同的。</p><p><img class="lazyload" data-original="%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97/baselib.png" src="/2019/04/13/multi-project-one-module/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="TestBase目录.png"></p><p>这样就达到了<code>baselib</code>被修改后所有引用<code>baselib</code>的项目会同步变化。</p><h4 id="git-同步管理"><a href="#git-同步管理" class="headerlink" title="git 同步管理"></a>git 同步管理</h4><blockquote><p>上述操作都是基于本地的，那么如何加入git管理呢</p></blockquote><p>将<code>TestA</code>和<code>TestBase</code>分别传至<code>github</code></p><p>在<code>TestA</code>项目中打开<code>settings</code>，找到如下位置并将<code>TestBase</code>加入到<code>git</code>管理</p><p><img class="lazyload" data-original="%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97/%E6%B7%BB%E5%8A%A0git.png" src="/2019/04/13/multi-project-one-module/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="添加git.png"></p><p>然后就可以同步管理这两个项目啦<br><img class="lazyload" data-original="%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97/%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86.png" src="/2019/04/13/multi-project-one-module/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="同步管理.png"><br><img class="lazyload" data-original="%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97/gitlog.png" src="/2019/04/13/multi-project-one-module/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="git log.png"></p><p>参考：<br><a href="https://www.jianshu.com/p/47156a6be8ce" target="_blank" rel="noopener">https://www.jianshu.com/p/47156a6be8ce</a><br><a href="https://blog.csdn.net/saintcs/article/details/78567612" target="_blank" rel="noopener">https://blog.csdn.net/saintcs/article/details/78567612</a></p>]]></content>
      
      
      <categories>
          
          <category> app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> app </tag>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下Android反编译初探</title>
      <link href="/2017/07/06/Mac-decompile/"/>
      <url>/2017/07/06/Mac-decompile/</url>
      
        <content type="html"><![CDATA[<blockquote><p>工作第四天，被要求学习逆向开发方面的知识，于是先将自己之前写的未经混淆的apk反编译，记录之。</p></blockquote><p><a href="http://blog.csdn.net/wj_november/article/details/51527286" target="_blank" rel="noopener">感谢该博文提供的思路</a></p><a id="more"></a><h3 id="1-工具准备"><a href="#1-工具准备" class="headerlink" title="1. 工具准备"></a>1. 工具准备</h3><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-569189364ef992cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/06/Mac-decompile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="工具"></p><p>需要的三件套，<a href="http://download.csdn.net/detail/wj_november/9657372" target="_blank" rel="noopener">下载请戳</a></p><ol><li>AndroidCrackTool 用于反编译apk文件<br>与直接解压apk不同，用该工具获得的文件资源可以直接打开阅读，而直接解压得到的是字节码。</li><li>dex2jar 用于将.dex文件转为jar文件<br> 传统的Java程序经过编译，生成Java字节码保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Davik字节码，所有的Davik字节码由Java字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中，Dalvik虚拟机通过解释DEX文件来执行这些字节码。</li><li>jd-gui 用于阅读源码</li></ol><h3 id="2-开始工作"><a href="#2-开始工作" class="headerlink" title="2. 开始工作"></a>2. 开始工作</h3><p>使用AndroidCrackTool反编译apk，设置好目录点击执行按钮，出现end字样即成功。<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-9dde0fe67fd84a07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/06/Mac-decompile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="反编译apk"><br>在这里可以查看一些资源文件</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-33d7aeb6f6b20770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/06/Mac-decompile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="查看资源文件"><br>将apk以普通解压的方式解压出来，找到其中的classes.dex文件，<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-46a0928132602efb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/06/Mac-decompile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="classes.dex位置"><br>将其复制到dex2jar目录，使用终端进入dex2jar目录并执行如下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sh dex2jar.sh classes.dex<br></code></pre></td></tr></table></figure><p>可以看到在dex2jar目录下生成了classes_dex2jar.jar的文件。</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-a489b4dd84c84ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/06/Mac-decompile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="终端下操作"></p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-6c746a8c946c3275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/06/Mac-decompile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="生成的classes_dex2jar.jar"><br>使用  jd-gui打开classes_dex2jar.jar即可看到源码，可以看到我的apk并没有混淆，所以名字都是正常的命名，经过混淆的名字大都是些字母。</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-b7afdfda627a9e6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/06/Mac-decompile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="阅读源码"></p>]]></content>
      
      
      <categories>
          
          <category> app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler深入分析</title>
      <link href="/2017/07/04/Handler/"/>
      <url>/2017/07/04/Handler/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在android中我们可以有很多方式去实现异步，比如AsyncTask，Rxjava。不过它们底层都是使用的Handler，所以我们来研究一下Handelr的实现。</p></blockquote><a id="more"></a><h3 id="1-TreadLocal的使用"><a href="#1-TreadLocal的使用" class="headerlink" title="1. TreadLocal的使用"></a>1. TreadLocal的使用</h3><p>下面我们来写一个小demo，创建两个子线程，在两个子线程中分别为字符串result2，result3赋值，在主线程中调用两个子线程，并且为字符串result1赋值，最后打印输出结果。</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-2e352e80d8f708cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="主线程"></p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-3593c9860a191e71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="子线程1"></p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-106032139bef8248.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="子线程2"></p><p>最后我们看一下打印结果</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-0fded8b582305652.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="测试结果"></p><p>很明显，这不是我们想要的结果。看来线程之间相互影响了，那么有没有办法实现上述的功能呢？</p><p>当然有，我们可以使用 TreadLocal</p><blockquote><p>我们可以把TreadLocal看做成一个容器，调用其中的set和get方法，可以设值和取值。下面我们看看是如何实现的。</p></blockquote><p>首先创建一个ThreadLocal对象，并设置泛型为String<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-b274968c0d87042d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ThreadLocal"><br>这里不同的是首先将要打印的字串放入ThreadLocal中，然后从ThreadLocal中取出。<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-b8a37fcc57787a3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="主线程"></p><p>子线程的操作也是类似的。<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-9b8b4a3c8f495526.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="子线程"></p><p>下面我们看一下打印结果</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-71885237f2c74d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="运行结果"></p><p>这样就完成了上述功能。那么这里说的ThreadLocal与Handler有什么关系呢？别急，往下看。</p><h3 id="2-在子线程中创建Handelr"><a href="#2-在子线程中创建Handelr" class="headerlink" title="2. 在子线程中创建Handelr"></a>2. 在子线程中创建Handelr</h3><p>我们在子线程中创建一个Handler对象，然后运行程序。<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-4673d3b294d1ff08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="子线程中创建Handler对象"></p><p>可以看到运行时出现了异常</p><blockquote><p> java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()</p></blockquote><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-42a0e89fbd6cfe2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="异常"><br>看字面意思是不能在调用Looper.prepare()之前在线程中创建handler。<br>那么我们在创建handler之前去调用Looper.prepare()。<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-036e11a4312a1dd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="调用Looper.prepare()"><br>之后就能成功运行了。</p><p>那么我们来研究一下为什么会这样。<br>鼠标放在Handler()上，win按住control+鼠标左键，Mac按住command+鼠标左键。进入Handler的构造器。<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-ddcf57bb316f4d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Handler构造器"><br>点击this</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-322cff8f6407b3f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="更进一步"></p><p>我们找到了源头，如果looper为空则抛出这个异常。</p><p>在这里从looper里取出mQueue赋值给mQueue</p><p>然后我们看一下这个Looper.prepare方法，<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-8092676c88450ad6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="prepare"></p><p>上方的注释说得很清楚，在真正开始这个loop之前，该方法为你提供了创建引用这个looper的handelr的机会。在调用完该方法后，应该确保调用了loop()方法，并且使用quit()方法去结束它。</p><p>我们还看到如果多次调用prepare方法会抛出Only one Looper may be created per thread异常。<br>在这里我们看到了熟悉的身影，ThreadLocal。在这里使用ThreadLocal来存looper。</p><p>看到这我们不禁要问，在主线程我们并没有调用prepare方法啊，没错，在主线程使用的是prepareMainLooper<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-28263341bcc4e038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="prepareMainLooper"><br>可以看到这个main looper已经被android environment创建了，所以不需要自己调用该方法。</p><p>下面我们来看一下在子线程中创建Handler的标准写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLooper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> Handler mHandler;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.run();<br>            Looper.prepare();<br>            mHandler = <span class="hljs-keyword">new</span> Handler() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>                &#125;<br>            &#125;;<br>            Looper.loop();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-Message的发送和处理过程"><a href="#3-Message的发送和处理过程" class="headerlink" title="3. Message的发送和处理过程"></a>3. Message的发送和处理过程</h3><p>Handler里提供了几个消息入队的方法</p><blockquote><p>post()<br>postAtTime()<br>postDelayed()<br>postAtFrontOfQueue()<br>sendMessageAtTime(Message msg , long uptimeMillis)</p></blockquote><p>其中post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法。</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-8f15bc3b507a098f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="post"><br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-1b8a08501a2a9251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="postAtTime"><br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-c5ef6085b80726ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="postDelayed"><br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-dbe0fccf4cc81722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="sendMessageDelayed"><br>下面我们看一下sendMessageAtTime方法</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-678aac95b1c8ad85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="sendMessageAtTime"></p><p>有两个参数，msg 和uptimeMillis ，如果消息队列为空，则打印警告，同时返回false。反之则调用enqueueMessage方法。</p><p>下面看一下enqueueMessage</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-ba4cd0593a2e8df7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="enqueueMessage"><br>这里有两个比较重要的操作。<br>msg.target赋值为this，有两层含义，一是message的来源是当前handler，二是当前的handler来处理消息。<br>将消息加入到消息队列中，既然是队列就有顺序，那么根据什么来判断顺序呢？就是根据uptimeMillis,这个时间，时间短就在前面，长就在后面。</p><p>细心的你可能发现刚刚我提到post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法，那postAtFrontOfQueue()呢？<br>从字面上看该方法是将消息置于消息队列的最前边。是不是这样呢？我们看一下源码。</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-76f2c74c7c0a3e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="postAtFrontOfQueue"><br>这里将入队的时间参数直接写死为0，那么肯定就是消息队列的最前边啦。</p><p>我们再来分析下入队之后的过程，上文提到调用Looper.prepare()方法后应调用Looper.loop()方法开始消息的轮询。那么我们看看loop方法做了些什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Looper me = myLooper();<br>    <span class="hljs-keyword">if</span> (me == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);<br>    &#125;<br>    <span class="hljs-keyword">final</span> MessageQueue queue = me.mQueue;<br><br>    <span class="hljs-comment">// Make sure the identity of this thread is that of the local process,</span><br>    <span class="hljs-comment">// and keep track of what that identity token actually is.</span><br>    Binder.clearCallingIdentity();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ident = Binder.clearCallingIdentity();<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Message msg = queue.next(); <span class="hljs-comment">// might block</span><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// No message indicates that the message queue is quitting.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// This must be in a local variable, in case a UI event sets the logger</span><br>        <span class="hljs-keyword">final</span> Printer logging = me.mLogging;<br>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>            logging.println(<span class="hljs-string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="hljs-string">" "</span> +<br>                    msg.callback + <span class="hljs-string">": "</span> + msg.what);<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> traceTag = me.mTraceTag;<br>        <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;<br>            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            msg.target.dispatchMessage(msg);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;<br>                Trace.traceEnd(traceTag);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>            logging.println(<span class="hljs-string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="hljs-string">" "</span> + msg.callback);<br>        &#125;<br><br>        <span class="hljs-comment">// Make sure that during the course of dispatching the</span><br>        <span class="hljs-comment">// identity of the thread wasn't corrupted.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> newIdent = Binder.clearCallingIdentity();<br>        <span class="hljs-keyword">if</span> (ident != newIdent) &#123;<br>            Log.wtf(TAG, <span class="hljs-string">"Thread identity changed from 0x"</span><br>                    + Long.toHexString(ident) + <span class="hljs-string">" to 0x"</span><br>                    + Long.toHexString(newIdent) + <span class="hljs-string">" while dispatching to "</span><br>                    + msg.target.getClass().getName() + <span class="hljs-string">" "</span><br>                    + msg.callback + <span class="hljs-string">" what="</span> + msg.what);<br>        &#125;<br><br>        msg.recycleUnchecked();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-5797c552356958b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="looper"><br>首先从ThreadLocal中取出looper并判断是否为空，之后将looper中的消息队列赋值，再然后进入一个死循环，循环内去不断寻找消息队列的下一项，没有消息发生阻塞。</p><p>找到 msg.target.dispatchMessage(msg);这一行，<br>之前我们提到target就是handler对象，这里handler把消息派发出去，接下来就进入消息的处理了。</p><p>进入到msg.target.dispatchMessage方法，<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-3d37b2fa8bb03c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="dispatchMessage"><br>这里分三步<br>1.判断msg的回调是否为空<br> 如果不为空则直接该回调自己处理，反之判断自己的回调</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-5cabf5368375e861.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="message的回调"><br>把Runnable 封装成msg的callback</p><p>2.判断自己的回调是否为空<br>3.调用handleMessage方法</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-ad49dc188525989f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/07/04/Handler/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="handleMessage"><br>这里由子类重写来处理message</p><h3 id="4-Handler机制的总结"><a href="#4-Handler机制的总结" class="headerlink" title="4. Handler机制的总结"></a>4. Handler机制的总结</h3><blockquote><p>Thread 负责业务逻辑<br>Handler 负责发送消息和处理消息<br>MessageQueue 负责保存消息<br>Looper 负责轮询消息队列</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> handler </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2从教务系统查询成绩并计算绩点——山东建筑大学为例</title>
      <link href="/2017/06/18/2-2-grade/"/>
      <url>/2017/06/18/2-2-grade/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前两天面试时被问到绩点是多少，但学校教务系统不提供绩点查询的功能，那么能不能写一个爬虫程序并计算出绩点呢？答案是肯定的！</p></blockquote><p> <a href="http://blog.csdn.net/pleasecallmewhy/article/details/9305229" target="_blank" rel="noopener">感谢该博客提供的思路</a></p><a id="more"></a><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h3><p>HttpFox插件，是一款http协议分析插件，分析页面请求和响应的时间、内容、以及浏览器用到的COOKIE等。是火狐浏览器的插件。谷歌浏览器和Safari都有自带的分析工具，可是感觉太复杂，没有这款好用。不过火狐浏览器对学校的教务系统兼容性不是很好，我还下载了IE tab插件。<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-79a8f42d306c605c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="插件的安装"></p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-fdddcc6520d47f18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt><br>可以非常直观的查看相应的信息。<br>点击start是开始检测，点击stop暂停检测，点击clear清除内容。</p><h3 id="2-探究过程"><a href="#2-探究过程" class="headerlink" title="2. 探究过程"></a>2. 探究过程</h3><p>下面就去山东建筑大学官网登录到数字校园综合信息门户，看一看在登录的时候，到底发送了那些信息。<br>先来到登录页面，把httpfox打开，clear之后，点击start开启检测：</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-0a6c714e2c2ff3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="开启检测"><br>输入完账号密码，确保httpfox处于开启状态，然后点击登录。<br>这个时候可以看到，httpfox检测到了好多信息：<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-d757be497cda18ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="捕捉到的信息"></p><p>那么我们来分析一下这些数据</p><p>看起来红框里的两条数据比较有意思，先看看这个post</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-f72b7d8e3375dafc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="post数据"></p><p>PostData中我们看到了比较熟悉的词，username和password，学过java web的我们很清楚这段数据的含义，点击登录后将这用户名和你们提交到服务器比对。<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-2a025613cb9cd840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="重定向到这里"></p><p>可以看到这里使用get的方式在链接上以?的方式显示的加上了参数，跳转到信息门户。<br>我们的post的数据就发送到了这个地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal<br></code></pre></td></tr></table></figure><p>需要的post数据是用户名密码，也就是说我们需要输入这两种数据来模拟登录过程。</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-40ea67af08eb6ab1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="进入到教务系统"></p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-c30fa7de450e5621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="点击成绩查询"><br>进入教务系统后点击成绩查询，我们看到请求的地址为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690<br></code></pre></td></tr></table></figure><p>我们整理一下整个过程的思路。</p><ol><li>POST学号和密码—&gt;然后返回cookie的值</li><li>发送cookie给服务器—&gt;返回页面信息。</li><li>获取到成绩页面的数据，用正则表达式将成绩和学分单独取出并计算加权平均数。</li></ol><p>ok，理顺思路后剩下的就只有编码问题了。</p><h3 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h3><p>我们先来实验下是否能够获得查询成绩界面的源码</p><p>我们先准备一个POST的数据，再准备一个cookie的接收，然后写出源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># coding=utf-8<br>import urllib<br>import urllib2<br>import cookielib<br><br>cookie = cookielib.CookieJar()<br>opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))<br><br># 需要的POST数据<br>postdata = urllib.urlencode(&#123;<br>    &apos;userName&apos;: &apos;20140216064&apos;,<br>    &apos;password&apos;: &apos;*********&apos;<br>&#125;)<br># 自定义一个请求<br>req1 = urllib2.Request(<br>    url=&apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos;,<br>    data=postdata<br>)<br><br>req2 = urllib2.Request(<br>    url=&apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos;<br>)<br><br># 访问登录链接<br>opener.open(req1)<br>result = opener.open(req2)<br># 打印返回的内容<br>print result.read()<br></code></pre></td></tr></table></figure><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-c2476106a0e29a70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="运行结果"></p><p>很棒呦，看来跟我们预期的一样。</p><h3 id="4-整理数据"><a href="#4-整理数据" class="headerlink" title="4. 整理数据"></a>4. 整理数据</h3><blockquote><p>获得了成绩查询界面的源码后我们需要将数据进行整理，获得我们想要的数据，课程名称，学分，成绩。</p></blockquote><p>将网页源码贴到Sublime Text中，方便我们查看源码</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-480626d6803e99fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="分析源码"><br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-6a978cc4d4c27ba1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="分析源码"><br>通过查看源码我们看到从这个<div>开始到3640行都是关于成绩的代码，而成绩是存放在这个table标签下。<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-b1573f6441632f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="需要提取的信息"><br>红色框中分别为课程名，学分，以及成绩。这些是我们需要抽取出来的数据。<br>看到这里竟然有意外收获！注意黄色框被注释的部分，看来学校的教务系统有计算绩点的功能的，不知由于何种原因不用呢？</div></p><p>这里是这段程序中最困难的部分，我也踩了很多坑。我参照的博客是使用正则表达式来抽取想要的信息的，但我对正则表达式掌握的并不好，弄了好久也没写出合适的表达式，于是我果断放弃了使用正则表达式，采用BeautifulSoup来进行信息的筛选。<br><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">BeautifulSoup用法参考</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># 将内容从页面源码中提取出来<br>   def deal_data(self, myPage):<br><br>       soup = BeautifulSoup(myPage)<br><br>       # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签)<br>       trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;)<br><br>       # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩<br>       for tr in trs:<br>           for index, td in enumerate(tr.findAll(&apos;td&apos;)):  # enumerate能在for循环中使用下标<br><br>               if index == 3:<br>                   print td.text<br>               elif index == 7:<br>                   self.weights.append(td.text.encode(&apos;utf8&apos;))<br>                   print td.text<br>               elif index == 8:<br>                   self.points.append(td.text.encode(&apos;utf8&apos;))<br>                   print td.text<br><br>           print<br></code></pre></td></tr></table></figure><p>整个逻辑我简单说一下，我觉得还可以改进。<br>首先查找title属性为”有效成绩“的标签，通过上文的截图我们可以知道这是那个div标签，之后在该div标签中定位class为t_con的tr标签。你也许会问为什么不直接定位到tr标签，因为后面的网页代码中还存在class 为t_con的tr标签，但不是我们需要的成绩。然后在每个tr标签下抽取下标为3，7，8的标签，这里我是把它存到数组里了。<br>接下来就清晰了，先打印成绩信息，然后计算绩点。</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-f6d0aff398d0089a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="运行截图"></p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-3d48f5287d16407e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-2-grade/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="运行截图"><br>学渣一个，绩点低请忽略。</p><p>源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># encoding=utf8<br>import urllib<br>import urllib2<br>import cookielib<br>import re<br>import string<br>from BeautifulSoup import BeautifulSoup<br>import sys<br><br>reload(sys)<br>sys.setdefaultencoding(&apos;utf8&apos;)<br><br><br>class SDJZU_Crawler:<br>    # 声明相关的属性<br>    def __init__(self):<br><br>        self.loginUrl = &apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos;  # 登录的url<br>        self.resultUrl = &apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos;  # 查询成绩的url<br>        self.cookieJar = cookielib.CookieJar()  # 初始化一个CookieJar来处理Cookie的信息<br>        self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: &apos;&apos;, &apos;password&apos;: &apos;&apos;&#125;)  # 登录需要POST的数据<br>        self.weights = []  # 存储权重，也就是学分<br>        self.points = []  # 存储分数，也就是成绩<br>        self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.cookieJar))<br><br>    def sdjzu_init(self):<br>        username = raw_input(&apos;请输入学号:&apos;)  # 这里不要用input，二者区别请自行查询<br>        password = raw_input(&apos;请输入密码:&apos;)<br>        self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: username, &apos;password&apos;: password&#125;)  # 将用户名密码加入到POST中<br>        # 初始化链接并且获取cookie<br>        myRequest = urllib2.Request(url=self.loginUrl, data=self.postdata)  # 自定义一个请求<br>        result = self.opener.open(myRequest)  # 访问登录页面，获取到必须的cookie的值<br>        result = self.opener.open(self.resultUrl)  # 访问成绩页面，获得成绩的数据<br>        self.deal_data(result.read())<br>        self.calculate_gpa()<br><br>    # 将内容从页面源码中提取出来<br>    def deal_data(self, myPage):<br><br>        soup = BeautifulSoup(myPage)<br><br>        # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签)<br>        trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;)<br><br>        # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩<br>        for tr in trs:<br>            for index, td in enumerate(tr.findAll(&apos;td&apos;)):  # enumerate能在for循环中使用下标<br><br>                if index == 3:<br>                    print td.text<br>                elif index == 7:<br>                    self.weights.append(td.text.encode(&apos;utf8&apos;))<br>                    print td.text<br>                elif index == 8:<br>                    self.points.append(td.text.encode(&apos;utf8&apos;))<br>                    print td.text<br><br>            print<br><br>    # 计算绩点，如果成绩还没出来，就不算该成绩，<br>    def calculate_gpa(self):<br>        point = 0.0  # 成绩<br>        weight = 0.0  # 学分<br>        for i in range(len(self.points)):<br>            if self.points[i].isdigit() and (self.weights[i] != 0):<br>                point += string.atof(self.points[i]) * string.atof(self.weights[i])  # 成绩*学分累加求和<br>                weight += string.atof(self.weights[i])  # 学分累加求和<br><br>        print &quot;绩点为：&quot;<br>        print point / weight  # 输出绩点 值成绩*学分累加求和 / 学分累加求和<br><br><br># 调用<br>mySpider = SDJZU_Crawler()<br>mySpider.sdjzu_init()<br></code></pre></td></tr></table></figure><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">我的github地址</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1开始第一个爬虫程序</title>
      <link href="/2017/06/18/2-1-first-program/"/>
      <url>/2017/06/18/2-1-first-program/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装IDE以及hello-world"><a href="#1-安装IDE以及hello-world" class="headerlink" title="1. 安装IDE以及hello world"></a>1. 安装IDE以及hello world</h3><blockquote><p>一个优秀的IDE可以极大地提高工作效率，在这里我选择使用JetBrains公司的PyCharm。是不是有些眼熟？没错，IDEA 和Android Studio就是他们做的，JetBrains出品，必属精品。</p></blockquote><a id="more"></a><p><a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">点击进入下载链接</a></p><p>点击download选择相应平台及版本，我这里选择的是社区版。</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-752e691985633d3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-1-first-program/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="下载界面"></p><p>安装过程，切换主题，调整字体之类的都跟跟IDEA类似，不需赘述。</p><p>那么开始我们的hello world程序吧。<br>新建一个Python file ，然后写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">print (&quot;hello world&quot;)<br></code></pre></td></tr></table></figure><p>第一次运行在工作区右击 run即可</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-4ffc1a9c05699113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-1-first-program/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="右击运行"><br>之后就会在Toolbar上显示run按钮了</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-a540d17991f6282d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-1-first-program/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="运行截图"><br>很棒有木有</p><h3 id="2-1-先爬他一个网页下来"><a href="#2-1-先爬他一个网页下来" class="headerlink" title="2.1 先爬他一个网页下来"></a>2.1 先爬他一个网页下来</h3><p>敲入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">import urllib2<br><br>response = urllib2.urlopen(&quot;http://www.baidu.com&quot;)<br>print response.read()<br></code></pre></td></tr></table></figure><p>点击运行，我们可以得到结果</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-165b12f5711bcd47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-1-first-program/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这个网页的源码被我们爬下来了，是不是很简单！</p><h3 id="2-2-分析代码"><a href="#2-2-分析代码" class="headerlink" title="2.2 分析代码"></a>2.2 分析代码</h3><p>下面我们来分析下这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">import urllib2<br></code></pre></td></tr></table></figure><p>urllib2库是学习Python爬虫最基本的模块，利用这个模块我们可以得到网页的内容，并对内容用正则表达式提取分析，得到我们想要的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">response = urllib2.urlopen(&quot;http://www.baidu.com&quot;)<br></code></pre></td></tr></table></figure><p>首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，urlopen一般接受三个参数，它的参数如下：</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-f03abc16265de8dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/18/2-1-first-program/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="urlopen参数"></p><p>第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。</p><p>第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT</p><p>第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">print response.read()<br></code></pre></td></tr></table></figure><p>response对象有一个read方法，可以返回获取到的网页内容</p><h3 id="2-3-构造Request"><a href="#2-3-构造Request" class="headerlink" title="2.3 构造Request"></a>2.3 构造Request</h3><p>上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。我们可以将上面的代码改写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">import urllib2<br><br>request = urllib2.Request(&quot;http://www.baidu.com&quot;)<br>response = urllib2.urlopen(request)<br>print response.read()<br></code></pre></td></tr></table></figure><p>运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1使用函数</title>
      <link href="/2017/06/05/1-1-use-function/"/>
      <url>/2017/06/05/1-1-use-function/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们编程时很容易疲劳，所以让我们来设计一个可以在一段时间后提醒你休息的小程序。比如每隔两个小时打开<a href="http://lines.frvr.com" target="_blank" rel="noopener">http://lines.frvr.com</a> 此网站来玩一会儿小游戏。</p></blockquote><a id="more"></a><p>让我们来分析下需要哪些步骤<br>我们首先要让程序等待两个小时，在需要休息的时候打开浏览器并转到这个小游戏的网站。也许我们一天要休息多次，所以我们需要一个循环来让其实现多次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1. 等待两小时<br>2. 打开浏览器<br>重复<br></code></pre></td></tr></table></figure><p>现在，让我们开始吧~</p><p>首先让我们google一下如何用Python来打开浏览器<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-ec11c33f9934a657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/1-1-use-function/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="查询Pyhon如何打开浏览器"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">webbrowser.open(&quot;http://lines.frvr.com&quot;)<br></code></pre></td></tr></table></figure><p>可以看到上述代码可以使用默认浏览器打开指定网页。</p><p>让我们试试吧~<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-ebeadc44e9ed109a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/1-1-use-function/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="保存"><br>保存并执行</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-07994ea86762efd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/1-1-use-function/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="运行截图"></p><p>出现了错误，不过学过java的你肯定能看懂是什么原因。</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-5f2951beae5bec8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/1-1-use-function/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="修正"><br>导入webbrowser模块就可以正常运行了，不要被这个网站的小游戏吸引走哦，我们还没有结束。</p><p>下面我们看看Python如何能让程序等待2小时，为了方便测试，我们把等待时间设置为3秒</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-0690b4988c6f6ae1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/1-1-use-function/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Python让程序等待"></p><p>可以看到使用time.sleep()方法可以是程序等待一段时间执行，参数以秒为单位<br>所以我们在程序中添加以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">time.sleep(3)<br></code></pre></td></tr></table></figure><p>当然也要导入相应模块。<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-3d2bb6b60a4ff0e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/1-1-use-function/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>很简单有没有？</p><p>接下来我们来让其循环3次</p><p>输入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">import webbrowser<br>import time<br>total_breaks = 3<br>break_count = 0<br><br>print(&quot;This program started on&quot; + time.ctime())<br>while(break_count &lt; total_breaks):<br>    time.sleep(3)<br>    webbrowser.open(&quot;http://lines.frvr.com&quot;)<br>    break_count = break_count + 1<br></code></pre></td></tr></table></figure><p>代码很简单，首先我们定义了总的休息次数为3，我们又定义了已休息次数初始值为0。接下来是一个while循环，当已休息次数小于总休息次数时执行循环体。最后将已休息次数加1。</p><p>值得注意的是while循环并没有花括号。</p><p>学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。<br>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">if True:<br>    print &quot;True&quot;<br>else:<br>  print &quot;False&quot;<br></code></pre></td></tr></table></figure><p>以下代码将会执行错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">#!/usr/bin/python<br># -*- coding: UTF-8 -*-<br># 文件名：test.py<br> if True:<br>    print &quot;Answer&quot;<br>    print &quot;True&quot;<br>else:<br>    print &quot;Answer&quot;<br>    # 没有严格缩进，在执行时会报错<br>  print &quot;False&quot;<br></code></pre></td></tr></table></figure><p>执行以上代码，会出现如下错误提醒：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ python test.py  <br>  File &quot;test.py&quot;, line 5<br>    if True:<br>    ^<br>IndentationError: unexpected indent<br></code></pre></td></tr></table></figure><p> IndentationError: unexpected indent 错误是 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有 python 对格式要求非常严格。<br>如果是 IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。<br>因此，在 Python 的代码块中必须使用相同数目的行首缩进空格数。<br>建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.从零开始，Python的安装</title>
      <link href="/2017/06/05/0-indtall-python/"/>
      <url>/2017/06/05/0-indtall-python/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这学期计算机网络课程有一个课程设计，要求使用Python写一个小程序。之前也没接触过Python，从优达学城里看到一个关于Python的课程，在此记录。</p></blockquote><a id="more"></a><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p>下载地址：<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a></p><hr><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-837d626cf0404cc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/0-indtall-python/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="安装步骤1"></p><p>确保安装了 pip 并且 Python 添加到了你的 PATH。</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-1ce43800911a180c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/0-indtall-python/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-9bccbfe4b2d0e766.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/0-indtall-python/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="安装步骤2"></p><p>要检查安装是否成功，打开 IDLE（Python 安装的一款程序，使你能够轻松地编辑和运行 Python 代码）。</p><p>a) Windows 7（及更早版本）：依次点击“开始”菜单&gt;“所有程序”&gt;“Python 2.7”，最后选择 IDLE (Python GUI)。</p><p>b) Windows 8/10：搜索 IDLE。目前，你可以从屏幕右侧向左滑动或用鼠标点击屏幕的右下角进行搜索。</p><hr><h3 id="MAC安装"><a href="#MAC安装" class="headerlink" title="MAC安装"></a>MAC安装</h3><p>要在 Mac 机器上安装 Python，你可以采用两种方法：在命令行中使用 Homebrew，或在官网上找到普通的 Python 安装程序。</p><p>方法 1：程序包安装程序<br>安装地址：<a href="https://www.python.org/downloads/release/python-2713/" target="_blank" rel="noopener">https://www.python.org/downloads/release/python-2713/</a><br>检查是否安装成功</p><p>a) IDLE 应该位于您的应用程序文件夹中。<br><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-746f86c26858feec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/0-indtall-python/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt><br>b)通过按下 ⌘+空格键，打开 Spotlight ，并输入“idle”来查找 IDLE</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-327506f6845e4d77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/0-indtall-python/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt><br>以下是它在我们的计算机上运行的屏幕截图！</p><p><img class="lazyload" data-original="http://upload-images.jianshu.io/upload_images/3155702-f5b789535b05b7ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" src="/2017/06/05/0-indtall-python/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>方法 2：Homebrew<br>要通过 Homebrew 安装 Python，只需执行以下两步：</p><p>打开终端，并输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”。<br></code></pre></td></tr></table></figure><p>安装过程中，系统会多次发出提示 。<br>安装完 Homebrew 后，你可以通过在命令行中输入 brew help，验证一切是否正常。现在输入 brew install python 获取 Python 2 的最新版本。这样就可以了！</p><p>通过在命令行里输入 python 即可验证 Python 是否安装正确。系统应该欢迎你使用 Python Shell。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
