<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【背上Jetpack之ViewModel】即使您不使用MVVM也要了解ViewModel ViewModel的职能边界]]></title>
    <url>%2F2020%2F03%2F23%2F%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BViewModel%E3%80%91%E5%8D%B3%E4%BD%BF%E6%82%A8%E4%B8%8D%E4%BD%BF%E7%94%A8MVVM%E4%B9%9F%E8%A6%81%E4%BA%86%E8%A7%A3ViewModel%20ViewModel%E7%9A%84%E8%81%8C%E8%83%BD%E8%BE%B9%E7%95%8C%2F</url>
    <content type="text"><![CDATA[前言 Android 开发时，我们使用 activity 和 fragment 作为视图控制器， 可能还会使用有一些类可以存储和提供 UI 数据（例如MVP中的 Presenter ） 但是 当配置更改时（如旋转屏幕），activity 会重建，但对于 UI 数据的持有者呢？ 开发者需要重新保存相关的信息并传递给重建的 activity ，否则开发者必须再次获取数据（通过网络请求或本地数据库） 由于 UI 数据的持有者的生命周期可能比 activity 长，因此开发者还需要避免出现内存泄漏的问题 如何解决上述问题？ViewModel 本文重点介绍 ViewModel 的职责（what）以及重点功能的实现原理（how），即使您不使用 Jetpack MVVM 架构，也要了解一下 ViewModel ViewModel 的原理部分要求您了解 activity 的启动流程，这部分内容网上文章很多，本文不再赘述 ViewModel 的职责我先上个 视频 ，这个小姐姐表述的比文字更形象 ViewModel 主要用于存储 UI 数据以及生命周期感知的数据 图片来自 Android Architecture Components: ViewModel ViewModel 的生命周期 ，图片来自 官方文档 作为数据持有者ViewModel 能够实时进行配置更改。 这意味着即使在手机旋转后销毁并重新创建 activity 之后，您仍然拥有相同的 ViewModel 和相同的数据。 因此： 您无需担心 UI 数据持有者的生命周期。 ViewModel 将由工厂自动创建，您无需自行创建和销毁 数据将始终更新，旋转手机后，您将获得与以前相同的数据。 因此，您无需手动将数据传递给新的 activity 实例或再次调用网络或数据库来获取数据。 Fragment 间共享数据一个 activity 中的两个或更多 fragment 需要相互通信是很常见的。例如您有一个片段，用户在其中从列表中选择一个 item，另一个片段显示了所选 item 的内容。 传统做法两个 fragment 都需要定义一些接口，并且宿主 activity 必须将两者绑定在一起。 此外，两个 fragment 都必须处理另一个 fragment 尚未创建或不可见的情况。 可以通过使用 ViewModel 对象解决此问题。 这些 fragment 可以使用 activity 范围内共享一个 ViewModel 来处理此通信，如以下示例代码所示： 1234567891011121314151617181920212223242526272829303132333435public class SharedViewModel extends ViewModel &#123; private final MutableLiveData&lt;Item&gt; selected = new MutableLiveData&lt;Item&gt;(); public void select(Item item) &#123; selected.setValue(item); &#125; public LiveData&lt;Item&gt; getSelected() &#123; return selected; &#125;&#125;public class MasterFragment extends Fragment &#123; private SharedViewModel model; public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); model = new ViewModelProvider(requireActivity()).get(SharedViewModel.class); itemSelector.setOnClickListener(item -&gt; &#123; model.select(item); &#125;); &#125;&#125;public class DetailFragment extends Fragment &#123; public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); SharedViewModel model = new ViewModelProvider(requireActivity()).get(SharedViewModel.class); model.getSelected().observe(getViewLifecycleOwner(), &#123; item -&gt; // Update the UI. &#125;); &#125;&#125; 由于 两个 fragment 使用的都是 activity 范围的 ViewModel （ViewModelProvider 构造器传入的 activity ），因此它们获得了相同的 ViewModel 实例，自然其持有的数据也是相同的，这也 保证了数据的一致性 这种方法具有以下优点： 宿主 activity 无需执行任何操作，也无需了解此通信。 除 SharedViewModel 外，fragment 不需要彼此了解。 如果其中一个 fragment 消失了，则另一个继续照常工作。 每个 fragment 都有其自己的生命周期，并且不受另一个 fragment 的生命周期影响。 如果一个 fragment 替换了另一个 fragment，则 UI 可以继续正常工作而不会出现任何问题。 代替 LoaderCursorLoader 这样的 Loader 类经常用于使应用程序 UI 中的数据与数据库保持同步。您可以使用 ViewModel 和其他一些类来替换 Loader。 使用 ViewModel 可将视图控制器与数据加载操作分开，这意味着您在类之间的强引用较少。 在使用 Loader 的一种常见方法中，应用程序可能会使用 CursorLoader 来观察数据库的内容。 当数据库中的值更改时，加载程序会自动触发数据的重新加载并更新 UI 图片来自 官方文档 ViewModel 与 Room 和 LiveData 一起使用以替换 Loader。 ViewModel 确保数据在设备配置更改后仍然存在。 当数据库发生更改时，Room 会通知 LiveData ，然后 LiveData 会使用修改后的数据更新 UI 图片来自 官方文档 总结 ViewModel 可作为 UI 数据的持有者，在 activity/fragment 重建时 ViewModel 中的数据不受影响，同时可以避免内存泄漏 可以通过 ViewModel 来进行 activity 和 fragment ，fragment 和 fragment 之间的通信，无需关心通信的对方是否存在，使用 application 范围的 ViewModel 可以进行全局通信 可以代替 Loader ViewModel 源码分析分析源码时我们可以不计较细枝末节，只分析主要的逻辑即可。因此我们来思考几个问题，并从源码中寻找答案 如何做到 activity 重建后 ViewModel 仍然存在？ 如何做到 fragment 重建后 ViewModel 仍然存在？ 如何控制作用域？（即保证相同作用域获取的 ViewModel 实例相同） 如何避免内存泄漏？ 维持我们一贯的风格，我们先来大胆地猜一猜 对于问题1 ：activity 有着 saveInstanceState 机制，因此可能通过该机制来处理（事实证明不是） 对于问题2：可能 fragment 通过 宿主 activity 或 父 fragment 的帮助来确保 ViewModel 实例在重建后仍然存在 对于问题3：实现一个类似单例的效果，相同作用域获取的对象是相同的 对于问题4：避免 ViewModel 持有 view 或 context 的引用 首先我们要先了解一下 ViewModel 的结构 ViewModel：抽象类，主要有 clear 方法，它是 final 级，不可修改，clear 方法中包含 onClear 钩子，开发者可重写 onClear 方法来自定义数据的清空 ViewModelStore：内部维护一个 HashMap 以管理 ViewModel ViewModelStoreOwner：接口，ViewModelStore 的作用域，实现类为 ComponentActivity 和 Fragment，此外还有 FragmentActivity.HostCallbacks ViewModelProvider：用于创建 ViewModel，其构造方法有两个参数，第一个参数传入 ViewModelStoreOwner ，确定了 ViewModelStore 的作用域，第二个参数为 ViewModelProvider.Factory，用于初始化 ViewModel 对象，默认为 getDefaultViewModelProviderFactory() 方法获取的 factory 简单来说 ViewModelStoreOwner 持有 ViewModelStore 持有 ViewModel 1. 如何做到 activity 重建后 ViewModel 仍然存在？在 【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析 中我们提到了 androidx.core.app.ComponentActivity 的引入并探讨了其作为中间层的作用 我们已经讲过 SavedStateRegistryOwner 和 OnBackPressedDispatcherOwner 这两种角色，而今天我们来聊一下 ViewModelStoreOwner 和 HasDefaultViewModelProviderFactory 。其中前者代表着 ViewModelStore 的作用域，后者来标记 ViewModelStoreOwner 拥有默认的 ViewModelProvider.Factory 那么 ViewModel 的逻辑肯定就在该类了 ComponentActivity 实现了 ViewModelStoreOwner 接口，意味着需要重写 getViewModelStore() 方法，该方法为 ComponentActivity 的 mViewModelStore 变量赋值。activity 重建后 ViewModel 仍然存在，只要保证 activity 重建后 mViewModelStore 变量值不变即可 顺着这个思路，我们来看一下 getViewModelStore() 的实现 1234567891011121314public ViewModelStore getViewModelStore() &#123; if (mViewModelStore == null) &#123; NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) &#123; //核心，在该位置重置 mViewModelStore mViewModelStore = nc.viewModelStore; &#125; if (mViewModelStore == null) &#123; mViewModelStore = new ViewModelStore(); &#125; &#125; return mViewModelStore;&#125; 即 mViewModelStore 的值由 getLastNonConfigurationInstance() 返回的 NonConfigurationInstances 对象中的 viewModelStore 赋值，如果此时还为空才去 new ViewModelStore 对象。因此我们只需找到 getLastNonConfigurationInstance 中的 NonConfigurationInstances 在哪里保存的即可 getLastNonConfigurationInstance 为平台 activity 中的方法，返回 mLastNonConfigurationInstances.activity 1234public Object getLastNonConfigurationInstance() &#123; return mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.activity : null;&#125; 那么我们看一下 mLastNonConfigurationInstances 的赋值位置 12345//省略其他参数final void attach(NonConfigurationInstances lastNonConfigurationInstances)&#123; mLastNonConfigurationInstances = lastNonConfigurationInstances; //...&#125; 了解过 activity 的启动流程的小伙伴肯定知道，这个 attach 方法是 ActivityThread 中的 performLaunchActivity 调用的 1234567private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); //省略其他参数 activity.attach(r.lastNonConfigurationInstances); r.lastNonConfigurationInstances = null; //...&#125; 深入追踪源码我们整理一下调用流程 由于 ActivityThread 中的 ActivityClientRecord 不受 activity 重建的影响，所以 activity 重建时 mLastNonConfigurationInstances 能够得到上一次的值，使得 ViewModelStore 值不变 ，问题1就解决了 2. 如何做到 fragment 重建后 ViewModel 仍然存在？对于问题2，有了上面的思路我们可以认定 fragment 重建后其内部的 getViewModelStore() 方法返回的对象是相同的。 1234// Fragment.javapublic ViewModelStore getViewModelStore() &#123; return mFragmentManager.getViewModelStore(this);&#125; 可以看到 getViewModelStore() 内部调用的是 mFragmentManager（普通fragment 对应 activity 中的 FragmentManager，子 fragment 则对应父 fragment 的 childFragmentManager）的 getViewModelStore() 方法 123456// FragmentManager.javaprivate FragmentManagerViewModel mNonConfig;ViewModelStore getViewModelStore(@NonNull Fragment f) &#123; return mNonConfig.getViewModelStore(f);&#125; 而 FragmentManager 中的 getViewModelStore 使用的是 mNonConfig ，mNonConfig 竟然是个 ViewModel！ 123// FragmentManagerViewModel.javaprivate final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();private final HashMap&lt;String, ViewModelStore&gt; mViewModelStores = new HashMap&lt;&gt;(); FragmentManagerViewModel 管理着内部的 ViewModelStore 和 child 的 FragmentManagerViewModel 。因此保证 mNonConfig 值不变即能确保 fragment 中的 getViewModelStore() 不变。那么看看 mNonConfig 赋值的位置 12345678910111213141516171819202122// FragmentManager.javavoid attachController(@NonNull FragmentHostCallback&lt;?&gt; host, @NonNull FragmentContainer container, @Nullable final Fragment parent) &#123; //... if (parent != null) &#123; // 嵌套 fragment 的情况，有父 fragment mNonConfig = parent.mFragmentManager.getChildNonConfig(parent); &#125; else if (host instanceof ViewModelStoreOwner) &#123; // host 是 FragmentActivity.HostCallbacks ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore(); mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore); &#125; else &#123; mNonConfig = new FragmentManagerViewModel(false); &#125;&#125;// FragmentManagerViewModel.javastatic FragmentManagerViewModel getInstance(ViewModelStore viewModelStore) &#123; ViewModelProvider viewModelProvider = new ViewModelProvider(viewModelStore, FACTORY); return viewModelProvider.get(FragmentManagerViewModel.class);&#125; 我们先看 fragment 的直接宿主是 activity （即没有嵌套）的情况，mNonConfig 由FragmentManagerViewModel.getInstance(viewModelStore) 赋值，而 getInstance 中使用的是 ViewModelProvider 获取 ViewModel ，根据我们上面的分析，只要保证作用域（viewModelStore）相同，即可获取相同的 ViewModel 实例，因此我们需要看一下 host 的 getViewModelStore 方法。经过一番寻找，host 是 FragmentActivity.HostCallbacks 1234567// FragmentActivity.java 内部类class HostCallbacks extends FragmentHostCallback&lt;FragmentActivity&gt; implements ViewModelStoreOwner, OnBackPressedDispatcherOwner &#123; public ViewModelStore getViewModelStore() &#123; // 宿主 activity 的 getViewModelStore return FragmentActivity.this.getViewModelStore(); &#125;&#125; host 的 getViewModelStore 方法返回的是宿主 activity 的 getViewModelStore() ，而 activity 重建后其内部的 mViewModelStore 是不变的，因此即使 activity 重建，其内部的 FragmentManager 对象变化，但 FragmentManager 内部的 FragmentManagerViewModel 的实例（mNonConfig）不变，mNonConfig.getViewModelStore 不变，fragment 的 getViewModelStore() 亦不变，fragment 重建后其内部的 ViewModel 仍然存在 对于嵌套 fragment ，mNonConfig 通过 parent.mFragmentManager.getChildNonConfig(parent) 获取 1234// FragmentManager.javaprivate FragmentManagerViewModel getChildNonConfig(@NonNull Fragment f) &#123; return mNonConfig.getChildNonConfig(f);&#125; 上文提到 FragmentManagerViewModel 管理着 mChildNonConfigs Map，因此子 fragment 重置后其内部的 mNonConfig 对象也是相同的 至此问题 2 就解决了 3. 如何控制作用域？对于问题3，我们知道 ViewModelStoreOwner 代表着作用域，其内部唯一的方法返回 ViewModelStore 对象，也即不同的作用域对应不同的 ViewModelStore ，而 ViewModelStore 内部维护着 ViewModel 的 HashMap ，因此只要保证相同作用域的 ViewModelStore 对象相同就能保证相同作用域获取到相同的 ViewModel 对象，而问题1我们已经解释了重建时如何保证 ViewModelStore 对象不变。 因此问题3也解决了。 4. 如何避免内存泄漏？对于问题4，由于 ViewModel 的设计，使得 activity/fragment 依赖它，而 ViewModel 不依赖视图控制器。因此只要不让 ViewModel 持有 context 或 view 的引用，就不会造成内存泄漏 总结简单的总结一下： activity 重建后 mViewModelStore 通过 ActivityThread 的一系列方法能够保持不变，从而当 activity 重建时 ViewModel 中的数据不受影响 通过宿主 activity 范围内共享的 FragmentManagerViewModel 来存储 fragment 的 ViewModelStore 和子fragment 的 FragmentManagerViewModel ，而 activity 重建后 FragmentManagerViewModel 中的数据不受影响，因此 fragment 内部的 ViewModel 的数据也不受影响 通过同一 ViewModelStoreOwner 获取的 ViewModelStore 相同，从而保证同一作用域通过 ViewModelProvider 获取的ViewModel 对象是相同的 通过单向依赖（视图控制器持有 ViewModel ）来解决内存泄漏的问题 ViewModel 和 onSaveInstanceStateViewModel 和 onSaveInstanceState 的功能有些类似，但它们也有很多差异 从存储位置上来说，ViewModel 是在内存中，因此其读写速度更快，但当进程被系统杀死后，ViewModel 中的数据也不存在了。从数据存储的类型上来看，ViewModel 适合存储相对较重的数据，例如网络请求到的 list 数据，而 onSaveInstanceState 适合存储轻量可序列化的数据 那么我们该如何使用呢？可以使用 viewmodel-savedstate 库，详情参考 【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之ViewModel】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析]]></title>
    <url>%2F2020%2F03%2F19%2F%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BViewModel%E3%80%91%E7%BB%9D%E4%B8%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E7%8A%B6%E6%80%81%20androidx%20SaveState%20ViewModel-SaveState%20%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言 大家都知道 activity 有着一套 onSaveInstanceState-onRestoreInstanceState 状态保存机制，旨在「系统资源回收」或「配置发生变化」保存状态，为用户提供更好的体验 在 androidx 下，提供了 SavedState 库帮助 activity 和 fragment 处理状态保存和恢复 本文默认您对状态保存机制有一定了解，这部分内容请移步 Saving UI States 此外，关于 android 下的进程管理，推荐 Ian Lake 的 Who lives and who dies? Process priorities on Android 本文介绍了 androidx 下 SavedState 如何帮助 activity 和 fragment 处理状态的保存和恢复，同时介绍 viewmodel-savedstate 库，以及在开发过程中正确使用状态保存的姿势 软件工程中没有什么是中间层解决不了的在分析 SavedState 库之前我们需要简单聊一聊 ComponentActivity androidx activity 1.0.0 时，ComponentActivity 成为了 FragmentActivity 和 AppCompatActivity 的基类。 俗话说「百因必有果」，带着强烈的好奇心，我查了一下 ComponentActivity 引入的原因。 可以看到 ComponentActivity 继承了 androidx.core.app.ComponentActivity(在fragment库中)，并且最初仅实现了LifecycleOwner 接口 我们创建的 activity 的继承关系现在变成了这样： 那么回到最初的问题，为什么要引入 ComponentActivity ？其实看看现在 ComponentActivity 的类结构答案就很清楚了 ComponentActivity 实现了五个接口，代表着其除了 activity 还充当着五种角色。本着职能单一原则，官方通过建立一个中间层将部分功能分别交于专门的类来负责，OnBackPressedDispatcherOwner 就是我们讲 fragment 返回栈（【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇）时提到的结构，而其中的 SavedStateRegistryOwner 则是我们今天要讲的主角 SavedState 中的成员 SavedState引入 SavedState 1implementation "androidx.savedstate:savedstate:1.0.0" 其实您不需要显示地声明，因为 activity 库内部已经引入了。jetpack 组件依赖关系可参考 【背上Jetpack】Jetpack 主要组件的依赖及传递关系 这是一个很小的库 图片来自 Android ViewModels: State persistence — SavedState SavedStateProvider保存状态的组件，此状态将在以后恢复并使用 1234public interface SavedStateProvider &#123; @NonNull Bundle saveState();&#125; SavedStateRegistry管理 SavedStateProvider 列表的组件，此注册表绑定了其所有者的生命周期（即 activity 或 fragment）。每次创建生命周期所有者都会创建一个新的实例 创建注册表的所有者后（例如，在调用 activity 的 onCreate(savedInstanceState) 方法之后），将调用其 performRestore(state) 方法，以恢复系统杀死其所有者之前保存的任何状态。 1234567void performRestore(@NonNull Lifecycle lifecycle, @Nullable Bundle savedState) &#123; // ... if (savedState != null) &#123; mRestoredState = savedState.getBundle(SAVED_COMPONENTS_KEY); &#125; // ...&#125; 每个注册表的 SavedStateProvider 都由用于注册它的唯一密钥标识 123456789101112private SafeIterableMap&lt;String, SavedStateProvider&gt; mComponents = new SafeIterableMap&lt;&gt;();public void registerSavedStateProvider(@NonNull String key, @NonNull SavedStateProvider provider) &#123; SavedStateProvider previous = mComponents.putIfAbsent(key, provider); if (previous != null) &#123; throw new IllegalArgumentException("SavedStateProvider with the given key is already registered"); &#125;&#125;public void unregisterSavedStateProvider(@NonNull String key) &#123; mComponents.remove(key);&#125; 一旦完成注册，就可以通过consumeRestoredStateForKey(key) 来使用特定密钥的还原状态 123456789101112public Bundle consumeRestoredStateForKey(@NonNull String key) &#123; if (mRestoredState != null) &#123; Bundle result = mRestoredState.getBundle(key); //调用后就会清空，第二次调用返回null mRestoredState.remove(key); if (mRestoredState.isEmpty()) &#123; mRestoredState = null; &#125; return result; &#125; return null;&#125; 请注意，此方法检索保存的状态，然后清除其内部引用，这意味着用相同的键调用它两次将在第二次调用中返回 null 一旦注册表恢复了其保存状态，则由提供者决定是否要求其恢复的数据。 如果没有，下次注册表的所有者被系统杀死时，未使用的还原数据将再次保存到保存状态 已注册的 provider 能够在其所有者被系统杀死之前保存状态。 发生这种情况时，将调用其 Bundle saveState() 方法。 对于每个已注册的 SavedStateProvider，都可以像这样保存状态。 1savedState.putBundle(savedStateProviderKey, savedStateProvider.saveState()); performSave(outBundle) 方法的源码如下 1234567891011121314151617void performSave(@NonNull Bundle outBundle) &#123; Bundle components = new Bundle(); // 1.保存未使用的状态 if (mRestoredState != null) &#123; components.putAll(mRestoredState); &#125; // 2. 通过 SavedStateProvider 保存状态 for (Iterator&lt;Map.Entry&lt;String, SavedStateProvider&gt;&gt; it = mComponents.iteratorWithAdditions(); it.hasNext(); ) &#123; Map.Entry&lt;String, SavedStateProvider&gt; entry1 = it.next(); components.putBundle(entry1.getKey(), entry1.getValue().saveState()); &#125; // 3. 将bundle 保存到 outBundle 对象中 outBundle.putBundle(SAVED_COMPONENTS_KEY, components);&#125; 执行状态保存将所有未使用的状态与注册表提供的状态合并。 此 outBundle 是 activity 的 onSaveInstanceState 中传入的 bundle 。 SavedStateRegistryController一个包装 SavedStateRegistry 并允许通过其2个主要方法对其进行控制的组件：performRestore(savedState) 和 performSave(outBundle )。 这两个方法将内部通过 SavedStateRegistry 中的方法处理 。 12345678910111213public final class SavedStateRegistryController &#123; private final SavedStateRegistryOwner mOwner; private final SavedStateRegistry mRegistry; public void performRestore(@Nullable Bundle savedState) &#123; // ... mRegistry.performRestore(lifecycle, savedState); &#125; public void performSave(@NonNull Bundle outBundle) &#123; mRegistry.performSave(outBundle); &#125;&#125; SavedStateRegistryOwner持有 SavedStateRegistry 的组件。 默认情况下，androidx 包中的ComponentActivity 和 Fragment 都实现此接口。 1234public interface SavedStateRegistryOwner extends LifecycleOwner &#123; @NonNull SavedStateRegistry getSavedStateRegistry();&#125; Activity 的状态保存这里我们要明确一件事情，activity 保存的状态究竟都有什么？ 这部分内容可以参见 官方文档 简单来说，activity 的状态保存分为 view 状态和成员状态 默认情况下，系统使用 Bundle 实例状态来保存有关 activity 布局中每个 View 对象的信息（例如，输入到 EditText 中的文本值或 recyclerview 的滚动位置）。 因此，如果 activity 实例被销毁并重新创建，则布局状态将恢复为之前的状态，而无需您执行任何代码。（注意，需要恢复状态的 view 需要配置 id ） 这部分逻辑在 activity 中的 onSaveInstanceState 方法内实现 不同平台 onSaveInstanceState 方法的执行时机稍有不同，android P 之前 onSaveInstanceState 执行在 onStop 之前，但不限于在 onPause 之前或之后。android P 及之后该方法在 onStop 后执行 前面我们提到 ComponentActivity 实现了 SavedStateRegistryOwner ，下面我们来看一看 activity 如何利用该库来实现状态的保存与恢复 12345678910111213141516171819202122232425public class ComponentActivity extends androidx.core.app.ComponentActivity implements SavedStateRegistryOwner &#123; private final SavedStateRegistryController mSavedStateRegistryController = SavedStateRegistryController.create(this); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSavedStateRegistryController.performRestore(savedInstanceState); // ... &#125; @Override protected void onSaveInstanceState(@NonNull Bundle outState) &#123; // ... //这里先调用父类的 onSaveInstanceState 保存 view 状态 super.onSaveInstanceState(outState); mSavedStateRegistryController.performSave(outState); &#125; @NonNull @Override public final SavedStateRegistry getSavedStateRegistry() &#123; return mSavedStateRegistryController.getSavedStateRegistry(); &#125;&#125; 其内部持有 SavedStateRegistryController 的实例 mSavedStateRegistryController ，在 activity 的 onCreate 方法中 通过 controller 的 performRestore 方法来查询已保存的状态，在 onSaveInstanceState 中 使用 controller 的 performSave 方法来保存状态 除了 view 状态和成员状态，activity 还负责保存其内部的 fragment 的状态。FragmentActivity 的 onSaveInstanceState 方法有对其内部 fragment 的状态进行保存，并在 onCreate 方法中对已保存的 fragment 进行恢复。这解释了如果操作不当会导致 fragment 重叠的问题 Fragment 的状态保存androidx fragment 使用 FragmentStateManager 来处理 fragment 的状态保存 其内部有四个保存相关的方法 saveState saveBasicState saveViewState saveInstanceState 其调用链为 activity 通过 FragmentController 间接 调用 FragmentManager 的 saveAllState，接着依次调用后面的save 方法 Fragment 的状态保存可分为 view 状态，成员状态，child fragment 状态 关于 view 状态 , FragmentStateManager 提供了 saveViewSate 方法，它的调用有两处： 在 activity 或父 fragment 触发状态保存时调用，即上述流程 在 fragment 即将进入 onDestroyView 生命周期时调用，其位置在 FragmentManager moveToState 方法内部，这解释了为什么加入返回栈的 replace 操作在返回时 view 状态可以自动恢复 关于成员状态，由 activity 中的状态机制处理，即上节内容 关于 child fragment 状态，fragment 的 onCreate 方法会调用 restoreChildFragmentState 来恢复 child fragment 的状态，并在 FragmentStateManager 中的 saveBasicState 方法中 调用 performSaveInstanceState 来保存 child fragment 的状态 Viewmodel-SavedState2020-01-22，ViewModel-SavedState 1.0.0 正式版发布，02-05 发布了 2.2.0 正式版 1implementation "androidx.lifecycle:lifecycle-viewmodel-savedstate:2.2.0" 您不需要手动引入该库，因为 fragment 库以及内部引入该库 Jetpack MVVM 下 UI State 通常被 ViewModel 持有并存储，因此该模块出现了，配置该模块后，ViewModel 对象将通过其构造函数接收 SavedStateHandle 对象（键值映射），可让您保存状态并查询已保存的状态。 这些值将在系统终止进程后继续存在，并可以通过同一对象使用。 图片来自 Android ViewModels: State persistence — SavedState SavedStateHandle内部持有已保存状态 key-value 的 map，允许读取和写入状态，这些状态在应用进程被杀死后仍然存在 SavedStateHandle 通过 ViewModel 的构造器传入，下面是其主要的主要的几个方法 T get(String key) MutableLiveData getLiveData(String key) void set(String key, T value) SavedStateHandle 还包含 SavedStateProvider 的实例，用于帮助 ViewModel 的 owner 保存状态 AbstractSavedStateViewModelFactory一个实现 ViewModelFactory.KeyedFactory 的 ViewModel Factory，它会创建一个与实例化的请求的 ViewModel 关联的 SavedStateHandle 12345678910111213141516171819202122232425public abstract class AbstractSavedStateViewModelFactory extends ViewModelProvider.KeyedFactory &#123; private final SavedStateRegistry mSavedStateRegistry; // Default state used when the saved state is empty private final Bundle mDefaultArgs; @Override public final &lt;T extends ViewModel&gt; T create(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; // 读取保存的状态 Bundle restoredState = mSavedStateRegistry.consumeRestoredStateForKey(key); // 创建保存状态的 handle SavedStateHandle handle = SavedStateHandle.createHandle(restoredState, mDefaultArgs); // ... // 创建 viewModel T viewmodel = create(key, modelClass, handle); // ... return viewmodel; &#125;&#125; SavedStateViewModelFactoryAbstractSavedStateViewModelFactory 的具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041public final class SavedStateViewModelFactory extends AbstractSavedStateVMFactory &#123; public SavedStateViewModelFactory(@NonNull Application application, @NonNull SavedStateRegistryOwner owner) &#123; this(application, owner, null); &#125; public SavedStateViewModelFactory(@NonNull Application application, @NonNull SavedStateRegistryOwner owner, @Nullable Bundle defaultArgs) &#123; mSavedStateRegistry = owner.getSavedStateRegistry(); mLifecycle = owner.getLifecycle(); mDefaultArgs = defaultArgs; mApplication = application; mFactory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; public &lt;T extends ViewModel&gt; T create(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass); Constructor&lt;T&gt; constructor; if (isAndroidViewModel) &#123; constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE); &#125; else &#123; constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE); &#125; // doesn't need SavedStateHandle if (constructor == null) &#123; return mFactory.create(modelClass); &#125; SavedStateHandleController controller = SavedStateHandleController.create( mSavedStateRegistry, mLifecycle, key, mDefaultArgs); T viewmodel; if (isAndroidViewModel) &#123; viewmodel = constructor.newInstance(mApplication, controller.getHandle()); &#125; else &#123; viewmodel = constructor.newInstance(controller.getHandle()); &#125; viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller); return viewmodel; //... &#125;&#125; 工作流程 1ViewModelProvider(this).get(MyViewModel::class.java) 在 activity 中创建 ViewModel 实例，传入 this （SavedStateRegistryOwner ）作为参数，该参数可以访问其 SavedStateRegistry，如果没有传入 factory 会通过 activity 重写的 getDefaultViewModelProviderFactory 方法来获取默认的 factory 。然后 factory 将使用保存的状态， 将其包装在 SavedStateHandle 中，并将其传递给 ViewModel。 ViewModel 可以读取和写入该 handle 当 activity 的 onSaveInstanceState(outState) 方法被调用，其 SavedStateRegistry 的 performSave(outState) 方法将被执行，其内部的所有 SavedStateProvider 的 saveState 方法均被执行，一旦执行完毕，outState 就包含了已保存的状态 当 app 被重启后，activity 和新的 registry 将被创建，activity 的 onCreate(savedInstanceState) 方法会被调用，然后 registry 的 performRestore(savedInstanceState) 将被调用以便恢复之前保存的状态 状态保存的正确姿势ViewModel 构造器加入 SavedStateHandle 参数，并将想要保存的数据使用该 handle 保存 12345class WithSavedStateViewModel(private val state: SavedStateHandle) : ViewModel() &#123; private val key = "key" fun setValue(value: String) = state.set(key, value) fun getValue(): LiveData&lt;String&gt; = state.getLiveData(key)&#125; 无需重写 onSaveInstanceState/onRestoreInstanceState 方法 Demo 地址 SavedState 仅适合保存轻量级的数据，重量级操作请考虑持sp，数据库等持久化方案 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之Fragment】从源码的角度看Fragment 返回栈]]></title>
    <url>%2F2020%2F03%2F16%2F%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BFragment%E3%80%91%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BFragment%20%E8%BF%94%E5%9B%9E%E6%A0%88%2F</url>
    <content type="text"><![CDATA[前言 上一篇 我们介绍了 OnBackPressedDispather ，那么今天我们来正式地从源码的角度看看 fragment 的返回栈吧。由于其主流程和生命周期差不多，因此本文将详细地分析返回栈相关的源码，并插入大量源码。建议将生命周期流程熟悉后阅读本文。文末提供单返回栈和多返回栈的 demo 如果您对 activity 对任务栈和返回栈不是很了解，可以移步 Tasks and the Back Stack 小问号你是否有很多朋友？在分析源码之前，我们先来思考几个问题。 返回栈中的元素是什么？ 谁来管理 fragment 的返回栈？ 如何返回？ 返回栈中的元素是什么？返回栈，顾名思义，是一个栈结构。所以我们要搞清楚，这个栈结构到底存的是什么。 我们都知道，使用 fragment 的返回栈需要调用 addToBackStack(&quot;&quot;) 方法 在 从源码角度看 Fragment 生命周期 一文中，我们提到了 FragmentTransaction ，它是一个「事务」的模型，事务可以回滚到之前的状态。所以当触发返回操作时，就是将之前提交的事务进行回滚。 FragmentTransaction 的实现类为 BackStackRecord ，所以 fragment 的返回栈其实存放的就是 BackStackRecord 作为返回栈的元素，BackStackRecord 实现了FragmentManager.BackStackEntry 接口 从 BackStackRecord 的定义我们可以发现 BackStackRecord 有三种身份 继承了 FragmentTransaction，即是事务，保存了整个事务的全部操作 实现了 FragmentManager.BackStackEntry ，作为回退栈的元素 实现了OpGenerator ，可以生成 BackStackRecord 列表，后文详细介绍 谁来管理 fragment 的返回栈？我们已经知道 fragment 的返回栈其实存放的是 BackSrackRecord , 那么谁来管理 fragment 的返回栈？ FragmentManager 用于管理 fragment ，所以 fragment 返回栈也应该由 FragmentManager 管理 12//FragmentManager.javaArrayList&lt;BackStackRecord&gt; mBackStack; 其实触发 fragment 的返回逻辑有两种途径 开发主动调用 fragment 的返回方法 用户按返回键触发 后文我们会从这两个角度分析一下 fragment 中的返回栈逻辑究竟是怎样的 如何返回？我们已经知道返回栈中的元素是 BackStackRecord ，也清楚了是 FragmentManager 来管理返回栈。那么如果让我们来实现「返回」逻辑，应该如何做？ 首先我们要清楚所谓的「返回」是对事务的回滚，即 对 commit 事务的内部逻辑执行相应的「逆操作」。 例如 addFragment←→removeFragment showFragment←→hideFragment attachFragment←→detachFragment 有的小伙伴可能会疑惑 replace 呢？ expandReplaceOps 方法会把 replace 替换(目标 fragment 已经被 add )成相应的 remove 和 add 两个操作，或者(目标 fragment 没有被 add )只替换成 add 操作 popBackStack 系列方法FragmentManager 中提供了popBackStack 系列方法 是否觉得很眼熟？提交事务也有类似的api，commit 系列方法 这里分别提供了同步和异步的方法，可能有读者会疑惑，同样是对事务的操作，一个为提交，一个为回滚，为什么一个封装到了 FragmentManager 中，一个却在 FragmentTransaction 中。既然都是对事务的操作，应该都放在FragmentManager 中。我认为可能为了api使用的方便，使得 FragmentManager 开启事务的链式调用一气呵成。各位有什么想法欢迎在评论区留言。 这里主要介绍一下 popBackStack(String name, int flag) name 为 addToBackStack(String name) 的参数，通过 name 能找到回退栈的特定元素，flag可以为 0 或者FragmentManager.POP_BACK_STACK_INCLUSIVE，0 表示只弹出该元素以上的所有元素，POP_BACK_STACK_INCLUSIVE 表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。如果这么说比较抽象的话，看图 12//flag 传入0，弹出 ♥2 上的所有元素childFragmentManager.popBackStack("♥", 0) 12//flag 为 POP_BACK_STACK_INCLUSIVE 弹出包括该元素及及以上的元素childFragmentManager.popBackStack("♥", androidx.fragment.app.FragmentManager.POP_BACK_STACK_INCLUSIVE) 走进源码1. popBackStack() 逻辑在分析返回栈源码之前我们回顾一下 FragmentManager 提交事务到 fragment 各个生命周期的流程 下面我们看看 popBackStack 的源码 等等，这个 enqueueAction 有些眼熟… 看来提交事务和回滚事务的流程基本是相同的，只是传递的 action 不同 由源码可知，OpGenerator 是一个接口，其内只有一个 generateOps 方法，用于生成事务列表以及对应的该事务是否是弹出的。有两个实现类 由此可见 commit 调用的为 BackStackRecord 的 generateOps 方法，popBackStack 调用的是 PopBackStackState 中的 generateOps 前者的逻辑很简单，向 records list 中添加数据， isRecordPop list 全部传入 false 12records.add(this);isRecordPop.add(false); 后者的逻辑稍微复杂些，其内部调用了 popBackStackState 方法 如果是 popBackStack 方法 ，则将 FragmentManager 的返回栈列表（mBackStack）的栈顶移除， isRecordPop list 全部传入 true 123int last = mBackStack.size() - 1;records.add(mBackStack.remove(last));isRecordPop.add(true); 如果传入的 name 或 id 有值，且 flag 为 0，则找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置，并将该位置上方的所有 BackStackRecord 并添加到 record list 中，同时 isRecordPop list 全部传入 true 12345678910111213141516index = mBackStack.size() - 1;while (index &gt;= 0) &#123; BackStackRecord bss = mBackStack.get(index); if (name != null &amp;&amp; name.equals(bss.getName())) &#123; break; &#125; if (id &gt;= 0 &amp;&amp; id == bss.mIndex) &#123; break; &#125; index--;&#125;for (int i = mBackStack.size() - 1; i &gt; index; i--) &#123; records.add(mBackStack.remove(i)); isRecordPop.add(true);&#125; 如果传入的 name 或 id 有值，且 flag 为 POP_BACK_STACK_INCLUSIVE，则在上一条获取位置的基础上继续遍历，直至栈底或者遇到不匹配的跳出循环，接着出栈所有 BackStackRecord 123456789101112131415//index 操作与上方相同，先找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置if ((flags &amp; POP_BACK_STACK_INCLUSIVE) != 0) &#123; index--; // 继续遍历 mBackStack 直至栈底或者遇到不匹配的跳出循环 while (index &gt;= 0) &#123; BackStackRecord bss = mBackStack.get(index); if ((name != null &amp;&amp; name.equals(bss.getName())) || (id &gt;= 0 &amp;&amp; id == bss.mIndex)) &#123; index--; continue; &#125; break; &#125;&#125;//后续出栈逻辑与上方相同 可以配合上面的动图理解 入栈和出栈后续的逻辑大体是相同的，只是根据 isPop 的正负出现了分支，出栈调用的是 executePopOps 上文我们有提到，「返回」逻辑实际上就是执行提交事务内部操作逻辑的「逆操作」 那么接下的逻辑就很清晰了，根据不同的 mCmd 执行相应的逆操作 12345678910111213141516171819202122232425262728293031323334353637383940414243void executePopOps(boolean moveToState) &#123; for (int opNum = mOps.size() - 1; opNum &gt;= 0; opNum--) &#123; final Op op = mOps.get(opNum); Fragment f = op.mFragment; switch (op.mCmd) &#123; case OP_ADD: mManager.removeFragment(f); break; case OP_REMOVE: mManager.addFragment(f); break; case OP_HIDE: mManager.showFragment(f); break; case OP_SHOW: mManager.hideFragment(f); break; case OP_DETACH: mManager.attachFragment(f); break; case OP_ATTACH: mManager.detachFragment(f); break; case OP_SET_PRIMARY_NAV: mManager.setPrimaryNavigationFragment(null); break; case OP_UNSET_PRIMARY_NAV: mManager.setPrimaryNavigationFragment(f); break; case OP_SET_MAX_LIFECYCLE: mManager.setMaxLifecycle(f, op.mOldMaxState); break; default: throw new IllegalArgumentException("Unknown cmd: " + op.mCmd); &#125; if (!mReorderingAllowed &amp;&amp; op.mCmd != OP_REMOVE &amp;&amp; f != null) &#123; mManager.moveFragmentToExpectedState(f); &#125; &#125; if (!mReorderingAllowed &amp;&amp; moveToState) &#123; mManager.moveToState(mManager.mCurState, true); &#125;&#125; 后面的逻辑就完全一样了 2. fragment 是怎样拦截 activity 的返回逻辑的？在 【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇 一文中我们介绍了 OnBackPressedDispatcher activity 的 onBackPressed 的逻辑主要分为两部分，判断所有注册的 OnBackPressedCallback 是否有 enabled 的，如果有则拦截，不执行后续逻辑； 否则着执行 mFallbackOnBackPressed.run() ，其内部逻辑为调用 ComponentActivity 父类的 onBackPressed 方法 所以我们只需看 mOnBackPressedCallbacks（ArrayDeque&lt;OnBackPressedCallback） 是怎样被添加的以及 isEnabled 何时赋值为 true 经过查找我们发现它是在 FragmentManager 的 attachController 调用 addCallback 1mOnBackPressedDispatcher.addCallback(owner,mOnBackPressedCallback) 进而执行了 而 mOnBackPressedCallback 在初始化时 enabled 赋值为 false isEnadbled 会在返回栈数量大于 0 且其 mParent 为 PrimaryNavigation 时赋值为true 而返回栈（mBackStack）的赋值在 BackStackRecord 的 generateOps 方法中，且是否添加到返回栈由 mAddToBackStack 这个布尔类型的属性控制 mAddToBackStack 的赋值在 addToBackStack 方法中，这也解释了为何调用 addToBackStack 方法就能将事务加入返回栈 我们来总结一下，fragment 拦截 activity 返回栈是通过 OnBackPressedDispatcher 实现的，如果开启事务调用了 addToBackStack 方法，则 mOnBackPressedCallback 的 isEnabled 属性会赋值为 true，进而起到拦截 activity 返回逻辑的作用。拦截后执行 popBackStackImmediate 方法 而 popBackStack系列方法会调用 popBackStackState 构造 records 和 isRecordPop 列表，isRecordPop 的内部元素的值均为true 后续流程和提交事务是一样的，根据 isRecordPop 值的不同选择执行 executePopOps 或 executeOps 方法 单返回栈和多返回栈的实现Ian Lake 在 Fragments: Past, Present, and Future (Android Dev Summit ‘19) 有提到未来会提供多返回栈的 api 那么以现有的 api 如何实现多返回栈呢？ 首先我要弄清楚怎样才会有多返回栈，根据上文我们知道 FragmentManager 内部持有mBackStack list，这对应着一个返回栈，如果想要实现多返回栈，则需要多个 FragmentManager，而多 FragmentManager 则对应多个 fragment 因此我们可以创建多个宿主 frament 作为导航 fragment 这样就可以用不同的宿主 fragment 的 独立的FragmentManager 分别管理各自的返回栈，如果这样说比较抽象，可以参考下图 图中有四个返回栈，其中最外部有一个宿主 fragment ，内部有四个负责导航的 fragment 管理其内部的返回栈，外部的宿主负责协调各个返回栈为空后如何切换至其他返回栈 单返回栈就很容易了，我们只需在同一个 FragmentManager 上添加返回栈即可 详情参照 demo 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack】Fragment返回栈预备篇 OnBackPressedDispatcher]]></title>
    <url>%2F2020%2F03%2F14%2F%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BFragment%E3%80%91Fragment%E8%BF%94%E5%9B%9E%E6%A0%88%E9%A2%84%E5%A4%87%E7%AF%87%20OnBackPressedDispatcher%2F</url>
    <content type="text"><![CDATA[这两天在准备写 fragment 返回栈的文章，但是发现必须先介绍一下 OnBackPressedDispatcher ，所以这是一篇介绍 what 的文章，喜欢一手资料的可以移步 官方文档 系列文章 【背上Jetpack】Jetpack 主要组件的依赖及传递关系 【背上Jetpack】AdroidX下使用Activity和Fragment的变化 【背上Jetpack之Fragment】你真的会用Fragment吗？Fragment常见问题以及androidx下Fragment的使用新姿势 【背上Jetpack之Fragment】从源码角度看 Fragment 生命周期 AndroidX Fragment1.2.2源码分析 WhenOnBackPressedDispatcher 在 androidx activity 1.0.0 加入，旨在处理返回逻辑。您不仅可以获得在 Activity 之外处理返回键的便捷方式。 根据您的需要，您可以在任意位置定义 OnBackPressedCallback，使其可复用，或根据应用程序的架构进行任何操作。 您不再需要重写Activity 中的 onBackPressed 方法，也不必提供自己的抽象的来实现需求的代码。 WhatComponentActivity 是 FragmentActivity 和 AppCompatActivity 的基类，它使您可以通过使用其 OnBackPressedDispatcher（可以通过调用 getOnBackPressedDispatcher() ）来控制返回按钮的行为。 OnBackPressedDispatcher 控制如何将返回按钮事件分配给一个或多个OnBackPressedCallback 对象。 OnBackPressedCallback 的构造函数将布尔值用于初始启用状态。 仅当启用了回调（即 isEnabled() 返回true）时，调度程序才会调用回调的handleOnBackPressed() 来处理返回按钮事件。 您可以通过调用 setEnabled() 来更改启用状态。 回调是通过 addCallback 方法添加的。 强烈建议使用采用 LifecycleOwner 的addCallback() 方法。 这样可以确保仅在 LifecycleOwner 为 Lifecycle.State.STARTED 时才添加OnBackPressedCallback。 当关联的 LifecycleOwner 被销毁时，该 activity 会删除已注册的回调，以防止内存泄漏，并使其适用于寿命比该 activity 短的 fragment 或其他生命周期所有者。 下面是一个示例 1234567891011121314class MyFragment : Fragment() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) //此 callback 仅当 MyFragment 至少是 Started 状态下调用 val callback = requireActivity().onBackPressedDispatcher.addCallback(this) &#123; //拦截返回事件 &#125; //此 callback 可以在这里或者上面的 lambda 中开启和关闭 &#125; ...&#125; 您可以通过 addCallback() 提供多个回调。 这样做时，将按照添加回调的相反顺序调用回调，即最后添加的回调是第一个给予处理返回按钮事件的机会的回调。 例如，如果您依次添加了三个分别名为1、2和3的回调，则将分别以3、2和1的顺序调用它们。 回调遵循“责任链”模式。 仅当未启用前一个回调时，才调用链中的每个回调。 这意味着在前面的示例中，仅当未启用回调3时，才会调用回调2。 仅当未启用回调2时，才调用回调1，依此类推。 请注意，通过 addCallback() 添加回调时，直到 LifecycleOwner 进入Lifecycle.State.STARTED 状态，才将回调添加到责任链中。 强烈建议更改 OnBackPressedCallback 的启用状态以进行临时更改(即更改 isEnabled 的值)，因为它可以保持上述顺序，如果您在多个不同的嵌套生命周期所有者上注册了回调，这尤其重要。 但是，如果要完全删除 OnBackPressedCallback，则应调用 remove()。 但是，这通常不是必需的，因为在销毁关联的 LifecycleOwner 时会自动删除其回调。 Activity onBackPressed()如果您使用 onBackPressed() 处理返回按钮事件，建议您改用 OnBackPressedCallback 。 但是，如果您无法进行此更改，则适用以下规则： 当您调用 super.onBackPressed() 时，将通过 addCallback 注册的所有回调。 无论 OnBackPressedCallback 的任何注册实例，始终会调用 onBackPressed。 Demo关于 fragment 返回栈的 demo 已经写好了，感兴趣的小伙伴可以 在这 找到它。 我们下一篇再见。 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之Fragment】从源码角度看Fragment的启动流程及生命周期 基于AndroidX Fragment1.2.2]]></title>
    <url>%2F2020%2F03%2F10%2F%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BFragment%E3%80%91%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8BFragment%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%20%E5%9F%BA%E4%BA%8EAndroidX%20Fragment1.2.2%2F</url>
    <content type="text"><![CDATA[笔者看过不少源码分析类的文章，动辄贴上大段代码，这种方式很容易打断读者的思路，所以很多时候看过这类文章感叹好文好文，却感觉什么都没记住，亦或者默默加入收藏却不知何时能去细心地研读。 所以本文不会过多介绍源码的细节，更多地是抛砖引玉，如果您看过本文后能够跟着本文的思路自己翻一下源码相信您就不会有我上述的体验了。 本文默认您已对 fragment 的生命周期有所了解，并清楚fragment的缘起与职责。这部分基础内容可移步 fragment 官方文档 也即本文不会介绍 “what”，而是介绍 “how” 并且探讨一下 “why” 这里贴一下 androidx fragment 源码地址 androidx fragment 官方源码地址 本文基于 androidx fragment 1.2.2 源码分析 1implementation "androidx.fragment:fragment-ktx:1.2.2" 本文主要介绍fragment的启动流程，其他内容例如返回栈，会后续更新，敬请关注。欢迎在评论区下讨论。本文demo 既然我们都知道 “what”，不妨我们来思考一下 “how” 分析前的思考请大家思考一个问题，我们知道fragment 的生命周期是与其宿主 activity 的生命周期息息相关的，也即 activity 的每次生命周期回调都会引发每个fragment的类似回调。 那么，如果让我们来实现这样的操作，应该怎么做？ 猜测：在activity每个生命周期的节点，去操作fragment，让其执行相应的生命周期方法。 思路有了，下面进行一些细节的确认。 activity 要能操作 fragment，fragment 亦可操作 fragment，所以需要抽象出一个管理 fragment 的模型 activity 操作 fragment 的一系列动作，应该是互为可逆一组操作。例如添加 fragment 后，也应能移除 fragment activity 对 fragment 的每组操作不应是单一的，例如可以在一次操作中在 activity 不同位置添加两个 fragment，同时该操作还应满足 2 ，具有可逆性 对于第一条，我们抽象出一个可以管理 fragment 的模型，加入上下级的关系，即 activity 可管理其内部的 fragment，fragment 亦可管理其内部的 fragment。因此 fragment 同时充当着管理者与被管理者两种角色 对于后两条，相信在大学学过数据库的人会想到一种结构：事务（Transaction） 事务是指一组原子性的操作，这些操作是不可分割的整体，要么全完成，要么全不完成，完成后可以回滚到完成前的状态 因此，fragment 中两个最重要的概念出现了，FragmentManager 和 FragmentTransaction FragmentManager 封装着对 fragment 操作的各种方法，addFragment removeFragment 等等，而 FragmentActivity 通过 FragmentController 来操作 FragmentManager FragmentTransaction 封装对 fragment 容器进行的 fragment 操作，例如在容器1内添加一个 fragment，同时在容器2内替换fragment。 它们均为抽象类，需要具体的实现类。 FragmentManager 的实现类为 FragmentManagerImpl，其内部逻辑已全部移至 FragmentManager 中，是个空实现。 FragmentTransaction 的实现类为 BackStackRecord ，其内部引用了 FragmentManager 的实例 ，同时重写了父类的 四个 commit 相关的方法。 看似最简单的启动流程现在让我们看一部分代码，平时在activity中我们是这样填充一个fragment的 12345678910override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) //避免旋转屏幕等场景 fragment 重叠的问题 if (savedInstanceState == null) &#123; supportFragmentManager//步骤1 .beginTransaction()//步骤2 .add(R.id.container, BlankFragment.newInstance())//步骤3 .commitNow()//步骤4 &#125;&#125; 步骤1，实例化 FragmentManagerImpl 对象 (内部经历了一些转换，详情参见源码或查看demo注释) 步骤2，实例化 BackStackRecord对象，并在构造器中传入 FragmentManager 实例 步骤3，调用事务方法，对 fragment 容器进行相应的操作，本例表示在 id 为 container 容器内添加 BlankFragment 步骤4，提交事务，交于 FragmentManager 处理 在 terminal 敲入 adb shell setprop log.tag.FragmentManager VERBOSE 可开启FragmentManager的日志功能，过滤 FragmentManager ，日志如下： 绿色部分为笔者手动添加的log，灰色和蓝色部分为 fragment 源码中的log 根据日志显示的流程，我们的猜测看似是正确的，“在 activity 每个生命周期的节点，去操作 fragment ，让其执行相应的生命周期方法” 其实这里是有干扰的，因为我们是在activity 的 onCreate 方法里 创建并提交 FragmentTransaction ，如果在 onResume 里调用呢？ WTF！ 或许，我们的猜测有问题？看似调用 commitNow 后 fragment 的生命流程是自发进行的 那如果我们把调用挪到 onPause 呢？ 打开 activity 并按下 home 键 我知道好奇的读者会尝试在 onStop 中尝试一下，有惊喜。手动滑稽。 从这几段日志上来看，fragment 在提交事务后会自发进入自己的生命周期流程，而当其宿主 activity 生命周期发生变化时，fragment 的生命周期也跟随变化。 如果这么说比较抽象的话，我们可以看在 onPause 中显示fragment 的日志，当 Fragment 进入 onStart 生命周期后，如果是正常流程应该进入 onResume，但由于按下 home 键 activity进入onStop，fragment 也进入了 onStop 状态 因此，我们将之前的猜测进行扩展： 在activity每个生命周期的节点，去操作fragment，让其执行相应的生命周期方法 FragmentTransaction 被提交后 fragment 会进入自己的生命周期流程，但受 1 约束 那么我们的源码解读就从两个方向入手 Activity 操作 Fragment 生命周期activity 是通过 FragmentController 操作 FragmentManager 进而操作 fragment 的。 具体点就是在 activity 各个生命周期节点通过调用 FragmentController 中的各个 dispatch- 方法进而调用 FragmentManager 中的各个 dispatch- 方法 12345678910111213141516171819202122232425262728293031323334//FragmentActivity.javafinal FragmentController mFragments = FragmentController.createController(new HostCallbacks());//以下代码省略部分逻辑@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; mFragments.dispatchCreate();&#125;@Overrideprotected void onStart() &#123; mFragments.dispatchStart();&#125;//onResume 彻底执行完毕的回调@Overrideprotected void onPostResume() &#123; mFragments.dispatchResume();&#125;@Overrideprotected void onPause() &#123; mFragments.dispatchPause();&#125;@Overrideprotected void onStop() &#123; mFragments.dispatchStop();&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); mFragments.dispatchDestroy();&#125; 这样猜测 1 就被证实了 activity 会在各个生命周期节点通过 FragmentController 间接调用 FragmentManager 中的 各种 dispatch- 方法，进而影响 fragment 的生命周期 那么嵌套 fragment 呢？ 嵌套 fragment 也应该是宿主使用 FragmentManager 中的各种 dispatch- 方法，基于这个想法我们可以看一下 FragmentManager 中 dispatch- 方法的调用 可以看到这里有两处调用，第二处为activity 通过 FragmentController 间接调用，第一处使用的是 mChildFragmentManager 这里引出 fragment 中另外两个比较重要的概念，getParentFragmentManager() 和 getChildFragmentManager() 注意：requireFragmentManager() 和 getFragmentManager 已弃用 getChildFragmentManager()获取的是fragment 中的 mChildFragmentManager getParentFragmentManager() 获取的是fragment 中的 mFragmentManager mChildFragmentManager 为fragment内部的 fragmentManager 123// Private fragment manager for child fragments inside of this one.@NonNullFragmentManager mChildFragmentManager = new FragmentManagerImpl(); mFragmentManager 稍显复杂， 如果 fragment 的直接宿主是 activity ，则返回的是 activity 中的getSupportFragmentManager() 返回的 fragmentManager 如果 fragment 的直接宿主是 fragment，即该 fragment 是其他 fragment 的子 fragment，则返回的是其父 fragment 的 getChildFragmentManager 所以 嵌套fragment 的生命周期是父 fragment 在各个生命周期节点上通过 mChildFragmentManager 调用 dispatch- 以影响其子 fragment 的生命周期 这样我们第一部分的解读就告一段落了, 这里点到为止,一些细节需要您自己亲自看看源码 Fragment 的生命周期自治在 看似最简单的启动流程 一节中我们分别在 activity 的 onCreate ，onResume，onPause 中分别开启并提交事务，来观察 fragment 的生命周期日志。 在没有 activity 干扰的情况下，fragment 的生命周期是自治的。 那么我们继续思考一个问题 Fragment 的生命周期是如何一环扣一环的执行的？ 从上面的日志，我们看到很多 “moveto-” 的日志， 我们可以继续大胆地猜测，一个生命周期节点结束后调用进入另一个生命周期节点的方法 基于这个猜测，我们确认一些细节 fragment 应该有自己的状态，它可能自己管理内部的状态，也可能会有封装着状态转移的逻辑的专门管理状态的抽象 这里引出另外一个概念 FragmentStateManager FragmentStateManager 中持有 fragment 的引用 mFragment 以及 FragmentManager 的状态 mFragmentManagerState 这里fragment的状态值为： 123456static final int INITIALIZING = -1; // Not yet attached.static final int ATTACHED = 0; // Attached to the host.static final int CREATED = 1; // Created.static final int ACTIVITY_CREATED = 2; // Fully created, not started.static final int STARTED = 3; // Created and started, not resumed.static final int RESUMED = 4; // Created started and resumed. FragmentStateManager 还封装着 fragment 状态转移的方法，例如： 123456789101112void activityCreated() &#123; if (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123; Log.d(TAG, "moveto ACTIVITY_CREATED: " + mFragment); &#125; mFragment.performActivityCreated(mFragment.mSavedFragmentState);&#125;void start() &#123; if (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123; Log.d(TAG, "moveto STARTED: " + mFragment); &#125; mFragment.performStart();&#125; fragment 生命周期自治的核心逻辑封装在 FragmentManager 中的 void moveToState(@NonNull Fragment f, int newState) 内，主要代码为(精简后)： 12345678910111213141516171819202122232425262728293031323334void moveToState(@NonNull Fragment f, int newState) &#123; FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho); newState = Math.min(newState, fragmentStateManager.computeMaxState()); if (f.mState &lt;= newState) &#123; switch (f.mState) &#123; case Fragment.INITIALIZING: if (newState &gt; Fragment.INITIALIZING) &#123; fragmentStateManager.attach(mHost, this, mParent); &#125; case Fragment.ATTACHED: if (newState &gt; Fragment.ATTACHED) &#123; fragmentStateManager.create(); &#125; case Fragment.CREATED: if (newState &gt; Fragment.INITIALIZING) &#123; fragmentStateManager.ensureInflatedView(); &#125; if (newState &gt; Fragment.CREATED) &#123; fragmentStateManager.createView(mContainer); fragmentStateManager.activityCreated(); fragmentStateManager.restoreViewState(); &#125; case Fragment.ACTIVITY_CREATED: if (newState &gt; Fragment.ACTIVITY_CREATED) &#123; fragmentStateManager.start(); &#125; case Fragment.STARTED: if (newState &gt; Fragment.STARTED) &#123; fragmentStateManager.resume(); &#125; &#125; &#125;&#125; 注意：这里的switch 没有 break 细心的读者可能发现了，fragment 中的状态怎么只到 resume ，后续的状态呢？ 我们可以看一下 FragmentManager 中的 dispatchPause 方法 123void dispatchPause() &#123; dispatchStateChange(Fragment.STARTED);&#125; 为什么 dispatch 了 STARTED 的状态？其实刚刚 moveToState 方法我精简掉了一部分代码，留下的只有 f.mState &lt;= newState 的逻辑，即 dispatch 的新状态大于等于当前的状态 而现在dispatch 的新状态比当前状态值小，则走了下面的逻辑，例如当前状态为 RESUMED ，新传递的状态为 STARTED，执行了 fragmentStateManager.pause(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void moveToState(@NonNull Fragment f, int newState) &#123; FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho); newState = Math.min(newState, fragmentStateManager.computeMaxState()); if (f.mState &lt;= newState) &#123; //省略... &#125;else if (f.mState &gt; newState) &#123; switch (f.mState) &#123; case Fragment.RESUMED: if (newState &lt; Fragment.RESUMED) &#123; fragmentStateManager.pause(); &#125; case Fragment.STARTED: if (newState &lt; Fragment.STARTED) &#123; fragmentStateManager.stop(); &#125; case Fragment.ACTIVITY_CREATED: if (newState &lt; Fragment.ACTIVITY_CREATED) &#123; if (isLoggingEnabled(Log.DEBUG)) &#123; Log.d(TAG, "movefrom ACTIVITY_CREATED: " + f); &#125; if (f.mView != null) &#123; if (mHost.onShouldSaveFragmentState(f) &amp;&amp; f.mSavedViewState == null) &#123; fragmentStateManager.saveViewState(); &#125; &#125; if (mExitAnimationCancellationSignals.get(f) == null) &#123; destroyFragmentView(f); &#125; else &#123; f.setStateAfterAnimating(newState); &#125; &#125; case Fragment.CREATED: if (newState &lt; Fragment.CREATED) &#123; boolean beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack(); if (beingRemoved || mNonConfig.shouldDestroy(f)) &#123; makeInactive(fragmentStateManager); &#125; else &#123; if (f.mTargetWho != null) &#123; Fragment target = findActiveFragment(f.mTargetWho); if (target != null &amp;&amp; target.getRetainInstance()) &#123; f.mTarget = target; &#125; &#125; &#125; if (mExitAnimationCancellationSignals.get(f) != null) &#123; f.setStateAfterAnimating(newState); newState = Fragment.CREATED; &#125; else &#123; fragmentStateManager.destroy(mHost, mNonConfig); &#125; &#125; case Fragment.ATTACHED: if (newState &lt; Fragment.ATTACHED) &#123; fragmentStateManager.detach(mNonConfig); &#125; &#125; &#125;&#125; 注意：这里的switch 还是没有 break 这里有个细节，由于activity没有 onDestroyView 的生命周期，所以 FragmentController 中的 dispatchDestroyView 是没有调用的 在 activity 中的 destroy 方法中通过 fragmentController 调用了 dispatchDestroy 内部调用 dispatchStateChange(Fragment.INITIALIZING) ，而此时的fragment 的 mState 为 ACTIVITY_CREATED，所以 moveToState 方法会走到 ACTIVITY_CREATED 的 case 并执行到底 这样 fragment 最简单场景的生命周期就结束了 总结我们做一个总结：activity 和 fragment 会在各个生命周期节点通过被调用 fragment 的 parentFragmentManager（或者说父 fragment 的 childFragmentManager 和 activity 的 supportFragmentManager）中的各种 dispatch- 方法以影响子 fragment 的 生命周期，同时子 fragment 也拥有自己生命周期的调用链（从状态A转移至状态B） 不得不说 fragment 的很多 API 并不是很好用，从 androidx fragment 的更新频率也可以看出。比如 fragment 中的 view 和 fragment本身的生命周期是不一致的，存在onDestroyView 但 fragment没有销毁的情况 Ian Lake 在 Fragments: Past, Present, and Future (Android Dev Summit ‘19) 中提到未来官方会将二者合并，届时 fragment 的使用会更加简洁 这里引用 The Android Lifecycle cheat sheet — part III : Fragments 文中的图片 ，和我画的commit FragmentTransaction 的脑图（略简陋），帮您更好的理解 强烈建议您自己亲自看一看源码，不然就变为我文章开头时说的状态了。 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之Fragment】你真的会用Fragment吗？Fragment常见问题以及androidx下Fragment的使用新姿势]]></title>
    <url>%2F2020%2F03%2F02%2F%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BFragment%E3%80%91%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8Fragment%E5%90%97%EF%BC%9FFragment%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Aandroidx%E4%B8%8BFragment%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B0%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[在 Android Jetpack 组件中，fragment作为视图控制器之一占有很重要的位置。但由于其bug众多，暗坑无数，以至于 Square 有这样一篇博客：Advocating Against Android Fragments。github上的 Fragmentation 有着 9.4k 的star。 而现在，androidx fragment 稳定版已来到 1.2.2，让我们总结一下fragment有哪些常见问题以及有哪些使用fragment的新姿势 Fragment 常见的问题 getSupportFragmentManager ， getParentFragmentManager 和 getChildFragmentManager FragmentStateAdapter 和 FragmentPagerAdapter add 和 replace observe LiveData时传入 this 还是 viewLifecycleOwner 使用 simpleName 作为 fragment 的 tag 有何风险？ 在 BottomBarNavigation 和 drawer 中如何使用Fragment多次添加？ 返回栈 getSupportFragmentManager , getParentFragmentManager和getChildFragmentManager FragmentManager是 androidx.fragment.app(已弃用的不考虑)下的抽象类，创建用于 添加，移除，替换 fragment 的事务（transaction） 首先要确认一件事，getSupportFragmentManager()是 FragmentActivity下的方法 getParentFragmentManager 和 getChildFragmentManager 是 androidx.fragment.app.Fragment 下的方法，其中 androidx.fragment 1.2.0 后 getFragmentManager 与 requireFragmentManager 已弃用 明确了这件事，接下来的就很清晰了 getSupportFragmentManager与 activity关联，可以将其视为 activity 的 FragmentManager getChildFragmentManager 与 fragment关联，可以将其视为fragment的FragmentManager getParentFragmentManager情况稍微复杂，正常情况返回的是该fragment 依附的activity的FragmentManager。如果该fragment是另一个fragment 的子 fragment，则返回的是其父fragment的 getChildFragmentManager 如果这么说还不明白的话，我们可以做一个实践。 创建一个 activity,一个父fragment ，一个子fragment 1234567891011121314151617181920212223242526272829// activityclass MyActivity : AppCompatActivity(R.layout.activity_main) &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) supportFragmentManager.commit &#123; add&lt;ParentFragment&gt;(R.id.content) &#125; Log.i("MyActivity", "supportFragmentManager $supportFragmentManager") &#125;&#125;class ParentFragment : Fragment(R.layout.fragment_parent) &#123; override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) childFragmentManager.commit &#123; add&lt;ChildFragment&gt;(R.id.content) &#125; Log.i("ParentFragment", "parentFragmentManager $parentFragmentManager") Log.i("ParentFragment", "childFragmentManager $childFragmentManager") &#125;&#125;class ChildFragment : Fragment(R.layout.fragment_child) &#123; override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) Log.i("ChildFragment", "parentFragmentManager $parentFragmentManager") Log.i("ChildFragment", "childFragmentManager $childFragmentManager") &#125;&#125; 123456//logI/MyActivity: supportFragmentManager FragmentManager&#123;825dcef in HostCallbacks&#123;14a13fc&#125;&#125;&#125;I/ParentFragment: parentFragmentManager FragmentManager&#123;825dcef in HostCallbacks&#123;14a13fc&#125;&#125;&#125;I/ParentFragment: childFragmentManager FragmentManager&#123;df5de83 in ParentFragment&#123;7cdd800&#125;&#125;&#125;I/ChildFragment: parentFragmentManager FragmentManager&#123;df5de83 in ParentFragment&#123;7cdd800&#125;&#125;&#125;I/ChildFragment: childFragmentManager FragmentManager&#123;aba9afb in ChildFragment&#123;5cea718&#125;&#125;&#125; 因此 在 activity 中使用 ViewPager，BottomSheetFragment 和DialogFragment 时，都应使用 getSupportFragmentManager 在fragment 中使用 ViewPager 时应该使用getChildFragmentManager 错误的在 fragment 中使用 activity 的 FragmentManager 会引发内存泄露。 为什么呢？假如您的fragment中有一些依靠 ViewPager 管理的子 fragment，并且所有这些 fragment 都在 activity 中，因为您使用的是activity 的FragmentManager 。 现在，如果关闭您的父fragment，它将被关闭，但不会被销毁，因为所有子fragment都处于活动状态，并且它们仍在内存中，从而导致泄漏。 它不仅会泄漏父fragment，还会泄漏所有子fragment，因为它们都无法从堆内存中清除。 FragmentStateAdapter 和 FragmentPagerAdapterFragmentPagerAdapter将整个 fragment存储在内存中，如果ViewPager中使用了大量 fragment，则可能导致内存开销增加。 FragmentStatePagerAdapter仅存储片段的savedInstanceState，并在失去焦点时销毁所有 fragment。 让我们看看常见的两个问题 1. 刷新ViewPager不生效ViewPager 中的 fragment 是通过 activity或 fragment的 FragmentManager 管理的，FragmentManager 包含了viewpager的所有fragment的实例 因此，当ViewPager没有刷新时，它只是FragmentManager仍保留的旧 fragment 实例。 您需要找出为什么FragmentManger持有fragment实例的原因。 2. 在Viewpager中访问当前fragment这也是我们遇到的一个非常普遍的问题。 如果遇到这种情况，我们一般在 adapter 内部创建 fragment 的数组列表，或者尝试使用某些标签访问fragment。 不过还有另一种选择。 FragmentStateAdapter 和FragmentPagerAdapter都提供方法setPrimaryItem。 可以用来设置当前fragment，如下所示： 12345678910 var fragment: ChildFragment? = null override fun setPrimaryItem(container: ViewGroup, position: Int, any: Any) &#123; if (getChildFragment() != any) fragment = any as ChildFragment super.setPrimaryItem(container, position, any) &#125; fun getChildFragment(): ChildFragment? = fragment//usemAapter.getChildFragment() add 和 replace 如何选择？在我们的activity中，我们有一个容器，其中装有fragment。 add只会将一个fragment添加到容器中。 假设您将FragmentA和FragmentB添加到容器中。 容器将具有FragmentA和FragmentB，如果容器是FrameLayout，则将fragment一个添加在另一个之上。 replace将简单地替换容器顶部的一个fragment，因此，如果我创建了 FragmentC并 replace 顶部的 FragmentB，则FragmentB将被从容器中删除（执行onDestroy，除非您调用addToBackStack，仅执行onDestroyView），而FragmentC将位于顶部。 那么如何选择呢？ replace删除现有fragment并添加一个新fragment。 这意味着当您按下返回按钮时，将创建被替换的fragment，并调用其onCreateView。 另一方面，add保留现有fragment，并添加一个新fragment，这意味着现有fragment将处于活动状态，并且它们不会处于 “paused” 状态。 因此，按下返回按钮时，现有fragment（添加新fragment之前的fragment）不会调用onCreateView。 就fragment的生命周期事件而言，在replace的情况下将调用onPause，onResume，onCreateView和其他生命周期事件，在add的情况下则不会。 如果不需要重新访问当前fragment并且不再需要当前fragment，请使用replace。 另外，如果您的应用有内存限制，请考虑使用replace。 observe LiveData时传入 this 还是 viewLifecycleOwnerandroidx fragment 1.2.0 起，添加了新的 Lint 检查，以确保您在从 onCreateView()、onViewCreated() 或 onActivityCreated() 观察 LiveData 时使用 getViewLifecycleOwner() 使用 simpleName 作为 fragment 的 tag 有何风险？一般情况下我们会使用calss的simpleName 作为fragment 的tag 12345supportFragmentManager.commit &#123; replace(R.id.content,MyFragment.newInstance("Fragment"), MyFragment::class.java.simpleName) addToBackStack(null)&#125; 这样做不会出现什么问题，但是… 1val fragment = supportFragmentManager.findFragmentByTag(tag) 这样获取到的fragment可能不是想要的结果。 为什么呢？ 加入有两个 fragment，经过混淆，它们变成 12com.mypackage.FragmentA → com.mypackage.c.acom.mypackage.FragmentB → com.mypackage.c.a.a 上面是混淆了 full name，如果是simpleName 呢？ 12com.mypackage.FragmentA → acom.mypackage.FragmentB → a WTF！ 所以在设置tag时尽量用全名或者常量 在 BottomBarNavigation 和 drawer 中如何使用Fragment多次添加？当我们使用BottomBarNavigation和 NavigationDrawer时，通常会看到诸如fragment 重建或多次添加相同fragment之类的问题。 在这种情况下，您可以使用show / hide 而不是 add 或 replace。 返回栈如果您想在fragment的一系列跳转中按返回键返回上一个fragment，应该在commit transaction之前调用addToBackStack方法 12345//使用该扩展 androidx.fragment:fragment-ktx:1.2.0 以上parentFragmentManager.commit &#123; addToBackStack(null) add&lt;SecondFragment&gt;(R.id.content)&#125; Fragment的使用新姿势 fragment-ktx 有哪些好用的扩展函数 fragment 之间和与 activity 通信 使用 FragmentContainerView 作为 fragment 容器 FragmentFactory 的使用 Fragment 返回键拦截 Fragment 使用 ViewBinding Fragment 使用 ViewPager2 不需要重写 onCreateView 了？ 使用require_()方法 fragment-ktx 有哪些好用的扩展函数1. FragmentManagerKt12345678910//beforesupportFragmentManager .beginTransaction() .add(R.id.content,Fragment1()) .commit()//aftersupportFragmentManager.commit &#123; add&lt;Fragment1&gt;(R.id.content)&#125; 2. FragmentViewModelLazyKt1234567891011//before//共享范围activityval mViewMode1l = ViewModelProvider(requireActivity()).get(UpdateAppViewModel::class.java)//共享范围fragment 内部val mViewMode1l = ViewModelProvider(this).get(UpdateAppViewModel::class.java)//after//共享范围activityprivate val mViewModel by activityViewModels&lt;MyViewModel&gt;()//共享范围fragment 内部private val mViewModel by viewModel&lt;MyViewModel&gt;() 注意：ViewModelProviders.of(this).get(MyViewModel.class); 的方式已弃用 lifecycle-extensions 依赖包已弃用 fragment 之间和与 activity 通信fragment 和 fragment之间，fragment 和 activity 之间的通信有很多方法，android jetpack 推荐我们使用 ViewModel + LiveData 处理 同一个activity 内的 fragment 之间通信，可以使用作用范围为activity的ViewModel，activity与 fragment通信同理。详情可移步 Android官方应用架构指南 使用 FragmentContainerView 作为 fragment 容器过去我们使用 FrameLayout 作为 Fragment 的容器，在 AndroidX Fragment 1.2.0 后，可以使用 FragmentContainerView 代替 Fragment 。 它修复了一些动画 z轴索引顺序问题和窗口插入调度，这意味着两个fragment之间的退出和进入过渡不会互相重叠。使用FragmentContainerView将先开启退出动画然后才是进入动画。 FragmentContainerView 是专门为 fragment设计的自定义View，它继承自 FrameLayout android:name 属性允许您添加fragment，android:tag 属性可以为fragment设置tag 123456789&lt;androidx.fragment.app.FragmentContainerView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/fragment_container_view" android:layout_width="match_parent" android:layout_height="match_parent" android:name="com.example.MyFragment" android:tag="my_tag"&gt;&lt;/androidx.fragment.app.FragmentContainerView&gt; FragmentFactory 的使用过去，我们只能使用其默认的空构造函数实例化Fragment实例。 这是因为在某些情况下，例如配置更改和应用程序的流程重新创建，系统需要重新初始化。 如果不是默认的构造方法，系统将不知道如何重新初始化Fragment实例。 创建FragmentFactory来解决此限制。 通过向其提供实例化Fragment所需的必要参数/依赖关系，它可以帮助系统创建Fragment实例。 过去我们实例化fragment并传递参数会使用类似下面的代码 123456789101112131415161718class MyFragment : Fragment() &#123; private lateinit var arg: String override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) arguments?.getString(ARG) ?: "" &#125; companion object &#123; fun newInstance(arg: String) = MyFragment().apply &#123; arguments = Bundle().apply &#123; putString(ARG, arg) &#125; &#125; &#125;&#125;//useval fragment = MyFragment.newInstance("my argument") 如果您的Fragment有一个非空的构造函数，则需要创建一个FragmentFactory来处理它的初始化。 12345678class MyFragmentFactory(private val arg: String) : FragmentFactory() &#123; override fun instantiate(classLoader: ClassLoader, className: String): Fragment &#123; if (className == MyFragment::class.java.name) &#123; return MyFragment(arg) &#125; return super.instantiate(classLoader, className) &#125;&#125; fragment由FragmentManager 管理，因此很自然，FragmentFactory需要添加到FragmentManager才能使用。 那么什么时候把FragmentFactory 添加到FragmentManager呢？ 父类调用 Activity#onCreate() 和 Fragment#onCreate()之前 12345678910111213141516171819class HostActivity : AppCompatActivity() &#123; private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) &#123; supportFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) // ... &#125;&#125;class ParentFragment : Fragment() &#123; private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) &#123; childFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) // ... &#125;&#125; 如果您的Fragment具有默认的空构造函数，则无需使用FragmentFactory。 但是，如果您的Fragment在其构造函数中接受参数，则必须使用FragmentFactory，否则将抛出Fragment.InstantiationException，因为将使用的默认FragmentFactory将不知道如何实例化Fragment的实例。 Fragment 返回键拦截有时候，您需要阻止用户返回上一级。 在这种情况下，您需要在 Activity 中重写 onBackPressed() 方法。 但是，当您使用 Fragment 时，没有直接的方法来拦截返回。 在 Fragment 类中没有可用的 onBackPressed() 方法，这是为了防止同时存在多个 Fragment 时发生意外行为。 但是，从 AndroidX Activity 1.0.0 开始，您可以使用 OnBackPressedDispatcher 在您可以访问该 Activity 的代码的任何位置（例如，在 Fragment 中）注册 OnBackPressedCallback。 1234567891011class MyFragment : Fragment() &#123; override fun onAttach(context: Context) &#123; super.onAttach(context) val callback = object : OnBackPressedCallback(true) &#123; override fun handleOnBackPressed() &#123; // Do something &#125; &#125; requireActivity().onBackPressedDispatcher.addCallback(this, callback) &#125;&#125; Fragment 使用 ViewBindingAndroid Studio 3.6.0 后提供了 ViewBindind的支持，完整使用流程参见 [译]深入研究ViewBinding 在 include, merge, adapter, fragment, activity 中使用 123456789101112class HomeFragment : Fragment() &#123; private var _binding: FragmentHomeBinding? = null private val binding get() = _binding!! override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; _binding = FragmentHomeBinding.inflate(inflater, container, false) return binding.root &#125; override fun onDestroyView() &#123; _binding = null &#125;&#125; Fragment 使用 ViewPager2ViewPager使用了三个adapter的抽象类，而ViewPager2中只有两个 ViewPager 中使用 PagerAdaper，ViewPager2 中使用 Recyclerview.Adapter ViewPager 中使用 FragmentPagerAdapter ，ViewPager2中使用 FragmentStateAdapter ViewPager 中使用 FragmentStatePagerAdapter ，ViewPager2中使用 FragmentStateAdapter 12345678910111213// A simple ViewPager adapter class for paging through fragmentsclass ScreenSlidePagerAdapter(fm: FragmentManager) : FragmentStatePagerAdapter(fm) &#123; override fun getCount(): Int = NUM_PAGES override fun getItem(position: Int): Fragment = ScreenSlidePageFragment()&#125;// An equivalent ViewPager2 adapter classclass ScreenSlidePagerAdapter(fa: FragmentActivity) : FragmentStateAdapter(fa) &#123; override fun getItemCount(): Int = NUM_PAGES override fun createFragment(position: Int): Fragment = ScreenSlidePageFragment()&#125; 使用 TabLayout的变化，TabLayout 已从ViewPager2中解耦，如果使用TabLayout，需要引入依赖 1implementation "com.google.android.material:material:1.1.0" 对于ViewPager2 ，TabLayout布局应与ViewPager2在同一级别 1234567891011121314151617181920212223242526272829303132&lt;!-- A ViewPager element with a TabLayout --&gt;&lt;androidx.viewpager.widget.ViewPager xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/pager" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;com.google.android.material.tabs.TabLayout android:id="@+id/tab_layout" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;&lt;/androidx.viewpager.widget.ViewPager&gt;&lt;!-- A ViewPager2 element with a TabLayout --&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;com.google.android.material.tabs.TabLayout android:id="@+id/tab_layout" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;androidx.viewpager2.widget.ViewPager2 android:id="@+id/pager" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" /&gt;&lt;/LinearLayout&gt; 使用ViewPager时，TabLayout与ViewPager联动需要调用 setupWithViewPager，并重写getPageTitle方法，而ViewPager2改为使用TabLayoutMediator对象 12345678910111213141516171819202122232425262728293031// Integrating TabLayout with ViewPagerclass CollectionDemoFragment : Fragment() &#123; ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; val tabLayout = view.findViewById(R.id.tab_layout) tabLayout.setupWithViewPager(viewPager) &#125; ...&#125;class DemoCollectionPagerAdapter(fm: FragmentManager) : FragmentStatePagerAdapter(fm) &#123; override fun getCount(): Int = 4 override fun getPageTitle(position: Int): CharSequence &#123; return "OBJECT $&#123;(position + 1)&#125;" &#125; ...&#125;// Integrating TabLayout with ViewPager2class CollectionDemoFragment : Fragment() &#123; ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; val tabLayout = view.findViewById(R.id.tab_layout) TabLayoutMediator(tabLayout, viewPager) &#123; tab, position -&gt; tab.text = "OBJECT $&#123;(position + 1)&#125;" &#125;.attach() &#125; ...&#125; 不需要重写 onCreateView 了？androidx fragment 1.1.0 后，您可以使用将 layoutId 作为参数的构造函数，这样就无需重写 onCreateView 方法了 123class MyActivity : AppCompatActivity(R.layout.my_activity)class MyFragmentActivity: FragmentActivity(R.layout.my_fragment_activity)class MyFragment : Fragment(R.layout.my_fragment) 使用require_()方法androidx fragment 1.2.2 起，新增了一项lint检查，fragment 建议使用关联的require_()方法获取更多描述性错误消息，而不是使用checkNotNull(get_())，requireNonNull(get_()) 或get()！ 适用于所有包含 get 和 require Fragment API 例如：使用 requireActivity() 替代 getActivity()]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack】AdroidX下使用Activity和Fragment的变化]]></title>
    <url>%2F2020%2F02%2F29%2F%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E3%80%91AdroidX%E4%B8%8B%E4%BD%BF%E7%94%A8Activity%E5%92%8CFragment%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原文：How AndroidX changes the way we work with Activities and Fragments 作者：Miłosz Lewandowski 译者：Fly_with24 过去的一段时间，AndroidX 软件包下的 Activity/Fragmet 的 API 发生了很多变化。让我们看看它们是如何提升Android 的开发效率以及如何适应当下流行的编程规则和模式。 本文中描述的所有功能现在都可以在稳定的 AndroidX 软件包中使用，它们在去年均已发布或移至稳定版本。 在构造器中传入布局 ID从 AndroidX AppCompat 1.1.0 和 Fragment 1.1.0 ( 译者注：AppCompat 包含 Fragment，且 Fragment 包含 Activity，详情见【整理】Jetpack 主要组件的依赖及传递关系 )开始，您可以使用将 layoutId 作为参数的构造函数： 123class MyActivity : AppCompatActivity(R.layout.my_activity)class MyFragmentActivity: FragmentActivity(R.layout.my_fragment_activity)class MyFragment : Fragment(R.layout.my_fragment) 这种方法可以减少 Activity/Fragment 中方法重写的数量，并使类更具可读性。 无需在 Activity 中重写 onCreate() 即可调用 setContentView() 方法。 另外，无需手动在Fragment 中重写 onCreateView 即可手动调用 Inflater 来扩展视图。 扩展 Activity/Fragment 的灵活性借助 AndroidX 新的 API ，可以减少在 Activity/Fragment 处理某些功能的情况。通常，您可以获取提供某些功能的对象并向其注册您的处理逻辑，而不是重写 Activity / Fragment 中的方法。 这样，您现在可以在屏幕上组成几个独立的类，获得更高的灵活性，复用代码，并且通常在不引入自己的抽象的情况下，对代码结构具有更多控制。 让我们看看这在两个示例中如何工作。 1. OnBackPressedDispatcher有时，您需要阻止用户返回上一级。 在这种情况下，您需要在 Activity 中重写 onBackPressed() 方法。 但是，当您使用 Fragment 时，没有直接的方法来拦截返回。 在 Fragment 类中没有可用的 onBackPressed() 方法，这是为了防止同时存在多个 Fragment 时发生意外行为。 但是，从 AndroidX Activity 1.0.0 开始，您可以使用 OnBackPressedDispatcher 在您可以访问该 Activity 的代码的任何位置（例如，在 Fragment 中）注册 OnBackPressedCallback。 1234567891011class MyFragment : Fragment() &#123; override fun onAttach(context: Context) &#123; super.onAttach(context) val callback = object : OnBackPressedCallback(true) &#123; override fun handleOnBackPressed() &#123; // Do something &#125; &#125; requireActivity().onBackPressedDispatcher.addCallback(this, callback) &#125;&#125; 您可能会在这里注意到另外两个有用的功能： OnBackPressedCallback 的构造函数中的布尔类型的参数有助于根据当前状态动态 打开/关闭按下的行为 addCallback() 方法的可选第一个参数是 LifecycleOwner，以确保仅在您的生命周期感知对象（例如，Fragment）至少处于 STARTED 状态时才使用回调。 通过使用 OnBackPressedDispatcher ，您不仅可以获得在 Activity 之外处理返回键的便捷方式。 根据您的需要，您可以在任意位置定义 OnBackPressedCallback，使其可复用，或根据应用程序的架构进行任何操作。 您不再需要重写Activity 中的 onBackPressed 方法，也不必提供自己的抽象的来实现需求的代码。 2. SavedStateRegistry如果您希望 Activity 在终止并重启后恢复之前的状态，则可能要使用 saved state 功能。 过去，您需要在 Activity 中重写两个方法：onSaveInstanceState 和 onRestoreInstanceState。 您还可以在 onCreate 方法中访问恢复的状态。 同样，在 Fragment 中，您可以使用onSaveInstanceState 方法（并且可以在 onCreate，onCreateView 和onActivityCreated方法中恢复状态）。 从 AndroidX SavedState 1.0.0（它是 AndroidX Activity 和 AndroidX Fragment 内部的依赖。译者注：您不需要单独声明它）开始，您可以访问 SavedStateRegistry，它使用了与前面描述的 OnBackPressedDispatcher 类似的机制：您可以从 Activity / Fragment 中获取 SavedStateRegistry，然后 注册您的 SavedStateProvider： 12345678910111213141516171819202122232425262728class MyActivity : AppCompatActivity() &#123; companion object &#123; private const val MY_SAVED_STATE_KEY = "my_saved_state" private const val SOME_VALUE_KEY = "some_value" &#125; private lateinit var someValue: String private val savedStateProvider = SavedStateRegistry.SavedStateProvider &#123; Bundle().apply &#123; putString(SOME_VALUE_KEY, someValue) &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) savedStateRegistry .registerSavedStateProvider(MY_SAVED_STATE_KEY, savedStateProvider) &#125; fun someMethod() &#123; someValue = savedStateRegistry .consumeRestoredStateForKey(MY_SAVED_STATE_KEY) ?.getString(SOME_VALUE_KEY) ?: "" &#125;&#125; 如您所见，SavedStateRegistry 强制您将密钥用于数据。 这样可以防止您的数据被 attach 到同一个 Activity/Fragment的另一个 SavedStateProvider 破坏。 就像在 OnBackPressedDispatcher 中一样，您可以例如将 SavedStateProvider 提取到另一个类，通过使用所需的任何逻辑使其与数据一起使用，从而在应用程序中实现清晰的保存状态行为。 此外，如果您在应用程序中使用 ViewModel，请考虑使用 AndroidX ViewModel-SavedState 使你的ViewModel 可以保存其状态。 为了方便起见，从 AndroidX Activity 1.1.0 和 AndroidX Fragment 1.2.0 开始，启用 SavedState 的SavedStateViewModelFactory 是在获取 ViewModel 的所有方式中使用的默认工厂：委托 ViewModelProvider 构造函数和 ViewModelProviders.of() 方法。 FragmentFactoryFragment 最常提及的问题之一是不能使用带有参数的构造函数。 例如，如果您使用 Dagger2 进行依赖项注入，则无法使用 Inject 注解 Fragment 构造函数并指定参数。 现在，您可以通过指定 FragmentFactory 类来减少 Fragment 创建过程中的类似问题。 通过在 FragmentManager 中注册 FragmentFactory，可以重写实例化 Fragment 的默认方法： 1234567891011121314class MyFragmentFactory : FragmentFactory() &#123; override fun instantiate(classLoader: ClassLoader, className: String): Fragment &#123; // Call loadFragmentClass() to obtain the Class object val fragmentClass = loadFragmentClass(classLoader, className) // Now you can use className/fragmentClass to determine your prefered way // of instantiating the Fragment object and just do it here. // Or just call regular FragmentFactory to instantiate the Fragment using // no arguments constructor return super.instantiate(classLoader, className) &#125;&#125; 如您所见，该API非常通用，因此您可以执行想要创建 Fragment 实例的所有操作。 回到 Dagger2 示例，例如，您可以注入FragmentFactory Provider &lt;Fragment&gt; 并使用它来获取 Fragment 对象。 测试 Fragment从AndroidX Fragment 1.1.0 开始，可以使用 Fragment 测试组件提供 FragmentScenario 类，该类可以帮助在测试中实例化 Fragment 并进行单独测试： 12345678910111213141516// To launch a Fragment with a user interface:val scenario = launchFragmentInContainer&lt;FirstFragment&gt;() // To launch a headless Fragment:val scenario = launchFragment&lt;FirstFragment&gt;() // To move the fragment to specific lifecycle state:scenario.moveToState(CREATED)// Now you can e.g. perform actions using Espresso:onView(withId(R.id.refresh)).perform(click())// To obtain a Fragment instance:scenario.onFragment &#123; fragment -&gt; ...&#125; More Kotlin!很高兴看到 -ktx AndroidX 软件包中提供了许多有用的 Kotlin 扩展方法，并且定期添加了新的方法。 例如，在AndroidX Fragment-KTX 1.2.0 中，使用片段化类型的扩展名可用于 FragmentTransaction 上的 replace() 方法。 将其与 commit() 扩展方法结合使用，我们可以获得以下代码： 12345678910// BeforesupportFragmentManager .beginTransaction() .add(R.id.container, MyFragment::class.java, null) .commit()// AftersupportFragmentManager.commit &#123; replace&lt;MyFragment&gt;(R.id.container)&#125; FragmentContainerView一件小而重要的事情。 如果您将 FrameLayout 用作 Fragment 的容器，则应改用 FragmentContainerView 。 它修复了一些动画 z轴索引顺序问题和窗口插入调度。 从 AndroidX Fragment 1.2.0 开始可以使用 FragmentContainerView。 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【重学Android读书笔记】Activity的任务栈与返回栈]]></title>
    <url>%2F2019%2F11%2F29%2F%E3%80%90%E9%87%8D%E5%AD%A6Android%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Activity%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88%2F</url>
    <content type="text"><![CDATA[订阅 重学安卓 很久了，最近在整理读书笔记，在此记录之。 在此隆重推荐这位大佬 KunMinX 本文记录Activity任务栈与返回栈相关内容的疑问与探索 该专栏的代码地址： https://github.com/KunMinX/Relearn-Android 疑惑产生根据大佬的代码以及文章描述，有个地方让我很疑惑。 我这里没有过滤当前使用的app，所以app1和app2产生的日志都显示了出来。 大佬在评论区关于此的回答 KunMinX #40 #2楼 @Sky63大概明白你提到的、造成困扰的地方了。D 和 C 是由 app1 启动，在 IDE 中可通过 app1 的视角观察到。同理，当 app2 的 B 唤起 D 时，你在回退 D 的时候能在 app2 和 app1 的视角中同时观察到 D 的销毁。而紧随其后再回退一次， 便能在 app1 中观察到 C 被销毁。再下一次才轮到 app2 中 B 被销毁。 但是根据我操作看到的现象，D的销毁不是在不同app视角观察到的同一次销毁。通过上图可以看出两次销毁是有时间差的，而且经过我的二次确认，的确是关闭两次界面才出现了两次销毁Log。 问题排查通过 adb shell 中的 dumpsys activity activities 命令可以查看 activity 栈信息，故我截取了相关的输出，以下堆栈信息均经过精简。 1. app1 依次打开 SingleTaskOne SingleTaskTwo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364➜ Relearn-Android (master) adb shellsagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #2: type=standard mode=fullscreen Task id #3 Running activities (most recent first): TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; mResumedActivity: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; mLastPausedActivity: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; Stack #1: type=standard mode=fullscreen Task id #2 Running activities (most recent first): TaskRecord&#123;d91b3e8 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125; Run #1: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Run #0: ActivityRecord&#123;d76e9a5 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125; mLastPausedActivity: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;94a7a01 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; ResumedActivity:ActivityRecord&#123; 93c0c72u0com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks &#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks &#125; mCurTaskIdForUser=&#123;0=3&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=3 mHomeStack=ActivityStack&#123; 76ebae7 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks &#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 此时看到堆栈顺序为：Stack #2 -&lt; Stack #1 -&lt; Stack #0 其中 Stack #0 为 launcher 获取焦点的 ActivityStack： 1234mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; 2. 按下HOME键，打开 app2 依次打开 StandardOneActivity StandardTwoActivity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Display #0 (activities from top to bottom): Stack #3: type=standard mode=fullscreen Task id #4 Running activities (most recent first): TaskRecord&#123;718157f #4 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; Run #2: ActivityRecord&#123;648188e u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #1: ActivityRecord&#123;f39ebe9 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #0: ActivityRecord&#123;f02fff8 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t4&#125; mResumedActivity: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; mLastPausedActivity: ActivityRecord&#123;648188e u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;2094d95 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;a7fed1a u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;a7fed1a u0 com.miui.home/.launcher.Launcher t1&#125; Stack #2: type=standard mode=fullscreen Task id #3 Running activities (most recent first): TaskRecord&#123;9d79eaa #3 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;15d3e09 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;20d177c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; mLastPausedActivity: ActivityRecord&#123;15d3e09 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Stack #1: type=standard mode=fullscreen isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #2 Running activities (most recent first): TaskRecord&#123;e526e38 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125; Run #1: ActivityRecord&#123;19055b2 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Run #0: ActivityRecord&#123;5a647a6 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125; mLastPausedActivity: ActivityRecord&#123;19055b2 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; ResumedActivity: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; mFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=4&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123;968fb76 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 这里的堆栈顺序为 Stack #3 -&lt; Stack #0 -&lt; Stack #2 -&lt; Stack #1 Stack #0 为home ，这里反应出点击home键，打开app2 的操作。此时 Stack #3 中有 4 个 ActivityRecord 当前获取焦点的 ActivityStack 12345 mFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=4&#125; 3. 接下来启动 SingleTaskTwoActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172sagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #2: type=standard mode=fullscreen Task id #3 Running activities (most recent first): TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=3&#125; Run #2: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; mResumedActivity: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Stack #3: type=standard mode=fullscreen Task id #4 Running activities (most recent first): TaskRecord&#123;f14a51a #4 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;1838862 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; Run #2: ActivityRecord&#123;bdb3180 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #1: ActivityRecord&#123;7b21450 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #0: ActivityRecord&#123;ff57abb u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t4&#125; mLastPausedActivity: ActivityRecord&#123;1838862 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;94a7a01 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; Stack #1: type=standard mode=fullscreen Task id #2 Running activities (most recent first): TaskRecord&#123;d91b3e8 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125; Run #1: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Run #0: ActivityRecord&#123;d76e9a5 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125; mLastPausedActivity: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; ResumedActivity: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=4&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123; 76ebae7 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 当前的堆栈顺序 Stack #2 -&lt; Stack #3 -&lt; Stack #0 -&lt;Stack #1 当前获取焦点的 ActivityStack 12345mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;mCurTaskIdForUser=&#123;0=4&#125; Stack #2 中 TaskRecord信息为 1234TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=3&#125; Run #2: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; 解惑关键的地方来了 的确有两个 SingleTaskTwoActivity 的 ActivityRecord ，栈顶的属于 app2 第二个属于 app1 由此看出这两个ActivityRecord 不是一个实例，所以这里 app2 启动的 SingleTaskTwoActivity 应该是 app2 自己的activity 废话不说，翻代码！这里截取了 BaseTaskActivity 中的部分代码，app1 和 app2中的 activity 都继承了BaseTaskActivity 12345678910111213141516171819202122232425262728293031323334353637383940@Override public void onClick(View v) &#123; int i = v.getId(); if (i == R.id.btn_standard_one) &#123; Intent intent = new Intent(this, StandardOneActivity.class); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_standard_two) &#123; Intent intent = new Intent(this, StandardTwoActivity.class); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_singletask_one) &#123; Intent intent = new Intent(this, SingleTaskOneActivity.class); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_singletask_two) &#123; Intent intent = new Intent(this, SingleTaskTwoActivity.class); startActivityWithCheck(intent); //以下测试结果证实： //1.在 App2 中启动 App1 的 standard Activity，仍然遵守 standard 的特点：在启动它的 Activity 所在的任务中启动，也即跟随 App2。 //2.在 App2 中启动 App1 的 singleTop Activity，跟随状况同 standard。 //3.在 App2 中启动 App1 的 singleTask Activity，仍然处于 App1 的任务中，并不跟随 App2。 &#125; else if (i == R.id.btn_singletask_a) &#123; Intent intent = new Intent(); ComponentName name = new ComponentName( "com.kunminx.relearn_android", "com.kunminx.relearn_android.SingleTaskAActivity"); intent.setComponent(name); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_singletask_b) &#123; Intent intent = new Intent(); ComponentName name = new ComponentName( "com.kunminx.relearn_android", "com.kunminx.relearn_android.SingleTaskBActivity"); intent.setComponent(name); startActivityWithCheck(intent); &#125; 可以看出这里 app2 启动SingleTaskTwoActivity 的确是自己的 activity 那么它为什么和app1 中的 SingleTaskTwoActivity 是同一个 TaskRecord 呢？ 12345678&lt;activity android:name=".test03_task_test.SingleTaskOneActivity" android:launchMode="singleTask" android:taskAffinity="com.kunminx.task.c" /&gt;&lt;activity android:name=".test03_task_test.SingleTaskTwoActivity" android:launchMode="singleTask" android:taskAffinity="com.kunminx.task.c" /&gt; 它们有着共同的 taskAffinity。至此，我的疑惑已经得到了答案。 拓展我试了以下 app2 中启动 app1 中的Activity的情况 app1 依次启动 StandardOneActivity -&lt; SingleTaskOneActivity -&lt; SingleTaskTwoActivity -&lt; SingleTaskAActivity 其中 SingleTaskOneActivity 与 SingleTaskTwoActivity 设置了相同的 taskAffinity ,StandardOneActivity 与 SingleTaskAActivity 未设置 taskAffinity 接着按 HOME 键，打开 app2 ，依次打开 StandardOneActivity -&lt; StandardOneActivity -&lt; StandardTwoActivity 此时堆栈信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768➜ Relearn-Android (master) adb shellsagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #3: type=standard mode=fullscreen isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #48 Running activities (most recent first): TaskRecord&#123;3b07175 #48 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; Run #2: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #1: ActivityRecord&#123;71254 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #0: ActivityRecord&#123;7c135cf u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t48&#125; mResumedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; mLastPausedActivity: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Stack #0: type=home mode=fullscreen Running activities (most recent first): TaskRecord&#123;185017b #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; Stack #1: type=standard mode=fullscreen Task id #46 Running activities (most recent first): TaskRecord&#123;c374b98 #46 A=com.kunminx.relearn_android U=0 StackId=1 sz=3&#125; Run #2: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Run #1: ActivityRecord&#123;bb0363c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t46&#125; Run #0: ActivityRecord&#123;510711c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t46&#125; mLastPausedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Stack #2: type=standard mode=fullscreen Task id #47 Running activities (most recent first): TaskRecord&#123;3387d6 #47 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; Run #0: ActivityRecord&#123;e9850ca u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t47&#125; mLastPausedActivity: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; ResumedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; mFocusedStack=ActivityStack&#123;ed83a57 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123;ed83a57 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=48&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123;a218944 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 最后在 app2 中启动 app1 的 SingleTaskAActivity 此时堆栈信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465➜ Relearn-Android (master) adb shellsagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #1: type=standard mode=fullscreen Task id #46 Running activities (most recent first): TaskRecord&#123;c374b98 #46 A=com.kunminx.relearn_android U=0 StackId=1 sz=3&#125; Run #2: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Run #1: ActivityRecord&#123;bb0363c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t46&#125; Run #0: ActivityRecord&#123;510711c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t46&#125; mResumedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Stack #3: type=standard mode=fullscreen Task id #48 Running activities (most recent first): TaskRecord&#123;3b07175 #48 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; Run #2: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #1: ActivityRecord&#123;71254 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #0: ActivityRecord&#123;7c135cf u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t48&#125; mLastPausedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;185017b #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; Stack #2: type=standard mode=fullscreen Task id #47 Running activities (most recent first): TaskRecord&#123;3387d6 #47 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; Run #0: ActivityRecord&#123;e9850ca u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t47&#125; mLastPausedActivity: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; ResumedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; mFocusedStack=ActivityStack&#123;50922c2 stackId=1 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123;50922c2 stackId=1 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=48&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123;a218944 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 此时 app1 的 taskid 46 的TaskRecord 转移到了 栈顶 接下来返回销毁的逻辑就很清晰了。 最后退到 launcher 界面 app1 的 TaskRecord 转移到了 app2 的返回栈中]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>app</tag>
        <tag>重学Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【流水账】Xposed模块开发]]></title>
    <url>%2F2019%2F08%2F30%2F%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91Xposed%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 本篇博客是记录一些学习 Xposed模块开发时知识的整理。 开发前的准备工作查看 Xposed-Framework-API 根据文档进行配置 1234567repositories &#123; jcenter();&#125;dependencies &#123; compileOnly 'de.robv.android.xposed:api:82'&#125; AndroidManifest.xml 中 application 标签下加入 123456789101112&lt;!-- 应用为模块 --&gt;&lt;meta-data android:name="xposedmodule" android:value="true" /&gt;&lt;!-- 版本信息 该版本号与引用的依赖版本相同--&gt;&lt;meta-data android:name="xposedminversion" android:value="82" /&gt;&lt;!-- 模块描述 --&gt;&lt;meta-data android:name="xposeddescription" android:value="Xposed Test" /&gt; 创建 Hook 类，该类是 Xposed 的入口类，用于拦截加载的 package ，实现 IXposedHookLoadPackage 接口 1234567package com.yyz.xposedtest;public class Main implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; // TODO: hook逻辑 &#125; &#125; 在 src/main 目录下创建assets目录，在该目录中创建 xposed_ini t文件，写入上面创建的 Xposed 的入口类，如下： XposedHelpers 常用方法findAndHookMethod Look up a method and hook it. The last argument must be the callback for the hook. 最后一个参数主要有两种 XC_MethodHook 在原有方法逻辑上添加逻辑，代码如下 12345678910111213141516//在原有方法逻辑上添加逻辑/** * 1. 包名 2. classLoader 3. 方法名 4. 参数类型（没有则不添加） 5.Callback */XposedHelpers.findAndHookMethod("cn.bcbook.kaixuetest.MainActivity", lpparam.classLoader, "printViewId", View.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Log.i("yyz", "afterHookedMethod hook success!"); &#125; &#125;); XC_MethodReplacement 替换原有方法逻辑，代码如下 123456789//替换原有方法XposedHelpers.findAndHookMethod("cn.bcbook.kaixuetest.MainActivity", lpparam.classLoader, "printViewId", View.class, new XC_MethodReplacement() &#123; @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable &#123; Log.i("yyz", "hook success!"); return null; &#125; &#125;);]]></content>
      <categories>
        <category>Xposed</category>
      </categories>
      <tags>
        <tag>Hook</tag>
        <tag>Xposed</tag>
        <tag>流水账</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【流水账】iptables 常用指令]]></title>
    <url>%2F2019%2F08%2F29%2F%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91iptabels%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 该文总结了 iptables 常用的指令。iptables 详细内容请看双印大佬 iptables 详解系列 规则查询查看指定表中的规则1iptables -t filter -L 使用 -t 选项，指定要操作的表，使用 -L 选项，查看-t选项对应的表的规则， -L 选项的意思是，列出规则。所以，上述命令的含义为列出filter表的所有规则。 filter 可替换为 raw mangle nat 如果仅查看 filter 可以省略 -t filter ，当没有使用 -t 选项指定表时，默认为操作 filter 表，即 iptables -L 表示列出 filter 表中的所有规则。 查看指定表中的指定链的规则1iptables -L INPUT 只查看 filter 表中 INPUT 链的规则 1iptables -vL INPUT 使用 -v 查看更多，更详细的信息 不让ip进行反解1iptables -nvL iptables 默认进行了名称解析，但是在规则非常多的情况下如果进行名称解析，效率会比较低。使用 -n 选项，表示不对 ip 地址进行名称反解，直接显示 ip 地址 只查看某个链的规则，并且不让 ip 进行反解，iptables -nvL INPUT 显示规则编号123iptables --line-number -nvL INPUT或iptables --line -nvL INPUT 规则管理添加规则注意：添加规则时，规则的顺序非常重要 123456789101112131415# 在指定表的指定链的尾部添加一条规则，-A选项表示在对应链的末尾添加规则命令语法：iptables -t 表名 -A 链名 匹配条件 -j 动作示例：iptables -t filter -A OUTPUT -s 192.168.10.225 -j DROP# 在指定表的指定链的首部添加一条规则，-I选型表示在对应链的开头添加规则命令语法：iptables -t 表名 -I 链名 匹配条件 -j 动作示例： iptables -t filter -I OUTPUT -s 192.168.10.225 -j ACCEPT# 在指定表的指定链的指定位置添加一条规则命令语法：iptables -t 表名 -I 链名 规则序号 匹配条件 -j 动作示例： iptables -t filter -I OUTPUT 3 -s 192.168.10.225 -j REJECT# 设置指定表的指定链的默认策略（默认动作），并非添加规则命令语法：iptables -t 表名 -P 链名 动作示例：iptables -t filter -P FORWARD ACCEPT 删除规则注意：如果没有保存规则，删除规则时请慎重 123456789101112131415# 按照规则序号删除规则，删除指定表的指定链的指定规则，-D选项表示删除对应链中的规则命令语法：iptables -t 表名 -D 链名 规则序号示例：iptables -t filter -D INPUT 3# 按照具体的匹配条件与动作删除规则，删除指定表的指定链的指定规则命令语法：iptables -t 表名 -D 链名 匹配条件 -j 动作示例：iptables -t filter -D INPUT -s 192.168.10.225 -j DROP# 删除指定表的指定链中的所有规则，-F选项表示清空对应链中的规则命令语法：iptables -t 表名 -F 链名示例：iptables -t filter -F INPUT# 删除指定表中的所有规则命令语法：iptables -t 表名 -F示例：iptables -t filter -F OUTPUT 修改规则注意：如果使用-R选项修改规则中的动作，那么必须指明原规则中的原匹配条件，例如源ip，目标ip等 123# 修改指定表中指定链的指定规则，-R选项表示修改对应链中的规则，使用-R选项时要同时指定对应的链以及规则对应的序号，并且规则中原本的匹配条件不可省略命令语法：iptables -t 表名 -R 链名 规则序号 规则原本的匹配条件 -j 动作示例：iptables -t filter -R INPUT 3 -s 192.168.10.225 -j ACCEPT 上述示例表示修改 filter 表中 INPUT 链的第3条规则，将这条规则的动作修改为 ACCEPT ， -s 192.168.10.225 为这条规则中原本的匹配条件，如果省略此匹配条件，修改后的规则中的源地址可能会变为 0.0.0.0/0 其他修改规则的方法：先通过编号删除规则，再在原编号位置添加一条规则 123# 修改指定表的指定链的默认策略（默认动作），并非修改规则命令语法：iptables -t 表名 -P 链名 动作示例：iptables -t filter -P FORWARD ACCEPT 保存规则12# 保存规则命令，表示将iptables规则保存至/etc/sysconfig/iptables文件中service iptables save 匹配条件基本匹配条件-s 用于匹配报文的源地址,可以同时指定多个源地址，每个 ip 之间用逗号隔开，也可以指定为一个网段 123iptables -t filter -I INPUT -s 192.168.10.111,192.168.10.225 -j DROPiptables -t filter -I INPUT -s 192.168.10.0/24 -j ACCEPTiptables -t filter -I INPUT ! -s 192.168.10.0/24 -j ACCEPT -d 用于匹配报文的目标地址,可以同时指定多个目标地址，每个 ip 之间用逗号隔开，也可以指定为一个网段 123iptables -t filter -I OUTPUT -d 192.168.10.111,192.168.10.225 -j DROPiptables -t filter -I INPUT -d 192.168.10.0/24 -j ACCEPTiptables -t filter -I INPUT ! -d 192.168.10.0/24 -j ACCEPT -p 用于匹配报文的协议类型,可以匹配的协议类型 tcp 、udp 、udplite 、icmp 、esp 、ah 、sctp 等 12iptables -t filter -I INPUT -p tcp -s 192.168.10.146 -j ACCEPTiptables -t filter -I INPUT ! -p udp -s 192.168.10.146 -j ACCEPT 扩展匹配条件 tcp 扩展模块 -p tcp -m tcp --sport 用于匹配 tcp 协议报文的源端口，可以使用冒号指定一个连续的端口范围-p tcp -m tcp --dport 用于匹配 tcp 协议报文的目标端口，可以使用冒号指定一个连续的端口范围 12345iptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp --sport 22 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 22:25 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport :22 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 80: -j REJECTiptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp ! --sport 22 -j ACCEPT multiport 扩展模块 -p tcp -m multiport --sports 用于匹配报文的源端口，可以指定离散的多个端口号,端口之间用”逗号”隔开-p udp -m multiport --dports 用于匹配报文的目标端口，可以指定离散的多个端口号，端口之间用”逗号”隔开 12345iptables -t filter -I OUTPUT -d 192.168.10.225 -p udp -m multiport --sports 137,138 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport ! --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 80:88 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80:88 -j REJECT udp 模块 --sport 匹配 udp 报文的源地址--dport 匹配 udp 报文的目标地址 123# 可以结合multiport模块指定多个离散的端口iptables -t filter -I INPUT -p udp -m udp --dport 137 -j ACCEPTiptables -t filter -I INPUT -p udp -m udp --dport 137:157 -j ACCEPT icmp 模块 --icmp-type 匹配 icmp 报文的具体类型 12345iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECTiptables -t filter -I INPUT -p icmp --icmp-type 8 -j REJECTiptables -t filter -I OUTPUT -p icmp -m icmp --icmp-type 0/0 -j REJECTiptables -t filter -I OUTPUT -p icmp --icmp-type 0 -j REJECTiptables -t filter -I INPUT -p icmp --icmp-type "echo-request" -j REJECT iprange 模块 --src-range 指定连续的源地址范围--dst-range 指定连续的目标地址范围 123iptables -t filter -I INPUT -m iprange --src-range 192.168.10.127-192.168.10.146 -j DROPiptables -t filter -I OUTPUT -m iprange --dst-range 192.168.10.127-192.168.10.146 -j DROPiptables -t filter -I INPUT -m iprange ! --src-range 192.168.10.127-192.168.10.146 -j DROP stirng 模块 --algo 指定对应的匹配算法，可用算法为 bm 、kmp，此选项为必需选项。--string 指定需要匹配的字符串 12iptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECTiptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECT time 模块 --timestart 用于指定时间范围的开始时间，不可取反--timestop 用于指定时间范围的结束时间，不可取反--weekdays 用于指定”星期几”，可取反--monthdays 用于指定”几号”，可取反--datestart 用于指定日期范围的开始日期，不可取反--datestop 用于指定日期范围的结束时间，不可取反 12345678iptables -t filter -I OUTPUT -p tcp --dport 80 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 443 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --weekdays 6,7 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --monthdays 22,23 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time ! --monthdays 22,23 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --timestart 09:00:00 --timestop 18:00:00 --weekdays 6,7 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --weekdays 5 --monthdays 22,23,24,25,26,27,28 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --datestart 2017-12-24 --datestop 2017-12-27 -j REJECT connlimit 模块 --connlimit-above 单独使用此选项时，表示限制每个 ip 的链接数量。--connlimit-mask 此选项不能单独使用，在使用 --connlimit-above 选项时，配合此选项，则可以针对”某类 ip 段内的一定数量的 ip “进行连接数量的限制 123iptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECTiptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j REJECTiptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 10 --connlimit-mask 27 -j REJECT limit 模块 --limit-burst 此选项用于指定令牌桶中令牌的最大数量--limit 此选项用于指定令牌桶中生成新令牌的频率，可用时间单位有second、minute 、hour、day 12iptables -t filter -I INPUT -p icmp -m limit --limit-burst 3 --limit 10/minute -j ACCEPTiptables -t filter -A INPUT -p icmp -j REJECT 自定义链创建自定义链12# 在filter表中创建yyz自定义链iptables -N yyz 引用自定义链12# 在OUTPUT链中引用刚才创建的自定义链iptables -I OUTPUT -j yyz 重命名自定义链12# 将yyz自定义链重命名为testiptabels -E yyz test 删除自定义链删除自定义链需要满足两个条件 自定义链中没有被引用 自定义链中没有任何规则 12# 删除引用计数为0且不包含任何规则的test链iptabels -X test]]></content>
      <categories>
        <category>ROM</category>
      </categories>
      <tags>
        <tag>流水账</tag>
        <tag>ROM</tag>
        <tag>framework</tag>
        <tag>iptables</tag>
        <tag>网络黑白名单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【流水账】记录Framework开发的常用指令]]></title>
    <url>%2F2019%2F08%2F16%2F%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91%E8%AE%B0%E5%BD%95Framework%E5%BC%80%E5%8F%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 本篇博客是记录一些学习 framework 开发时知识的整理。 源码全盘编译指令 source build/envsetup.sh 输入 lunch 同时选择欲编译的源码 编译指令：make -j32 2&gt;&amp;1 | tee build_20190717_1724.log 编译后out目录可查看编译出的镜像 前两步执行完毕即可执行 mmm 等命令，使用 make clean可以在编译前clean源码，该操作会导致编译时间边长。 ROM烧录（mtk） 打开 flash_tool.exe 选择源码的配置文件 切换下载/全部格式化和下 点击下载，同时将已关机的设备连接电脑 等待红条，绿条，黄条走完烧录成功 ROM写号 打开 SN Writer.exe 点击 System Config 配置欲写哪些号，点击AP_DB进行配置文件，点击 Save 点击 Start 将关机的设备连入电脑 源码检出1repo-local init -u git://&#123;ip&#125;/shupai_android7.1/manifests.git &amp;&amp; repo-local sync -j8 &amp;&amp; repo-local start --all master {ip} 使用源码地址替换 开机动画/system/media/ 重新打包 System 生成镜像1make -j8 snod 对 Settings 部分的修改 移除某项（removePreference方法） 禁用某项 （配置enabled属性） 隐藏 Settings 主界面选项：TileUtils 三大金刚键 HOME 和 BACKPhoneWindowManager 类 interceptKeyBeforeDispatching 方法修改 KEYCODE_HOME KEYCODE_BACK case 中的逻辑 RECENTsrc/com/android/systemui/recents/RecentsImpl 类 startRecentsActivity 方法 预装应用device/mediatek/common device.mk 关机 重启操作1base/services/core/java/com/android/server/policy/GloablActions PowerAction]]></content>
      <categories>
        <category>ROM</category>
      </categories>
      <tags>
        <tag>流水账</tag>
        <tag>ROM</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个项目添加依赖同一个模块]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[android Studio 中的项目在正常引用module的时候是用复制到项目中的方式进行，单个项目调用还能适用，但是如果多个项目要引用同一个module的时候，如果module中进行了修改，那么每个项目中的module都要进行修改，这样增加了工作量，并且容易出现bug 因此我们需要引用module ，而不是复制module，实现方法如下 新建项目 TestBase，在其 app build.gradle 中将 apply plugin: &#39;com.android.application&#39; 改为apply plugin: &#39;com.android.library&#39; 删除applicationId 配置项，将module名修改为baselib。 新建项目 TestA 在其settings.gradle 文件中加入下列代码。 123include ':app'include ':baselib'project(':baselib').projectDir=new File("../TestBase", 'baselib') 引用依赖时正常引用即可 1implementation project(&apos;:baselib&apos;) 同步gradle ，此时我们发现baselib出现在TestA项目中。 打开TestA 项目文件夹，我们发现了 baselib 文件夹，下面只有一个baselib.iml文件 在baselib中加入Utils 工具类 切换到TestBase中查看，代码是相同的。 这样就达到了baselib被修改后所有引用baselib的项目会同步变化。 git 同步管理 上述操作都是基于本地的，那么如何加入git管理呢 将TestA和TestBase分别传至github 在TestA项目中打开settings，找到如下位置并将TestBase加入到git管理 然后就可以同步管理这两个项目啦 参考：https://www.jianshu.com/p/47156a6be8cehttps://blog.csdn.net/saintcs/article/details/78567612]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>app</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下Android反编译初探]]></title>
    <url>%2F2017%2F07%2F06%2FMac%E4%B8%8BAndroid%E5%8F%8D%E7%BC%96%E8%AF%91%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[工作第四天，被要求学习逆向开发方面的知识，于是先将自己之前写的未经混淆的apk反编译，记录之。 感谢该博文提供的思路 1. 工具准备 需要的三件套，下载请戳 AndroidCrackTool 用于反编译apk文件与直接解压apk不同，用该工具获得的文件资源可以直接打开阅读，而直接解压得到的是字节码。 dex2jar 用于将.dex文件转为jar文件 传统的Java程序经过编译，生成Java字节码保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Davik字节码，所有的Davik字节码由Java字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中，Dalvik虚拟机通过解释DEX文件来执行这些字节码。 jd-gui 用于阅读源码 2. 开始工作使用AndroidCrackTool反编译apk，设置好目录点击执行按钮，出现end字样即成功。在这里可以查看一些资源文件 将apk以普通解压的方式解压出来，找到其中的classes.dex文件，将其复制到dex2jar目录，使用终端进入dex2jar目录并执行如下命令。 1sh dex2jar.sh classes.dex 可以看到在dex2jar目录下生成了classes_dex2jar.jar的文件。 使用 jd-gui打开classes_dex2jar.jar即可看到源码，可以看到我的apk并没有混淆，所以名字都是正常的命名，经过混淆的名字大都是些字母。]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler深入分析]]></title>
    <url>%2F2017%2F07%2F04%2FHandler%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在android中我们可以有很多方式去实现异步，比如AsyncTask，Rxjava。不过它们底层都是使用的Handler，所以我们来研究一下Handelr的实现。 1. TreadLocal的使用下面我们来写一个小demo，创建两个子线程，在两个子线程中分别为字符串result2，result3赋值，在主线程中调用两个子线程，并且为字符串result1赋值，最后打印输出结果。 最后我们看一下打印结果 很明显，这不是我们想要的结果。看来线程之间相互影响了，那么有没有办法实现上述的功能呢？ 当然有，我们可以使用 TreadLocal 我们可以把TreadLocal看做成一个容器，调用其中的set和get方法，可以设值和取值。下面我们看看是如何实现的。 首先创建一个ThreadLocal对象，并设置泛型为String这里不同的是首先将要打印的字串放入ThreadLocal中，然后从ThreadLocal中取出。 子线程的操作也是类似的。 下面我们看一下打印结果 这样就完成了上述功能。那么这里说的ThreadLocal与Handler有什么关系呢？别急，往下看。 2. 在子线程中创建Handelr我们在子线程中创建一个Handler对象，然后运行程序。 可以看到运行时出现了异常 java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare() 看字面意思是不能在调用Looper.prepare()之前在线程中创建handler。那么我们在创建handler之前去调用Looper.prepare()。之后就能成功运行了。 那么我们来研究一下为什么会这样。鼠标放在Handler()上，win按住control+鼠标左键，Mac按住command+鼠标左键。进入Handler的构造器。点击this 我们找到了源头，如果looper为空则抛出这个异常。 在这里从looper里取出mQueue赋值给mQueue 然后我们看一下这个Looper.prepare方法， 上方的注释说得很清楚，在真正开始这个loop之前，该方法为你提供了创建引用这个looper的handelr的机会。在调用完该方法后，应该确保调用了loop()方法，并且使用quit()方法去结束它。 我们还看到如果多次调用prepare方法会抛出Only one Looper may be created per thread异常。在这里我们看到了熟悉的身影，ThreadLocal。在这里使用ThreadLocal来存looper。 看到这我们不禁要问，在主线程我们并没有调用prepare方法啊，没错，在主线程使用的是prepareMainLooper可以看到这个main looper已经被android environment创建了，所以不需要自己调用该方法。 下面我们来看一下在子线程中创建Handler的标准写法。 123456789101112131415class ThreadLooper extends Thread &#123; public Handler mHandler; @Override public void run() &#123; super.run(); Looper.prepare(); mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; &#125; &#125;; Looper.loop(); &#125; &#125; 3. Message的发送和处理过程Handler里提供了几个消息入队的方法 post()postAtTime()postDelayed()postAtFrontOfQueue()sendMessageAtTime(Message msg , long uptimeMillis) 其中post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法。 下面我们看一下sendMessageAtTime方法 有两个参数，msg 和uptimeMillis ，如果消息队列为空，则打印警告，同时返回false。反之则调用enqueueMessage方法。 下面看一下enqueueMessage 这里有两个比较重要的操作。msg.target赋值为this，有两层含义，一是message的来源是当前handler，二是当前的handler来处理消息。将消息加入到消息队列中，既然是队列就有顺序，那么根据什么来判断顺序呢？就是根据uptimeMillis,这个时间，时间短就在前面，长就在后面。 细心的你可能发现刚刚我提到post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法，那postAtFrontOfQueue()呢？从字面上看该方法是将消息置于消息队列的最前边。是不是这样呢？我们看一下源码。 这里将入队的时间参数直接写死为0，那么肯定就是消息队列的最前边啦。 我们再来分析下入队之后的过程，上文提到调用Looper.prepare()方法后应调用Looper.loop()方法开始消息的轮询。那么我们看看loop方法做了些什么。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 首先从ThreadLocal中取出looper并判断是否为空，之后将looper中的消息队列赋值，再然后进入一个死循环，循环内去不断寻找消息队列的下一项，没有消息发生阻塞。 找到 msg.target.dispatchMessage(msg);这一行，之前我们提到target就是handler对象，这里handler把消息派发出去，接下来就进入消息的处理了。 进入到msg.target.dispatchMessage方法，这里分三步1.判断msg的回调是否为空 如果不为空则直接该回调自己处理，反之判断自己的回调 把Runnable 封装成msg的callback 2.判断自己的回调是否为空3.调用handleMessage方法 这里由子类重写来处理message 4. Handler机制的总结 Thread 负责业务逻辑Handler 负责发送消息和处理消息MessageQueue 负责保存消息Looper 负责轮询消息队列]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>handler</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2从教务系统查询成绩并计算绩点——山东建筑大学为例]]></title>
    <url>%2F2017%2F06%2F18%2F2-2%E4%BB%8E%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9F%A5%E8%AF%A2%E6%88%90%E7%BB%A9%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%BB%A9%E7%82%B9%E2%80%94%E2%80%94%E5%B1%B1%E4%B8%9C%E5%BB%BA%E7%AD%91%E5%A4%A7%E5%AD%A6%E4%B8%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前两天面试时被问到绩点是多少，但学校教务系统不提供绩点查询的功能，那么能不能写一个爬虫程序并计算出绩点呢？答案是肯定的！ 感谢该博客提供的思路 1. 准备HttpFox插件，是一款http协议分析插件，分析页面请求和响应的时间、内容、以及浏览器用到的COOKIE等。是火狐浏览器的插件。谷歌浏览器和Safari都有自带的分析工具，可是感觉太复杂，没有这款好用。不过火狐浏览器对学校的教务系统兼容性不是很好，我还下载了IE tab插件。 可以非常直观的查看相应的信息。点击start是开始检测，点击stop暂停检测，点击clear清除内容。 2. 探究过程下面就去山东建筑大学官网登录到数字校园综合信息门户，看一看在登录的时候，到底发送了那些信息。先来到登录页面，把httpfox打开，clear之后，点击start开启检测： 输入完账号密码，确保httpfox处于开启状态，然后点击登录。这个时候可以看到，httpfox检测到了好多信息： 那么我们来分析一下这些数据 看起来红框里的两条数据比较有意思，先看看这个post PostData中我们看到了比较熟悉的词，username和password，学过java web的我们很清楚这段数据的含义，点击登录后将这用户名和你们提交到服务器比对。 可以看到这里使用get的方式在链接上以?的方式显示的加上了参数，跳转到信息门户。我们的post的数据就发送到了这个地址 1http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal 需要的post数据是用户名密码，也就是说我们需要输入这两种数据来模拟登录过程。 进入教务系统后点击成绩查询，我们看到请求的地址为 1http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690 我们整理一下整个过程的思路。 POST学号和密码—&gt;然后返回cookie的值 发送cookie给服务器—&gt;返回页面信息。 获取到成绩页面的数据，用正则表达式将成绩和学分单独取出并计算加权平均数。 ok，理顺思路后剩下的就只有编码问题了。 3. 实验我们先来实验下是否能够获得查询成绩界面的源码 我们先准备一个POST的数据，再准备一个cookie的接收，然后写出源码如下： 12345678910111213141516171819202122232425262728# coding=utf-8import urllibimport urllib2import cookielibcookie = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))# 需要的POST数据postdata = urllib.urlencode(&#123; &apos;userName&apos;: &apos;20140216064&apos;, &apos;password&apos;: &apos;*********&apos;&#125;)# 自定义一个请求req1 = urllib2.Request( url=&apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos;, data=postdata)req2 = urllib2.Request( url=&apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos;)# 访问登录链接opener.open(req1)result = opener.open(req2)# 打印返回的内容print result.read() 很棒呦，看来跟我们预期的一样。 4. 整理数据 获得了成绩查询界面的源码后我们需要将数据进行整理，获得我们想要的数据，课程名称，学分，成绩。 将网页源码贴到Sublime Text中，方便我们查看源码 通过查看源码我们看到从这个开始到3640行都是关于成绩的代码，而成绩是存放在这个table标签下。红色框中分别为课程名，学分，以及成绩。这些是我们需要抽取出来的数据。看到这里竟然有意外收获！注意黄色框被注释的部分，看来学校的教务系统有计算绩点的功能的，不知由于何种原因不用呢？ 这里是这段程序中最困难的部分，我也踩了很多坑。我参照的博客是使用正则表达式来抽取想要的信息的，但我对正则表达式掌握的并不好，弄了好久也没写出合适的表达式，于是我果断放弃了使用正则表达式，采用BeautifulSoup来进行信息的筛选。BeautifulSoup用法参考 12345678910111213141516171819202122# 将内容从页面源码中提取出来 def deal_data(self, myPage): soup = BeautifulSoup(myPage) # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签) trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;) # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩 for tr in trs: for index, td in enumerate(tr.findAll(&apos;td&apos;)): # enumerate能在for循环中使用下标 if index == 3: print td.text elif index == 7: self.weights.append(td.text.encode(&apos;utf8&apos;)) print td.text elif index == 8: self.points.append(td.text.encode(&apos;utf8&apos;)) print td.text print 整个逻辑我简单说一下，我觉得还可以改进。首先查找title属性为”有效成绩“的标签，通过上文的截图我们可以知道这是那个div标签，之后在该div标签中定位class为t_con的tr标签。你也许会问为什么不直接定位到tr标签，因为后面的网页代码中还存在class 为t_con的tr标签，但不是我们需要的成绩。然后在每个tr标签下抽取下标为3，7，8的标签，这里我是把它存到数组里了。接下来就清晰了，先打印成绩信息，然后计算绩点。 学渣一个，绩点低请忽略。 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# encoding=utf8import urllibimport urllib2import cookielibimport reimport stringfrom BeautifulSoup import BeautifulSoupimport sysreload(sys)sys.setdefaultencoding(&apos;utf8&apos;)class SDJZU_Crawler: # 声明相关的属性 def __init__(self): self.loginUrl = &apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos; # 登录的url self.resultUrl = &apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos; # 查询成绩的url self.cookieJar = cookielib.CookieJar() # 初始化一个CookieJar来处理Cookie的信息 self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: &apos;&apos;, &apos;password&apos;: &apos;&apos;&#125;) # 登录需要POST的数据 self.weights = [] # 存储权重，也就是学分 self.points = [] # 存储分数，也就是成绩 self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.cookieJar)) def sdjzu_init(self): username = raw_input(&apos;请输入学号:&apos;) # 这里不要用input，二者区别请自行查询 password = raw_input(&apos;请输入密码:&apos;) self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: username, &apos;password&apos;: password&#125;) # 将用户名密码加入到POST中 # 初始化链接并且获取cookie myRequest = urllib2.Request(url=self.loginUrl, data=self.postdata) # 自定义一个请求 result = self.opener.open(myRequest) # 访问登录页面，获取到必须的cookie的值 result = self.opener.open(self.resultUrl) # 访问成绩页面，获得成绩的数据 self.deal_data(result.read()) self.calculate_gpa() # 将内容从页面源码中提取出来 def deal_data(self, myPage): soup = BeautifulSoup(myPage) # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签) trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;) # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩 for tr in trs: for index, td in enumerate(tr.findAll(&apos;td&apos;)): # enumerate能在for循环中使用下标 if index == 3: print td.text elif index == 7: self.weights.append(td.text.encode(&apos;utf8&apos;)) print td.text elif index == 8: self.points.append(td.text.encode(&apos;utf8&apos;)) print td.text print # 计算绩点，如果成绩还没出来，就不算该成绩， def calculate_gpa(self): point = 0.0 # 成绩 weight = 0.0 # 学分 for i in range(len(self.points)): if self.points[i].isdigit() and (self.weights[i] != 0): point += string.atof(self.points[i]) * string.atof(self.weights[i]) # 成绩*学分累加求和 weight += string.atof(self.weights[i]) # 学分累加求和 print &quot;绩点为：&quot; print point / weight # 输出绩点 值成绩*学分累加求和 / 学分累加求和# 调用mySpider = SDJZU_Crawler()mySpider.sdjzu_init() 我的github地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1开始第一个爬虫程序]]></title>
    <url>%2F2017%2F06%2F18%2F2-1%E5%BC%80%E5%A7%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1. 安装IDE以及hello world 一个优秀的IDE可以极大地提高工作效率，在这里我选择使用JetBrains公司的PyCharm。是不是有些眼熟？没错，IDEA 和Android Studio就是他们做的，JetBrains出品，必属精品。 点击进入下载链接 点击download选择相应平台及版本，我这里选择的是社区版。 安装过程，切换主题，调整字体之类的都跟跟IDEA类似，不需赘述。 那么开始我们的hello world程序吧。新建一个Python file ，然后写入 1print (&quot;hello world&quot;) 第一次运行在工作区右击 run即可 之后就会在Toolbar上显示run按钮了 很棒有木有 2.1 先爬他一个网页下来敲入如下代码 1234import urllib2response = urllib2.urlopen(&quot;http://www.baidu.com&quot;)print response.read() 点击运行，我们可以得到结果 这个网页的源码被我们爬下来了，是不是很简单！ 2.2 分析代码下面我们来分析下这段代码 1import urllib2 urllib2库是学习Python爬虫最基本的模块，利用这个模块我们可以得到网页的内容，并对内容用正则表达式提取分析，得到我们想要的结果 1response = urllib2.urlopen(&quot;http://www.baidu.com&quot;) 首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，urlopen一般接受三个参数，它的参数如下： 第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。 第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT 第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。 1print response.read() response对象有一个read方法，可以返回获取到的网页内容 2.3 构造Request上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。我们可以将上面的代码改写为 12345import urllib2request = urllib2.Request(&quot;http://www.baidu.com&quot;)response = urllib2.urlopen(request)print response.read() 运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1使用函数]]></title>
    <url>%2F2017%2F06%2F05%2F1-1%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我们编程时很容易疲劳，所以让我们来设计一个可以在一段时间后提醒你休息的小程序。比如每隔两个小时打开http://lines.frvr.com 此网站来玩一会儿小游戏。 让我们来分析下需要哪些步骤我们首先要让程序等待两个小时，在需要休息的时候打开浏览器并转到这个小游戏的网站。也许我们一天要休息多次，所以我们需要一个循环来让其实现多次。 1231. 等待两小时2. 打开浏览器重复 现在，让我们开始吧~ 首先让我们google一下如何用Python来打开浏览器 1webbrowser.open(&quot;http://lines.frvr.com&quot;) 可以看到上述代码可以使用默认浏览器打开指定网页。 让我们试试吧~保存并执行 出现了错误，不过学过java的你肯定能看懂是什么原因。 导入webbrowser模块就可以正常运行了，不要被这个网站的小游戏吸引走哦，我们还没有结束。 下面我们看看Python如何能让程序等待2小时，为了方便测试，我们把等待时间设置为3秒 可以看到使用time.sleep()方法可以是程序等待一段时间执行，参数以秒为单位所以我们在程序中添加以下代码 1time.sleep(3) 当然也要导入相应模块。 很简单有没有？ 接下来我们来让其循环3次 输入以下代码 12345678910import webbrowserimport timetotal_breaks = 3break_count = 0print(&quot;This program started on&quot; + time.ctime())while(break_count &lt; total_breaks): time.sleep(3) webbrowser.open(&quot;http://lines.frvr.com&quot;) break_count = break_count + 1 代码很简单，首先我们定义了总的休息次数为3，我们又定义了已休息次数初始值为0。接下来是一个while循环，当已休息次数小于总休息次数时执行循环体。最后将已休息次数加1。 值得注意的是while循环并没有花括号。 学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示： 1234if True: print &quot;True&quot;else: print &quot;False&quot; 以下代码将会执行错误： 12345678910#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：test.py if True: print &quot;Answer&quot; print &quot;True&quot;else: print &quot;Answer&quot; # 没有严格缩进，在执行时会报错 print &quot;False&quot; 执行以上代码，会出现如下错误提醒： 12345$ python test.py File &quot;test.py&quot;, line 5 if True: ^IndentationError: unexpected indent IndentationError: unexpected indent 错误是 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有 python 对格式要求非常严格。如果是 IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。因此，在 Python 的代码块中必须使用相同数目的行首缩进空格数。建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0.从零开始，Python的安装]]></title>
    <url>%2F2017%2F06%2F05%2F0-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%8CPython%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[这学期计算机网络课程有一个课程设计，要求使用Python写一个小程序。之前也没接触过Python，从优达学城里看到一个关于Python的课程，在此记录。 Windows安装下载地址：https://www.python.org/downloads/ 确保安装了 pip 并且 Python 添加到了你的 PATH。 要检查安装是否成功，打开 IDLE（Python 安装的一款程序，使你能够轻松地编辑和运行 Python 代码）。 a) Windows 7（及更早版本）：依次点击“开始”菜单&gt;“所有程序”&gt;“Python 2.7”，最后选择 IDLE (Python GUI)。 b) Windows 8/10：搜索 IDLE。目前，你可以从屏幕右侧向左滑动或用鼠标点击屏幕的右下角进行搜索。 MAC安装要在 Mac 机器上安装 Python，你可以采用两种方法：在命令行中使用 Homebrew，或在官网上找到普通的 Python 安装程序。 方法 1：程序包安装程序安装地址：https://www.python.org/downloads/release/python-2713/检查是否安装成功 a) IDLE 应该位于您的应用程序文件夹中。b)通过按下 ⌘+空格键，打开 Spotlight ，并输入“idle”来查找 IDLE 以下是它在我们的计算机上运行的屏幕截图！ 方法 2：Homebrew要通过 Homebrew 安装 Python，只需执行以下两步： 打开终端，并输入命令： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”。 安装过程中，系统会多次发出提示 。安装完 Homebrew 后，你可以通过在命令行中输入 brew help，验证一切是否正常。现在输入 brew install python 获取 Python 2 的最新版本。这样就可以了！ 通过在命令行里输入 python 即可验证 Python 是否安装正确。系统应该欢迎你使用 Python Shell。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
