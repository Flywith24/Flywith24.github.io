<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【背上Jetpack】AdroidX下使用Activity和Fragment的变化]]></title>
    <url>%2F2020%2F02%2F29%2F%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E3%80%91AdroidX%E4%B8%8B%E4%BD%BF%E7%94%A8Activity%E5%92%8CFragment%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原文：How AndroidX changes the way we work with Activities and Fragments 作者：Miłosz Lewandowski 译者：Fly_with24 过去的一段时间，AndroidX 软件包下的 Activity/Fragmet 的 API 发生了很多变化。让我们看看它们是如何提升Android 的开发效率以及如何适应当下流行的编程规则和模式。 本文中描述的所有功能现在都可以在稳定的 AndroidX 软件包中使用，它们在去年均已发布或移至稳定版本。 在构造器中传入布局 ID从 AndroidX AppCompat 1.1.0 和 Fragment 1.1.0 ( 译者注：AppCompat 包含 Fragment，且 Fragment 包含 Activity，详情见【整理】Jetpack 主要组件的依赖及传递关系 )开始，您可以使用将 layoutId 作为参数的构造函数： 123class MyActivity : AppCompatActivity(R.layout.my_activity)class MyFragmentActivity: FragmentActivity(R.layout.my_fragment_activity)class MyFragment : Fragment(R.layout.my_fragment) 这种方法可以减少 Activity/Fragment 中方法重写的数量，并使类更具可读性。 无需在 Activity 中重写 onCreate() 即可调用 setContentView() 方法。 另外，无需手动在Fragment 中重写 onCreateView 即可手动调用 Inflater 来扩展视图。 扩展 Activity/Fragment 的灵活性借助 AndroidX 新的 API ，可以减少在 Activity/Fragment 处理某些功能的情况。通常，您可以获取提供某些功能的对象并向其注册您的处理逻辑，而不是重写 Activity / Fragment 中的方法。 这样，您现在可以在屏幕上组成几个独立的类，获得更高的灵活性，复用代码，并且通常在不引入自己的抽象的情况下，对代码结构具有更多控制。 让我们看看这在两个示例中如何工作。 1. OnBackPressedDispatcher有时，您需要阻止用户返回上一级。 在这种情况下，您需要在 Activity 中重写 onBackPressed() 方法。 但是，当您使用 Fragment 时，没有直接的方法来拦截返回。 在 Fragment 类中没有可用的 onBackPressed() 方法，这是为了防止同时存在多个 Fragment 时发生意外行为。 但是，从 AndroidX Activity 1.0.0 开始，您可以使用 OnBackPressedDispatcher 在您可以访问该 Activity 的代码的任何位置（例如，在 Fragment 中）注册 OnBackPressedCallback。 1234567891011class MyFragment : Fragment() &#123; override fun onAttach(context: Context) &#123; super.onAttach(context) val callback = object : OnBackPressedCallback(true) &#123; override fun handleOnBackPressed() &#123; // Do something &#125; &#125; requireActivity().onBackPressedDispatcher.addCallback(this, callback) &#125;&#125; 您可能会在这里注意到另外两个有用的功能： OnBackPressedCallback 的构造函数中的布尔类型的参数有助于根据当前状态动态 打开/关闭按下的行为 addCallback() 方法的可选第一个参数是 LifecycleOwner，以确保仅在您的生命周期感知对象（例如，Fragment）至少处于 STARTED 状态时才使用回调。 通过使用 OnBackPressedDispatcher ，您不仅可以获得在 Activity 之外处理返回键的便捷方式。 根据您的需要，您可以在任意位置定义 OnBackPressedCallback，使其可复用，或根据应用程序的架构进行任何操作。 您不再需要重写Activity 中的 onBackPressed 方法，也不必提供自己的抽象的来实现需求的代码。 2. SavedStateRegistry如果您希望 Activity 在终止并重启后恢复之前的状态，则可能要使用 saved state 功能。 过去，您需要在 Activity 中重写两个方法：onSaveInstanceState 和 onRestoreInstanceState。 您还可以在 onCreate 方法中访问恢复的状态。 同样，在 Fragment 中，您可以使用onSaveInstanceState 方法（并且可以在 onCreate，onCreateView 和onActivityCreated方法中恢复状态）。 从 AndroidX SavedState 1.0.0（它是 AndroidX Activity 和 AndroidX Fragment 内部的依赖。译者注：您不需要单独声明它）开始，您可以访问 SavedStateRegistry，它使用了与前面描述的 OnBackPressedDispatcher 类似的机制：您可以从 Activity / Fragment 中获取 SavedStateRegistry，然后 注册您的 SavedStateProvider： 12345678910111213141516171819202122232425262728class MyActivity : AppCompatActivity() &#123; companion object &#123; private const val MY_SAVED_STATE_KEY = "my_saved_state" private const val SOME_VALUE_KEY = "some_value" &#125; private lateinit var someValue: String private val savedStateProvider = SavedStateRegistry.SavedStateProvider &#123; Bundle().apply &#123; putString(SOME_VALUE_KEY, someValue) &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) savedStateRegistry .registerSavedStateProvider(MY_SAVED_STATE_KEY, savedStateProvider) &#125; fun someMethod() &#123; someValue = savedStateRegistry .consumeRestoredStateForKey(MY_SAVED_STATE_KEY) ?.getString(SOME_VALUE_KEY) ?: "" &#125;&#125; 如您所见，SavedStateRegistry 强制您将密钥用于数据。 这样可以防止您的数据被 attach 到同一个 Activity/Fragment的另一个 SavedStateProvider 破坏。 就像在 OnBackPressedDispatcher 中一样，您可以例如将 SavedStateProvider 提取到另一个类，通过使用所需的任何逻辑使其与数据一起使用，从而在应用程序中实现清晰的保存状态行为。 此外，如果您在应用程序中使用 ViewModel，请考虑使用 AndroidX ViewModel-SavedState 使你的ViewModel 可以保存其状态。 为了方便起见，从 AndroidX Activity 1.1.0 和 AndroidX Fragment 1.2.0 开始，启用 SavedState 的SavedStateViewModelFactory 是在获取 ViewModel 的所有方式中使用的默认工厂：委托 ViewModelProvider 构造函数和 ViewModelProviders.of() 方法。 FragmentFactoryFragment 最常提及的问题之一是不能使用带有参数的构造函数。 例如，如果您使用 Dagger2 进行依赖项注入，则无法使用 Inject 注解 Fragment 构造函数并指定参数。 现在，您可以通过指定 FragmentFactory 类来减少 Fragment 创建过程中的类似问题。 通过在 FragmentManager 中注册 FragmentFactory，可以重写实例化 Fragment 的默认方法： 1234567891011121314class MyFragmentFactory : FragmentFactory() &#123; override fun instantiate(classLoader: ClassLoader, className: String): Fragment &#123; // Call loadFragmentClass() to obtain the Class object val fragmentClass = loadFragmentClass(classLoader, className) // Now you can use className/fragmentClass to determine your prefered way // of instantiating the Fragment object and just do it here. // Or just call regular FragmentFactory to instantiate the Fragment using // no arguments constructor return super.instantiate(classLoader, className) &#125;&#125; 如您所见，该API非常通用，因此您可以执行想要创建 Fragment 实例的所有操作。 回到 Dagger2 示例，例如，您可以注入FragmentFactory Provider &lt;Fragment&gt; 并使用它来获取 Fragment 对象。 测试 Fragment从AndroidX Fragment 1.1.0 开始，可以使用 Fragment 测试组件提供 FragmentScenario 类，该类可以帮助在测试中实例化 Fragment 并进行单独测试： 12345678910111213141516// To launch a Fragment with a user interface:val scenario = launchFragmentInContainer&lt;FirstFragment&gt;() // To launch a headless Fragment:val scenario = launchFragment&lt;FirstFragment&gt;() // To move the fragment to specific lifecycle state:scenario.moveToState(CREATED)// Now you can e.g. perform actions using Espresso:onView(withId(R.id.refresh)).perform(click())// To obtain a Fragment instance:scenario.onFragment &#123; fragment -&gt; ...&#125; More Kotlin!很高兴看到 -ktx AndroidX 软件包中提供了许多有用的 Kotlin 扩展方法，并且定期添加了新的方法。 例如，在AndroidX Fragment-KTX 1.2.0 中，使用片段化类型的扩展名可用于 FragmentTransaction 上的 replace() 方法。 将其与 commit() 扩展方法结合使用，我们可以获得以下代码： 12345678910// BeforesupportFragmentManager .beginTransaction() .add(R.id.container, MyFragment::class.java, null) .commit()// AftersupportFragmentManager.commit &#123; replace&lt;MyFragment&gt;(R.id.container)&#125; FragmentContainerView一件小而重要的事情。 如果您将 FrameLayout 用作 Fragment 的容器，则应改用 FragmentContainerView 。 它修复了一些动画 z轴索引顺序问题和窗口插入调度。 从 AndroidX Fragment 1.2.0 开始可以使用 FragmentContainerView。 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【重学Android读书笔记】Activity的任务栈与返回栈]]></title>
    <url>%2F2019%2F11%2F29%2F%E3%80%90%E9%87%8D%E5%AD%A6Android%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Activity%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88%2F</url>
    <content type="text"><![CDATA[订阅 重学安卓 很久了，最近在整理读书笔记，在此记录之。 在此隆重推荐这位大佬 KunMinX 本文记录Activity任务栈与返回栈相关内容的疑问与探索 该专栏的代码地址： https://github.com/KunMinX/Relearn-Android 疑惑产生根据大佬的代码以及文章描述，有个地方让我很疑惑。 我这里没有过滤当前使用的app，所以app1和app2产生的日志都显示了出来。 大佬在评论区关于此的回答 KunMinX #40 #2楼 @Sky63大概明白你提到的、造成困扰的地方了。D 和 C 是由 app1 启动，在 IDE 中可通过 app1 的视角观察到。同理，当 app2 的 B 唤起 D 时，你在回退 D 的时候能在 app2 和 app1 的视角中同时观察到 D 的销毁。而紧随其后再回退一次， 便能在 app1 中观察到 C 被销毁。再下一次才轮到 app2 中 B 被销毁。 但是根据我操作看到的现象，D的销毁不是在不同app视角观察到的同一次销毁。通过上图可以看出两次销毁是有时间差的，而且经过我的二次确认，的确是关闭两次界面才出现了两次销毁Log。 问题排查通过 adb shell 中的 dumpsys activity activities 命令可以查看 activity 栈信息，故我截取了相关的输出，以下堆栈信息均经过精简。 1. app1 依次打开 SingleTaskOne SingleTaskTwo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364➜ Relearn-Android (master) adb shellsagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #2: type=standard mode=fullscreen Task id #3 Running activities (most recent first): TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; mResumedActivity: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; mLastPausedActivity: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; Stack #1: type=standard mode=fullscreen Task id #2 Running activities (most recent first): TaskRecord&#123;d91b3e8 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125; Run #1: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Run #0: ActivityRecord&#123;d76e9a5 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125; mLastPausedActivity: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;94a7a01 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; ResumedActivity:ActivityRecord&#123; 93c0c72u0com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks &#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks &#125; mCurTaskIdForUser=&#123;0=3&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=3 mHomeStack=ActivityStack&#123; 76ebae7 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks &#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 此时看到堆栈顺序为：Stack #2 -&lt; Stack #1 -&lt; Stack #0 其中 Stack #0 为 launcher 获取焦点的 ActivityStack： 1234mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; 2. 按下HOME键，打开 app2 依次打开 StandardOneActivity StandardTwoActivity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Display #0 (activities from top to bottom): Stack #3: type=standard mode=fullscreen Task id #4 Running activities (most recent first): TaskRecord&#123;718157f #4 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; Run #2: ActivityRecord&#123;648188e u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #1: ActivityRecord&#123;f39ebe9 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #0: ActivityRecord&#123;f02fff8 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t4&#125; mResumedActivity: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; mLastPausedActivity: ActivityRecord&#123;648188e u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;2094d95 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;a7fed1a u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;a7fed1a u0 com.miui.home/.launcher.Launcher t1&#125; Stack #2: type=standard mode=fullscreen Task id #3 Running activities (most recent first): TaskRecord&#123;9d79eaa #3 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;15d3e09 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;20d177c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; mLastPausedActivity: ActivityRecord&#123;15d3e09 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Stack #1: type=standard mode=fullscreen isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #2 Running activities (most recent first): TaskRecord&#123;e526e38 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125; Run #1: ActivityRecord&#123;19055b2 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Run #0: ActivityRecord&#123;5a647a6 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125; mLastPausedActivity: ActivityRecord&#123;19055b2 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; ResumedActivity: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; mFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=4&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123;968fb76 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 这里的堆栈顺序为 Stack #3 -&lt; Stack #0 -&lt; Stack #2 -&lt; Stack #1 Stack #0 为home ，这里反应出点击home键，打开app2 的操作。此时 Stack #3 中有 4 个 ActivityRecord 当前获取焦点的 ActivityStack 12345 mFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=4&#125; 3. 接下来启动 SingleTaskTwoActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172sagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #2: type=standard mode=fullscreen Task id #3 Running activities (most recent first): TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=3&#125; Run #2: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; mResumedActivity: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Stack #3: type=standard mode=fullscreen Task id #4 Running activities (most recent first): TaskRecord&#123;f14a51a #4 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;1838862 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; Run #2: ActivityRecord&#123;bdb3180 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #1: ActivityRecord&#123;7b21450 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #0: ActivityRecord&#123;ff57abb u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t4&#125; mLastPausedActivity: ActivityRecord&#123;1838862 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;94a7a01 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; Stack #1: type=standard mode=fullscreen Task id #2 Running activities (most recent first): TaskRecord&#123;d91b3e8 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125; Run #1: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Run #0: ActivityRecord&#123;d76e9a5 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125; mLastPausedActivity: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; ResumedActivity: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=4&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123; 76ebae7 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 当前的堆栈顺序 Stack #2 -&lt; Stack #3 -&lt; Stack #0 -&lt;Stack #1 当前获取焦点的 ActivityStack 12345mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;mCurTaskIdForUser=&#123;0=4&#125; Stack #2 中 TaskRecord信息为 1234TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=3&#125; Run #2: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; 解惑关键的地方来了 的确有两个 SingleTaskTwoActivity 的 ActivityRecord ，栈顶的属于 app2 第二个属于 app1 由此看出这两个ActivityRecord 不是一个实例，所以这里 app2 启动的 SingleTaskTwoActivity 应该是 app2 自己的activity 废话不说，翻代码！这里截取了 BaseTaskActivity 中的部分代码，app1 和 app2中的 activity 都继承了BaseTaskActivity 12345678910111213141516171819202122232425262728293031323334353637383940@Override public void onClick(View v) &#123; int i = v.getId(); if (i == R.id.btn_standard_one) &#123; Intent intent = new Intent(this, StandardOneActivity.class); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_standard_two) &#123; Intent intent = new Intent(this, StandardTwoActivity.class); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_singletask_one) &#123; Intent intent = new Intent(this, SingleTaskOneActivity.class); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_singletask_two) &#123; Intent intent = new Intent(this, SingleTaskTwoActivity.class); startActivityWithCheck(intent); //以下测试结果证实： //1.在 App2 中启动 App1 的 standard Activity，仍然遵守 standard 的特点：在启动它的 Activity 所在的任务中启动，也即跟随 App2。 //2.在 App2 中启动 App1 的 singleTop Activity，跟随状况同 standard。 //3.在 App2 中启动 App1 的 singleTask Activity，仍然处于 App1 的任务中，并不跟随 App2。 &#125; else if (i == R.id.btn_singletask_a) &#123; Intent intent = new Intent(); ComponentName name = new ComponentName( "com.kunminx.relearn_android", "com.kunminx.relearn_android.SingleTaskAActivity"); intent.setComponent(name); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_singletask_b) &#123; Intent intent = new Intent(); ComponentName name = new ComponentName( "com.kunminx.relearn_android", "com.kunminx.relearn_android.SingleTaskBActivity"); intent.setComponent(name); startActivityWithCheck(intent); &#125; 可以看出这里 app2 启动SingleTaskTwoActivity 的确是自己的 activity 那么它为什么和app1 中的 SingleTaskTwoActivity 是同一个 TaskRecord 呢？ 12345678&lt;activity android:name=".test03_task_test.SingleTaskOneActivity" android:launchMode="singleTask" android:taskAffinity="com.kunminx.task.c" /&gt;&lt;activity android:name=".test03_task_test.SingleTaskTwoActivity" android:launchMode="singleTask" android:taskAffinity="com.kunminx.task.c" /&gt; 它们有着共同的 taskAffinity。至此，我的疑惑已经得到了答案。 拓展我试了以下 app2 中启动 app1 中的Activity的情况 app1 依次启动 StandardOneActivity -&lt; SingleTaskOneActivity -&lt; SingleTaskTwoActivity -&lt; SingleTaskAActivity 其中 SingleTaskOneActivity 与 SingleTaskTwoActivity 设置了相同的 taskAffinity ,StandardOneActivity 与 SingleTaskAActivity 未设置 taskAffinity 接着按 HOME 键，打开 app2 ，依次打开 StandardOneActivity -&lt; StandardOneActivity -&lt; StandardTwoActivity 此时堆栈信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768➜ Relearn-Android (master) adb shellsagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #3: type=standard mode=fullscreen isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #48 Running activities (most recent first): TaskRecord&#123;3b07175 #48 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; Run #2: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #1: ActivityRecord&#123;71254 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #0: ActivityRecord&#123;7c135cf u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t48&#125; mResumedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; mLastPausedActivity: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Stack #0: type=home mode=fullscreen Running activities (most recent first): TaskRecord&#123;185017b #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; Stack #1: type=standard mode=fullscreen Task id #46 Running activities (most recent first): TaskRecord&#123;c374b98 #46 A=com.kunminx.relearn_android U=0 StackId=1 sz=3&#125; Run #2: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Run #1: ActivityRecord&#123;bb0363c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t46&#125; Run #0: ActivityRecord&#123;510711c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t46&#125; mLastPausedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Stack #2: type=standard mode=fullscreen Task id #47 Running activities (most recent first): TaskRecord&#123;3387d6 #47 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; Run #0: ActivityRecord&#123;e9850ca u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t47&#125; mLastPausedActivity: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; ResumedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; mFocusedStack=ActivityStack&#123;ed83a57 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123;ed83a57 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=48&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123;a218944 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 最后在 app2 中启动 app1 的 SingleTaskAActivity 此时堆栈信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465➜ Relearn-Android (master) adb shellsagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #1: type=standard mode=fullscreen Task id #46 Running activities (most recent first): TaskRecord&#123;c374b98 #46 A=com.kunminx.relearn_android U=0 StackId=1 sz=3&#125; Run #2: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Run #1: ActivityRecord&#123;bb0363c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t46&#125; Run #0: ActivityRecord&#123;510711c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t46&#125; mResumedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Stack #3: type=standard mode=fullscreen Task id #48 Running activities (most recent first): TaskRecord&#123;3b07175 #48 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; Run #2: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #1: ActivityRecord&#123;71254 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #0: ActivityRecord&#123;7c135cf u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t48&#125; mLastPausedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;185017b #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; Stack #2: type=standard mode=fullscreen Task id #47 Running activities (most recent first): TaskRecord&#123;3387d6 #47 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; Run #0: ActivityRecord&#123;e9850ca u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t47&#125; mLastPausedActivity: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; ResumedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; mFocusedStack=ActivityStack&#123;50922c2 stackId=1 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123;50922c2 stackId=1 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=48&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123;a218944 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 此时 app1 的 taskid 46 的TaskRecord 转移到了 栈顶 接下来返回销毁的逻辑就很清晰了。 最后退到 launcher 界面 app1 的 TaskRecord 转移到了 app2 的返回栈中]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>app</tag>
        <tag>重学Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【流水账】Xposed模块开发]]></title>
    <url>%2F2019%2F08%2F30%2F%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91Xposed%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 本篇博客是记录一些学习 Xposed模块开发时知识的整理。 开发前的准备工作查看 Xposed-Framework-API 根据文档进行配置 1234567repositories &#123; jcenter();&#125;dependencies &#123; compileOnly 'de.robv.android.xposed:api:82'&#125; AndroidManifest.xml 中 application 标签下加入 123456789101112&lt;!-- 应用为模块 --&gt;&lt;meta-data android:name="xposedmodule" android:value="true" /&gt;&lt;!-- 版本信息 该版本号与引用的依赖版本相同--&gt;&lt;meta-data android:name="xposedminversion" android:value="82" /&gt;&lt;!-- 模块描述 --&gt;&lt;meta-data android:name="xposeddescription" android:value="Xposed Test" /&gt; 创建 Hook 类，该类是 Xposed 的入口类，用于拦截加载的 package ，实现 IXposedHookLoadPackage 接口 1234567package com.yyz.xposedtest;public class Main implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; // TODO: hook逻辑 &#125; &#125; 在 src/main 目录下创建assets目录，在该目录中创建 xposed_ini t文件，写入上面创建的 Xposed 的入口类，如下： XposedHelpers 常用方法findAndHookMethod Look up a method and hook it. The last argument must be the callback for the hook. 最后一个参数主要有两种 XC_MethodHook 在原有方法逻辑上添加逻辑，代码如下 12345678910111213141516//在原有方法逻辑上添加逻辑/** * 1. 包名 2. classLoader 3. 方法名 4. 参数类型（没有则不添加） 5.Callback */XposedHelpers.findAndHookMethod("cn.bcbook.kaixuetest.MainActivity", lpparam.classLoader, "printViewId", View.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Log.i("yyz", "afterHookedMethod hook success!"); &#125; &#125;); XC_MethodReplacement 替换原有方法逻辑，代码如下 123456789//替换原有方法XposedHelpers.findAndHookMethod("cn.bcbook.kaixuetest.MainActivity", lpparam.classLoader, "printViewId", View.class, new XC_MethodReplacement() &#123; @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable &#123; Log.i("yyz", "hook success!"); return null; &#125; &#125;);]]></content>
      <categories>
        <category>Xposed</category>
      </categories>
      <tags>
        <tag>Hook</tag>
        <tag>Xposed</tag>
        <tag>流水账</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【流水账】iptables 常用指令]]></title>
    <url>%2F2019%2F08%2F29%2F%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91iptabels%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 该文总结了 iptables 常用的指令。iptables 详细内容请看双印大佬 iptables 详解系列 规则查询查看指定表中的规则1iptables -t filter -L 使用 -t 选项，指定要操作的表，使用 -L 选项，查看-t选项对应的表的规则， -L 选项的意思是，列出规则。所以，上述命令的含义为列出filter表的所有规则。 filter 可替换为 raw mangle nat 如果仅查看 filter 可以省略 -t filter ，当没有使用 -t 选项指定表时，默认为操作 filter 表，即 iptables -L 表示列出 filter 表中的所有规则。 查看指定表中的指定链的规则1iptables -L INPUT 只查看 filter 表中 INPUT 链的规则 1iptables -vL INPUT 使用 -v 查看更多，更详细的信息 不让ip进行反解1iptables -nvL iptables 默认进行了名称解析，但是在规则非常多的情况下如果进行名称解析，效率会比较低。使用 -n 选项，表示不对 ip 地址进行名称反解，直接显示 ip 地址 只查看某个链的规则，并且不让 ip 进行反解，iptables -nvL INPUT 显示规则编号123iptables --line-number -nvL INPUT或iptables --line -nvL INPUT 规则管理添加规则注意：添加规则时，规则的顺序非常重要 123456789101112131415# 在指定表的指定链的尾部添加一条规则，-A选项表示在对应链的末尾添加规则命令语法：iptables -t 表名 -A 链名 匹配条件 -j 动作示例：iptables -t filter -A OUTPUT -s 192.168.10.225 -j DROP# 在指定表的指定链的首部添加一条规则，-I选型表示在对应链的开头添加规则命令语法：iptables -t 表名 -I 链名 匹配条件 -j 动作示例： iptables -t filter -I OUTPUT -s 192.168.10.225 -j ACCEPT# 在指定表的指定链的指定位置添加一条规则命令语法：iptables -t 表名 -I 链名 规则序号 匹配条件 -j 动作示例： iptables -t filter -I OUTPUT 3 -s 192.168.10.225 -j REJECT# 设置指定表的指定链的默认策略（默认动作），并非添加规则命令语法：iptables -t 表名 -P 链名 动作示例：iptables -t filter -P FORWARD ACCEPT 删除规则注意：如果没有保存规则，删除规则时请慎重 123456789101112131415# 按照规则序号删除规则，删除指定表的指定链的指定规则，-D选项表示删除对应链中的规则命令语法：iptables -t 表名 -D 链名 规则序号示例：iptables -t filter -D INPUT 3# 按照具体的匹配条件与动作删除规则，删除指定表的指定链的指定规则命令语法：iptables -t 表名 -D 链名 匹配条件 -j 动作示例：iptables -t filter -D INPUT -s 192.168.10.225 -j DROP# 删除指定表的指定链中的所有规则，-F选项表示清空对应链中的规则命令语法：iptables -t 表名 -F 链名示例：iptables -t filter -F INPUT# 删除指定表中的所有规则命令语法：iptables -t 表名 -F示例：iptables -t filter -F OUTPUT 修改规则注意：如果使用-R选项修改规则中的动作，那么必须指明原规则中的原匹配条件，例如源ip，目标ip等 123# 修改指定表中指定链的指定规则，-R选项表示修改对应链中的规则，使用-R选项时要同时指定对应的链以及规则对应的序号，并且规则中原本的匹配条件不可省略命令语法：iptables -t 表名 -R 链名 规则序号 规则原本的匹配条件 -j 动作示例：iptables -t filter -R INPUT 3 -s 192.168.10.225 -j ACCEPT 上述示例表示修改 filter 表中 INPUT 链的第3条规则，将这条规则的动作修改为 ACCEPT ， -s 192.168.10.225 为这条规则中原本的匹配条件，如果省略此匹配条件，修改后的规则中的源地址可能会变为 0.0.0.0/0 其他修改规则的方法：先通过编号删除规则，再在原编号位置添加一条规则 123# 修改指定表的指定链的默认策略（默认动作），并非修改规则命令语法：iptables -t 表名 -P 链名 动作示例：iptables -t filter -P FORWARD ACCEPT 保存规则12# 保存规则命令，表示将iptables规则保存至/etc/sysconfig/iptables文件中service iptables save 匹配条件基本匹配条件-s 用于匹配报文的源地址,可以同时指定多个源地址，每个 ip 之间用逗号隔开，也可以指定为一个网段 123iptables -t filter -I INPUT -s 192.168.10.111,192.168.10.225 -j DROPiptables -t filter -I INPUT -s 192.168.10.0/24 -j ACCEPTiptables -t filter -I INPUT ! -s 192.168.10.0/24 -j ACCEPT -d 用于匹配报文的目标地址,可以同时指定多个目标地址，每个 ip 之间用逗号隔开，也可以指定为一个网段 123iptables -t filter -I OUTPUT -d 192.168.10.111,192.168.10.225 -j DROPiptables -t filter -I INPUT -d 192.168.10.0/24 -j ACCEPTiptables -t filter -I INPUT ! -d 192.168.10.0/24 -j ACCEPT -p 用于匹配报文的协议类型,可以匹配的协议类型 tcp 、udp 、udplite 、icmp 、esp 、ah 、sctp 等 12iptables -t filter -I INPUT -p tcp -s 192.168.10.146 -j ACCEPTiptables -t filter -I INPUT ! -p udp -s 192.168.10.146 -j ACCEPT 扩展匹配条件 tcp 扩展模块 -p tcp -m tcp --sport 用于匹配 tcp 协议报文的源端口，可以使用冒号指定一个连续的端口范围-p tcp -m tcp --dport 用于匹配 tcp 协议报文的目标端口，可以使用冒号指定一个连续的端口范围 12345iptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp --sport 22 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 22:25 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport :22 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 80: -j REJECTiptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp ! --sport 22 -j ACCEPT multiport 扩展模块 -p tcp -m multiport --sports 用于匹配报文的源端口，可以指定离散的多个端口号,端口之间用”逗号”隔开-p udp -m multiport --dports 用于匹配报文的目标端口，可以指定离散的多个端口号，端口之间用”逗号”隔开 12345iptables -t filter -I OUTPUT -d 192.168.10.225 -p udp -m multiport --sports 137,138 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport ! --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 80:88 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80:88 -j REJECT udp 模块 --sport 匹配 udp 报文的源地址--dport 匹配 udp 报文的目标地址 123# 可以结合multiport模块指定多个离散的端口iptables -t filter -I INPUT -p udp -m udp --dport 137 -j ACCEPTiptables -t filter -I INPUT -p udp -m udp --dport 137:157 -j ACCEPT icmp 模块 --icmp-type 匹配 icmp 报文的具体类型 12345iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECTiptables -t filter -I INPUT -p icmp --icmp-type 8 -j REJECTiptables -t filter -I OUTPUT -p icmp -m icmp --icmp-type 0/0 -j REJECTiptables -t filter -I OUTPUT -p icmp --icmp-type 0 -j REJECTiptables -t filter -I INPUT -p icmp --icmp-type "echo-request" -j REJECT iprange 模块 --src-range 指定连续的源地址范围--dst-range 指定连续的目标地址范围 123iptables -t filter -I INPUT -m iprange --src-range 192.168.10.127-192.168.10.146 -j DROPiptables -t filter -I OUTPUT -m iprange --dst-range 192.168.10.127-192.168.10.146 -j DROPiptables -t filter -I INPUT -m iprange ! --src-range 192.168.10.127-192.168.10.146 -j DROP stirng 模块 --algo 指定对应的匹配算法，可用算法为 bm 、kmp，此选项为必需选项。--string 指定需要匹配的字符串 12iptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECTiptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECT time 模块 --timestart 用于指定时间范围的开始时间，不可取反--timestop 用于指定时间范围的结束时间，不可取反--weekdays 用于指定”星期几”，可取反--monthdays 用于指定”几号”，可取反--datestart 用于指定日期范围的开始日期，不可取反--datestop 用于指定日期范围的结束时间，不可取反 12345678iptables -t filter -I OUTPUT -p tcp --dport 80 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 443 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --weekdays 6,7 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --monthdays 22,23 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time ! --monthdays 22,23 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --timestart 09:00:00 --timestop 18:00:00 --weekdays 6,7 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --weekdays 5 --monthdays 22,23,24,25,26,27,28 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --datestart 2017-12-24 --datestop 2017-12-27 -j REJECT connlimit 模块 --connlimit-above 单独使用此选项时，表示限制每个 ip 的链接数量。--connlimit-mask 此选项不能单独使用，在使用 --connlimit-above 选项时，配合此选项，则可以针对”某类 ip 段内的一定数量的 ip “进行连接数量的限制 123iptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECTiptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j REJECTiptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 10 --connlimit-mask 27 -j REJECT limit 模块 --limit-burst 此选项用于指定令牌桶中令牌的最大数量--limit 此选项用于指定令牌桶中生成新令牌的频率，可用时间单位有second、minute 、hour、day 12iptables -t filter -I INPUT -p icmp -m limit --limit-burst 3 --limit 10/minute -j ACCEPTiptables -t filter -A INPUT -p icmp -j REJECT 自定义链创建自定义链12# 在filter表中创建yyz自定义链iptables -N yyz 引用自定义链12# 在OUTPUT链中引用刚才创建的自定义链iptables -I OUTPUT -j yyz 重命名自定义链12# 将yyz自定义链重命名为testiptabels -E yyz test 删除自定义链删除自定义链需要满足两个条件 自定义链中没有被引用 自定义链中没有任何规则 12# 删除引用计数为0且不包含任何规则的test链iptabels -X test]]></content>
      <categories>
        <category>ROM</category>
      </categories>
      <tags>
        <tag>流水账</tag>
        <tag>ROM</tag>
        <tag>framework</tag>
        <tag>iptables</tag>
        <tag>网络黑白名单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【流水账】记录Framework开发的常用指令]]></title>
    <url>%2F2019%2F08%2F16%2F%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91%E8%AE%B0%E5%BD%95Framework%E5%BC%80%E5%8F%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 本篇博客是记录一些学习 framework 开发时知识的整理。 源码全盘编译指令 source build/envsetup.sh 输入 lunch 同时选择欲编译的源码 编译指令：make -j32 2&gt;&amp;1 | tee build_20190717_1724.log 编译后out目录可查看编译出的镜像 前两步执行完毕即可执行 mmm 等命令，使用 make clean可以在编译前clean源码，该操作会导致编译时间边长。 ROM烧录（mtk） 打开 flash_tool.exe 选择源码的配置文件 切换下载/全部格式化和下 点击下载，同时将已关机的设备连接电脑 等待红条，绿条，黄条走完烧录成功 ROM写号 打开 SN Writer.exe 点击 System Config 配置欲写哪些号，点击AP_DB进行配置文件，点击 Save 点击 Start 将关机的设备连入电脑 源码检出1repo-local init -u git://&#123;ip&#125;/shupai_android7.1/manifests.git &amp;&amp; repo-local sync -j8 &amp;&amp; repo-local start --all master {ip} 使用源码地址替换 开机动画/system/media/ 重新打包 System 生成镜像1make -j8 snod 对 Settings 部分的修改 移除某项（removePreference方法） 禁用某项 （配置enabled属性） 隐藏 Settings 主界面选项：TileUtils 三大金刚键 HOME 和 BACKPhoneWindowManager 类 interceptKeyBeforeDispatching 方法修改 KEYCODE_HOME KEYCODE_BACK case 中的逻辑 RECENTsrc/com/android/systemui/recents/RecentsImpl 类 startRecentsActivity 方法 预装应用device/mediatek/common device.mk 关机 重启操作1base/services/core/java/com/android/server/policy/GloablActions PowerAction]]></content>
      <categories>
        <category>ROM</category>
      </categories>
      <tags>
        <tag>流水账</tag>
        <tag>ROM</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个项目添加依赖同一个模块]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[android Studio 中的项目在正常引用module的时候是用复制到项目中的方式进行，单个项目调用还能适用，但是如果多个项目要引用同一个module的时候，如果module中进行了修改，那么每个项目中的module都要进行修改，这样增加了工作量，并且容易出现bug 因此我们需要引用module ，而不是复制module，实现方法如下 新建项目 TestBase，在其 app build.gradle 中将 apply plugin: &#39;com.android.application&#39; 改为apply plugin: &#39;com.android.library&#39; 删除applicationId 配置项，将module名修改为baselib。 新建项目 TestA 在其settings.gradle 文件中加入下列代码。 123include ':app'include ':baselib'project(':baselib').projectDir=new File("../TestBase", 'baselib') 引用依赖时正常引用即可 1implementation project(&apos;:baselib&apos;) 同步gradle ，此时我们发现baselib出现在TestA项目中。 打开TestA 项目文件夹，我们发现了 baselib 文件夹，下面只有一个baselib.iml文件 在baselib中加入Utils 工具类 切换到TestBase中查看，代码是相同的。 这样就达到了baselib被修改后所有引用baselib的项目会同步变化。 git 同步管理 上述操作都是基于本地的，那么如何加入git管理呢 将TestA和TestBase分别传至github 在TestA项目中打开settings，找到如下位置并将TestBase加入到git管理 然后就可以同步管理这两个项目啦 参考：https://www.jianshu.com/p/47156a6be8cehttps://blog.csdn.net/saintcs/article/details/78567612]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>app</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下Android反编译初探]]></title>
    <url>%2F2017%2F07%2F06%2FMac%E4%B8%8BAndroid%E5%8F%8D%E7%BC%96%E8%AF%91%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[工作第四天，被要求学习逆向开发方面的知识，于是先将自己之前写的未经混淆的apk反编译，记录之。 感谢该博文提供的思路 1. 工具准备 需要的三件套，下载请戳 AndroidCrackTool 用于反编译apk文件与直接解压apk不同，用该工具获得的文件资源可以直接打开阅读，而直接解压得到的是字节码。 dex2jar 用于将.dex文件转为jar文件 传统的Java程序经过编译，生成Java字节码保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Davik字节码，所有的Davik字节码由Java字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中，Dalvik虚拟机通过解释DEX文件来执行这些字节码。 jd-gui 用于阅读源码 2. 开始工作使用AndroidCrackTool反编译apk，设置好目录点击执行按钮，出现end字样即成功。在这里可以查看一些资源文件 将apk以普通解压的方式解压出来，找到其中的classes.dex文件，将其复制到dex2jar目录，使用终端进入dex2jar目录并执行如下命令。 1sh dex2jar.sh classes.dex 可以看到在dex2jar目录下生成了classes_dex2jar.jar的文件。 使用 jd-gui打开classes_dex2jar.jar即可看到源码，可以看到我的apk并没有混淆，所以名字都是正常的命名，经过混淆的名字大都是些字母。]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler深入分析]]></title>
    <url>%2F2017%2F07%2F04%2FHandler%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在android中我们可以有很多方式去实现异步，比如AsyncTask，Rxjava。不过它们底层都是使用的Handler，所以我们来研究一下Handelr的实现。 1. TreadLocal的使用下面我们来写一个小demo，创建两个子线程，在两个子线程中分别为字符串result2，result3赋值，在主线程中调用两个子线程，并且为字符串result1赋值，最后打印输出结果。 最后我们看一下打印结果 很明显，这不是我们想要的结果。看来线程之间相互影响了，那么有没有办法实现上述的功能呢？ 当然有，我们可以使用 TreadLocal 我们可以把TreadLocal看做成一个容器，调用其中的set和get方法，可以设值和取值。下面我们看看是如何实现的。 首先创建一个ThreadLocal对象，并设置泛型为String这里不同的是首先将要打印的字串放入ThreadLocal中，然后从ThreadLocal中取出。 子线程的操作也是类似的。 下面我们看一下打印结果 这样就完成了上述功能。那么这里说的ThreadLocal与Handler有什么关系呢？别急，往下看。 2. 在子线程中创建Handelr我们在子线程中创建一个Handler对象，然后运行程序。 可以看到运行时出现了异常 java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare() 看字面意思是不能在调用Looper.prepare()之前在线程中创建handler。那么我们在创建handler之前去调用Looper.prepare()。之后就能成功运行了。 那么我们来研究一下为什么会这样。鼠标放在Handler()上，win按住control+鼠标左键，Mac按住command+鼠标左键。进入Handler的构造器。点击this 我们找到了源头，如果looper为空则抛出这个异常。 在这里从looper里取出mQueue赋值给mQueue 然后我们看一下这个Looper.prepare方法， 上方的注释说得很清楚，在真正开始这个loop之前，该方法为你提供了创建引用这个looper的handelr的机会。在调用完该方法后，应该确保调用了loop()方法，并且使用quit()方法去结束它。 我们还看到如果多次调用prepare方法会抛出Only one Looper may be created per thread异常。在这里我们看到了熟悉的身影，ThreadLocal。在这里使用ThreadLocal来存looper。 看到这我们不禁要问，在主线程我们并没有调用prepare方法啊，没错，在主线程使用的是prepareMainLooper可以看到这个main looper已经被android environment创建了，所以不需要自己调用该方法。 下面我们来看一下在子线程中创建Handler的标准写法。 123456789101112131415class ThreadLooper extends Thread &#123; public Handler mHandler; @Override public void run() &#123; super.run(); Looper.prepare(); mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; &#125; &#125;; Looper.loop(); &#125; &#125; 3. Message的发送和处理过程Handler里提供了几个消息入队的方法 post()postAtTime()postDelayed()postAtFrontOfQueue()sendMessageAtTime(Message msg , long uptimeMillis) 其中post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法。 下面我们看一下sendMessageAtTime方法 有两个参数，msg 和uptimeMillis ，如果消息队列为空，则打印警告，同时返回false。反之则调用enqueueMessage方法。 下面看一下enqueueMessage 这里有两个比较重要的操作。msg.target赋值为this，有两层含义，一是message的来源是当前handler，二是当前的handler来处理消息。将消息加入到消息队列中，既然是队列就有顺序，那么根据什么来判断顺序呢？就是根据uptimeMillis,这个时间，时间短就在前面，长就在后面。 细心的你可能发现刚刚我提到post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法，那postAtFrontOfQueue()呢？从字面上看该方法是将消息置于消息队列的最前边。是不是这样呢？我们看一下源码。 这里将入队的时间参数直接写死为0，那么肯定就是消息队列的最前边啦。 我们再来分析下入队之后的过程，上文提到调用Looper.prepare()方法后应调用Looper.loop()方法开始消息的轮询。那么我们看看loop方法做了些什么。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 首先从ThreadLocal中取出looper并判断是否为空，之后将looper中的消息队列赋值，再然后进入一个死循环，循环内去不断寻找消息队列的下一项，没有消息发生阻塞。 找到 msg.target.dispatchMessage(msg);这一行，之前我们提到target就是handler对象，这里handler把消息派发出去，接下来就进入消息的处理了。 进入到msg.target.dispatchMessage方法，这里分三步1.判断msg的回调是否为空 如果不为空则直接该回调自己处理，反之判断自己的回调 把Runnable 封装成msg的callback 2.判断自己的回调是否为空3.调用handleMessage方法 这里由子类重写来处理message 4. Handler机制的总结 Thread 负责业务逻辑Handler 负责发送消息和处理消息MessageQueue 负责保存消息Looper 负责轮询消息队列]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>handler</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2从教务系统查询成绩并计算绩点——山东建筑大学为例]]></title>
    <url>%2F2017%2F06%2F18%2F2-2%E4%BB%8E%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9F%A5%E8%AF%A2%E6%88%90%E7%BB%A9%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%BB%A9%E7%82%B9%E2%80%94%E2%80%94%E5%B1%B1%E4%B8%9C%E5%BB%BA%E7%AD%91%E5%A4%A7%E5%AD%A6%E4%B8%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前两天面试时被问到绩点是多少，但学校教务系统不提供绩点查询的功能，那么能不能写一个爬虫程序并计算出绩点呢？答案是肯定的！ 感谢该博客提供的思路 1. 准备HttpFox插件，是一款http协议分析插件，分析页面请求和响应的时间、内容、以及浏览器用到的COOKIE等。是火狐浏览器的插件。谷歌浏览器和Safari都有自带的分析工具，可是感觉太复杂，没有这款好用。不过火狐浏览器对学校的教务系统兼容性不是很好，我还下载了IE tab插件。 可以非常直观的查看相应的信息。点击start是开始检测，点击stop暂停检测，点击clear清除内容。 2. 探究过程下面就去山东建筑大学官网登录到数字校园综合信息门户，看一看在登录的时候，到底发送了那些信息。先来到登录页面，把httpfox打开，clear之后，点击start开启检测： 输入完账号密码，确保httpfox处于开启状态，然后点击登录。这个时候可以看到，httpfox检测到了好多信息： 那么我们来分析一下这些数据 看起来红框里的两条数据比较有意思，先看看这个post PostData中我们看到了比较熟悉的词，username和password，学过java web的我们很清楚这段数据的含义，点击登录后将这用户名和你们提交到服务器比对。 可以看到这里使用get的方式在链接上以?的方式显示的加上了参数，跳转到信息门户。我们的post的数据就发送到了这个地址 1http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal 需要的post数据是用户名密码，也就是说我们需要输入这两种数据来模拟登录过程。 进入教务系统后点击成绩查询，我们看到请求的地址为 1http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690 我们整理一下整个过程的思路。 POST学号和密码—&gt;然后返回cookie的值 发送cookie给服务器—&gt;返回页面信息。 获取到成绩页面的数据，用正则表达式将成绩和学分单独取出并计算加权平均数。 ok，理顺思路后剩下的就只有编码问题了。 3. 实验我们先来实验下是否能够获得查询成绩界面的源码 我们先准备一个POST的数据，再准备一个cookie的接收，然后写出源码如下： 12345678910111213141516171819202122232425262728# coding=utf-8import urllibimport urllib2import cookielibcookie = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))# 需要的POST数据postdata = urllib.urlencode(&#123; &apos;userName&apos;: &apos;20140216064&apos;, &apos;password&apos;: &apos;*********&apos;&#125;)# 自定义一个请求req1 = urllib2.Request( url=&apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos;, data=postdata)req2 = urllib2.Request( url=&apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos;)# 访问登录链接opener.open(req1)result = opener.open(req2)# 打印返回的内容print result.read() 很棒呦，看来跟我们预期的一样。 4. 整理数据 获得了成绩查询界面的源码后我们需要将数据进行整理，获得我们想要的数据，课程名称，学分，成绩。 将网页源码贴到Sublime Text中，方便我们查看源码 通过查看源码我们看到从这个开始到3640行都是关于成绩的代码，而成绩是存放在这个table标签下。红色框中分别为课程名，学分，以及成绩。这些是我们需要抽取出来的数据。看到这里竟然有意外收获！注意黄色框被注释的部分，看来学校的教务系统有计算绩点的功能的，不知由于何种原因不用呢？ 这里是这段程序中最困难的部分，我也踩了很多坑。我参照的博客是使用正则表达式来抽取想要的信息的，但我对正则表达式掌握的并不好，弄了好久也没写出合适的表达式，于是我果断放弃了使用正则表达式，采用BeautifulSoup来进行信息的筛选。BeautifulSoup用法参考 12345678910111213141516171819202122# 将内容从页面源码中提取出来 def deal_data(self, myPage): soup = BeautifulSoup(myPage) # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签) trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;) # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩 for tr in trs: for index, td in enumerate(tr.findAll(&apos;td&apos;)): # enumerate能在for循环中使用下标 if index == 3: print td.text elif index == 7: self.weights.append(td.text.encode(&apos;utf8&apos;)) print td.text elif index == 8: self.points.append(td.text.encode(&apos;utf8&apos;)) print td.text print 整个逻辑我简单说一下，我觉得还可以改进。首先查找title属性为”有效成绩“的标签，通过上文的截图我们可以知道这是那个div标签，之后在该div标签中定位class为t_con的tr标签。你也许会问为什么不直接定位到tr标签，因为后面的网页代码中还存在class 为t_con的tr标签，但不是我们需要的成绩。然后在每个tr标签下抽取下标为3，7，8的标签，这里我是把它存到数组里了。接下来就清晰了，先打印成绩信息，然后计算绩点。 学渣一个，绩点低请忽略。 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# encoding=utf8import urllibimport urllib2import cookielibimport reimport stringfrom BeautifulSoup import BeautifulSoupimport sysreload(sys)sys.setdefaultencoding(&apos;utf8&apos;)class SDJZU_Crawler: # 声明相关的属性 def __init__(self): self.loginUrl = &apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos; # 登录的url self.resultUrl = &apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos; # 查询成绩的url self.cookieJar = cookielib.CookieJar() # 初始化一个CookieJar来处理Cookie的信息 self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: &apos;&apos;, &apos;password&apos;: &apos;&apos;&#125;) # 登录需要POST的数据 self.weights = [] # 存储权重，也就是学分 self.points = [] # 存储分数，也就是成绩 self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.cookieJar)) def sdjzu_init(self): username = raw_input(&apos;请输入学号:&apos;) # 这里不要用input，二者区别请自行查询 password = raw_input(&apos;请输入密码:&apos;) self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: username, &apos;password&apos;: password&#125;) # 将用户名密码加入到POST中 # 初始化链接并且获取cookie myRequest = urllib2.Request(url=self.loginUrl, data=self.postdata) # 自定义一个请求 result = self.opener.open(myRequest) # 访问登录页面，获取到必须的cookie的值 result = self.opener.open(self.resultUrl) # 访问成绩页面，获得成绩的数据 self.deal_data(result.read()) self.calculate_gpa() # 将内容从页面源码中提取出来 def deal_data(self, myPage): soup = BeautifulSoup(myPage) # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签) trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;) # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩 for tr in trs: for index, td in enumerate(tr.findAll(&apos;td&apos;)): # enumerate能在for循环中使用下标 if index == 3: print td.text elif index == 7: self.weights.append(td.text.encode(&apos;utf8&apos;)) print td.text elif index == 8: self.points.append(td.text.encode(&apos;utf8&apos;)) print td.text print # 计算绩点，如果成绩还没出来，就不算该成绩， def calculate_gpa(self): point = 0.0 # 成绩 weight = 0.0 # 学分 for i in range(len(self.points)): if self.points[i].isdigit() and (self.weights[i] != 0): point += string.atof(self.points[i]) * string.atof(self.weights[i]) # 成绩*学分累加求和 weight += string.atof(self.weights[i]) # 学分累加求和 print &quot;绩点为：&quot; print point / weight # 输出绩点 值成绩*学分累加求和 / 学分累加求和# 调用mySpider = SDJZU_Crawler()mySpider.sdjzu_init() 我的github地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1开始第一个爬虫程序]]></title>
    <url>%2F2017%2F06%2F18%2F2-1%E5%BC%80%E5%A7%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1. 安装IDE以及hello world 一个优秀的IDE可以极大地提高工作效率，在这里我选择使用JetBrains公司的PyCharm。是不是有些眼熟？没错，IDEA 和Android Studio就是他们做的，JetBrains出品，必属精品。 点击进入下载链接 点击download选择相应平台及版本，我这里选择的是社区版。 安装过程，切换主题，调整字体之类的都跟跟IDEA类似，不需赘述。 那么开始我们的hello world程序吧。新建一个Python file ，然后写入 1print (&quot;hello world&quot;) 第一次运行在工作区右击 run即可 之后就会在Toolbar上显示run按钮了 很棒有木有 2.1 先爬他一个网页下来敲入如下代码 1234import urllib2response = urllib2.urlopen(&quot;http://www.baidu.com&quot;)print response.read() 点击运行，我们可以得到结果 这个网页的源码被我们爬下来了，是不是很简单！ 2.2 分析代码下面我们来分析下这段代码 1import urllib2 urllib2库是学习Python爬虫最基本的模块，利用这个模块我们可以得到网页的内容，并对内容用正则表达式提取分析，得到我们想要的结果 1response = urllib2.urlopen(&quot;http://www.baidu.com&quot;) 首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，urlopen一般接受三个参数，它的参数如下： 第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。 第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT 第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。 1print response.read() response对象有一个read方法，可以返回获取到的网页内容 2.3 构造Request上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。我们可以将上面的代码改写为 12345import urllib2request = urllib2.Request(&quot;http://www.baidu.com&quot;)response = urllib2.urlopen(request)print response.read() 运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1使用函数]]></title>
    <url>%2F2017%2F06%2F05%2F1-1%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我们编程时很容易疲劳，所以让我们来设计一个可以在一段时间后提醒你休息的小程序。比如每隔两个小时打开http://lines.frvr.com 此网站来玩一会儿小游戏。 让我们来分析下需要哪些步骤我们首先要让程序等待两个小时，在需要休息的时候打开浏览器并转到这个小游戏的网站。也许我们一天要休息多次，所以我们需要一个循环来让其实现多次。 1231. 等待两小时2. 打开浏览器重复 现在，让我们开始吧~ 首先让我们google一下如何用Python来打开浏览器 1webbrowser.open(&quot;http://lines.frvr.com&quot;) 可以看到上述代码可以使用默认浏览器打开指定网页。 让我们试试吧~保存并执行 出现了错误，不过学过java的你肯定能看懂是什么原因。 导入webbrowser模块就可以正常运行了，不要被这个网站的小游戏吸引走哦，我们还没有结束。 下面我们看看Python如何能让程序等待2小时，为了方便测试，我们把等待时间设置为3秒 可以看到使用time.sleep()方法可以是程序等待一段时间执行，参数以秒为单位所以我们在程序中添加以下代码 1time.sleep(3) 当然也要导入相应模块。 很简单有没有？ 接下来我们来让其循环3次 输入以下代码 12345678910import webbrowserimport timetotal_breaks = 3break_count = 0print(&quot;This program started on&quot; + time.ctime())while(break_count &lt; total_breaks): time.sleep(3) webbrowser.open(&quot;http://lines.frvr.com&quot;) break_count = break_count + 1 代码很简单，首先我们定义了总的休息次数为3，我们又定义了已休息次数初始值为0。接下来是一个while循环，当已休息次数小于总休息次数时执行循环体。最后将已休息次数加1。 值得注意的是while循环并没有花括号。 学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示： 1234if True: print &quot;True&quot;else: print &quot;False&quot; 以下代码将会执行错误： 12345678910#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：test.py if True: print &quot;Answer&quot; print &quot;True&quot;else: print &quot;Answer&quot; # 没有严格缩进，在执行时会报错 print &quot;False&quot; 执行以上代码，会出现如下错误提醒： 12345$ python test.py File &quot;test.py&quot;, line 5 if True: ^IndentationError: unexpected indent IndentationError: unexpected indent 错误是 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有 python 对格式要求非常严格。如果是 IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。因此，在 Python 的代码块中必须使用相同数目的行首缩进空格数。建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0.从零开始，Python的安装]]></title>
    <url>%2F2017%2F06%2F05%2F0-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%8CPython%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[这学期计算机网络课程有一个课程设计，要求使用Python写一个小程序。之前也没接触过Python，从优达学城里看到一个关于Python的课程，在此记录。 Windows安装下载地址：https://www.python.org/downloads/ 确保安装了 pip 并且 Python 添加到了你的 PATH。 要检查安装是否成功，打开 IDLE（Python 安装的一款程序，使你能够轻松地编辑和运行 Python 代码）。 a) Windows 7（及更早版本）：依次点击“开始”菜单&gt;“所有程序”&gt;“Python 2.7”，最后选择 IDLE (Python GUI)。 b) Windows 8/10：搜索 IDLE。目前，你可以从屏幕右侧向左滑动或用鼠标点击屏幕的右下角进行搜索。 MAC安装要在 Mac 机器上安装 Python，你可以采用两种方法：在命令行中使用 Homebrew，或在官网上找到普通的 Python 安装程序。 方法 1：程序包安装程序安装地址：https://www.python.org/downloads/release/python-2713/检查是否安装成功 a) IDLE 应该位于您的应用程序文件夹中。b)通过按下 ⌘+空格键，打开 Spotlight ，并输入“idle”来查找 IDLE 以下是它在我们的计算机上运行的屏幕截图！ 方法 2：Homebrew要通过 Homebrew 安装 Python，只需执行以下两步： 打开终端，并输入命令： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”。 安装过程中，系统会多次发出提示 。安装完 Homebrew 后，你可以通过在命令行中输入 brew help，验证一切是否正常。现在输入 brew install python 获取 Python 2 的最新版本。这样就可以了！ 通过在命令行里输入 python 即可验证 Python 是否安装正确。系统应该欢迎你使用 Python Shell。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
