<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 AccountManager 实现系统内共享账号]]></title>
    <url>%2F2020%2F09%2F04%2FAccountManager%2F</url>
    <content type="text"><![CDATA[使用 AccountManager 实现系统内共享账号在开发过程中我们可能遇到自家应用间共享账号的场景。例如 APP1 登录成功后，启动 APP2 时自动完成登录并与 APP1 共享账号信息。 Android 为我们提供了AccountManager 来管理账号信息。 demo 地址 共享前提 两个 app 在一个用户组内 使用相同的签名（使用 debug 默认签名也可以共享） accountType 相同 原理 AccountManager是一个面向应用程序开发的组件，它提供了一套对应于 IAccountManager 协议的应用程序接口；这组接口通过Binder机制与系统服务AccountManagerService进行通信，协作完成帐号相关的操作。同时，AccountManager接收authenticators 提供的回调，以便在帐号操作完成之后向调用此帐号服务的业务返回对应的接口，同时触发这个业务对结果的处理。- authenticators 即注册帐号服务的app；- 业务调用方 即使用authenticators提供的帐号服务的第三方，也可以是authenticator自己 摘自：Android AccountManager帐号管理（一） 使用该项目中有两个 module ，app 对应注册账号服务的app，app1 对应使用账号服务的第三方应用 在两个应用的 manifest 中加入 &lt;uses-permission android:name=&quot;android.permission.GET_ACCOUNTS&quot; /&gt; 权限 在 app 中创建 authenticator.xml 文件，注意 accountType 的配置，这里的应用名及 icon 会在设备的 设置 -&gt; 账号 中显示 在 app 中注册一个 action 为“android.accounts.AccountAuthenticator”的 authenticator service，引入上一步创建的 xml 文件 在 app 中创建 authenticator 创建账号 删除账号 第三方 app 获取 用户，token 等信息]]></content>
      <categories>
        <category>ROM</category>
      </categories>
      <tags>
        <tag>ROM</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【折腾Framework】源码编译与烧写]]></title>
    <url>%2F2020%2F08%2F18%2FFramework-Compile%2F</url>
    <content type="text"><![CDATA[前言环境搭建等内容网上资料很多，这里不再赘述。 此处以 Pixel 3a &amp; Android 10 为例介绍如何编译 ROM 包并烧录 手上没有真机的小伙伴可以选择制作模拟器，本文最后提供了基于 Android 10 编译的自定义 AVD 下载链接 编译环境官方文档 下载源码这里推荐使用 清华镜像 下载 每月更新的初始化包 并解压 下载驱动（可选）如果要刷到真机上，需要下载相应机型的驱动，进入 该链接，选择相应的机型对应的 Android 版本号和驱动 我这里选择的是 Android 10.0.0（QQ3A.200605.002.A1） 将两个驱动文件下载并解压，并执行 12./extract-qcom-sargo.sh./extract-google_devices-sargo.sh 点击 Enter 并输入 I ACCEPT 同意 License 根据 Build 在 该链接 中找到相匹配的分支，本例中对应 android-10.0.0_r39 选择分支执行完上述操作如果直接编译的话实际上是编译的 master 分支，我们还需要切换到想要编译的分支 123repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-10.0.0_r39 --depth=1repo sync -j8repo start android-10.0.0_r39 --all 编译与烧写在源码目录执行 source build/envsetup.sh lunch 进入菜单 选择相应的版本 我这里选择的是 19 编译接着便可以进行编译了，可以使用 make -j 命令，其中 j 代表的是编译 job 的数量 执行（我这里指定了生成 log 文件） make -j32 2&gt;&amp;1 | tee build_20200628_1635.log 编译成功后会出现一个 out 目录，ROM 镜像文件就在此处 例如我的路径为：~/aosp/out/target/product/sargo 烧写设备进入 bootloader 并执行：fastboot flashall -w，其中 -w 代表清空数据 烧写成功，开机！ 制作自定义 AVD（Android Virtual Devices） 系统镜像很多小伙伴没有相应的真机，不过可以制作出自定义的 AVD 作为模拟器使用。 lunch 进入菜单时选择相应的模拟器，例如选择上图的 24，64 位的通用设备 想要制作 AVD 系统镜像需要制作附加 sdk 和 sdk_repo 软件包 执行 1$ make -j32 sdk sdk_repo 该操作可能会出现异常，例如 这是由于没有编译这些工具导致的，解决办法是依次编译这些工具 依次输入如下命令，后面工具视情况而定 12345678910111213141516171819$ make libaapt2_jni$ make dmtracedump$ make etc1tool$ make deployagent$ make aapt$ make split-select$ make bcc_compat$ make apksigner$ make dx$ make layoutlib-legacy 编译好相关工具我们再次执行 make -j32 sdk sdk_repo 编译成功后会在 out/host/linux-x86/sdk/aosp_x86_64 目录下生成 sdk-repo-linux-system-images-eng.[username].zip 文件 按照官方文档中使用镜像的方式我没有成功 这里我使用了一个取巧的方式 我们在 Android Studio 创建 AVD 时可选的镜像一般有三种，这里还是以 Android 10 为例 Google Play，Google APIs，和默认的 它们会下载到 SDK/system-images/android-29 中 Google APIs 版本对应的目录就是 google_apis 我们可以将我们编译出的 AVD 镜像 copy 到其中的一个目录 例如，我将自定义的 AVD 镜像放置在了这里： 我们在创建模拟器时选择自定义的 AVD 镜像即可创建出自己编译 ROM 的模拟器 这里提供了我编译出来的自定义 AVD，不方便自己编译的小伙伴可以在此处下载 链接：https://pan.baidu.com/s/1LIcuycoU4Ou42VsSBM_MuQ提取码：CAVD]]></content>
      <categories>
        <category>ROM</category>
      </categories>
      <tags>
        <tag>ROM</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【奇技淫巧】使用 ProcessLifecycle 优雅地监听应用前后台切换]]></title>
    <url>%2F2020%2F07%2F01%2FTips-ProcessLifecycle%2F</url>
    <content type="text"><![CDATA[前言很高兴见到你，又来到了「奇技淫巧」系列，本系列介绍一些「骚操作」，可能不适合用于生产，但可以开拓思路 前些天在群里看到有人讨论通过维护 activity 栈来监听程序前后台切换的问题。其实单纯监听程序的前后台切换完全不需要维护 activity 栈，而现在比较主流的做法是使用 registerActivityLifecycleCallbacks。而今天我来介绍一下使用 ProcessLifecycleOwner 来实现这一功能 lifecycle-process 库Android Jetpack Lifecycle 组件有一个可选库：lifecycle-process，它可以为整个 app 进程提供一个 ProcessLifecycleOwner 该库十分简单，只有四个文件 ProcessLifecycleOwnerInitializer 借助 ContentProvider 拿到 Context，用于初始化操作 EmptyActivityLifecycleCallbacks 为 Application.ActivityLifecycleCallbacks 的实现类，内部为空实现 LifecycleDispatcher 通过 ReportFragment 来 hook 宿主的生命周期事件 核心逻辑都在 ProcessLifecycleOwner 中 该类提供了整个 app 进程的 lifecycle 可以将其视为所有 activity 的 LifecycleOwner ，其中 Lifecycle.Event.ON_CREATE 只会分发一次，而 Lifecycle.Event.ON_DESTROY 则永远不会分发 其它的生命周期事件将按以下规则分发： ProcessLifecycleOwner 会分发 Lifecycle.Event.ON_START 和 Lifecycle.Event.ON_RESUME 事件（在第一个 activity 移动到这些事件时） Lifecycle.Event.ON_PAUSE 与 Lifecycle.Event.ON_STOP 会在最后一个 activity 移动到这些状态后 延迟 分发，该延迟足够长，以确保由于配置更改等操作重建 activity 后不会分发任何事件 对于监听应用在前后台切换且不需要毫秒级的精度的场景，这十分有用 ProcessLifecycleOwner 源码解析根据上图我们得知 ProcessLifecycleOwner 实现了 LifecycleOwner 接口 由于在 ProcessLifecycleOwnerInitializer 中初始化时传入了 Context，因此 ProcessLifecycleOwner 在 attach 方法中借助 Context 拿到了 Application 实例，并调用了 registerActivityLifecycleCallbacks 1234567891011121314151617181920212223242526272829303132333435363738394041void attach(Context context) &#123; mHandler = new Handler(); mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); Application app = (Application) context.getApplicationContext(); app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() @RequiresApi(29) @Override public void onActivityPreCreated(@NonNull Activity activity, @Nullable Bundle savedInstanceState) &#123; //我们需要 ProcessLifecycleOwner 刚好在第一个 activity 的 LifecycleOwner started/resumed 之前获取 ON_START 和 ON_RESUME。 //activity 的 LifecycleOwner 通过在 onCreate() 中添加 activity 注册的 callback 来获取 started/resumed 状态。 //通过在 onActivityPreCreated() 中添加我们自己的 activity 注册的 callback，我们首先获得了回调，同时与 Activity 的 onStart()/ onResume()回调相比仍具有正确的相对顺序 activity.registerActivityLifecycleCallbacks(new EmptyActivityLifecycl @Override public void onActivityPostStarted(@NonNull Activity activity) &#123; activityStarted(); &#125; @Override public void onActivityPostResumed(@NonNull Activity activity) &#123; activityResumed(); &#125; &#125;); &#125; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceStat //仅在API 29 之前使用 ReportFragment，在此之后，我们可以使用在 onActivityPreCreated() 中注册的 onActivityPostStarted 和 onActivityPostResumed 回调 if (Build.VERSION.SDK_INT &lt; 29) &#123; ReportFragment.get(activity).setProcessListener(mInitializationLi &#125; &#125; @Override public void onActivityPaused(Activity activity) &#123; activityPaused(); &#125; @Override public void onActivityStopped(Activity activity) &#123; activityStopped(); &#125; &#125;);&#125; 内部维护了 Started 和 Resumed 的数量 1234private int mStartedCounter = 0;private int mResumedCounter = 0;private boolean mPauseSent = true;private boolean mStopSent = true; 并在 activityStarted 和 activityResumed 方法中对 这两个数值进行 ++，并更改 lifecycle 状态 123456789101112131415161718void activityStarted() &#123; mStartedCounter++; if (mStartedCounter == 1 &amp;&amp; mStopSent) &#123; mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); mStopSent = false; &#125;&#125;void activityResumed() &#123; mResumedCounter++; if (mResumedCounter == 1) &#123; if (mPauseSent) &#123; mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); mPauseSent = false; &#125; else &#123; mHandler.removeCallbacks(mDelayedPauseRunnable); &#125; &#125;&#125; 在 activityPaused 和 activityStopped 方法对这两个数值进行 – 12345678910void activityPaused() &#123; mResumedCounter--; if (mResumedCounter == 0) &#123; mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS); &#125;&#125;void activityStopped() &#123; mStartedCounter--; dispatchStopIfNeeded();&#125; 而在这里我们看到了上文提到的延迟操作 123456789101112131415161718192021222324252627// 使用 handler 进行延迟操作mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);// 延迟 700 msstatic final long TIMEOUT_MS = 700; //mlsprivate Runnable mDelayedPauseRunnable = new Runnable() &#123; @Override public void run() &#123; // 根据需要分发事件 dispatchPauseIfNeeded(); dispatchStopIfNeeded(); &#125;&#125;;void dispatchPauseIfNeeded() &#123; if (mResumedCounter == 0) &#123; mPauseSent = true; mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE); &#125;&#125;void dispatchStopIfNeeded() &#123; if (mStartedCounter == 0 &amp;&amp; mPauseSent) &#123; mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP); mStopSent = true; &#125;&#125; 源码就解析到这里，接下来我们看看如何使用吧 使用首先引入该库 1implementation "androidx.lifecycle:lifecycle-process:2.3.0-alpha05" 由于我们要自定义 lifecycleObserver，因此还需引入 1implementation "androidx.lifecycle:lifecycle-common-java8:2.3.0-alpha05" 首先创建 ProcessLifecycleObserver 类，实现 DefaultLifecycleObserver 接口，在相应的生命周期中打印 log 接着在自定义 Application 中加入 这样便完成了！ Demo 在这里 系列文章 【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案 【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin 【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你 【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转 【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil 【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化 【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild 【奇技淫巧】巧用 kotlin 扩展函数和 typealias 封装 带网络状态和解决「粘性」事件的 LiveData 关于我我是 Flywith24，我的博客内容已经分类整理 在这里，点击右上角的 Watch 可以及时获取我的文章更新哦 😉 掘金 小专栏 Github]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化]]></title>
    <url>%2F2020%2F05%2F20%2FTips-Navagion%2BDynamicFeatureModule%2F</url>
    <content type="text"><![CDATA[androidx navigation 2.3.0 加入了对 dynamic feature module 的导航支持，因此我们利用这个来分离出多个功能 module 来实现模块化 国内基本不用的 dynamic feature moduleAndroid App Bundle 是官方 18 年推出的动态发布方案，类似国内各种插件化方案。不过它需要 Google Play Store 支持，这导致在国内无法使用 借着 navigation 组件支持 dynamic feature module 间导航的契机，我们可以使用 dynamic feature module 来拆分功能模块以实现模块化 传统的拆分方案大概是这样，feature module 之间相互隔离，app module 依赖各个 feature module 间接依赖 base 库，公共库 而使用 dynamic feature module ，其结构是这样的 dynamic feature module 也可以按需安装，也就是说，它们可能不包含在用户最初下载的 APK 中，而是在运行时安装。而我们可以直接将它们包含到 APK 中 使用 dynamic feature module首先我们在 base lib 中引入依赖 1234567dependencies &#123; def nav_version = "2.3.0-alpha06" api "androidx.navigation:navigation-fragment-ktx:$nav_version" api "androidx.navigation:navigation-ui-ktx:$nav_version" api "androidx.navigation:navigation-dynamic-features-fragment:$nav_version"&#125; 我们在 app module 中的 res/navigation 目录下创建 main_nav.xml 接着我们在 activity_main 中设置默认的 host 这里不同于正常 navigation 的用法，没有使用 NavHostFragment，而是使用 DynamicNavHostFragment 直接跳转 fragment我们创建 dynamic feature module ，取名为 feature1 这里 dynamic feature module 的包名前部分要和 applicationId 即 app module 包名相同，否则后续的 include 操作会有问题 这里我们选择在安装时集成该 module 接着我们在该 module 下创建一个 fragment 取名为 Feature1OneFragment 之后我们直接在 main_nav.xml 中引入 该 fragment 并加入 action 接着我们就可以在 app 下的 MainFragment 打开 Feature1OneFragment 我的 demo 中 feature2 是直接引入 fragment，因此跳转的是 Feature2OneFragment 直接跳转 activity在 feature1 中创建 activity (demo 中为 feature2) 同样需要指定 moduleName 使用 dynamic feature module 内部的 graph我们可以为 dynamic feature module 单独配置 navigation graph，这样就可以处理 dynamic feature module 内部的跳转了 在 feature1 中创建 feature1_nav.xml ，其中 startDestination 为 Feature1OneFragment 在 main_nav.xml 我们需要使用另外一种方式来使用该 graph 我们使用了一个新的标签 include-dynamic，同时我们看到了几个没用过的属性 graphPackage 为 dynamic feature module 的包名 graphResName 为 dynamic feature module 内部 graph 的名字 moduleName 为 module 名 注意：这里的 graphPackage 可以省略 如果 module 的包名没用按照前文的格式配置会导致无法找到 graphId 的异常 include-dynamic 标签的 id 要与 feature1_nav.xml navigation 标签下的 id 一致，或者后者不设置 id 这样从 app module 导航到 feature1 的 startDestination 后便可使用其内部的逻辑进行后续的导航了 feature module 间跳转 Navigation 组件暂不支持 Dynamic include graph 的 deep link 因此我目前也没有找到特别优雅的方式，已知的方案如下 反射 使用 ServiceLoader 使用依赖注入 demo 关于我我是 Flywith24，我的博客内容已经分类整理 在这里，点击右上角的 Watch 可以及时获取我的文章更新哦 😉 掘金 小专栏 Github]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil]]></title>
    <url>%2F2020%2F05%2F18%2FTips-Coil%2F</url>
    <content type="text"><![CDATA[新的图片加载库——CoilCoil 是 Instacart 团队研发的新的的图片加载库，它使用了很多高级功能，例如协程，Okhttp，androidx.lifecycle。Coil 还包括一些高级功能，例如图像采样，有效的内存使用以及请求的自动取消/暂停 默认情况下 Coil 与 R8 完全兼容，开箱即用，不需要添加额外的规则。如果使用 Proguard ，您可能需要为 Coroutines, OkHttp 和 Okio 添加规则 Coil 的优势 快速：Coil 进行了很多优化，包括内存和磁盘缓存，对内存中的图像进行采样，重新使用位图，自动暂停/取消请求等等 轻量：Coil 在您的APK中添加了约 2000 种方法（对于已经使用 OkHttp 和 Coroutines 的应用程序），与 Picasso 相当，远少于 Glide 和 Fresco 易用：Coil 的 API 利用 Kotlin 的特性简化了样板代码 现代：Coil 是 Kotlin-first，使用现代化的库，例如 Coroutines, OkHttp, Okio, 以及 AndroidX Lifecycles Coil 是以下名称的缩写：Coroutine Image Loader ArtifactsCoil 拥有 5 个 artifact 并发布在 mavenCentral() io.coil-kt:coil：依赖于 io.coil-kt:coil-base 并且包含了 Coil 的单例和 ImageView.load 的扩展函数 io.coil-kt:coil-base：base 库，不包含 Coil 的单例和 ImageView.load 的扩展函数，如果使用依赖注入，则可以使用该库 io.coil-kt:coil-gif：引入一系列解码器以支持解码 gif io.coil-kt:coil-svg：引入一系列解码器以支持 svg io.coil-kt:coil-video：包括两个 fetchers ，以支持从 Android 支持的任何视频格式中提取和解码帧 1234// 普通使用引用implementation "io.coil-kt:coil:0.11.0"// 使用依赖注入时或者制作基于 coil 的库引用implementation "io.coil-kt:coil-base:0.11.0" Java 8Coil 要求 Java 8，要通过 D8 启用 Java 8 调试，请将以下内容添加到 Gradle 脚本 Gradle (.gradle) 123456789101112android &#123; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125;tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all &#123; kotlinOptions &#123; jvmTarget = "1.8" &#125;&#125; Gradle Kotlin DSL (.gradle.kts) 123456789101112android &#123; compileOptions &#123; sourceCompatibility = JavaVersion.VERSION_1_8 targetCompatibility = JavaVersion.VERSION_1_8 &#125;&#125;tasks.withType&lt;KotlinCompile&gt; &#123; kotlinOptions &#123; jvmTarget = "1.8" &#125;&#125; 使用ImageView 扩展函数io.coil-kt:coil 提供了 类型安全的 ImageView 扩展函数 在 ImageView 中加载图片，只需调用 load 扩展函数 12345678910// URLimageView.load("https://www.example.com/image.jpg")// ResourceimageView.load(R.drawable.image)// FileimageView.load(File("/path/to/image.jpg"))// And more... 上面的请求等价于： 123456val imageLoader = Coil.imageLoader(context)val request = LoadRequest.Builder(imageView.context) .data("https://www.example.com/image.jpg") .target(imageView) .build()imageLoader.execute(request) 可选的请求配置可以通过 lambda 来操作 12345imageView.load("https://www.example.com/image.jpg") &#123; crossfade(true) placeholder(R.drawable.image) transformations(CircleCropTransformation())&#125; Image Loaders¶ImageLoader 是执行请求的服务类。 他们处理缓存，数据获取，图像解码，请求管理，bitmap pool，内存管理等。 可以使用 builder 来创建和配置新实例： 1234val imageLoader = ImageLoader.Builder(context) .availableMemoryPercentage(0.25) .crossfade(true) .build() imageView.load 使用单例 ImageLoader 执行 LoadRequest 。 可以使用以下方式访问单例 ImageLoader： 1val imageLoader = Coil.imageLoader(context) （可选）您可以创建自己的ImageLoader实例，并通过依赖项注入将它们注入： 1val imageLoader = ImageLoader(context) 当您创建单个 ImageLoader 并在整个应用程序中共享时，Coil 的性能最佳。 这是因为每个 ImageLoader 都有自己的内存缓存，bitmap pool 和网络监听 Requests¶有两种 Request 类型 LoadRequest 是一个生命周期范围的 request，支持 Target，Transition 等等 GetRequest 挂起并返回 RequestResult 如果要加载到自定义 target 中，可以执行 LoadRequest 1234567val request = LoadRequest.Builder(context) .data("https://www.example.com/image.jpg") .target &#123; drawable -&gt; // Handle the result. &#125; .build()imageLoader.execute(request) 要强制获取图像，请执行GetRequest： 1234val request = GetRequest.Builder(context) .data("https://www.example.com/image.jpg") .build()val drawable = imageLoader.execute(request).drawable 单例如果您使用的是 io.coil-kt:coil ，您可以使用以下任意方式设置 ImageLoader 的实例 在 Application 中实现 ImageLoaderFactory（推荐） 12345678910111213class MyApplication : Application(), ImageLoaderFactory &#123; override fun newImageLoader(): ImageLoader &#123; return ImageLoader.Builder(context) .crossfade(true) .okHttpClient &#123; OkHttpClient.Builder() .cache(CoilUtils.createDefaultCache(context)) .build() &#125; .build() &#125;&#125; 调用 Coil.setImageLoader 123456789val imageLoader = ImageLoader.Builder(context) .crossfade(true) .okHttpClient &#123; OkHttpClient.Builder() .cache(CoilUtils.createDefaultCache(context)) .build() &#125; .build()Coil.setImageLoader(imageLoader) 默认的 ImageLoader 可以通过这样取回 1val imageLoader = Coil.imageLoader(context) 设置默认的 ImageLoader 是可选的。 如果未设置，则 Coil 会延迟创建具有默认值的 ImageLoader 如果您使用的是 io.coil-kt:coil-base，您应创建自己的 ImageLoader 实例并通过依赖注入将它注入到 app 中 注意：如果设置自定义OkHttpClient，则必须设置缓存实现，否则ImageLoader将没有磁盘缓存。 可以使用CoilUtils.createDefaultCache 创建默认的 Coil 缓存实例 支持的数据类型ImageLoader 支持的数据类型为 String (mapped to a Uri) HttpUrl Uri (android.resource, content, file, http, and https schemes only) File @DrawableRes Int Drawable Bitmap 预加载如果要预加载到内存中，执行一个不带 target 的 LoadRequest 123456val request = LoadRequest.Builder(context) .data("https://www.example.com/image.jpg") // 可选的，但是设置 ViewSizeResolver 可以通过限制预加载的大小来节省内存 .size(ViewSizeResolver(imageView)) .build()imageLoader.execute(request) 如果只想将网络图片预加载到磁盘中，可以为 request 关闭内存缓存 12345val request = LoadRequest.Builder(context) .data("https://www.example.com/image.jpg") .memoryCachePolicy(CachePolicy.DISABLED) .build()imageLoader.execute(request) 取消请求LoadRequest 会自动取消在以下几种情况下 关联的 view detached， 关联的 lifecycle destroyed 另一个 request 在相同的 view 中开启 此外，每个 LoadRequest 返回一个 RequestDisposable，可用于检查请求是否在运行中或处理该请求（有效地取消请求并释放其关联资源） 1234val disposable = imageView.load("https://www.example.com/image.jpg")// Cancel the request.disposable.dispose() GetRequest 仅当协程的上下文被取消时才会取消 图片采样假设磁盘上有一个 500x500 的映像，但是只需要以 100x100 的大小将其加载到内存中即可在视图中显示。 Coil 会将图像加载到内存中，但是如果您需要 500x500 的图像会怎样呢？ 从磁盘读取还有更好的「质量」，但是图像已经以 100x100 加载到内存中。 理想情况下，当我们从磁盘以 500x500 读取图像时，我们将使用 100x100 图像作为占位符。 这正是 Coil 所做的，并且 Coil 自动为所有 BitmapDrawables 处理此过程。 与 crossfade(true) 搭配使用时，可以创建视觉效果，使图像细节看起来像淡入淡出，类似于渐进式 JPEG 使用要求 AndroidX Min SDK 14+ Compile SDK: 29+ Java 8+ 详细内容移步 官方文档 关于我我是 Flywith24，我的博客内容已经分类整理 在这里，点击右上角的 Watch 可以及时获取我的文章更新哦 😉 掘金 小专栏 Github]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Jetpack更新之Fragment】1.3.0-alpha04 来袭，Fragment 间通信的新姿势]]></title>
    <url>%2F2020%2F04%2F30%2FJetpack-fragment-ResultAPI%2F</url>
    <content type="text"><![CDATA[前言fragment 1.3.0-alpha04 发布了，其中有很多变动，其中提供了 fragment 间传递数据的新方式 API 更改首先我们介绍一下 API 更改 startActivityForResult()/onActivityResult() 和 requestPermissions()/onRequestPermissionsResult() 弃用 prepareCall() 重命名为 registerForActivityResult() target fragment API 被弃用 Activity Result API 上位由于官方提供了 Activity Result API 来替换 onActivityResult 机制，因此 fragment 的 startActivityForResult()/onActivityResult() 和 requestPermissions()/onRequestPermissionsResult() 方法被标记弃用了 Activity Result API 详情可参考 秉心说 的 是时候丢掉 onActivityResult 了 ！ 文章介绍的很详尽，这里不再赘述 prepareCall 重命名值得注意的地方是 prepareCall() 被命名为 registerForActivityResult() 注意：在版本处于 Alpha 版状态时，可以添加、移除或更改 API。因此 Alpha 版本不适合在生产上使用 target fragment API 被弃用其实 target fragment API 早已被弃用 target fragment 需要直接访问另一个 fragment 的实例，这是十分危险的，因为你不知道目标 fragment 处于什么状态。而且 target fragment 不支持 Navigation 那么，fragment 之间传递数据更干净的方式是什么呢？ fragment 之间传递数据的新方式前文提到，在相同的 FragmentManager 中可以使用 target fragment API 来在 fragment 间传递数据，但这种方式需要直接访问目标fragment 的实例，这很危险，因为目标 fragment 的状态是未知的 因此官方提供了这样的 API，它允许在一个 fragment 上设置结果，并将该结果在 fragment 的适当的生命周期中使用。 这种传递数据的方式适用于 DialogFragment ，Navigation 中的 fragment 此更改还包括 -ktx 扩展功能以确保 kotlin 用户可以将 FragmentResultListener 作为 lambda 传递 源码分析老规矩，我们沿着官方的 commit log 来看看官方实现该功能的思路 首先，添加了 FragmentResultOwner 这样的的抽象，用于处理 fragment result，其内部有两个方法 setResult setResultListener 前者用于发送数据，后者用于接收数据 而其实现类为 FragmentManager 我们来看看 FragmentManager 两个方法的具体实现 123456789101112131415161718192021222324252627282930313233343536373839public final void setFragmentResultListener(@NonNull final String requestKey, @NonNull final LifecycleOwner lifecycleOwner, @Nullable final FragmentResultListener listener) &#123; // 设置的 listener 为空时将 requestKey 对应的 listener 移除 if (listener == null) &#123; mResultListeners.remove(requestKey); return; &#125; // 当fragment 处于DESTROYED 状态时 直接 return ，避免了异常 final Lifecycle lifecycle = lifecycleOwner.getLifecycle(); if (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) &#123; return; &#125; // 观察生命周期，fragment started 后接收回调，destroyed 移除回调 LifecycleEventObserver observer = new LifecycleEventObserver() &#123; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; if (event == Lifecycle.Event.ON_START) &#123; // once we are started, check for any stored results Bundle storedResult = mResults.get(requestKey); if (storedResult != null) &#123; // if there is a result, fire the callback listener.onFragmentResult(requestKey, storedResult); // and clear the result setFragmentResult(requestKey, null); &#125; &#125; if (event == Lifecycle.Event.ON_DESTROY) &#123; lifecycle.removeObserver(this); mResultListeners.remove(requestKey); &#125; &#125; &#125;; lifecycle.addObserver(observer); mResultListeners.put(requestKey, new LifecycleAwareResultListener(lifecycle, listener));&#125; 以上便是这部分的源码 这里要注意一点的是 fragment result api 是基于同一 FragmentManager 的 总结官方一直致力于将 fragment 的 api 变得更好用 Ian Lake 在 Fragments: Past, Present, and Future (Android Dev Summit ‘19) 中提到了 fragment 间通信的问题，未来 fragment 会整合 fragment 自身和其内部 view 的生命周期，提供同一 FragmentManager 多返回栈的支持 看到 fragment result API ，我突然有个想法，如果将其应用到 Navigation 中是否是解决 Navigation 跳转返回后状态重置的一个方法呢？ 各位小伙伴有什么想法欢迎评论区留言 关于我我是 Fly_with24 掘金 简书 Github 欢迎关注我的公众号]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Jetpack更新之Fragment】setRetainInstance 被弃用，那么 fragment 是如何保存状态的？]]></title>
    <url>%2F2020%2F04%2F30%2FJetpack-fragment-savestate%2F</url>
    <content type="text"><![CDATA[我们都知道 fragment 中的 setRetainInstance 用于控制是否在 activity 保留 fragment 实例，具体内容可参见 WanAndroid 的每日一问：Fragment 是如何被存储与恢复的？ 但是该方法已于 androidx fragment 1.3.0-alpha01 弃用了 老规矩，我们查看一下 commit log 简单概况一下 SetRetainInstance 尝试在 activity 重建时保存状态。但它带来了很多副作用。 随着 ViewModel 的引入，开发者拥有一个特定的 API，用于保留与 Activity，Fragments 和 Navigation 相关联的状态。 这使开发者可以使用正常的，不需要保留 fragment ，从而在保存单个需要的属性时避免了常见的泄漏源，并且可以销毁保存的状态（即 ViewModel 的构造器和 onCleared 回调） 详情可参见 【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析 和 【背上Jetpack之ViewModel】即使您不使用MVVM也要了解ViewModel ——ViewModel 的职能边界 从这个改动可以看出官方正致力于保证逻辑的单一性，状态保存交给 ViewModel ，减少这种特殊的例外情况，从而消除一些不符合预期的问题 关于我我是 Fly_with24 掘金 简书 Github 欢迎关注我的公众号]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Jetpack更新之Fragment】setMaxLifecycle 上位，setUserVisibleHint 被弃用]]></title>
    <url>%2F2020%2F04%2F29%2FJetpack-fragment-setMaxLifecycle%2F</url>
    <content type="text"><![CDATA[很多情况下，fragment 的生命周期上限应该低于 FragmentManager/Activity。例如，ViewPager 屏幕外的界面不应被 resumed 理想状态下，可以通过以下 API 实现 1234supportFragmentManager .beginTransaction() .setMaxLifecycle(fragment, Lifecycle.State.RESUMED) .commit() 将最大生命周期设置为 Lifecycle.State.RESUMED 将有效地消除限制（因为这是最高生命周期状态） 这将允许废弃 setUserVisibleHint() API setMaxLifecycle 出现始末该功能应如何实现的？我们沿着 commit log 来理一下官方的思路 将 BackStackRecord 的部分逻辑转移至父类 FragmentTransaction 中 在 FragmentTransaction 中添加 setMaxLifecycle API 保存 fragment maxState 弃用 setUserVisibleHint FragmentPagerAdapter 构造器新增参数，使用 setMaxLifecycle() API 确保 fragment resumed 时对用户可见 弃用 FragmentStatePagerAdapter 原来的单参构造器，推荐使用新的构造 随着 ViewPager2 1.0.0 正式版发布，与 ViewPager 交互的FragmentPagerAdapter 和 FragmentStatePagerAdapter 被弃用了 至此我们捋顺了 setMaxLifecycle 的出现，setUserVisibleHint 的弃用以及与ViewPager 相关的 FragmentPagerAdapter 和 FragmentStatePagerAdapter 的弃用 setMaxLifecycle 内部逻辑接下来我们看看 setMaxLifecycle 是如何发挥作用的 首先我们要研究一下 fragment 的状态管理，为了更好的管理 fragment 的状态，官方添加了 FragmentStateManager 类来专门管理 fragment 的状态，职能单一原则哈 接着在该类中添加了计算 fragment 最大生命周期的方法 computeMaxState() 后来该方法改名为 computeExpectedState() 并加入了 moveToExpectedState() 方法 computeExpectedState() 方法会根据 fragment mMaxState 计算 fragment 应该所处的生命周期 而 fragment 的 mMaxState 是通过 FragmentManager 的 setMaxLifecycle() 方法设置的 ，而该方法是 BackStackRecord 执行 OP 时调用的，而 OP 值正是通过 FragmentTransaction 的 setMaxLifecycle() 设置的 至此，我们理清了 setMaxLifecycle() 的内部逻辑 总结我们可以看到官方为了使 fragment 能够在正确的生命周期上，引入了 setMaxLifecycle() 方法，同时为了更好的管理 fragment 的状态，抽象出了 FragmentStateManager 。更少的代码，更少的职责，fragment 的内部逻辑会越来越清晰 关于如何迁移至 ViewPager2 ，请移步 官方视频 关于新的 API 下懒加载实现，请移步 Androidx 下 Fragment 懒加载的新实现 关于我我是 Fly_with24 掘金 简书 Github 欢迎关注我的公众号]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【奇技淫巧】巧用 kotlin 扩展函数和 typealias 封装 LiveData]]></title>
    <url>%2F2020%2F04%2F15%2FTips-StateLiveData%2F</url>
    <content type="text"><![CDATA[关于 LiveData 两个常用的姿势使用包装类传递事件我们在使用 LiveData 时可能会遇到「粘性」事件的问题，该问题可以使用包装类的方式解决。解决方案见 [译] 在 SnackBar，Navigation 和其他事件中使用 LiveData（SingleLiveEvent 案例） 使用时是这样的 1234567891011121314151617class ListViewModel : ViewModel &#123; private val _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;() val navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt; get() = _navigateToDetails fun userClicksOnButton(itemId: String) &#123; _navigateToDetails.value = Event(itemId) // Trigger the event by setting a new Event as a new value &#125;&#125;myViewModel.navigateToDetails.observe(this, Observer &#123; it.getContentIfNotHandled()?.let &#123; // Only proceed if the event has never been handled startActivity(DetailsActivity...) &#125;&#125;) 不过这样写甚是繁琐，我们可以使用更优雅的方式解决该问题 1234//为 LiveData&lt;Event&lt;T&gt;&gt;提供类型别名，使用 EventLiveData&lt;T&gt; 即可typealias EventMutableLiveData&lt;T&gt; = MutableLiveData&lt;Event&lt;T&gt;&gt;typealias EventLiveData&lt;T&gt; = LiveData&lt;Event&lt;T&gt;&gt; 使用 typealias 关键字，我们可以提供一个类型别名，可以这样使用 12//等价于 MutableLiveData&lt;Event&lt;Boolean&gt;&gt;(Event(false))val eventContent = EventMutableLiveData&lt;Boolean&gt;(Event(false)) 现在声明时不用多加一层泛型了，那么使用时还是很繁琐 我们可以借助 kotlin 的 扩展函数更优雅的使用 demo 中封装了两种形式的 LiveData，一种为 LiveData&lt;Boolean&gt;，一种为 EventLiveData&lt;Boolean&gt;，当屏幕旋转时，前者会再次回调结果，而后者由于事件已被处理而不执行 onChanged，我们通过 Toast 可观察到这一现象 java 版的可参考 封装带网络状态的数据很多时候我们在获取网络数据时要封装一层网络状态，例如：加载中，成功，失败 在使用时我们遇到了和上面一样的问题，多层泛型用起来很麻烦 我们依然可以使用 typealias + 扩展函数来优雅的处理该问题 demo 截图 Demodemo 在这，如果感觉这个思路对你有帮助的话，点一颗小星星吧～ 😉 另外我还将它传到了 JitPack 上，引入姿势如下： 在项目根目录的 build.gradle 加入 123456allprojects &#123; repositories &#123; //... maven &#123; url 'https://jitpack.io' &#125; &#125;&#125; 添加依赖 123dependencies &#123; implementation 'com.github.Flywith24:WrapperLiveData:$version'&#125; 往期文章该系列主要介绍一些「骚操作」，它未必适合生产环境使用，但是是一些比较新颖的思路 【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案 【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin 【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你 【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转 【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil 【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化 【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild 我的其他系列文章 在这里 关于我我是 Flywith24，我的博客内容已经分类整理 在这里，点击右上角的 Watch 可以及时获取我的文章更新哦 😉 掘金 简书 Github]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild]]></title>
    <url>%2F2020%2F04%2F15%2FTips-includeBuild%2F</url>
    <content type="text"><![CDATA[buildSrc 的缺陷Android 开发中统一不同 module 的依赖版本十分重要，传统的方式是使用 ext 的方式 之前我发过关于使用 buildSrc 简化项目中 gradle 代码的译文：什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin 该种方式可以很好的管理 gradle 的公共配置，这其中当然包括依赖版本 如图，在使用依赖时有代码提示，而且可以点击进入查看 但是由于 buildSrc 是对全局的所有 module 的配置，因此在构建速度上会慢一些。那么有没有一个更纯净的方式来配置依赖版本呢？ 今天我们来介绍一种新的方式 自定义 plugin + includeBuild使用 Gradle Composite builds 可以很容易解决这一问题 我们新建一个 module，命名为 version ，并将原来的 buildSrc 的代码转移过来 12345class DependencyVersionPlugin : Plugin&lt;Project&gt; &#123; override fun apply(project: Project) &#123; &#125;&#125; 在 version 的 build.gradle 文件加入 12345678gradlePlugin &#123; plugins &#123; version &#123; id = 'com.flywith24.version' implementationClass = 'com.flywith24.version.DependencyVersionPlugin' &#125; &#125;&#125; 在 settings.gradle 加入 includeBuild(&quot;version&quot;) （重点） 12345includeBuild("version")rootProject.name='VersionControlDemo'include ':app'include ':lib' 接下来在需要引用的 module 中引入该插件 123plugins &#123; id "com.flywith24.version"&#125; 之后我们就可以使用了 Demo demo 在这 往期文章该系列主要介绍一些「骚操作」，它未必适合生产环境使用，但是是一些比较新颖的思路 【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案 【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin 【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你 【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转 【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil 【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化 我的其他系列文章 在这里 关于我我是 Flywith24，我的博客内容已经分类整理 在这里，点击右上角的 Watch 可以及时获取我的文章更新哦 😉 掘金 小专栏 Github]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转]]></title>
    <url>%2F2020%2F04%2F15%2FTips-Components-Jump%2F</url>
    <content type="text"><![CDATA[前言越来越多的项目使用了组件化，组件之间的通信是一个比较重要的问题。ARouter 等路由方案为我们提供了解决办法。那么如果不使用 Router 如何实现组件间的界面跳转呢？ 万能的 setClassName从一个 Activity 跳转到另一个Activity 的最直接方法如下： 12val intent = Intent(this, TestActivity::class.java)startActivity(intent) 但是，采用这种方法，当原 activity 位于一个 module（例如 FeatureA ）中，而目标 activity 位于另一个 module（FeatureB）中时，该怎么办？ 我们可以使用 Intent 的 setClassName 方法 123val intent = Intent()intent.setClassName(this, “com.flywith24.demo.TestActivity”)startActivity(intent) 但是这种方式硬编码目标 activity 的完整类名，如果 activity 的类名被更改或者移动，而且没有更改硬编码，则编译可以通过，但是运行时崩溃 如果可以自动生成 activity 完整类名就好了 使用插件我们知道 activity 作为 Android 的组件之一需要在 Manifest 文件中声明 123&lt;activity android:name=”com.flywith24.demo.MainActivity” /&gt;&lt;activity android:name=”com.flywith24.demo.TestActivity” /&gt; 如果我们的数据是从 Manifest 中获得的，那么就解决了硬编码的问题了 有这样一个插件 ，在 build 时会将所有在 Manifest 中声明的 activity 的完整类名以静态常量的形式罗列到一个静态类中 12345678object QuadrantConstants &#123; const val MAIN_ACTIVITY: String = "com.gaelmarhic.quadrant.MainActivity" const val SECONDARY_ACTIVITY: String = "com.gaelmarhic.quadrant.SecondaryActivity" const val TERTIARY_ACTIVITY: String = "com.gaelmarhic.quadrant.TertiaryActivity"&#125; 这样在使用时就避免了硬编码 123val intent = Intent()intent.setClassName(context, QuadrantConstants.MAIN_ACTIVITY)startActivity(intent) 使用依赖注入组件化中 app module 会依赖所有的功能 module ，因此如果我们使用依赖注入在 app 中将所有的目标 activity 的完整类名声明出来，也能达到解决硬编码的问题 这里以 koin 为例 12345678910111213class MyApplication : Application() &#123; val myModule = module &#123; single &#123; Feature2Activity::class.java.name &#125; &#125; override fun onCreate() &#123; super.onCreate() startKoin &#123; androidContext(this@MyApplication) modules(myModule) &#125; &#125;&#125; 这样通过 get() 方法即可拿到 Feature2Activity 的完整类名 1234val intent = Intent() .setClassName(this@Feature1Activity, get()) .putExtra("key", "value")startActivity(intent) DemoDemo 地址 各位有什么想法欢迎在评论区留言 关于我我是 Flywith24，我的博客内容已经分类整理 在这里，点击右上角的 Watch 可以及时获取我的文章更新哦 😉 掘金 小专栏 Github]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之DataBinding】数据驱动魔法师 何时迎来翻身日？]]></title>
    <url>%2F2020%2F04%2F09%2FJetpack-DataBinding%2F</url>
    <content type="text"><![CDATA[LiveData 篇 我们提到 Android 开发的主要工作内容是将数据转换为 UI ，同时我们也介绍了数据驱动 UI 的思想，使用 ViewModel + LiveData，可以安全地在订阅者的生命周期内分发正确的数据。但是 activity 和 fragment 充斥着大量的模板代码，铺天盖地的 findViewById，以及各种 set （根据数据设置 UI）。如果能够消灭掉这些模板代码就好了 他来了他来了，他欢快地走来了 然而，很多开发者对 DataBinding 存在偏见，「DataBinding 不是个好东西，在声明式编程中书写 UI 逻辑，既不可调试，也不便于察觉和追踪，万一出现问题就麻烦了。」 本文主要介绍 DataBinding 的解决的问题以及其背后的逻辑，带您对 DataBinding 有一个感性的认识。本文末尾会对各个 findViewById 的替代方案进行对比 DataBinding 的相关资源 官方文档 codelab 官方示例 数据驱动魔法师 DataBinding 允许使用声明性格式而不是通过编程方式将布局中的 UI 组件与数据源绑定 123// beforeTextView textView = findViewById(R.id.sample_text);textView.setText(viewModel.getUserName()); 12&lt;TextView android:text="@&#123;viewmodel.userName&#125;" /&gt; 通过在布局文件中绑定组件，您可以删除 activity 中的许多设置 UI 调用，从而使它们更易于维护。 这也可以提高应用程序的性能，并有助于防止内存泄漏和空指针异常 如果仅替换 findViewById 而不需要数据的绑定，可以使用 ViewBinding，它使用起来更简单，性能也更好。 使用方法参见 [译]深入研究ViewBinding 在 include, merge, adapter, fragment, activity 中使用 DataBinding 基础 详细内容参见 官方文档 ，这里只简单介绍 DataBinding DataBinding 引入app build.gradle 中加入 1234567891011121314android &#123; ... dataBinding &#123; enabled = true &#125;&#125;// Android Studio 4.0android &#123; ... buildFeatures &#123; dataBinding = true &#125;&#125; 必须在 app module 中声明，声明后其他子 module 可直接使用 DataBinding 使用 DataBinding 无需开发者手动引入库，android build gradle plugin 内部已经引入了 DataBinding 中使用了注解，因此在构建速度上比 ViewBinding 差些（不过功能这么强大要啥自行车） 布局DataBinding 布局文件略有不同，它们以 layout 的根标记开始，后跟一个 data 元素和一个 view 根元素。 view 元素是您的根将位于非绑定布局文件中的元素。 以下代码显示了一个示例布局文件： 123456789&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="viewmodel" type="com.myapp.data.ViewModel" /&gt; &lt;/data&gt; &lt;ConstraintLayout... /&gt; &lt;!-- UI layout's root element --&gt;&lt;/layout&gt; 生成绑定类DataBinding 会为每个在布局声明 layout 标签的 xml 布局文件生成一个绑定类。 默认情况下，类的名称基于布局文件的名称。 上面的布局文件名是 activity_main.xml，因此相应的生成类是 ActivityMainBinding。 此类包含从布局属性（例如，viewmodel 变量）到布局视图的所有绑定，并且知道如何为绑定表达式分配值 配置绑定12345678910@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // before // setContentView(R.layout.activity_main) // after val binding : ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)&#125; 使用DataBinding 解决的问题及实现原理 不知道你是否有这些烦恼：activity 和 fragment 中有着大量的模板代码，即使使用 ButterKnife 等工具写起代码来也很繁琐。而且 View id 与 View 的类型不匹配时，只有在运行期才能发现；旋转屏幕后如果新的布局中不存在之前 id 的 view ，可能还导致空指针异常；项目中使用各类 bus 通知 UI 刷新，但是有时 UI 的显示并不符合预期，而排查起来特别困难，因为数据源很多… 不要慌，DataBinding 可以解决以下问题 替换 findViewById ，减少模板代码 解决类型安全问题 解决空安全问题 保证了数据的一致性 魔法的背后com.android.tools.build:gradle 插件中封装了 DataBinding 的魔法 查看 com.android.tools.build:gradle:3.6.2 的源码，找到 DataBinding 配置项的类 DataBindingOptions 123456// DataBindingOptions.java@Overridepublic boolean isEnabled() &#123; // DataBinding 是否开启，对应上面在 build.gradle 中的配置 return enabled;&#125; 它的调用者很多，在 TaskManager 中的 createDataBindingTasksIfNecessary 12345678910111213141516171819202122232425// TaskManager protected void createDataBindingTasksIfNecessary(@NonNull VariantScope scope) &#123; // 是否开启 DataBinding boolean dataBindingEnabled = extension.getDataBinding().isEnabled(); boolean viewBindingEnabled = extension.getViewBinding().isEnabled(); if (!dataBindingEnabled &amp;&amp; !viewBindingEnabled) &#123; // DataBinding 和 ViewBinding 均未开启则直接 return return; &#125; createDataBindingMergeBaseClassesTask(scope); createDataBindingMergeArtifactsTask(scope); //... // 构建 DataBinding 相应绑定类 taskFactory.register(new DataBindingGenBaseClassesTask.CreationAction(scope));&#125;// CreationActionoverride fun handleProvider(taskProvider: TaskProvider&lt;out DataBindingGenBaseClassesTask&gt;) &#123; variantScope.artifacts.producesDir( // DATA_BINDING_BASE_CLASS_SOURCE_OUT InternalArtifactType.DATA_BINDING_BASE_CLASS_SOURCE_OUT, BuildArtifactsHolder.OperationType.INITIAL, taskProvider, DataBindingGenBaseClassesTask::sourceOutFolder )&#125; 可以看到生成 DataBinding 绑定类的 task 为 DataBindingGenBaseClassesTask，而InternalArtifactType.DATA_BINDING_BASE_CLASS_SOURCE_OUT 则对应着 build 目录生成的 DataBinding 类的 data_binding_base_class_source_out 目录 这里可以简单看一下，感兴趣的小伙伴可以自己查看源码 DataBinding 如何解决上述问题的我们可以查看 DataBinding 生成的绑定类 1234567891011121314151617181920212223public final class FragmentSingleChildBinding implements ViewBinding &#123; // NonNull 注解标记 // 如果存在不同配置的不同布局文件（如横竖屏）且该控件不是存在于所有布局，该处使用 Nullable注解标记 @NonNull public final MaterialButton button; // 省略... @NonNull public static FragmentSingleChildBinding bind(@NonNull View rootView) &#123; String missingId; missingId: &#123; //其内部也是使用 findViewById MaterialButton button = rootView.findViewById(R.id.button); if (button == null) &#123; missingId = "button"; break missingId; &#125; return new FragmentSingleChildBinding((MaterialButton) rootView, button); &#125; throw new NullPointerException("Missing required view with ID: ".concat(missingId)); &#125;&#125; Binding 类内部的也是使用 findViewById ，因此 DataBinding 可以代替 findViewById ，并且减少模板代码 View 控件变量类型是固定的，因此不会出现类型安全问题 View 控件变量由空/非空注解修饰，（如果为 Nullable java 中会有 lint 警告，而 kotlin 直接调用时无法通过编译的）因此 不会出现空安全问题 通过声明式的配置，UI 完全来自唯一可信的数据源配置，保证了数据的一致性 注意：以上分析同样适用于 ViewBinding 感受魔法的魅力 这里简单展示一下 DataBinding 的「魔法」 基本操作123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/firstName" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/lastName" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Before Data Binding //setContentView(R.layout.activity_main); //TextView firstName = (TextView) findViewById(R.id.firstName); //TextView lastName = (TextView) findViewById(R.id.lastName); //firstName.setText("xxx"); //lastName.setText("xxx"); // After Data Binding ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); binding.firstName.setText("xxx"); binding.lastName.setText("xxx"); &#125;&#125; 上面展示了 DataBinding 的基础操作（单纯的替换 findViewById），如果仅使用 DataBinding 这部分功能，可以考虑使用 ViewBinding 绑定数据在之前的布局的基础上绑定数据 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/firstName" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;"/&gt; &lt;TextView android:id="@+id/lastName" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.lastName&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 123456789public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); binding.user = new User("xxx","xxx"); &#125;&#125; 这种方式也可以用在 recyclerview adapter 中，adapter 中的代码大大减少 Binding Adapter您可能会好奇配置 android:text=&quot;@{user.firstName} 后内部发生了什么 DataBinding 中使用 Binding Adapter 来处理，它主要处理「属性」和「事件」，前者如 setText() ，后者如 setOnClickListener()。上面的 android:text 实际上调用的是下面的方法 DataBinding 中提供了很多 Binding Adapter 如果官方提供的 Binding Adapter 不满足您的需求，您还可以自定义 Binding Adapter 1234@BindingAdapter(&#123;"imageUrl", "error"&#125;)public static void loadImage(ImageView view, String url, Drawable error) &#123; Glide.with(view).load(url).error(error).into(view);&#125; 1&lt;ImageView app:imageUrl="@&#123;venue.imageUrl&#125;" app:error="@&#123;@drawable/venueError&#125;" /&gt; DadaBinding + LiveData要将 LiveData 与 DataBinding 一起使用，需要指定生命周期所有者来定义 LiveData 对象的范围 12345678class ViewModelActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; UserBinding binding = DataBindingUtil.setContentView(this, R.layout.user); binding.setLifecycleOwner(this); &#125;&#125; 双向绑定使用单向 DataBinding，可以在属性上设置一个值，并设置一个对该属性的更改做出反应的监听器： 12345&lt;CheckBox android:id="@+id/rememberMeCheckBox" android:checked="@&#123;viewmodel.rememberMe&#125;" android:onCheckedChanged="@&#123;viewmodel.rememberMeChanged&#125;"/&gt; 使用双向绑定可以简化该过程 1234&lt;CheckBox android:id="@+id/rememberMeCheckBox" android:checked="@=&#123;viewmodel.rememberMe&#125;"/&gt; 使用 @={} 接收对该属性的数据更改，并同时监听用户更新（注意，这里有 = ） 那么究竟什么是双向绑定呢？ 所谓的「数据驱动」就是数据驱动视图的变化，而 DataBinding 的单向绑定就是如此。反过来讲，有些时候我们需要视图来驱动数据的变化（例如当我们在 EditText 上输入了文字，我们希望对应的 ViewModel 的 LiveData 的值能够及时响应该变化） 如图，绿色部分为独立的 fragment ，内部存在两个 TextView，用于显示外部 fragment EditText 输入的文字 如果实现上述功能，传统做法可能是使用 activity 级别的 ViewModel 进行两个 fragment 之间的通信，通过监听 EditText 文字的变化改变 ViewModel 中 LiveData 的值，并在绿色 fragment 中观察 LiveData 并显示到 TextView 中 123456789101112131415161718192021222324252627282930class NormalViewModel : ViewModel() &#123; val firstName = MutableLiveData&lt;String&gt;() val lastName = MutableLiveData&lt;String&gt;()&#125;class NormalDetailFragment : Fragment(R.layout.fragment_normal_detail) &#123; private val mViewModel by activityViewModels&lt;NormalViewModel&gt;() override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; mViewModel.firstName.observe(viewLifecycleOwner) &#123; tvFirstName.text = it &#125; mViewModel.lastName.observe(viewLifecycleOwner) &#123; tvLastName.text = it &#125; &#125;&#125;class NormalFragment : Fragment(R.layout.fragment_normal) &#123; private val mViewModel by activityViewModels&lt;NormalViewModel&gt;() override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; etFirstName.addTextChangedListener &#123; mViewModel.firstName.value = it.toString() &#125; etLastName.addTextChangedListener &#123; mViewModel.lastName.value = it.toString() &#125; &#125;&#125; 得益于 kotlin ，上面的代码以及很简洁了，如果使用 java 代码片段只会更长。 不过使用 DataBinding，还可以更简洁 123456&lt;com.google.android.material.textview.MaterialTextView android:id="@+id/tvFirstName" android:text="@&#123;vm.firstName&#125;"/&gt;&lt;com.google.android.material.textview.MaterialTextView android:id="@+id/tvLastName" android:text="@&#123;vm.lastName&#125;"/&gt; 123456&lt;com.google.android.material.textfield.TextInputEditText android:id="@+id/etFirstName" android:text="@=&#123;vm.firstName&#125;"/&gt;&lt;com.google.android.material.textfield.TextInputEditText android:id="@+id/etLastName" android:text="@=&#123;vm.lastName&#125;"/&gt; 只需配置好双向绑定（EditText 驱动 ViewModel 的 LiveData 的值变化，ViewModel 再驱动 TextView 显示数据），并在 fragment 通过固定的模板代码设置好 ViewModel 即可 这里的魔法还是来自 Binding Adapter 12345678910111213141516171819202122232425262728293031323334353637383940414243// TextViewBindingAdapter.java@BindingAdapter(value = &#123;"android:beforeTextChanged", "android:onTextChanged", "android:afterTextChanged", "android:textAttrChanged"&#125;, requireAll = false)public static void setTextWatcher(TextView view, final BeforeTextChanged before, final OnTextChanged on, final AfterTextChanged after, final InverseBindingListener textAttrChanged) &#123; final TextWatcher newValue; if (before == null &amp;&amp; after == null &amp;&amp; on == null &amp;&amp; textAttrChanged == null) &#123; newValue = null; &#125; else &#123; newValue = new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; if (before != null) &#123; before.beforeTextChanged(s, start, count, after); &#125; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; if (on != null) &#123; on.onTextChanged(s, start, before, count); &#125; if (textAttrChanged != null) &#123; //通知发生变化 textAttrChanged.onChange(); &#125; &#125; @Override public void afterTextChanged(Editable s) &#123; if (after != null) &#123; after.afterTextChanged(s); &#125; &#125; &#125;; &#125; final TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher); if (oldValue != null) &#123; view.removeTextChangedListener(oldValue); &#125; if (newValue != null) &#123; view.addTextChangedListener(newValue); &#125;&#125; 这里使用 InverseBindingListener （调用 textAttrChanged.onChange()）来通知 LiveData 数据发生变化 而变化后的值 通过 @InverseBindingAdapter 注解标记的方法处理，这里的 event 与上面的标记匹配（android:textAttrChanged） 12345// TextViewBindingAdapter.java@InverseBindingAdapter(attribute = "android:text", event = "android:textAttrChanged")public static String getTextString(TextView view) &#123; return view.getText().toString();&#125; view 层变化通知数据变化，数据变化再通知 view 层变化，仿佛是个套娃 因此避免这种死循环十分重要，setText 方法判断了新旧值是否相等来避免死循环 总结 DataBinding 主要提供两部分功能 替换 findViewById ，如果只用这部分功能可以使用 ViewBinding 进行 data 和 UI 的绑定，使用「数据驱动」的思想解决了视图的一致性问题 各种 findViewById 替代方案对比 findViewById Butterknife Kotlin Synthetics Data Binding View Binding findViewById findViewById 有两个问题 当不能在 Activity/Fragment/ViewGroup 中定位到指定 id 的 View，会在运行期间崩溃，即非空安全 如果某个 view 为 TextView 类型，而在使用中将其指定为其他类型不会在编译器报错，即非类型安全 在 compileSdk 的 API 级别 26 中，对该方法的定义稍作更改以消除强制类型转换问题 现在，开发人员无需在代码中手动转换 view 类型。 如果您引用 id 指向类型 TextView 的 View 并将其指定为 Button，则 Android SDK 会尝试查找具有提供的 id 的 Button，并且它将返回 Null，因为它将无法找到它 但是在 Kotlin 中，您仍然需要提供诸如 findViewById(R.id.txtUsername) 之类的类型。 如果您不检查视图是否具有 null 安全，则可能出现 NullPointerException，但是此方法不会像以前那样抛出ClassCastException ButterknifeButterknife 是 Jake Wharton 大神写的替代 findViewById 的库，该库使用注解处理并生成 findViewById 代码 它具有与 findViewById 几乎相似的问题。 但是，它在运行时添加了null 安全检查以避免 NullPointerException 由于 DataBinding 和 ViewBinding 的出现，沃神已经宣布弃用该库 Kotlin SyntheticsKotlin 引入的最大功能之一是 Kotlin 扩展方法。 在它的帮助下，Kotlin Synthetics 诞生了。 Kotlin Synthetics 通过自动生成的 Kotlin 扩展方法，使开发人员可以从 xml 布局直接访问其内部的 view Kotlin Synthetics 第一次调用 findViewById 方法，然后默认情况下将 view 实例缓存在 HashMap 中。 可以通过Gradle 设置将此缓存配置更改为 SparseArray 或不缓存 总体而言，Kotlin Synthetics 是一种很好的选择，因为它类型安全，并且通过 Kotlin 的 ？进行空检查。 它不需要开发人员的额外代码。 但这仅适用于 Kotlin 项目 但是，在使用 Kotlin Synthetics 时遇到了一个小问题。 例如，如果将内容视图设置为布局，然后使用仅存在于其他布局中的 id ，则 IDE 可让您自动完成并添加新的 import 语句。 除非您专门检查以确保其 import 语句仅导入正确的 view，否则没有安全的方法来验证这不会导致运行时问题 DataBindingDataBinding 在功能上比其他方法优越得多，因为它不仅为您提供类型安全和空安全的 view 引用，而且还允许您直接在 xml 布局内使用数据驱动视图变化 ViewBinding最近在 Android Studio 3.6 中引入的 ViewBinding 是 DataBinding 库的子集。 由于不需要注解处理，因此可以缩短构建时间。详细的使用可以参见 这篇文章 findViewById Butterknife Kotlin Synthetics DataBinding ViewBinding 一直空安全 ❌ 部分 部分 ✔️ ✔️ 类型安全 ❌ ❌ ✔️ ✔️ ✔️ 样板代码 多 少 少 中等 少 构建时间 ✔️ ❌ ✔️ ❌ ✔️ 支持语音 java/kotlin java/kotlin kotlin java/kotlin java/kotlin 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Jetpack更新之Recyclerview】更优雅地恢复 recyclerview 的滚动位置]]></title>
    <url>%2F2020%2F04%2F09%2FJetpack-Recyclerview-Scoroll%2F</url>
    <content type="text"><![CDATA[被我忽视的更新androidx recyclerview 1.2.0-alpha02 版本添加了新功能 MergeAdapter，帮助开发者更容易地为 RecyclerView 添加 Header 和 Footer。详情参见 【译】MergeAdapter 的使用 使用官方 API 为 Recyclerview 添加 Header 和 Footer 该版本中还有一个改动：RecyclerView.Adapter lazy state restoration，帮助开发者恢复 RecyclerView 的状态 我对这个功能并没有什么感觉。众所周知，Android 中的 View 内部是有着状态保存和恢复的方法的。RecyclerView 也是如此，它可以恢复自身已滚动的位置 有关状态保存的内容可以参见 【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析 真实情况也是如此 意外发现最近看到 Florina Muntenescu 的 Restore RecyclerView scroll position ，其中介绍了 RecyclerView.Adapter lazy state restoration，这勾起了我的兴趣 如文中描述，RecyclerView 在 activity/fragment 重建时失去滚动位置是因为 Adapter 中的数据是 异步 加载的，当 RecyclerView layout 时数据并没有加载，因此也恢复不了之前的位置状态。一个比较简单的例子是使用 Navigation 组件进行导航，返回时 fragment 中的 RecyclerView 由于再次调用接口获取数据，导致其滑动位置失去 解决方案有几种方法可以保证 RecyclerView 恢复到正确的滚动位置，最好的办法是借助缓存，ViewModel 或 Repository 中缓存要显示的数据，确保始终在第一个布局传入前在 Adapter 上设置数据。也有一些其他的方案，这些方案要么太复杂，要么不够优雅 recyclerview:1.2.0-alpha02 中的解决方案是提供一个新的 Adapter 方法，该方法允许设置状态恢复策略，它有三个选项 ALLOW PREVENT_WHEN_EMPTY PREVENT ALLOW这是 默认 的状态，它会立即恢复 RecyclerView 的状态，该种策略无法解决延迟加载的数据的问题，可以使用 PREVENT_WHEN_EMPTY PREVENT_WHEN_EMPTY仅当 Adapter 不为空（adapter.getItemCount() &gt; 0）时，才恢复 RecyclerView 状态。 如果您的数据是异步加载的，那么 RecyclerView 会一直等到数据加载完毕，然后状态才能恢复。 如果您有默认 item（例如 Header 或 加载指示器）作为适配器的一部分，则应该使用PREVENT 选项，除非使用 MergeAdapter 添加了默认 item。 MergeAdapter 等待所有适配器准备就绪，然后才恢复状态 PREVENT状态不会恢复，直到配置了 ALLOW 或者 PREVENT_WHEN_EMPTY 使用方式如下： 1adapter.stateRestorationPolicy = PREVENT_WHEN_EMPTY 加入了上面的配置后即使是异步加载数据也能恢复 RecyclerView 的位置 追踪引入过程老规矩，我们沿着官方的 commit log 来看看其实现原理 首先我们看看 IssueTracker 上提的 Feature 表达的意思也很简单，就是当加载异步数据时 RecyclerView 的位置状态无法恢复，Adapter 应该提供相关的解决方案 有意思的是，实现该功能时还重新实现了前一个版本的逻辑，我在 git commit log 中看到了 revert 操作 为了防止 LayoutManager#onRestore 执行多次，没有采用最开始的实现方式。但 Yigit Boyar (这个提交的开发者) 仍然希望使用最开始的实现方式，但是 LayoutManager#onRestoreInstance 的状态时 public ，因此只能选取一个折中的方案 过去，开发者会无意间调用 onRestoreInstanceState(State) 方法。例如，一些开发者已使用它来手动设置自己更新的状态，这样即使在此状态之前已恢复，在此处传递状态也将导致 LayoutManager 接收它并相应地更新其内部状态。因此，即使看起来好像很奇怪，也必须始终调用 requestLayout 来保留功能 源码分析接下来我们来分析这部分源码，内容很少，所以我们详细看下 首先是引入 StateRestorationPolicy的枚举 然后需要提供 setStateRestorationPolicy 和 getStateRestorationPolicy 方法，此时我们还需要一个方法来判断是否要将 SavedState 传递给 LayoutManager 前面的 setStateRestorationPolicy 方法中 调用了 notifyStateRestorationPolicyChanged，而 notifyStateRestorationPolicyChanged 为静态类 AdapterDataObservable 中的方法，该类中的其他方法我们也很熟悉，均是刷新 Adapter 中数据的方法。 而 notifyStateRestorationPolicyChanged 中调用了 mObservers list 中元素的 onStateRestorationPolicyChanged 方法，通过源码我们得知该 list 中的元素类型为 AdapterDataObserver，因此还需要在 AdapterDataObserver 中加入 onStateRestorationPolicyChanged 方法 该方法是个空实现，而 RecyclerViewDataObserver 重写了该方法 配置恢复策略以及恢复策略变化时的监听都有了，接下来要做的就是如果之前有待恢复的装则恢复之前的状态 注意：发布之前 StateRestorationPolicy 叫做 StateRestorationStrategy，后来命名为 StateRestorationPolicy，alpha 版本的库可能随时更改 API 的命名和删除 API，因此查看这部分源码的同学请注意 至此，相关的源码都在这里了 总结StateRestorationPolicy 提供了 RecyclerView 异步加载数据恢复滚动位置的解决方案。原理就是通过配置 StateRestorationPolicy 来改变恢复策略，同时在策略改变时调用 requestLayout 方法。在 dispatchLayoutStep2() (该方法会在 onLayout 和 measure 方法中调用) 方法中恢复状态(如果 canRestoreState() 返回 true) demo 地址 一点思考：我们都知道 ViewPager2 是使用 RecyclerView 实现的，那么借助本文介绍的 API 可以做点什么吗？ 欢迎各位小伙伴在评论区留言，说说你的想法 关于我我是 Flywith24，我的博客内容已经分类整理 在这里，点击右上角的 Watch 可以及时获取我的文章更新哦 😉 掘金 小专栏 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Jetpack更新之Fragment】终于动手了，onActivityCreated 被弃用]]></title>
    <url>%2F2020%2F04%2F09%2FJetpack-fragment-onActivityCreated-Deprecated%2F</url>
    <content type="text"><![CDATA[本系列文章介绍 Jetpack 组件库的更新一直以来， fragment 的 api 都非常难用，官方也承认这一点。一个月前，fragment 中的 onActivityCreated() 被弃用了 Fragmentfragment 1.3.0-alpha02 中 onActivityCreated() 方法被弃用了 让我们来看一下提交 log 简单翻译一下 onActivityCreated() 最初的目的是让 fragment 的逻辑与其宿主 activity 创建建立关联，我们不鼓励这种耦合 我们应该传递外部依赖来作为 FragmentFactory 参数。view 相关的代码应该放置在 onViewCreated() 完成，其他的初始化代码应该在 onCreate() 中完成。为了在 activity onCreate() 完成后接收回调，可以添加一个 activity 生命周期的 LifecycleObserver ，并且接收到 Lifecycle.State#CREATED 回调时将其移除 123456789override fun onAttach(context: Context) &#123; super.onAttach(context) requireActivity().lifecycle.addObserver(object : DefaultLifecycleObserver &#123; override fun onCreate(owner: LifecycleOwner) &#123; // 想做啥做点啥 owner.lifecycle.removeObserver(this) &#125; &#125;)&#125; DialogFragment那么 DialogFragment 怎么办？其 onActivityCreated 变为可选的 简单翻译一下 DialogFragment 使用 onActivityCreated() 帮助创建 dialog。onActivityCreated() 弃用后我们应当寻找一个更好的方式来执行这部分逻辑 关于 view 相关的代码已经转移至 DialogFragment 的 viewLifecycleOwnerLiveData ，其他初始化逻辑可以放在 onGetLayoutInflater 我们仍支持为自定义 dialog 在 onActivityCreated() 中配置 dialog End查看 Jetpack fragment 的变动，不难看出官方正致力于为 fragment 「减负」，将小的，独立的功能从 fragment 中抽离出去，降低耦合，后续文章我们介绍其他的改动 关于我我是 Fly_with24 掘金 简书 Github 欢迎关注我的公众号]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之LiveData】ViewModel的左膀右臂 数据驱动真的香]]></title>
    <url>%2F2020%2F03%2F31%2FJetpack-LiveData%2F</url>
    <content type="text"><![CDATA[前言 之前我们讨论过 ViewModel 的职能边界 ，得益于 ViewModel 的生命周期更长，我们可以在 activity 重建后将数据传递给 activity ，也可以避免内存泄漏。但是如果不是每次需要就获取数据，而是当每次有新数据时通知我们，应该怎么办？ 本文介绍 LiveData ，一个 生命周期感知的，可观察的，数据持有者。同时还会简单分析 LiveData 的源码实现 我们都是 Adapter在谈 LiveData 前我们来思考一个问题 Android 开发（亦或者说前端开发）的本质工作内容是什么？ 对于应用层 app 开发者，开发者的工作主要工作就是 Adapter 什么是 Adapter ，下图可能比较直观 图片来自 google image 我们的工作本质是 将数据转换成 UI 数据可能来自网络，来自本地数据库，来自内存，而 UI 可能是 activity 或 fragment。 理想的数据模型上面我们提到 Android 开发者的核心工作就是将数据转换为 UI 。这个过程比较理想的状态是：当数据发生变化时，UI 跟随变化。我们还可以进一步展开：当 UI 对用户可见时，数据发生变化时 UI 跟随变化；当 UI 对用户不可见时，我们希望数据变化时什么都不做，当 UI 再次对用户可见时根据最新的数据进行 UI 的处理。 而 LiveData 就是我们理想中的数据模型 图片来自 Android Dev Summit ‘18-Fun with LiveData LiveData 可以三个关键词概括 lifecycle-aware observable data holder observableAndroid 中不同的组件有着不同的生命周期，不同的存活时间 因此我们不会在 ViewModel 中持有 Activity 的引用，因为这会导致当 Activity 重建时内存泄漏，甚至出现空指针的情况 通常我们会在 Activity 中持有 ViewModel 的引用，那么如何进行二者间的通信，如何向 Activity 发送 ViewModel 中的数据？ 答案是让 Activity 观察 ViewModel LiveData 是 observable lifecycle-aware当观察者观察着某个数据时，该数据必须保留对观察者的引用才能调用它，为了解决这个问题，LiveData 被设计成可感知生命周期 当 activity / fragment 被销毁后，它会自动的取消订阅 data holderLiveData 仅持有 单个且最新 的数据 上图中，最右侧是在 ViewModel 中的 LiveData，左侧为观察这个 LiveData 的 activity / fragment 。一旦我们为 LiveData 设值，该值会传递到 activity。简而言之，LiveData 值改变，activity 收到最新的值的变化。但是当观察者不再处于活动状态（STARTED 到 RESUMED ），数据 C 不会被发送到 activity 。当 activity 回到前台，它将收到最新的值，数据 D。LiveData 仅持有单个且最新的数据。当 activity 执行销毁流程时，此时的数据 E 也不会产生任何影响 TransformationsLiveData 提供 两种 transformation ，map 和 switch map。开发者也可以创建自定义的 MediatorLiveData 我们都知道 LiveData 可以为 View 和 ViewModel 提供通信，但如果有一个第三方组件（例如 repository ）也持有 LiveData。那么它应该如何在 ViewModel 中订阅？该组件并没有 lifecycle 一旦我们的应用愈发复杂，repository 可能会观察数据源 那么 view 如何获取 repository 中的 LiveData？ 一对一的静态转换（map） 在上面的示例中，ViewModel 仅将数据从 repository 转发到 view，然后将其转换为 UI Model。 每当 repository 中有新数据时，ViewModel 只需 map 12345class MainViewModel &#123; val viewModelResult = Transformations.map(repository.getDataForUser()) &#123; data -&gt; convertDataToMainUIModel(data) &#125;&#125; 第一个参数为 LiveData 源（来自 repository ），第二个参数是一个转换函数。 123// 这里的转换为将 X 转换为 Yinline fun &lt;X, Y&gt; LiveData&lt;X&gt;.map(crossinline transform: (X) -&gt; Y): LiveData&lt;Y&gt; = Transformations.map(this) &#123; transform(it) &#125; 一对一的动态转换（switchMap）假如您正在观察一个提供用户的用户管理器，并且需要提供用户的 id 才能开始观察 repository 您不能将其写到 ViewModel 初始化的过程中，因为此时用户的 id 还不可用 这时 switchMap 就派上用场了 12345class MainViewModel &#123; val repositoryResult = Transformations.switchMap(userManager.userId) &#123; userId -&gt; repository.getDataForUser(userId) &#125;&#125; switchMap 在内部使用 MediatorLiveData，因此了解它非常重要，因为当您要组合多个 LiveData 源时需要使用它 1234// 这里的转换为将 X 转换为 LiveData&lt;Y&gt;inline fun &lt;X, Y&gt; LiveData&lt;X&gt;.switchMap( crossinline transform: (X) -&gt; LiveData&lt;Y&gt;): LiveData&lt;Y&gt; = Transformations.switchMap(this) &#123; transform(it) &#125; 一对多依赖（MediatorLiveData）MediatorLiveData 允许您将一个或多个数据源添加到单个可观察的 LiveData 中 1234567891011val liveData1: LiveData&lt;Int&gt; = ...val liveData2: LiveData&lt;Int&gt; = ...val result = MediatorLiveData&lt;Int&gt;()result.addSource(liveData1) &#123; value -&gt; result.setValue(value)&#125;result.addSource(liveData2) &#123; value -&gt; result.setValue(value)&#125; 在上面的例子中，当任何一个数据源变化时，result 会更新。 注意：数据并不是合并，MediatorLiveData 只是处理通知 为了实现示例中的转换，我们需要将两个不同的 LiveData 组合为一个 图片来自 LiveData beyond the ViewModel — Reactive patterns using Transformations and MediatorLiveData 使用 MediatorLiveData 合并数据的一种方法是添加源并以其他方法设置值： 123456789101112131415fun blogpostBoilerplateExample(newUser: String): LiveData&lt;UserDataResult&gt; &#123; val liveData1 = userOnlineDataSource.getOnlineTime(newUser) val liveData2 = userCheckinsDataSource.getCheckins(newUser) val result = MediatorLiveData&lt;UserDataResult&gt;() result.addSource(liveData1) &#123; value -&gt; result.value = combineLatestData(liveData1, liveData2) &#125; result.addSource(liveData2) &#123; value -&gt; result.value = combineLatestData(liveData1, liveData2) &#125; return result&#125; 数据的实际组合是在 combineLatestData 方法中完成的 1234567891011121314151617private fun combineLatestData( onlineTimeResult: LiveData&lt;Long&gt;, checkinsResult: LiveData&lt;CheckinsResult&gt;): UserDataResult &#123; val onlineTime = onlineTimeResult.value val checkins = checkinsResult.value // Don't send a success until we have both results if (onlineTime == null || checkins == null) &#123; return UserDataLoading() &#125; // TODO: Check for errors and return UserDataError if any. return UserDataSuccess(timeOnline = onlineTime, checkins = checkins)&#125; 检查值是否准备好并发出结果（加载中，失败或成功） LiveData 的错误用法错误地使用 var LiveData1234567var lateinit randomNumber: LiveData&lt;Int&gt;fun onGetNumber() &#123; randomNumber = Transformations.map(numberGenerator.getNumber()) &#123; it &#125;&#125; 这里有一个重要的问题需要理解：转换会在调用时（map 和 switchMap）会创建一个新的 LiveData。 在此示例中，randomNumber 公开给 View ，但是每次用户单击按钮时都会对其进行重新赋值。 观察者只会在订阅时收到分配给 var 的 LiveData 更新的信息 1234// 只会收到第一次分配的值viewmodel.randomNumber.observe(this, Observer &#123; number -&gt; numberTv.text = resources.getString(R.string.random_text, number)&#125;) 如果 viewmodel.randomNumber LiveData 实例发生更改，这里永远不会回调。而且这里泄漏了之前的 LiveData ，这些 LiveData 不会再发送更新 一言以蔽之，不要在 var 中使用 Livedata 正确示例见 demo LiveData 粘性事件一般来说我们使用 LiveData 持有 UI 数据和状态，但是如果通过它来发送事件，可能会出现一些问题。这些问题及解决方案 在这 fragment 中错误地传入 LifecycleOwnerandroidx fragment 1.2.0 起，添加了新的 Lint 检查，以确保您在从 onCreateView()、onViewCreated() 或 onActivityCreated() 观察 LiveData 时使用 getViewLifecycleOwner() 如图，我们有一个 fragment ，onCreate 观察 LiveData，通过正常的生命周期创建了 View ，接着进入了 resume 状态。此时你使用了 LiveData，UI 将开始展示它。之后，用户点击了按钮，由于跳转了另一个 fragment，所以要 detach 该 fragment，一旦 fragment stop 我们就不需要其中的 view 了，因此 destroyView 。之后用户点击了返回按钮回到了上一个 fragment，由于我们已经 destroyView，因此我们需要创建一个新的 view ，接着进入正常的生命周期，但此时，出现了一个 bug 。这个新 View 不会恢复 LiveData 的状态，因为我们使用的是 fragment 的 lifecycle observe 的 LiveData 我们有两种选择，在 onCreate 或者在 onCreateView 中使用 fragment 的 lifecycle observe LiveData 前者的优点是一次注册，缺点是当 recreate 时有bug；后者优点是能够解决 recreate 的 bug，但会导致重复注册 该问题的核心是 fragment 拥有两个生命周期：fragment 自身和 fragment 内部 view 的生命周期 androidx fragment 1.0 和 support library 28 了 viewLifecycle 因此，当需要观察 view 相关的 LiveData ，可以在 onCreateView()、onViewCreated() 或 onActivityCreated() 中 LiveData observe 方法中传入 viewLifecycleOwner 而不是传入 this 源码结构首先来看 LiveData 主要的源码结构 LiveData MutableLiveData Observer LiveDataLiveData 是可以在给定生命周期内观察到的数据持有者类。 这意味着可以将一个Observer 与 LifecycleOwner 成对添加，并且只有在配对的 LifecycleOwner 处于活动状态时，才会向该观察者通知有关包装数据的修改。 如果 LifecycleOwner 的状态为 Lifecycle.State.STARTED 或 Lifecycle.State.RESUMED，则将其视为活动状态。 通过 observeForever（Observer）添加的观察者被视为始终处于活动状态，因此将始终收到有关修改的通知。 对于那些观察者，需要手动调用 removeObserver（Observer） 如果相应的生命周期移至 Lifecycle.State.DESTROYED 状态，则添加了生命周期的观察者将被自动删除。 这对于 activity 和 fragment 可以安全地观察 LiveData 而不用担心泄漏 此外，LiveData 具有 onActive() 和 onInactive() 方法，以便在活动观察者的数量在 0 到 1 之间变化时得到通知。这使 LiveData 在没有任何活动观察者的情况下可以释放大量资源。 主要方法有： T getValue() 获取LiveData 包装的数据 observe(LifecycleOwner owner, Observer&lt;? super T&gt; observer) 设置观察者（主线程调用） setValue(T value) 设值（主线程调用），可见性为 protected 无法直接使用 postValue(T value) 设置（其他线程调用），可见性为 protected 无法直接使用 MutableLiveDataLiveData 实现类，公开了 setValue 和 postValue 方法 Observer接口，内部只有 onChanged(T t) 方法，在数据变化时该方法会被调用 源码分析我们通过源码来看看 LiveData 如何实现它的特性的 如何控制在 activity 或 fragment 活动状态时接收回调，否则不接收？ 如何在 activity 或 fragment 销毁时自动取消注册观察者？ 如何保证 LiveData 持有最新的数据？ 我们查看 LiveData 的 observe 方法 123456789101112131415161718192021222324252627// LiveData.java@MainThreadpublic void observe(LifecycleOwner owner, Observer&lt;? super T&gt; observer) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // 如果 owner 已经是 DESTROYED 状态，则忽略 return; &#125; // 使用 LifecycleBoundObserver 包装 owner 和 observer LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); // 如果已经添加过直接 return if (existing != null) &#123; return; &#125; owner.getLifecycle().addObserver(wrapper);&#125;// LifecycleBoundObserver.javaclass LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123; @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(LifecycleOwner owner, Observer&lt;? super T&gt; observer) &#123; super(observer); mOwner = owner; &#125;&#125; 通过源码我们知道，当我们调用 observe 方法时，内部是通过 LifecycleBoundObserver 将 owner 和 observer 包裹起来并通过 addObserver 方法添加观察者的，因而当数据变化时，会调用 LifecycleBoundObserver 的 onStateChanged 方法 1234567891011// LiveData.LifecycleBoundObserver.java@Overridepublic void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; if (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123; // 自动移除观察者，问题 2 得到解释 removeObserver(mObserver); return; &#125; activeStateChanged(shouldBeActive());&#125; 当什么周期所有者处于 DESTROYED 状态时，会调用 removeObserver 方法，因此问题 2 得到解释 我们继续向下看，activeStateChanged 方法调用时传入了 shouldBeActive() 1234567891011121314151617181920212223242526@Overrideboolean shouldBeActive() &#123; // 至少是 STARTED 状态 返回 true return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);&#125;void activeStateChanged(boolean newActive) &#123; if (newActive == mActive) &#123; // 与上次值相同，则直接 return （两次均为活动状态或均为非活动状态） return; &#125; mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; // 根据 mActive 修改活动状态观察者的数量（加 1 或减 1 ） LiveData.this.mActiveCount += mActive ? 1 : -1; if (wasInactive &amp;&amp; mActive) &#123; onActive(); &#125; if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123; onInactive(); &#125; if (mActive) &#123; // 如果是活动状态，则发送数据，问题 1 得到解释 dispatchingValue(this); &#125;&#125; 这里牵扯了 Lifecycle State 比较的知识，详情在这 只有 STARTED 和 RESUMED 状态 shouldBeActive() 才返回 true，至此问题 1 得到解释 dispatchingValue 方法内部调用了 considerNotify 方法 1234567891011121314151617private void considerNotify(ObserverWrapper observer) &#123; if (!observer.mActive) &#123; return; &#125; // 再次判断生命周期所有者状态 if (!observer.shouldBeActive()) &#123; observer.activeStateChanged(false); return; &#125; // 比较版本号 if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; observer.mLastVersion = mVersion; // 调用我们传入的 mObserver 的 onChanged 方法 observer.mObserver.onChanged((T) mData);&#125; 可以看到 considerNotify 中比较了 observer 的版本号，如果是最新的数据，直接 return 而 mVersion 在 setValue 方法中 进行更改 1234567@MainThreadprotected void setValue(T value) &#123; // 每次设置对 mVersion 进行++ mVersion++; mData = value; dispatchingValue(null);&#125; 因此 LiveData 每次都持有最新的数据，问题 3 得到解释 总结回到本文开头的思考，Android 开发者的主要工作是将数据转换成 UI ，而 LiveData 本质上是一种「数据驱动」，即通过改变状态数据，来驱动视图树中绑定了相应状态数据的控件重新发生绘制。Flutter 和未来的 Jetpack Compose 采用的都是这种机制。使用 ViewModel + LiveData，可以 安全地在订阅者的生命周期内分发正确的数据，使开发者不知不觉中完成了 UI -&gt; ViewModel -&gt; Data 的单向依赖。 所谓架构，很多时候不是使用它能做什么，更多的是不要做什么，使用它时开发者能够得到约束，以便产出更健壮的代码 各位小伙伴如果有什么想法欢迎在评论区留言 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之Lifecycle】万物基于Lifecycle 默默无闻大作用]]></title>
    <url>%2F2020%2F03%2F30%2FJetpack-Lifecycle%2F</url>
    <content type="text"><![CDATA[Android 中有一个比较重要的概念：「生命周期」。刚毕业去面试，总会被问到「四大组件的生命周期」这类的问题。17年的 IO 大会上，Google 推出了 Lifecycle-Aware Components（生命周期感知组件），帮助开发者组织更好，更轻量，易于维护的代码 本文介绍 Lifecycle 的职责以及简单分析 lifecycle 如何感知 activity 和 fragment ，帮助您对 Lifecycle 有一个感性的认识 万物基于 Lifecycle手动管理生命周期的痛苦你不懂 鲁迅曾说过：万物基于 Lifecycle 哦不对 Android 中的视图控制器就有这么多生命周期的情况，所以处理好生命周期十分重要，否则会导致内存泄漏甚至是程序崩溃。这里引用 官方文档 的例子 1234567891011121314151617181920212223242526272829303132333435363738class MyLocationListener &#123; public MyLocationListener(Context context, Callback callback) &#123; // ... &#125; void start() &#123; // 连接系统的定位服务 &#125; void stop() &#123; // 与系统的定位服务断开连接 &#125;&#125;class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; @Override public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, (location) -&gt; &#123; // 更新 UI &#125;); &#125; @Override public void onStart() &#123; super.onStart(); myLocationListener.start(); //管理其他需要响应 activity 生命周期的组件 &#125; @Override public void onStop() &#123; super.onStop(); myLocationListener.stop(); //管理其他需要响应 activity 生命周期的组件 &#125;&#125; 此示例看起来不错，在实际的应用程序中，您仍然会响应生命周期的当前状态而进行过多的调用来管理 UI 和其他组件。 管理多个组件会在生命周期方法中放置大量代码，例如 onStart() 和 onStop()，这使它们难以维护 而且，不能保证组件在 activity 或 fragment 停止之前就已启动。 如果我们需要执行长时间运行的操作（例如onStart() 中的某些配置检查），则可能会导致争用情况，其中onStop() 方法在 onStart() 之前完成，从而使组件的生存期超过了所需的生存期。 1234567891011121314151617181920212223242526class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, location -&gt; &#123; // 更新 UI &#125;); &#125; @Override public void onStart() &#123; super.onStart(); Util.checkUserStatus(result -&gt; &#123; // 如果在 activity 停止后调用此回调怎么办？ if (result) &#123; myLocationListener.start(); &#125; &#125;); &#125; @Override public void onStop() &#123; super.onStop(); myLocationListener.stop(); &#125;&#125; 如果有所有的组件，都能感知外部的生命周期，能在相应的时机释放资源，并且在错过生命周期时能及时叫停异步的任务就好了， 我们不妨先思考一下，如果实现这样的想法，应该如何做 按照惯例的思考首先我们先来整理一下我们的需求 内部组件能够感知外部的生命周期 能够统一地管理，做到一处修改，处处生效 能够及时叫停错过的任务 针对需求1，可以用观察者模式，内部组件能够在外部生命周期变化时做出相应 针对需求2，可以将依赖组件的代码移出生命周期方法内，然后移入组件本身，这样只需修改组件内部逻辑即可 针对需求3，可以在合适的时机移除观察者 观察者模式关于开发者模式，我第一次比较详细的了解是在 扔物线 的 给 Android 开发者的 RxJava 详解。 观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者（例如 A 不需要每过 2ms 就检查一次 B 的状态），而是采用注册(Register)或者称为订阅(Subscribe)的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 OnClickListener 。对设置 OnClickListener 来说， View 是被观察者， OnClickListener 是观察者，二者通过 setOnClickListener() 方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 OnClickListener 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷『你在作案的时候务必通知我』。 OnClickListener 的模式大致如下图： 上述描述及图片均来自 给 Android 开发者的 RxJava 详解 因此在生命周期组件的生命周期发生变化时告诉观察者，内部组件即可感知外部的生命周期 引入 Lifecycle 后12345678910111213public class MyObserver implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void connectListener() &#123; ... &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) public void disconnectListener() &#123; ... &#125;&#125;myLifecycleOwner.getLifecycle().addObserver(new MyObserver()); 源码结构 这是 Lifecycle 的结构，抽象类，其内部有两个枚举，分别代表着「事件」和「状态」，此外还有三个方法，添加/移除观察者，获取当前状态 注意，这里 State 中的枚举顺序是有意义的，后文详细介绍 其实现类为 LifecycleRegistry ，可以处理多个观察者 其内部持有当前的状态 mState ，LifecycleOwner 以及观察者的自定义列表，同时重写了父类的添加/删除观察者的方法 LifecycleOwner ，具有 Android 的生命周期，定制组件可以使用这些事件来处理生命周期更改，而无需在 Activity 或 Fragment 中实现任何代码 LifecycleObserver ，将一个类标记为 LifecycleObserver。 它没有任何方法，而是依赖于 OnLifecycleEvent 注解的方法 LifecycleEventObserver ，可以接收任何生命周期更改并将其分派给接收方。 如果一个类实现此接口并同时使用 OnLifecycleEvent，则注解将被忽略 DefaultLifecycleObserver ，用于监听 LifecycleOwner 状态更改的回调接口。 如果一个类同时实现了此接口和 LifecycleEventObserver，则将首先调用DefaultLifecycleObserver 的方法，然后再调用LifecycleEventObserver.onStateChanged（LifecycleOwner，Lifecycle.Event） 注意：使用 DefaultLifecycleObserver 需引入 implementation “androidx.lifecycle:lifecycle-common-java8:$lifecycle_version” 简单的源码分析activity 生命周期处理首先我们还是来看 androidx.activity.ComponentActivity ，这个类我们这个系列的文章里提到多次，第一次提及是在 【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析 ，感兴趣的小伙伴可以看看。 其实现的接口大多数我们都已经探讨过了，今天我们来看看 LifecycleOwner ActivityResultCaller 为 activity 1.2.0-alpha02 推出的，旨在统一 onActivityResult ，这里暂时不讨论它 既然实现了 LifecycleOwner 接口，必定重写 getLifecycle() 方法 1234567// androidx.activity.ComponentActivity.javaprivate final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);@Overridepublic Lifecycle getLifecycle() &#123; return mLifecycleRegistry;&#125; 其返回的 Lifecycle 为 实现类 LifecycleRegistry 的实例 而 activity 操作生命周期是通过 ReportFragment 处理的 1234567891011121314151617181920// androidx.activity.ComponentActivity.javaprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this); //...&#125;// ReportFragmentpublic static void injectIfNeededIn(Activity activity) &#123; if (Build.VERSION.SDK_INT &gt;= 29) &#123; // api 29 及以上 直接注册正确的生命周期回调 activity.registerActivityLifecycleCallbacks( new LifecycleCallbacks()); &#125; android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); manager.executePendingTransactions(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ReportFragment.javastatic void dispatch(@NonNull Activity activity, @NonNull Lifecycle.Event event) &#123; if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125;&#125;private void dispatch(@NonNull Lifecycle.Event event) &#123; if (Build.VERSION.SDK_INT &lt; 29) &#123; dispatch(getActivity(), event); &#125;&#125;@Overridepublic void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatch(Lifecycle.Event.ON_CREATE);&#125;@Overridepublic void onStart() &#123; super.onStart(); dispatch(Lifecycle.Event.ON_START);&#125;@Overridepublic void onResume() &#123; super.onResume(); dispatch(Lifecycle.Event.ON_RESUME);&#125;@Overridepublic void onPause() &#123; super.onPause(); dispatch(Lifecycle.Event.ON_PAUSE);&#125;@Overridepublic void onStop() &#123; super.onStop(); dispatch(Lifecycle.Event.ON_STOP);&#125;@Overridepublic void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY);&#125; 123456789101112131415161718192021222324252627282930313233// LifecycleCallbacksstatic class LifecycleCallbacks implements Application.ActivityLifecycleCallbacks &#123; @Override public void onActivityPostCreated(@NonNull Activity activity, @Nullable Bundle savedInstanceState) &#123; dispatch(activity, Lifecycle.Event.ON_CREATE); &#125; @Override public void onActivityPostStarted(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_START); &#125; @Override public void onActivityPostResumed(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_RESUME); &#125; @Override public void onActivityPrePaused(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_PAUSE); &#125; @Override public void onActivityPreStopped(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_STOP); &#125; @Override public void onActivityPreDestroyed(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_DESTROY); &#125; //...&#125; 在 activity 的 onCreate 方法中，调用了 ReportFragment 中的静态方法 injectIfNeededIn() 。而其内部，如果 api 29 及以上的设备上直接注册正确的生命周期回调，低版本通过启动 ReportFragment ，借助 fragment 各个生命周期来处理生命周期回调 fragment 生命周期处理在 fragment 内部，每个生命周期节点调用 handleLifecycleEvent 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243// Fragment.javapublic Fragment() &#123; initLifecycle();&#125;private void initLifecycle() &#123; mLifecycleRegistry = new LifecycleRegistry(this);&#125;@Overridepublic Lifecycle getLifecycle() &#123; return mLifecycleRegistry;&#125;void performCreate(Bundle savedInstanceState) &#123; onCreate(savedInstanceState); mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); &#125;void performStart() &#123; onStart(); mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);&#125;void performResume() &#123; onResume(); mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); &#125;void performPause() &#123; mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE); onPause();&#125;void performStop() &#123; mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP); onStop();&#125;void performDestroy() &#123; mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY); onDestroy();&#125; Lifecycle State 大小比较Lifecycle.State 中有一个 isAtLeast 方法，用于判断当前状态是否不小于传入的状态 1234// Lifecycle.Statepublic boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0;&#125; 枚举的 compareTo 方法其实是比较的枚举声明的顺序 而 State 的顺序为 DESTROYED -&gt; INITIALIZED -&gt; CREATED -&gt; STARTED -&gt; RESUMED 如果传入的 state 为 STARTED，则当前状态为 STARTED 或 RESUMED 时返回 true ，否则返回 false LiveData 篇会用到这个知识点 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之ViewModel】即使您不使用MVVM也要了解ViewModel ViewModel的职能边界]]></title>
    <url>%2F2020%2F03%2F23%2FJetpack-ViewModel%2F</url>
    <content type="text"><![CDATA[前言 Android 开发时，我们使用 activity 和 fragment 作为视图控制器， 可能还会使用有一些类可以存储和提供 UI 数据（例如MVP中的 Presenter ） 但是 当配置更改时（如旋转屏幕），activity 会重建，但对于 UI 数据的持有者呢？ 开发者需要重新保存相关的信息并传递给重建的 activity ，否则开发者必须再次获取数据（通过网络请求或本地数据库） 由于 UI 数据的持有者的生命周期可能比 activity 长，因此开发者还需要避免出现内存泄漏的问题 如何解决上述问题？ViewModel 本文重点介绍 ViewModel 的职责（what）以及重点功能的实现原理（how），即使您不使用 Jetpack MVVM 架构，也要了解一下 ViewModel ViewModel 的原理部分要求您了解 activity 的启动流程，这部分内容网上文章很多，本文不再赘述 ViewModel 的职责我先上个 视频 ，这个小姐姐表述的比文字更形象 ViewModel 主要用于存储 UI 数据以及生命周期感知的数据 图片来自 Android Architecture Components: ViewModel ViewModel 的生命周期 ，图片来自 官方文档 作为数据持有者ViewModel 能够实时进行配置更改。 这意味着即使在手机旋转后销毁并重新创建 activity 之后，您仍然拥有相同的 ViewModel 和相同的数据。 因此： 您无需担心 UI 数据持有者的生命周期。 ViewModel 将由工厂自动创建，您无需自行创建和销毁 数据将始终更新，旋转手机后，您将获得与以前相同的数据。 因此，您无需手动将数据传递给新的 activity 实例或再次调用网络或数据库来获取数据。 Fragment 间共享数据一个 activity 中的两个或更多 fragment 需要相互通信是很常见的。例如您有一个片段，用户在其中从列表中选择一个 item，另一个片段显示了所选 item 的内容。 传统做法两个 fragment 都需要定义一些接口，并且宿主 activity 必须将两者绑定在一起。 此外，两个 fragment 都必须处理另一个 fragment 尚未创建或不可见的情况。 可以通过使用 ViewModel 对象解决此问题。 这些 fragment 可以使用 activity 范围内共享一个 ViewModel 来处理此通信，如以下示例代码所示： 1234567891011121314151617181920212223242526272829303132333435public class SharedViewModel extends ViewModel &#123; private final MutableLiveData&lt;Item&gt; selected = new MutableLiveData&lt;Item&gt;(); public void select(Item item) &#123; selected.setValue(item); &#125; public LiveData&lt;Item&gt; getSelected() &#123; return selected; &#125;&#125;public class MasterFragment extends Fragment &#123; private SharedViewModel model; public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); model = new ViewModelProvider(requireActivity()).get(SharedViewModel.class); itemSelector.setOnClickListener(item -&gt; &#123; model.select(item); &#125;); &#125;&#125;public class DetailFragment extends Fragment &#123; public void onViewCreated(@NonNull View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); SharedViewModel model = new ViewModelProvider(requireActivity()).get(SharedViewModel.class); model.getSelected().observe(getViewLifecycleOwner(), &#123; item -&gt; // Update the UI. &#125;); &#125;&#125; 由于 两个 fragment 使用的都是 activity 范围的 ViewModel （ViewModelProvider 构造器传入的 activity ），因此它们获得了相同的 ViewModel 实例，自然其持有的数据也是相同的，这也 保证了数据的一致性 这种方法具有以下优点： 宿主 activity 无需执行任何操作，也无需了解此通信。 除 SharedViewModel 外，fragment 不需要彼此了解。 如果其中一个 fragment 消失了，则另一个继续照常工作。 每个 fragment 都有其自己的生命周期，并且不受另一个 fragment 的生命周期影响。 如果一个 fragment 替换了另一个 fragment，则 UI 可以继续正常工作而不会出现任何问题。 代替 LoaderCursorLoader 这样的 Loader 类经常用于使应用程序 UI 中的数据与数据库保持同步。您可以使用 ViewModel 和其他一些类来替换 Loader。 使用 ViewModel 可将视图控制器与数据加载操作分开，这意味着您在类之间的强引用较少。 在使用 Loader 的一种常见方法中，应用程序可能会使用 CursorLoader 来观察数据库的内容。 当数据库中的值更改时，加载程序会自动触发数据的重新加载并更新 UI 图片来自 官方文档 ViewModel 与 Room 和 LiveData 一起使用以替换 Loader。 ViewModel 确保数据在设备配置更改后仍然存在。 当数据库发生更改时，Room 会通知 LiveData ，然后 LiveData 会使用修改后的数据更新 UI 图片来自 官方文档 总结 ViewModel 可作为 UI 数据的持有者，在 activity/fragment 重建时 ViewModel 中的数据不受影响，同时可以避免内存泄漏 可以通过 ViewModel 来进行 activity 和 fragment ，fragment 和 fragment 之间的通信，无需关心通信的对方是否存在，使用 application 范围的 ViewModel 可以进行全局通信 可以代替 Loader ViewModel 源码分析分析源码时我们可以不计较细枝末节，只分析主要的逻辑即可。因此我们来思考几个问题，并从源码中寻找答案 如何做到 activity 重建后 ViewModel 仍然存在？ 如何做到 fragment 重建后 ViewModel 仍然存在？ 如何控制作用域？（即保证相同作用域获取的 ViewModel 实例相同） 如何避免内存泄漏？ 维持我们一贯的风格，我们先来大胆地猜一猜 对于问题1 ：activity 有着 saveInstanceState 机制，因此可能通过该机制来处理（事实证明不是） 对于问题2：可能 fragment 通过 宿主 activity 或 父 fragment 的帮助来确保 ViewModel 实例在重建后仍然存在 对于问题3：实现一个类似单例的效果，相同作用域获取的对象是相同的 对于问题4：避免 ViewModel 持有 view 或 context 的引用 首先我们要先了解一下 ViewModel 的结构 ViewModel：抽象类，主要有 clear 方法，它是 final 级，不可修改，clear 方法中包含 onClear 钩子，开发者可重写 onClear 方法来自定义数据的清空 ViewModelStore：内部维护一个 HashMap 以管理 ViewModel ViewModelStoreOwner：接口，ViewModelStore 的作用域，实现类为 ComponentActivity 和 Fragment，此外还有 FragmentActivity.HostCallbacks ViewModelProvider：用于创建 ViewModel，其构造方法有两个参数，第一个参数传入 ViewModelStoreOwner ，确定了 ViewModelStore 的作用域，第二个参数为 ViewModelProvider.Factory，用于初始化 ViewModel 对象，默认为 getDefaultViewModelProviderFactory() 方法获取的 factory 简单来说 ViewModelStoreOwner 持有 ViewModelStore 持有 ViewModel 1. 如何做到 activity 重建后 ViewModel 仍然存在？在 【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析 中我们提到了 androidx.core.app.ComponentActivity 的引入并探讨了其作为中间层的作用 我们已经讲过 SavedStateRegistryOwner 和 OnBackPressedDispatcherOwner 这两种角色，而今天我们来聊一下 ViewModelStoreOwner 和 HasDefaultViewModelProviderFactory 。其中前者代表着 ViewModelStore 的作用域，后者来标记 ViewModelStoreOwner 拥有默认的 ViewModelProvider.Factory 那么 ViewModel 的逻辑肯定就在该类了 ComponentActivity 实现了 ViewModelStoreOwner 接口，意味着需要重写 getViewModelStore() 方法，该方法为 ComponentActivity 的 mViewModelStore 变量赋值。activity 重建后 ViewModel 仍然存在，只要保证 activity 重建后 mViewModelStore 变量值不变即可 顺着这个思路，我们来看一下 getViewModelStore() 的实现 1234567891011121314public ViewModelStore getViewModelStore() &#123; if (mViewModelStore == null) &#123; NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) &#123; //核心，在该位置重置 mViewModelStore mViewModelStore = nc.viewModelStore; &#125; if (mViewModelStore == null) &#123; mViewModelStore = new ViewModelStore(); &#125; &#125; return mViewModelStore;&#125; 即 mViewModelStore 的值由 getLastNonConfigurationInstance() 返回的 NonConfigurationInstances 对象中的 viewModelStore 赋值，如果此时还为空才去 new ViewModelStore 对象。因此我们只需找到 getLastNonConfigurationInstance 中的 NonConfigurationInstances 在哪里保存的即可 getLastNonConfigurationInstance 为平台 activity 中的方法，返回 mLastNonConfigurationInstances.activity 1234public Object getLastNonConfigurationInstance() &#123; return mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.activity : null;&#125; 那么我们看一下 mLastNonConfigurationInstances 的赋值位置 12345//省略其他参数final void attach(NonConfigurationInstances lastNonConfigurationInstances)&#123; mLastNonConfigurationInstances = lastNonConfigurationInstances; //...&#125; 了解过 activity 的启动流程的小伙伴肯定知道，这个 attach 方法是 ActivityThread 中的 performLaunchActivity 调用的 1234567private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); //省略其他参数 activity.attach(r.lastNonConfigurationInstances); r.lastNonConfigurationInstances = null; //...&#125; 深入追踪源码我们整理一下调用流程 由于 ActivityThread 中的 ActivityClientRecord 不受 activity 重建的影响，所以 activity 重建时 mLastNonConfigurationInstances 能够得到上一次的值，使得 ViewModelStore 值不变 ，问题1就解决了 2. 如何做到 fragment 重建后 ViewModel 仍然存在？对于问题2，有了上面的思路我们可以认定 fragment 重建后其内部的 getViewModelStore() 方法返回的对象是相同的。 1234// Fragment.javapublic ViewModelStore getViewModelStore() &#123; return mFragmentManager.getViewModelStore(this);&#125; 可以看到 getViewModelStore() 内部调用的是 mFragmentManager（普通fragment 对应 activity 中的 FragmentManager，子 fragment 则对应父 fragment 的 childFragmentManager）的 getViewModelStore() 方法 123456// FragmentManager.javaprivate FragmentManagerViewModel mNonConfig;ViewModelStore getViewModelStore(@NonNull Fragment f) &#123; return mNonConfig.getViewModelStore(f);&#125; 而 FragmentManager 中的 getViewModelStore 使用的是 mNonConfig ，mNonConfig 竟然是个 ViewModel！ 123// FragmentManagerViewModel.javaprivate final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();private final HashMap&lt;String, ViewModelStore&gt; mViewModelStores = new HashMap&lt;&gt;(); FragmentManagerViewModel 管理着内部的 ViewModelStore 和 child 的 FragmentManagerViewModel 。因此保证 mNonConfig 值不变即能确保 fragment 中的 getViewModelStore() 不变。那么看看 mNonConfig 赋值的位置 12345678910111213141516171819202122// FragmentManager.javavoid attachController(@NonNull FragmentHostCallback&lt;?&gt; host, @NonNull FragmentContainer container, @Nullable final Fragment parent) &#123; //... if (parent != null) &#123; // 嵌套 fragment 的情况，有父 fragment mNonConfig = parent.mFragmentManager.getChildNonConfig(parent); &#125; else if (host instanceof ViewModelStoreOwner) &#123; // host 是 FragmentActivity.HostCallbacks ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore(); mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore); &#125; else &#123; mNonConfig = new FragmentManagerViewModel(false); &#125;&#125;// FragmentManagerViewModel.javastatic FragmentManagerViewModel getInstance(ViewModelStore viewModelStore) &#123; ViewModelProvider viewModelProvider = new ViewModelProvider(viewModelStore, FACTORY); return viewModelProvider.get(FragmentManagerViewModel.class);&#125; 我们先看 fragment 的直接宿主是 activity （即没有嵌套）的情况，mNonConfig 由FragmentManagerViewModel.getInstance(viewModelStore) 赋值，而 getInstance 中使用的是 ViewModelProvider 获取 ViewModel ，根据我们上面的分析，只要保证作用域（viewModelStore）相同，即可获取相同的 ViewModel 实例，因此我们需要看一下 host 的 getViewModelStore 方法。经过一番寻找，host 是 FragmentActivity.HostCallbacks 1234567// FragmentActivity.java 内部类class HostCallbacks extends FragmentHostCallback&lt;FragmentActivity&gt; implements ViewModelStoreOwner, OnBackPressedDispatcherOwner &#123; public ViewModelStore getViewModelStore() &#123; // 宿主 activity 的 getViewModelStore return FragmentActivity.this.getViewModelStore(); &#125;&#125; host 的 getViewModelStore 方法返回的是宿主 activity 的 getViewModelStore() ，而 activity 重建后其内部的 mViewModelStore 是不变的，因此即使 activity 重建，其内部的 FragmentManager 对象变化，但 FragmentManager 内部的 FragmentManagerViewModel 的实例（mNonConfig）不变，mNonConfig.getViewModelStore 不变，fragment 的 getViewModelStore() 亦不变，fragment 重建后其内部的 ViewModel 仍然存在 对于嵌套 fragment ，mNonConfig 通过 parent.mFragmentManager.getChildNonConfig(parent) 获取 1234// FragmentManager.javaprivate FragmentManagerViewModel getChildNonConfig(@NonNull Fragment f) &#123; return mNonConfig.getChildNonConfig(f);&#125; 上文提到 FragmentManagerViewModel 管理着 mChildNonConfigs Map，因此子 fragment 重置后其内部的 mNonConfig 对象也是相同的 至此问题 2 就解决了 3. 如何控制作用域？对于问题3，我们知道 ViewModelStoreOwner 代表着作用域，其内部唯一的方法返回 ViewModelStore 对象，也即不同的作用域对应不同的 ViewModelStore ，而 ViewModelStore 内部维护着 ViewModel 的 HashMap ，因此只要保证相同作用域的 ViewModelStore 对象相同就能保证相同作用域获取到相同的 ViewModel 对象，而问题1我们已经解释了重建时如何保证 ViewModelStore 对象不变。 因此问题3也解决了。 4. 如何避免内存泄漏？对于问题4，由于 ViewModel 的设计，使得 activity/fragment 依赖它，而 ViewModel 不依赖视图控制器。因此只要不让 ViewModel 持有 context 或 view 的引用，就不会造成内存泄漏 总结简单的总结一下： activity 重建后 mViewModelStore 通过 ActivityThread 的一系列方法能够保持不变，从而当 activity 重建时 ViewModel 中的数据不受影响 通过宿主 activity 范围内共享的 FragmentManagerViewModel 来存储 fragment 的 ViewModelStore 和子fragment 的 FragmentManagerViewModel ，而 activity 重建后 FragmentManagerViewModel 中的数据不受影响，因此 fragment 内部的 ViewModel 的数据也不受影响 通过同一 ViewModelStoreOwner 获取的 ViewModelStore 相同，从而保证同一作用域通过 ViewModelProvider 获取的ViewModel 对象是相同的 通过单向依赖（视图控制器持有 ViewModel ）来解决内存泄漏的问题 ViewModel 和 onSaveInstanceStateViewModel 和 onSaveInstanceState 的功能有些类似，但它们也有很多差异 从存储位置上来说，ViewModel 是在内存中，因此其读写速度更快，但当进程被系统杀死后，ViewModel 中的数据也不存在了。从数据存储的类型上来看，ViewModel 适合存储相对较重的数据，例如网络请求到的 list 数据，而 onSaveInstanceState 适合存储轻量可序列化的数据 那么我们该如何使用呢？可以使用 viewmodel-savedstate 库，详情参考 【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之ViewModel】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析]]></title>
    <url>%2F2020%2F03%2F19%2FJetpack-ViewModel-SaveState%2F</url>
    <content type="text"><![CDATA[前言 大家都知道 activity 有着一套 onSaveInstanceState-onRestoreInstanceState 状态保存机制，旨在「系统资源回收」或「配置发生变化」保存状态，为用户提供更好的体验 在 androidx 下，提供了 SavedState 库帮助 activity 和 fragment 处理状态保存和恢复 本文默认您对状态保存机制有一定了解，这部分内容请移步 Saving UI States 此外，关于 android 下的进程管理，推荐 Ian Lake 的 Who lives and who dies? Process priorities on Android 本文介绍了 androidx 下 SavedState 如何帮助 activity 和 fragment 处理状态的保存和恢复，同时介绍 viewmodel-savedstate 库，以及在开发过程中正确使用状态保存的姿势 软件工程中没有什么是中间层解决不了的在分析 SavedState 库之前我们需要简单聊一聊 ComponentActivity androidx activity 1.0.0 时，ComponentActivity 成为了 FragmentActivity 和 AppCompatActivity 的基类。 俗话说「百因必有果」，带着强烈的好奇心，我查了一下 ComponentActivity 引入的原因。 可以看到 ComponentActivity 继承了 androidx.core.app.ComponentActivity(在fragment库中)，并且最初仅实现了LifecycleOwner 接口 我们创建的 activity 的继承关系现在变成了这样： 那么回到最初的问题，为什么要引入 ComponentActivity ？其实看看现在 ComponentActivity 的类结构答案就很清楚了 ComponentActivity 实现了五个接口，代表着其除了 activity 还充当着五种角色。本着职能单一原则，官方通过建立一个中间层将部分功能分别交于专门的类来负责，OnBackPressedDispatcherOwner 就是我们讲 fragment 返回栈（【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇）时提到的结构，而其中的 SavedStateRegistryOwner 则是我们今天要讲的主角 SavedState 中的成员 SavedState引入 SavedState 1implementation "androidx.savedstate:savedstate:1.0.0" 其实您不需要显示地声明，因为 activity 库内部已经引入了。jetpack 组件依赖关系可参考 【背上Jetpack】Jetpack 主要组件的依赖及传递关系 这是一个很小的库 图片来自 Android ViewModels: State persistence — SavedState SavedStateProvider保存状态的组件，此状态将在以后恢复并使用 1234public interface SavedStateProvider &#123; @NonNull Bundle saveState();&#125; SavedStateRegistry管理 SavedStateProvider 列表的组件，此注册表绑定了其所有者的生命周期（即 activity 或 fragment）。每次创建生命周期所有者都会创建一个新的实例 创建注册表的所有者后（例如，在调用 activity 的 onCreate(savedInstanceState) 方法之后），将调用其 performRestore(state) 方法，以恢复系统杀死其所有者之前保存的任何状态。 1234567void performRestore(@NonNull Lifecycle lifecycle, @Nullable Bundle savedState) &#123; // ... if (savedState != null) &#123; mRestoredState = savedState.getBundle(SAVED_COMPONENTS_KEY); &#125; // ...&#125; 每个注册表的 SavedStateProvider 都由用于注册它的唯一密钥标识 123456789101112private SafeIterableMap&lt;String, SavedStateProvider&gt; mComponents = new SafeIterableMap&lt;&gt;();public void registerSavedStateProvider(@NonNull String key, @NonNull SavedStateProvider provider) &#123; SavedStateProvider previous = mComponents.putIfAbsent(key, provider); if (previous != null) &#123; throw new IllegalArgumentException("SavedStateProvider with the given key is already registered"); &#125;&#125;public void unregisterSavedStateProvider(@NonNull String key) &#123; mComponents.remove(key);&#125; 一旦完成注册，就可以通过consumeRestoredStateForKey(key) 来使用特定密钥的还原状态 123456789101112public Bundle consumeRestoredStateForKey(@NonNull String key) &#123; if (mRestoredState != null) &#123; Bundle result = mRestoredState.getBundle(key); //调用后就会清空，第二次调用返回null mRestoredState.remove(key); if (mRestoredState.isEmpty()) &#123; mRestoredState = null; &#125; return result; &#125; return null;&#125; 请注意，此方法检索保存的状态，然后清除其内部引用，这意味着用相同的键调用它两次将在第二次调用中返回 null 一旦注册表恢复了其保存状态，则由提供者决定是否要求其恢复的数据。 如果没有，下次注册表的所有者被系统杀死时，未使用的还原数据将再次保存到保存状态 已注册的 provider 能够在其所有者被系统杀死之前保存状态。 发生这种情况时，将调用其 Bundle saveState() 方法。 对于每个已注册的 SavedStateProvider，都可以像这样保存状态。 1savedState.putBundle(savedStateProviderKey, savedStateProvider.saveState()); performSave(outBundle) 方法的源码如下 1234567891011121314151617void performSave(@NonNull Bundle outBundle) &#123; Bundle components = new Bundle(); // 1.保存未使用的状态 if (mRestoredState != null) &#123; components.putAll(mRestoredState); &#125; // 2. 通过 SavedStateProvider 保存状态 for (Iterator&lt;Map.Entry&lt;String, SavedStateProvider&gt;&gt; it = mComponents.iteratorWithAdditions(); it.hasNext(); ) &#123; Map.Entry&lt;String, SavedStateProvider&gt; entry1 = it.next(); components.putBundle(entry1.getKey(), entry1.getValue().saveState()); &#125; // 3. 将bundle 保存到 outBundle 对象中 outBundle.putBundle(SAVED_COMPONENTS_KEY, components);&#125; 执行状态保存将所有未使用的状态与注册表提供的状态合并。 此 outBundle 是 activity 的 onSaveInstanceState 中传入的 bundle 。 SavedStateRegistryController一个包装 SavedStateRegistry 并允许通过其2个主要方法对其进行控制的组件：performRestore(savedState) 和 performSave(outBundle )。 这两个方法将内部通过 SavedStateRegistry 中的方法处理 。 12345678910111213public final class SavedStateRegistryController &#123; private final SavedStateRegistryOwner mOwner; private final SavedStateRegistry mRegistry; public void performRestore(@Nullable Bundle savedState) &#123; // ... mRegistry.performRestore(lifecycle, savedState); &#125; public void performSave(@NonNull Bundle outBundle) &#123; mRegistry.performSave(outBundle); &#125;&#125; SavedStateRegistryOwner持有 SavedStateRegistry 的组件。 默认情况下，androidx 包中的ComponentActivity 和 Fragment 都实现此接口。 1234public interface SavedStateRegistryOwner extends LifecycleOwner &#123; @NonNull SavedStateRegistry getSavedStateRegistry();&#125; Activity 的状态保存这里我们要明确一件事情，activity 保存的状态究竟都有什么？ 这部分内容可以参见 官方文档 简单来说，activity 的状态保存分为 view 状态和成员状态 默认情况下，系统使用 Bundle 实例状态来保存有关 activity 布局中每个 View 对象的信息（例如，输入到 EditText 中的文本值或 recyclerview 的滚动位置）。 因此，如果 activity 实例被销毁并重新创建，则布局状态将恢复为之前的状态，而无需您执行任何代码。（注意，需要恢复状态的 view 需要配置 id ） 这部分逻辑在 activity 中的 onSaveInstanceState 方法内实现 不同平台 onSaveInstanceState 方法的执行时机稍有不同，android P 之前 onSaveInstanceState 执行在 onStop 之前，但不限于在 onPause 之前或之后。android P 及之后该方法在 onStop 后执行 前面我们提到 ComponentActivity 实现了 SavedStateRegistryOwner ，下面我们来看一看 activity 如何利用该库来实现状态的保存与恢复 12345678910111213141516171819202122232425public class ComponentActivity extends androidx.core.app.ComponentActivity implements SavedStateRegistryOwner &#123; private final SavedStateRegistryController mSavedStateRegistryController = SavedStateRegistryController.create(this); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSavedStateRegistryController.performRestore(savedInstanceState); // ... &#125; @Override protected void onSaveInstanceState(@NonNull Bundle outState) &#123; // ... //这里先调用父类的 onSaveInstanceState 保存 view 状态 super.onSaveInstanceState(outState); mSavedStateRegistryController.performSave(outState); &#125; @NonNull @Override public final SavedStateRegistry getSavedStateRegistry() &#123; return mSavedStateRegistryController.getSavedStateRegistry(); &#125;&#125; 其内部持有 SavedStateRegistryController 的实例 mSavedStateRegistryController ，在 activity 的 onCreate 方法中 通过 controller 的 performRestore 方法来查询已保存的状态，在 onSaveInstanceState 中 使用 controller 的 performSave 方法来保存状态 除了 view 状态和成员状态，activity 还负责保存其内部的 fragment 的状态。FragmentActivity 的 onSaveInstanceState 方法有对其内部 fragment 的状态进行保存，并在 onCreate 方法中对已保存的 fragment 进行恢复。这解释了如果操作不当会导致 fragment 重叠的问题 Fragment 的状态保存androidx fragment 使用 FragmentStateManager 来处理 fragment 的状态保存 其内部有四个保存相关的方法 saveState saveBasicState saveViewState saveInstanceState 其调用链为 activity 通过 FragmentController 间接 调用 FragmentManager 的 saveAllState，接着依次调用后面的save 方法 Fragment 的状态保存可分为 view 状态，成员状态，child fragment 状态 关于 view 状态 , FragmentStateManager 提供了 saveViewSate 方法，它的调用有两处： 在 activity 或父 fragment 触发状态保存时调用，即上述流程 在 fragment 即将进入 onDestroyView 生命周期时调用，其位置在 FragmentManager moveToState 方法内部，这解释了为什么加入返回栈的 replace 操作在返回时 view 状态可以自动恢复 关于成员状态，由 activity 中的状态机制处理，即上节内容 关于 child fragment 状态，fragment 的 onCreate 方法会调用 restoreChildFragmentState 来恢复 child fragment 的状态，并在 FragmentStateManager 中的 saveBasicState 方法中 调用 performSaveInstanceState 来保存 child fragment 的状态 Viewmodel-SavedState2020-01-22，ViewModel-SavedState 1.0.0 正式版发布，02-05 发布了 2.2.0 正式版 1implementation "androidx.lifecycle:lifecycle-viewmodel-savedstate:2.2.0" 您不需要手动引入该库，因为 fragment 库以及内部引入该库 Jetpack MVVM 下 UI State 通常被 ViewModel 持有并存储，因此该模块出现了，配置该模块后，ViewModel 对象将通过其构造函数接收 SavedStateHandle 对象（键值映射），可让您保存状态并查询已保存的状态。 这些值将在系统终止进程后继续存在，并可以通过同一对象使用。 图片来自 Android ViewModels: State persistence — SavedState SavedStateHandle内部持有已保存状态 key-value 的 map，允许读取和写入状态，这些状态在应用进程被杀死后仍然存在 SavedStateHandle 通过 ViewModel 的构造器传入，下面是其主要的主要的几个方法 T get(String key) MutableLiveData getLiveData(String key) void set(String key, T value) SavedStateHandle 还包含 SavedStateProvider 的实例，用于帮助 ViewModel 的 owner 保存状态 AbstractSavedStateViewModelFactory一个实现 ViewModelFactory.KeyedFactory 的 ViewModel Factory，它会创建一个与实例化的请求的 ViewModel 关联的 SavedStateHandle 12345678910111213141516171819202122232425public abstract class AbstractSavedStateViewModelFactory extends ViewModelProvider.KeyedFactory &#123; private final SavedStateRegistry mSavedStateRegistry; // Default state used when the saved state is empty private final Bundle mDefaultArgs; @Override public final &lt;T extends ViewModel&gt; T create(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; // 读取保存的状态 Bundle restoredState = mSavedStateRegistry.consumeRestoredStateForKey(key); // 创建保存状态的 handle SavedStateHandle handle = SavedStateHandle.createHandle(restoredState, mDefaultArgs); // ... // 创建 viewModel T viewmodel = create(key, modelClass, handle); // ... return viewmodel; &#125;&#125; SavedStateViewModelFactoryAbstractSavedStateViewModelFactory 的具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041public final class SavedStateViewModelFactory extends AbstractSavedStateVMFactory &#123; public SavedStateViewModelFactory(@NonNull Application application, @NonNull SavedStateRegistryOwner owner) &#123; this(application, owner, null); &#125; public SavedStateViewModelFactory(@NonNull Application application, @NonNull SavedStateRegistryOwner owner, @Nullable Bundle defaultArgs) &#123; mSavedStateRegistry = owner.getSavedStateRegistry(); mLifecycle = owner.getLifecycle(); mDefaultArgs = defaultArgs; mApplication = application; mFactory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; public &lt;T extends ViewModel&gt; T create(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass); Constructor&lt;T&gt; constructor; if (isAndroidViewModel) &#123; constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE); &#125; else &#123; constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE); &#125; // doesn't need SavedStateHandle if (constructor == null) &#123; return mFactory.create(modelClass); &#125; SavedStateHandleController controller = SavedStateHandleController.create( mSavedStateRegistry, mLifecycle, key, mDefaultArgs); T viewmodel; if (isAndroidViewModel) &#123; viewmodel = constructor.newInstance(mApplication, controller.getHandle()); &#125; else &#123; viewmodel = constructor.newInstance(controller.getHandle()); &#125; viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller); return viewmodel; //... &#125;&#125; 工作流程 1ViewModelProvider(this).get(MyViewModel::class.java) 在 activity 中创建 ViewModel 实例，传入 this （SavedStateRegistryOwner ）作为参数，该参数可以访问其 SavedStateRegistry，如果没有传入 factory 会通过 activity 重写的 getDefaultViewModelProviderFactory 方法来获取默认的 factory 。然后 factory 将使用保存的状态， 将其包装在 SavedStateHandle 中，并将其传递给 ViewModel。 ViewModel 可以读取和写入该 handle 当 activity 的 onSaveInstanceState(outState) 方法被调用，其 SavedStateRegistry 的 performSave(outState) 方法将被执行，其内部的所有 SavedStateProvider 的 saveState 方法均被执行，一旦执行完毕，outState 就包含了已保存的状态 当 app 被重启后，activity 和新的 registry 将被创建，activity 的 onCreate(savedInstanceState) 方法会被调用，然后 registry 的 performRestore(savedInstanceState) 将被调用以便恢复之前保存的状态 状态保存的正确姿势ViewModel 构造器加入 SavedStateHandle 参数，并将想要保存的数据使用该 handle 保存 12345class WithSavedStateViewModel(private val state: SavedStateHandle) : ViewModel() &#123; private val key = "key" fun setValue(value: String) = state.set(key, value) fun getValue(): LiveData&lt;String&gt; = state.getLiveData(key)&#125; 无需重写 onSaveInstanceState/onRestoreInstanceState 方法 Demo 地址 SavedState 仅适合保存轻量级的数据，重量级操作请考虑持sp，数据库等持久化方案 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之Fragment】从源码的角度看Fragment 返回栈]]></title>
    <url>%2F2020%2F03%2F16%2FJetpack-fragment-back-stack%2F</url>
    <content type="text"><![CDATA[前言 上一篇 我们介绍了 OnBackPressedDispather ，那么今天我们来正式地从源码的角度看看 fragment 的返回栈吧。由于其主流程和生命周期差不多，因此本文将详细地分析返回栈相关的源码，并插入大量源码。建议将生命周期流程熟悉后阅读本文。文末提供单返回栈和多返回栈的 demo 如果您对 activity 对任务栈和返回栈不是很了解，可以移步 Tasks and the Back Stack 小问号你是否有很多朋友？在分析源码之前，我们先来思考几个问题。 返回栈中的元素是什么？ 谁来管理 fragment 的返回栈？ 如何返回？ 返回栈中的元素是什么？返回栈，顾名思义，是一个栈结构。所以我们要搞清楚，这个栈结构到底存的是什么。 我们都知道，使用 fragment 的返回栈需要调用 addToBackStack(&quot;&quot;) 方法 在 从源码角度看 Fragment 生命周期 一文中，我们提到了 FragmentTransaction ，它是一个「事务」的模型，事务可以回滚到之前的状态。所以当触发返回操作时，就是将之前提交的事务进行回滚。 FragmentTransaction 的实现类为 BackStackRecord ，所以 fragment 的返回栈其实存放的就是 BackStackRecord 作为返回栈的元素，BackStackRecord 实现了FragmentManager.BackStackEntry 接口 从 BackStackRecord 的定义我们可以发现 BackStackRecord 有三种身份 继承了 FragmentTransaction，即是事务，保存了整个事务的全部操作 实现了 FragmentManager.BackStackEntry ，作为回退栈的元素 实现了OpGenerator ，可以生成 BackStackRecord 列表，后文详细介绍 谁来管理 fragment 的返回栈？我们已经知道 fragment 的返回栈其实存放的是 BackSrackRecord , 那么谁来管理 fragment 的返回栈？ FragmentManager 用于管理 fragment ，所以 fragment 返回栈也应该由 FragmentManager 管理 12//FragmentManager.javaArrayList&lt;BackStackRecord&gt; mBackStack; 其实触发 fragment 的返回逻辑有两种途径 开发主动调用 fragment 的返回方法 用户按返回键触发 后文我们会从这两个角度分析一下 fragment 中的返回栈逻辑究竟是怎样的 如何返回？我们已经知道返回栈中的元素是 BackStackRecord ，也清楚了是 FragmentManager 来管理返回栈。那么如果让我们来实现「返回」逻辑，应该如何做？ 首先我们要清楚所谓的「返回」是对事务的回滚，即 对 commit 事务的内部逻辑执行相应的「逆操作」。 例如 addFragment←→removeFragment showFragment←→hideFragment attachFragment←→detachFragment 有的小伙伴可能会疑惑 replace 呢？ expandReplaceOps 方法会把 replace 替换(目标 fragment 已经被 add )成相应的 remove 和 add 两个操作，或者(目标 fragment 没有被 add )只替换成 add 操作 popBackStack 系列方法FragmentManager 中提供了popBackStack 系列方法 是否觉得很眼熟？提交事务也有类似的api，commit 系列方法 这里分别提供了同步和异步的方法，可能有读者会疑惑，同样是对事务的操作，一个为提交，一个为回滚，为什么一个封装到了 FragmentManager 中，一个却在 FragmentTransaction 中。既然都是对事务的操作，应该都放在FragmentManager 中。我认为可能为了api使用的方便，使得 FragmentManager 开启事务的链式调用一气呵成。各位有什么想法欢迎在评论区留言。 这里主要介绍一下 popBackStack(String name, int flag) name 为 addToBackStack(String name) 的参数，通过 name 能找到回退栈的特定元素，flag可以为 0 或者FragmentManager.POP_BACK_STACK_INCLUSIVE，0 表示只弹出该元素以上的所有元素，POP_BACK_STACK_INCLUSIVE 表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。如果这么说比较抽象的话，看图 12//flag 传入0，弹出 ♥2 上的所有元素childFragmentManager.popBackStack("♥", 0) 12//flag 为 POP_BACK_STACK_INCLUSIVE 弹出包括该元素及及以上的元素childFragmentManager.popBackStack("♥", androidx.fragment.app.FragmentManager.POP_BACK_STACK_INCLUSIVE) 走进源码1. popBackStack() 逻辑在分析返回栈源码之前我们回顾一下 FragmentManager 提交事务到 fragment 各个生命周期的流程 下面我们看看 popBackStack 的源码 等等，这个 enqueueAction 有些眼熟… 看来提交事务和回滚事务的流程基本是相同的，只是传递的 action 不同 由源码可知，OpGenerator 是一个接口，其内只有一个 generateOps 方法，用于生成事务列表以及对应的该事务是否是弹出的。有两个实现类 由此可见 commit 调用的为 BackStackRecord 的 generateOps 方法，popBackStack 调用的是 PopBackStackState 中的 generateOps 前者的逻辑很简单，向 records list 中添加数据， isRecordPop list 全部传入 false 12records.add(this);isRecordPop.add(false); 后者的逻辑稍微复杂些，其内部调用了 popBackStackState 方法 如果是 popBackStack 方法 ，则将 FragmentManager 的返回栈列表（mBackStack）的栈顶移除， isRecordPop list 全部传入 true 123int last = mBackStack.size() - 1;records.add(mBackStack.remove(last));isRecordPop.add(true); 如果传入的 name 或 id 有值，且 flag 为 0，则找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置，并将该位置上方的所有 BackStackRecord 并添加到 record list 中，同时 isRecordPop list 全部传入 true 12345678910111213141516index = mBackStack.size() - 1;while (index &gt;= 0) &#123; BackStackRecord bss = mBackStack.get(index); if (name != null &amp;&amp; name.equals(bss.getName())) &#123; break; &#125; if (id &gt;= 0 &amp;&amp; id == bss.mIndex) &#123; break; &#125; index--;&#125;for (int i = mBackStack.size() - 1; i &gt; index; i--) &#123; records.add(mBackStack.remove(i)); isRecordPop.add(true);&#125; 如果传入的 name 或 id 有值，且 flag 为 POP_BACK_STACK_INCLUSIVE，则在上一条获取位置的基础上继续遍历，直至栈底或者遇到不匹配的跳出循环，接着出栈所有 BackStackRecord 123456789101112131415//index 操作与上方相同，先找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置if ((flags &amp; POP_BACK_STACK_INCLUSIVE) != 0) &#123; index--; // 继续遍历 mBackStack 直至栈底或者遇到不匹配的跳出循环 while (index &gt;= 0) &#123; BackStackRecord bss = mBackStack.get(index); if ((name != null &amp;&amp; name.equals(bss.getName())) || (id &gt;= 0 &amp;&amp; id == bss.mIndex)) &#123; index--; continue; &#125; break; &#125;&#125;//后续出栈逻辑与上方相同 可以配合上面的动图理解 入栈和出栈后续的逻辑大体是相同的，只是根据 isPop 的正负出现了分支，出栈调用的是 executePopOps 上文我们有提到，「返回」逻辑实际上就是执行提交事务内部操作逻辑的「逆操作」 那么接下的逻辑就很清晰了，根据不同的 mCmd 执行相应的逆操作 12345678910111213141516171819202122232425262728293031323334353637383940414243void executePopOps(boolean moveToState) &#123; for (int opNum = mOps.size() - 1; opNum &gt;= 0; opNum--) &#123; final Op op = mOps.get(opNum); Fragment f = op.mFragment; switch (op.mCmd) &#123; case OP_ADD: mManager.removeFragment(f); break; case OP_REMOVE: mManager.addFragment(f); break; case OP_HIDE: mManager.showFragment(f); break; case OP_SHOW: mManager.hideFragment(f); break; case OP_DETACH: mManager.attachFragment(f); break; case OP_ATTACH: mManager.detachFragment(f); break; case OP_SET_PRIMARY_NAV: mManager.setPrimaryNavigationFragment(null); break; case OP_UNSET_PRIMARY_NAV: mManager.setPrimaryNavigationFragment(f); break; case OP_SET_MAX_LIFECYCLE: mManager.setMaxLifecycle(f, op.mOldMaxState); break; default: throw new IllegalArgumentException("Unknown cmd: " + op.mCmd); &#125; if (!mReorderingAllowed &amp;&amp; op.mCmd != OP_REMOVE &amp;&amp; f != null) &#123; mManager.moveFragmentToExpectedState(f); &#125; &#125; if (!mReorderingAllowed &amp;&amp; moveToState) &#123; mManager.moveToState(mManager.mCurState, true); &#125;&#125; 后面的逻辑就完全一样了 2. fragment 是怎样拦截 activity 的返回逻辑的？在 【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇 一文中我们介绍了 OnBackPressedDispatcher activity 的 onBackPressed 的逻辑主要分为两部分，判断所有注册的 OnBackPressedCallback 是否有 enabled 的，如果有则拦截，不执行后续逻辑； 否则着执行 mFallbackOnBackPressed.run() ，其内部逻辑为调用 ComponentActivity 父类的 onBackPressed 方法 所以我们只需看 mOnBackPressedCallbacks（ArrayDeque&lt;OnBackPressedCallback） 是怎样被添加的以及 isEnabled 何时赋值为 true 经过查找我们发现它是在 FragmentManager 的 attachController 调用 addCallback 1mOnBackPressedDispatcher.addCallback(owner,mOnBackPressedCallback) 进而执行了 而 mOnBackPressedCallback 在初始化时 enabled 赋值为 false isEnadbled 会在返回栈数量大于 0 且其 mParent 为 PrimaryNavigation 时赋值为true 而返回栈（mBackStack）的赋值在 BackStackRecord 的 generateOps 方法中，且是否添加到返回栈由 mAddToBackStack 这个布尔类型的属性控制 mAddToBackStack 的赋值在 addToBackStack 方法中，这也解释了为何调用 addToBackStack 方法就能将事务加入返回栈 我们来总结一下，fragment 拦截 activity 返回栈是通过 OnBackPressedDispatcher 实现的，如果开启事务调用了 addToBackStack 方法，则 mOnBackPressedCallback 的 isEnabled 属性会赋值为 true，进而起到拦截 activity 返回逻辑的作用。拦截后执行 popBackStackImmediate 方法 而 popBackStack系列方法会调用 popBackStackState 构造 records 和 isRecordPop 列表，isRecordPop 的内部元素的值均为true 后续流程和提交事务是一样的，根据 isRecordPop 值的不同选择执行 executePopOps 或 executeOps 方法 单返回栈和多返回栈的实现Ian Lake 在 Fragments: Past, Present, and Future (Android Dev Summit ‘19) 有提到未来会提供多返回栈的 api 那么以现有的 api 如何实现多返回栈呢？ 首先我要弄清楚怎样才会有多返回栈，根据上文我们知道 FragmentManager 内部持有mBackStack list，这对应着一个返回栈，如果想要实现多返回栈，则需要多个 FragmentManager，而多 FragmentManager 则对应多个 fragment 因此我们可以创建多个宿主 frament 作为导航 fragment 这样就可以用不同的宿主 fragment 的 独立的FragmentManager 分别管理各自的返回栈，如果这样说比较抽象，可以参考下图 图中有四个返回栈，其中最外部有一个宿主 fragment ，内部有四个负责导航的 fragment 管理其内部的返回栈，外部的宿主负责协调各个返回栈为空后如何切换至其他返回栈 单返回栈就很容易了，我们只需在同一个 FragmentManager 上添加返回栈即可 详情参照 demo 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack】Fragment返回栈预备篇 OnBackPressedDispatcher]]></title>
    <url>%2F2020%2F03%2F14%2FJetpack-OnBackPressedDispatcher%2F</url>
    <content type="text"><![CDATA[这两天在准备写 fragment 返回栈的文章，但是发现必须先介绍一下 OnBackPressedDispatcher ，所以这是一篇介绍 what 的文章，喜欢一手资料的可以移步 官方文档 系列文章 【背上Jetpack】Jetpack 主要组件的依赖及传递关系 【背上Jetpack】AdroidX下使用Activity和Fragment的变化 【背上Jetpack之Fragment】你真的会用Fragment吗？Fragment常见问题以及androidx下Fragment的使用新姿势 【背上Jetpack之Fragment】从源码角度看 Fragment 生命周期 AndroidX Fragment1.2.2源码分析 WhenOnBackPressedDispatcher 在 androidx activity 1.0.0 加入，旨在处理返回逻辑。您不仅可以获得在 Activity 之外处理返回键的便捷方式。 根据您的需要，您可以在任意位置定义 OnBackPressedCallback，使其可复用，或根据应用程序的架构进行任何操作。 您不再需要重写Activity 中的 onBackPressed 方法，也不必提供自己的抽象的来实现需求的代码。 WhatComponentActivity 是 FragmentActivity 和 AppCompatActivity 的基类，它使您可以通过使用其 OnBackPressedDispatcher（可以通过调用 getOnBackPressedDispatcher() ）来控制返回按钮的行为。 OnBackPressedDispatcher 控制如何将返回按钮事件分配给一个或多个OnBackPressedCallback 对象。 OnBackPressedCallback 的构造函数将布尔值用于初始启用状态。 仅当启用了回调（即 isEnabled() 返回true）时，调度程序才会调用回调的handleOnBackPressed() 来处理返回按钮事件。 您可以通过调用 setEnabled() 来更改启用状态。 回调是通过 addCallback 方法添加的。 强烈建议使用采用 LifecycleOwner 的addCallback() 方法。 这样可以确保仅在 LifecycleOwner 为 Lifecycle.State.STARTED 时才添加OnBackPressedCallback。 当关联的 LifecycleOwner 被销毁时，该 activity 会删除已注册的回调，以防止内存泄漏，并使其适用于寿命比该 activity 短的 fragment 或其他生命周期所有者。 下面是一个示例 1234567891011121314class MyFragment : Fragment() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) //此 callback 仅当 MyFragment 至少是 Started 状态下调用 val callback = requireActivity().onBackPressedDispatcher.addCallback(this) &#123; //拦截返回事件 &#125; //此 callback 可以在这里或者上面的 lambda 中开启和关闭 &#125; ...&#125; 您可以通过 addCallback() 提供多个回调。 这样做时，将按照添加回调的相反顺序调用回调，即最后添加的回调是第一个给予处理返回按钮事件的机会的回调。 例如，如果您依次添加了三个分别名为1、2和3的回调，则将分别以3、2和1的顺序调用它们。 回调遵循“责任链”模式。 仅当未启用前一个回调时，才调用链中的每个回调。 这意味着在前面的示例中，仅当未启用回调3时，才会调用回调2。 仅当未启用回调2时，才调用回调1，依此类推。 请注意，通过 addCallback() 添加回调时，直到 LifecycleOwner 进入Lifecycle.State.STARTED 状态，才将回调添加到责任链中。 强烈建议更改 OnBackPressedCallback 的启用状态以进行临时更改(即更改 isEnabled 的值)，因为它可以保持上述顺序，如果您在多个不同的嵌套生命周期所有者上注册了回调，这尤其重要。 但是，如果要完全删除 OnBackPressedCallback，则应调用 remove()。 但是，这通常不是必需的，因为在销毁关联的 LifecycleOwner 时会自动删除其回调。 Activity onBackPressed()如果您使用 onBackPressed() 处理返回按钮事件，建议您改用 OnBackPressedCallback 。 但是，如果您无法进行此更改，则适用以下规则： 当您调用 super.onBackPressed() 时，将通过 addCallback 注册的所有回调。 无论 OnBackPressedCallback 的任何注册实例，始终会调用 onBackPressed。 Demo关于 fragment 返回栈的 demo 已经写好了，感兴趣的小伙伴可以 在这 找到它。 我们下一篇再见。 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之Fragment】从源码角度看Fragment的启动流程及生命周期 基于AndroidX Fragment1.2.2]]></title>
    <url>%2F2020%2F03%2F10%2FJetpack-fragment-lifecycle%2F</url>
    <content type="text"><![CDATA[笔者看过不少源码分析类的文章，动辄贴上大段代码，这种方式很容易打断读者的思路，所以很多时候看过这类文章感叹好文好文，却感觉什么都没记住，亦或者默默加入收藏却不知何时能去细心地研读。 所以本文不会过多介绍源码的细节，更多地是抛砖引玉，如果您看过本文后能够跟着本文的思路自己翻一下源码相信您就不会有我上述的体验了。 本文默认您已对 fragment 的生命周期有所了解，并清楚fragment的缘起与职责。这部分基础内容可移步 fragment 官方文档 也即本文不会介绍 “what”，而是介绍 “how” 并且探讨一下 “why” 这里贴一下 androidx fragment 源码地址 androidx fragment 官方源码地址 本文基于 androidx fragment 1.2.2 源码分析 1implementation "androidx.fragment:fragment-ktx:1.2.2" 本文主要介绍fragment的启动流程，其他内容例如返回栈，会后续更新，敬请关注。欢迎在评论区下讨论。本文demo 既然我们都知道 “what”，不妨我们来思考一下 “how” 分析前的思考请大家思考一个问题，我们知道fragment 的生命周期是与其宿主 activity 的生命周期息息相关的，也即 activity 的每次生命周期回调都会引发每个fragment的类似回调。 那么，如果让我们来实现这样的操作，应该怎么做？ 猜测：在activity每个生命周期的节点，去操作fragment，让其执行相应的生命周期方法。 思路有了，下面进行一些细节的确认。 activity 要能操作 fragment，fragment 亦可操作 fragment，所以需要抽象出一个管理 fragment 的模型 activity 操作 fragment 的一系列动作，应该是互为可逆一组操作。例如添加 fragment 后，也应能移除 fragment activity 对 fragment 的每组操作不应是单一的，例如可以在一次操作中在 activity 不同位置添加两个 fragment，同时该操作还应满足 2 ，具有可逆性 对于第一条，我们抽象出一个可以管理 fragment 的模型，加入上下级的关系，即 activity 可管理其内部的 fragment，fragment 亦可管理其内部的 fragment。因此 fragment 同时充当着管理者与被管理者两种角色 对于后两条，相信在大学学过数据库的人会想到一种结构：事务（Transaction） 事务是指一组原子性的操作，这些操作是不可分割的整体，要么全完成，要么全不完成，完成后可以回滚到完成前的状态 因此，fragment 中两个最重要的概念出现了，FragmentManager 和 FragmentTransaction FragmentManager 封装着对 fragment 操作的各种方法，addFragment removeFragment 等等，而 FragmentActivity 通过 FragmentController 来操作 FragmentManager FragmentTransaction 封装对 fragment 容器进行的 fragment 操作，例如在容器1内添加一个 fragment，同时在容器2内替换fragment。 它们均为抽象类，需要具体的实现类。 FragmentManager 的实现类为 FragmentManagerImpl，其内部逻辑已全部移至 FragmentManager 中，是个空实现。 FragmentTransaction 的实现类为 BackStackRecord ，其内部引用了 FragmentManager 的实例 ，同时重写了父类的 四个 commit 相关的方法。 看似最简单的启动流程现在让我们看一部分代码，平时在activity中我们是这样填充一个fragment的 12345678910override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) //避免旋转屏幕等场景 fragment 重叠的问题 if (savedInstanceState == null) &#123; supportFragmentManager//步骤1 .beginTransaction()//步骤2 .add(R.id.container, BlankFragment.newInstance())//步骤3 .commitNow()//步骤4 &#125;&#125; 步骤1，实例化 FragmentManagerImpl 对象 (内部经历了一些转换，详情参见源码或查看demo注释) 步骤2，实例化 BackStackRecord对象，并在构造器中传入 FragmentManager 实例 步骤3，调用事务方法，对 fragment 容器进行相应的操作，本例表示在 id 为 container 容器内添加 BlankFragment 步骤4，提交事务，交于 FragmentManager 处理 在 terminal 敲入 adb shell setprop log.tag.FragmentManager VERBOSE 可开启FragmentManager的日志功能，过滤 FragmentManager ，日志如下： 绿色部分为笔者手动添加的log，灰色和蓝色部分为 fragment 源码中的log 根据日志显示的流程，我们的猜测看似是正确的，“在 activity 每个生命周期的节点，去操作 fragment ，让其执行相应的生命周期方法” 其实这里是有干扰的，因为我们是在activity 的 onCreate 方法里 创建并提交 FragmentTransaction ，如果在 onResume 里调用呢？ WTF！ 或许，我们的猜测有问题？看似调用 commitNow 后 fragment 的生命流程是自发进行的 那如果我们把调用挪到 onPause 呢？ 打开 activity 并按下 home 键 我知道好奇的读者会尝试在 onStop 中尝试一下，有惊喜。手动滑稽。 从这几段日志上来看，fragment 在提交事务后会自发进入自己的生命周期流程，而当其宿主 activity 生命周期发生变化时，fragment 的生命周期也跟随变化。 如果这么说比较抽象的话，我们可以看在 onPause 中显示fragment 的日志，当 Fragment 进入 onStart 生命周期后，如果是正常流程应该进入 onResume，但由于按下 home 键 activity进入onStop，fragment 也进入了 onStop 状态 因此，我们将之前的猜测进行扩展： 在activity每个生命周期的节点，去操作fragment，让其执行相应的生命周期方法 FragmentTransaction 被提交后 fragment 会进入自己的生命周期流程，但受 1 约束 那么我们的源码解读就从两个方向入手 Activity 操作 Fragment 生命周期activity 是通过 FragmentController 操作 FragmentManager 进而操作 fragment 的。 具体点就是在 activity 各个生命周期节点通过调用 FragmentController 中的各个 dispatch- 方法进而调用 FragmentManager 中的各个 dispatch- 方法 12345678910111213141516171819202122232425262728293031323334//FragmentActivity.javafinal FragmentController mFragments = FragmentController.createController(new HostCallbacks());//以下代码省略部分逻辑@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; mFragments.dispatchCreate();&#125;@Overrideprotected void onStart() &#123; mFragments.dispatchStart();&#125;//onResume 彻底执行完毕的回调@Overrideprotected void onPostResume() &#123; mFragments.dispatchResume();&#125;@Overrideprotected void onPause() &#123; mFragments.dispatchPause();&#125;@Overrideprotected void onStop() &#123; mFragments.dispatchStop();&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); mFragments.dispatchDestroy();&#125; 这样猜测 1 就被证实了 activity 会在各个生命周期节点通过 FragmentController 间接调用 FragmentManager 中的 各种 dispatch- 方法，进而影响 fragment 的生命周期 那么嵌套 fragment 呢？ 嵌套 fragment 也应该是宿主使用 FragmentManager 中的各种 dispatch- 方法，基于这个想法我们可以看一下 FragmentManager 中 dispatch- 方法的调用 可以看到这里有两处调用，第二处为activity 通过 FragmentController 间接调用，第一处使用的是 mChildFragmentManager 这里引出 fragment 中另外两个比较重要的概念，getParentFragmentManager() 和 getChildFragmentManager() 注意：requireFragmentManager() 和 getFragmentManager 已弃用 getChildFragmentManager()获取的是fragment 中的 mChildFragmentManager getParentFragmentManager() 获取的是fragment 中的 mFragmentManager mChildFragmentManager 为fragment内部的 fragmentManager 123// Private fragment manager for child fragments inside of this one.@NonNullFragmentManager mChildFragmentManager = new FragmentManagerImpl(); mFragmentManager 稍显复杂， 如果 fragment 的直接宿主是 activity ，则返回的是 activity 中的getSupportFragmentManager() 返回的 fragmentManager 如果 fragment 的直接宿主是 fragment，即该 fragment 是其他 fragment 的子 fragment，则返回的是其父 fragment 的 getChildFragmentManager 所以 嵌套fragment 的生命周期是父 fragment 在各个生命周期节点上通过 mChildFragmentManager 调用 dispatch- 以影响其子 fragment 的生命周期 这样我们第一部分的解读就告一段落了, 这里点到为止,一些细节需要您自己亲自看看源码 Fragment 的生命周期自治在 看似最简单的启动流程 一节中我们分别在 activity 的 onCreate ，onResume，onPause 中分别开启并提交事务，来观察 fragment 的生命周期日志。 在没有 activity 干扰的情况下，fragment 的生命周期是自治的。 那么我们继续思考一个问题 Fragment 的生命周期是如何一环扣一环的执行的？ 从上面的日志，我们看到很多 “moveto-” 的日志， 我们可以继续大胆地猜测，一个生命周期节点结束后调用进入另一个生命周期节点的方法 基于这个猜测，我们确认一些细节 fragment 应该有自己的状态，它可能自己管理内部的状态，也可能会有封装着状态转移的逻辑的专门管理状态的抽象 这里引出另外一个概念 FragmentStateManager FragmentStateManager 中持有 fragment 的引用 mFragment 以及 FragmentManager 的状态 mFragmentManagerState 这里fragment的状态值为： 123456static final int INITIALIZING = -1; // Not yet attached.static final int ATTACHED = 0; // Attached to the host.static final int CREATED = 1; // Created.static final int ACTIVITY_CREATED = 2; // Fully created, not started.static final int STARTED = 3; // Created and started, not resumed.static final int RESUMED = 4; // Created started and resumed. FragmentStateManager 还封装着 fragment 状态转移的方法，例如： 123456789101112void activityCreated() &#123; if (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123; Log.d(TAG, "moveto ACTIVITY_CREATED: " + mFragment); &#125; mFragment.performActivityCreated(mFragment.mSavedFragmentState);&#125;void start() &#123; if (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123; Log.d(TAG, "moveto STARTED: " + mFragment); &#125; mFragment.performStart();&#125; fragment 生命周期自治的核心逻辑封装在 FragmentManager 中的 void moveToState(@NonNull Fragment f, int newState) 内，主要代码为(精简后)： 12345678910111213141516171819202122232425262728293031323334void moveToState(@NonNull Fragment f, int newState) &#123; FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho); newState = Math.min(newState, fragmentStateManager.computeMaxState()); if (f.mState &lt;= newState) &#123; switch (f.mState) &#123; case Fragment.INITIALIZING: if (newState &gt; Fragment.INITIALIZING) &#123; fragmentStateManager.attach(mHost, this, mParent); &#125; case Fragment.ATTACHED: if (newState &gt; Fragment.ATTACHED) &#123; fragmentStateManager.create(); &#125; case Fragment.CREATED: if (newState &gt; Fragment.INITIALIZING) &#123; fragmentStateManager.ensureInflatedView(); &#125; if (newState &gt; Fragment.CREATED) &#123; fragmentStateManager.createView(mContainer); fragmentStateManager.activityCreated(); fragmentStateManager.restoreViewState(); &#125; case Fragment.ACTIVITY_CREATED: if (newState &gt; Fragment.ACTIVITY_CREATED) &#123; fragmentStateManager.start(); &#125; case Fragment.STARTED: if (newState &gt; Fragment.STARTED) &#123; fragmentStateManager.resume(); &#125; &#125; &#125;&#125; 注意：这里的switch 没有 break 细心的读者可能发现了，fragment 中的状态怎么只到 resume ，后续的状态呢？ 我们可以看一下 FragmentManager 中的 dispatchPause 方法 123void dispatchPause() &#123; dispatchStateChange(Fragment.STARTED);&#125; 为什么 dispatch 了 STARTED 的状态？其实刚刚 moveToState 方法我精简掉了一部分代码，留下的只有 f.mState &lt;= newState 的逻辑，即 dispatch 的新状态大于等于当前的状态 而现在dispatch 的新状态比当前状态值小，则走了下面的逻辑，例如当前状态为 RESUMED ，新传递的状态为 STARTED，执行了 fragmentStateManager.pause(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void moveToState(@NonNull Fragment f, int newState) &#123; FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho); newState = Math.min(newState, fragmentStateManager.computeMaxState()); if (f.mState &lt;= newState) &#123; //省略... &#125;else if (f.mState &gt; newState) &#123; switch (f.mState) &#123; case Fragment.RESUMED: if (newState &lt; Fragment.RESUMED) &#123; fragmentStateManager.pause(); &#125; case Fragment.STARTED: if (newState &lt; Fragment.STARTED) &#123; fragmentStateManager.stop(); &#125; case Fragment.ACTIVITY_CREATED: if (newState &lt; Fragment.ACTIVITY_CREATED) &#123; if (isLoggingEnabled(Log.DEBUG)) &#123; Log.d(TAG, "movefrom ACTIVITY_CREATED: " + f); &#125; if (f.mView != null) &#123; if (mHost.onShouldSaveFragmentState(f) &amp;&amp; f.mSavedViewState == null) &#123; fragmentStateManager.saveViewState(); &#125; &#125; if (mExitAnimationCancellationSignals.get(f) == null) &#123; destroyFragmentView(f); &#125; else &#123; f.setStateAfterAnimating(newState); &#125; &#125; case Fragment.CREATED: if (newState &lt; Fragment.CREATED) &#123; boolean beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack(); if (beingRemoved || mNonConfig.shouldDestroy(f)) &#123; makeInactive(fragmentStateManager); &#125; else &#123; if (f.mTargetWho != null) &#123; Fragment target = findActiveFragment(f.mTargetWho); if (target != null &amp;&amp; target.getRetainInstance()) &#123; f.mTarget = target; &#125; &#125; &#125; if (mExitAnimationCancellationSignals.get(f) != null) &#123; f.setStateAfterAnimating(newState); newState = Fragment.CREATED; &#125; else &#123; fragmentStateManager.destroy(mHost, mNonConfig); &#125; &#125; case Fragment.ATTACHED: if (newState &lt; Fragment.ATTACHED) &#123; fragmentStateManager.detach(mNonConfig); &#125; &#125; &#125;&#125; 注意：这里的switch 还是没有 break 这里有个细节，由于activity没有 onDestroyView 的生命周期，所以 FragmentController 中的 dispatchDestroyView 是没有调用的 在 activity 中的 destroy 方法中通过 fragmentController 调用了 dispatchDestroy 内部调用 dispatchStateChange(Fragment.INITIALIZING) ，而此时的fragment 的 mState 为 ACTIVITY_CREATED，所以 moveToState 方法会走到 ACTIVITY_CREATED 的 case 并执行到底 这样 fragment 最简单场景的生命周期就结束了 总结我们做一个总结：activity 和 fragment 会在各个生命周期节点通过被调用 fragment 的 parentFragmentManager（或者说父 fragment 的 childFragmentManager 和 activity 的 supportFragmentManager）中的各种 dispatch- 方法以影响子 fragment 的 生命周期，同时子 fragment 也拥有自己生命周期的调用链（从状态A转移至状态B） 不得不说 fragment 的很多 API 并不是很好用，从 androidx fragment 的更新频率也可以看出。比如 fragment 中的 view 和 fragment本身的生命周期是不一致的，存在onDestroyView 但 fragment没有销毁的情况 Ian Lake 在 Fragments: Past, Present, and Future (Android Dev Summit ‘19) 中提到未来官方会将二者合并，届时 fragment 的使用会更加简洁 这里引用 The Android Lifecycle cheat sheet — part III : Fragments 文中的图片 ，和我画的commit FragmentTransaction 的脑图（略简陋），帮您更好的理解 强烈建议您自己亲自看一看源码，不然就变为我文章开头时说的状态了。 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack之Fragment】你真的会用Fragment吗？Fragment常见问题以及androidx下Fragment的使用新姿势]]></title>
    <url>%2F2020%2F03%2F02%2FJetpack-fragment%2F</url>
    <content type="text"><![CDATA[在 Android Jetpack 组件中，fragment作为视图控制器之一占有很重要的位置。但由于其bug众多，暗坑无数，以至于 Square 有这样一篇博客：Advocating Against Android Fragments。github上的 Fragmentation 有着 9.4k 的star。 而现在，androidx fragment 稳定版已来到 1.2.2，让我们总结一下fragment有哪些常见问题以及有哪些使用fragment的新姿势 Fragment 常见的问题 getSupportFragmentManager ， getParentFragmentManager 和 getChildFragmentManager FragmentStateAdapter 和 FragmentPagerAdapter add 和 replace observe LiveData时传入 this 还是 viewLifecycleOwner 使用 simpleName 作为 fragment 的 tag 有何风险？ 在 BottomBarNavigation 和 drawer 中如何使用Fragment多次添加？ 返回栈 getSupportFragmentManager , getParentFragmentManager和getChildFragmentManager FragmentManager是 androidx.fragment.app(已弃用的不考虑)下的抽象类，创建用于 添加，移除，替换 fragment 的事务（transaction） 首先要确认一件事，getSupportFragmentManager()是 FragmentActivity下的方法 getParentFragmentManager 和 getChildFragmentManager 是 androidx.fragment.app.Fragment 下的方法，其中 androidx.fragment 1.2.0 后 getFragmentManager 与 requireFragmentManager 已弃用 明确了这件事，接下来的就很清晰了 getSupportFragmentManager与 activity关联，可以将其视为 activity 的 FragmentManager getChildFragmentManager 与 fragment关联，可以将其视为fragment的FragmentManager getParentFragmentManager情况稍微复杂，正常情况返回的是该fragment 依附的activity的FragmentManager。如果该fragment是另一个fragment 的子 fragment，则返回的是其父fragment的 getChildFragmentManager 如果这么说还不明白的话，我们可以做一个实践。 创建一个 activity,一个父fragment ，一个子fragment 1234567891011121314151617181920212223242526272829// activityclass MyActivity : AppCompatActivity(R.layout.activity_main) &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) supportFragmentManager.commit &#123; add&lt;ParentFragment&gt;(R.id.content) &#125; Log.i("MyActivity", "supportFragmentManager $supportFragmentManager") &#125;&#125;class ParentFragment : Fragment(R.layout.fragment_parent) &#123; override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) childFragmentManager.commit &#123; add&lt;ChildFragment&gt;(R.id.content) &#125; Log.i("ParentFragment", "parentFragmentManager $parentFragmentManager") Log.i("ParentFragment", "childFragmentManager $childFragmentManager") &#125;&#125;class ChildFragment : Fragment(R.layout.fragment_child) &#123; override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) Log.i("ChildFragment", "parentFragmentManager $parentFragmentManager") Log.i("ChildFragment", "childFragmentManager $childFragmentManager") &#125;&#125; 123456//logI/MyActivity: supportFragmentManager FragmentManager&#123;825dcef in HostCallbacks&#123;14a13fc&#125;&#125;&#125;I/ParentFragment: parentFragmentManager FragmentManager&#123;825dcef in HostCallbacks&#123;14a13fc&#125;&#125;&#125;I/ParentFragment: childFragmentManager FragmentManager&#123;df5de83 in ParentFragment&#123;7cdd800&#125;&#125;&#125;I/ChildFragment: parentFragmentManager FragmentManager&#123;df5de83 in ParentFragment&#123;7cdd800&#125;&#125;&#125;I/ChildFragment: childFragmentManager FragmentManager&#123;aba9afb in ChildFragment&#123;5cea718&#125;&#125;&#125; 因此 在 activity 中使用 ViewPager，BottomSheetFragment 和DialogFragment 时，都应使用 getSupportFragmentManager 在fragment 中使用 ViewPager 时应该使用getChildFragmentManager 错误的在 fragment 中使用 activity 的 FragmentManager 会引发内存泄露。 为什么呢？假如您的fragment中有一些依靠 ViewPager 管理的子 fragment，并且所有这些 fragment 都在 activity 中，因为您使用的是activity 的FragmentManager 。 现在，如果关闭您的父fragment，它将被关闭，但不会被销毁，因为所有子fragment都处于活动状态，并且它们仍在内存中，从而导致泄漏。 它不仅会泄漏父fragment，还会泄漏所有子fragment，因为它们都无法从堆内存中清除。 FragmentStateAdapter 和 FragmentPagerAdapterFragmentPagerAdapter将整个 fragment存储在内存中，如果ViewPager中使用了大量 fragment，则可能导致内存开销增加。 FragmentStatePagerAdapter仅存储片段的savedInstanceState，并在失去焦点时销毁所有 fragment。 让我们看看常见的两个问题 1. 刷新ViewPager不生效ViewPager 中的 fragment 是通过 activity或 fragment的 FragmentManager 管理的，FragmentManager 包含了viewpager的所有fragment的实例 因此，当ViewPager没有刷新时，它只是FragmentManager仍保留的旧 fragment 实例。 您需要找出为什么FragmentManger持有fragment实例的原因。 2. 在Viewpager中访问当前fragment这也是我们遇到的一个非常普遍的问题。 如果遇到这种情况，我们一般在 adapter 内部创建 fragment 的数组列表，或者尝试使用某些标签访问fragment。 不过还有另一种选择。 FragmentStateAdapter 和FragmentPagerAdapter都提供方法setPrimaryItem。 可以用来设置当前fragment，如下所示： 12345678910 var fragment: ChildFragment? = null override fun setPrimaryItem(container: ViewGroup, position: Int, any: Any) &#123; if (getChildFragment() != any) fragment = any as ChildFragment super.setPrimaryItem(container, position, any) &#125; fun getChildFragment(): ChildFragment? = fragment//usemAapter.getChildFragment() add 和 replace 如何选择？在我们的activity中，我们有一个容器，其中装有fragment。 add只会将一个fragment添加到容器中。 假设您将FragmentA和FragmentB添加到容器中。 容器将具有FragmentA和FragmentB，如果容器是FrameLayout，则将fragment一个添加在另一个之上。 replace将简单地替换容器顶部的一个fragment，因此，如果我创建了 FragmentC并 replace 顶部的 FragmentB，则FragmentB将被从容器中删除（执行onDestroy，除非您调用addToBackStack，仅执行onDestroyView），而FragmentC将位于顶部。 那么如何选择呢？ replace删除现有fragment并添加一个新fragment。 这意味着当您按下返回按钮时，将创建被替换的fragment，并调用其onCreateView。 另一方面，add保留现有fragment，并添加一个新fragment，这意味着现有fragment将处于活动状态，并且它们不会处于 “paused” 状态。 因此，按下返回按钮时，现有fragment（添加新fragment之前的fragment）不会调用onCreateView。 就fragment的生命周期事件而言，在replace的情况下将调用onPause，onResume，onCreateView和其他生命周期事件，在add的情况下则不会。 如果不需要重新访问当前fragment并且不再需要当前fragment，请使用replace。 另外，如果您的应用有内存限制，请考虑使用replace。 observe LiveData时传入 this 还是 viewLifecycleOwnerandroidx fragment 1.2.0 起，添加了新的 Lint 检查，以确保您在从 onCreateView()、onViewCreated() 或 onActivityCreated() 观察 LiveData 时使用 getViewLifecycleOwner() 使用 simpleName 作为 fragment 的 tag 有何风险？一般情况下我们会使用calss的simpleName 作为fragment 的tag 12345supportFragmentManager.commit &#123; replace(R.id.content,MyFragment.newInstance("Fragment"), MyFragment::class.java.simpleName) addToBackStack(null)&#125; 这样做不会出现什么问题，但是… 1val fragment = supportFragmentManager.findFragmentByTag(tag) 这样获取到的fragment可能不是想要的结果。 为什么呢？ 加入有两个 fragment，经过混淆，它们变成 12com.mypackage.FragmentA → com.mypackage.c.acom.mypackage.FragmentB → com.mypackage.c.a.a 上面是混淆了 full name，如果是simpleName 呢？ 12com.mypackage.FragmentA → acom.mypackage.FragmentB → a WTF！ 所以在设置tag时尽量用全名或者常量 在 BottomBarNavigation 和 drawer 中如何使用Fragment多次添加？当我们使用BottomBarNavigation和 NavigationDrawer时，通常会看到诸如fragment 重建或多次添加相同fragment之类的问题。 在这种情况下，您可以使用show / hide 而不是 add 或 replace。 返回栈如果您想在fragment的一系列跳转中按返回键返回上一个fragment，应该在commit transaction之前调用addToBackStack方法 12345//使用该扩展 androidx.fragment:fragment-ktx:1.2.0 以上parentFragmentManager.commit &#123; addToBackStack(null) add&lt;SecondFragment&gt;(R.id.content)&#125; Fragment的使用新姿势 fragment-ktx 有哪些好用的扩展函数 fragment 之间和与 activity 通信 使用 FragmentContainerView 作为 fragment 容器 FragmentFactory 的使用 Fragment 返回键拦截 Fragment 使用 ViewBinding Fragment 使用 ViewPager2 不需要重写 onCreateView 了？ 使用require_()方法 fragment-ktx 有哪些好用的扩展函数1. FragmentManagerKt12345678910//beforesupportFragmentManager .beginTransaction() .add(R.id.content,Fragment1()) .commit()//aftersupportFragmentManager.commit &#123; add&lt;Fragment1&gt;(R.id.content)&#125; 2. FragmentViewModelLazyKt1234567891011//before//共享范围activityval mViewMode1l = ViewModelProvider(requireActivity()).get(UpdateAppViewModel::class.java)//共享范围fragment 内部val mViewMode1l = ViewModelProvider(this).get(UpdateAppViewModel::class.java)//after//共享范围activityprivate val mViewModel by activityViewModels&lt;MyViewModel&gt;()//共享范围fragment 内部private val mViewModel by viewModel&lt;MyViewModel&gt;() 注意：ViewModelProviders.of(this).get(MyViewModel.class); 的方式已弃用 lifecycle-extensions 依赖包已弃用 fragment 之间和与 activity 通信fragment 和 fragment之间，fragment 和 activity 之间的通信有很多方法，android jetpack 推荐我们使用 ViewModel + LiveData 处理 同一个activity 内的 fragment 之间通信，可以使用作用范围为activity的ViewModel，activity与 fragment通信同理。详情可移步 Android官方应用架构指南 使用 FragmentContainerView 作为 fragment 容器过去我们使用 FrameLayout 作为 Fragment 的容器，在 AndroidX Fragment 1.2.0 后，可以使用 FragmentContainerView 代替 Fragment 。 它修复了一些动画 z轴索引顺序问题和窗口插入调度，这意味着两个fragment之间的退出和进入过渡不会互相重叠。使用FragmentContainerView将先开启退出动画然后才是进入动画。 FragmentContainerView 是专门为 fragment设计的自定义View，它继承自 FrameLayout android:name 属性允许您添加fragment，android:tag 属性可以为fragment设置tag 123456789&lt;androidx.fragment.app.FragmentContainerView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/fragment_container_view" android:layout_width="match_parent" android:layout_height="match_parent" android:name="com.example.MyFragment" android:tag="my_tag"&gt;&lt;/androidx.fragment.app.FragmentContainerView&gt; FragmentFactory 的使用过去，我们只能使用其默认的空构造函数实例化Fragment实例。 这是因为在某些情况下，例如配置更改和应用程序的流程重新创建，系统需要重新初始化。 如果不是默认的构造方法，系统将不知道如何重新初始化Fragment实例。 创建FragmentFactory来解决此限制。 通过向其提供实例化Fragment所需的必要参数/依赖关系，它可以帮助系统创建Fragment实例。 过去我们实例化fragment并传递参数会使用类似下面的代码 123456789101112131415161718class MyFragment : Fragment() &#123; private lateinit var arg: String override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) arguments?.getString(ARG) ?: "" &#125; companion object &#123; fun newInstance(arg: String) = MyFragment().apply &#123; arguments = Bundle().apply &#123; putString(ARG, arg) &#125; &#125; &#125;&#125;//useval fragment = MyFragment.newInstance("my argument") 如果您的Fragment有一个非空的构造函数，则需要创建一个FragmentFactory来处理它的初始化。 12345678class MyFragmentFactory(private val arg: String) : FragmentFactory() &#123; override fun instantiate(classLoader: ClassLoader, className: String): Fragment &#123; if (className == MyFragment::class.java.name) &#123; return MyFragment(arg) &#125; return super.instantiate(classLoader, className) &#125;&#125; fragment由FragmentManager 管理，因此很自然，FragmentFactory需要添加到FragmentManager才能使用。 那么什么时候把FragmentFactory 添加到FragmentManager呢？ 父类调用 Activity#onCreate() 和 Fragment#onCreate()之前 12345678910111213141516171819class HostActivity : AppCompatActivity() &#123; private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) &#123; supportFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) // ... &#125;&#125;class ParentFragment : Fragment() &#123; private val customFragmentFactory = CustomFragmentFactory(Dependency()) override fun onCreate(savedInstanceState: Bundle?) &#123; childFragmentManager.fragmentFactory = customFragmentFactory super.onCreate(savedInstanceState) // ... &#125;&#125; 如果您的Fragment具有默认的空构造函数，则无需使用FragmentFactory。 但是，如果您的Fragment在其构造函数中接受参数，则必须使用FragmentFactory，否则将抛出Fragment.InstantiationException，因为将使用的默认FragmentFactory将不知道如何实例化Fragment的实例。 Fragment 返回键拦截有时候，您需要阻止用户返回上一级。 在这种情况下，您需要在 Activity 中重写 onBackPressed() 方法。 但是，当您使用 Fragment 时，没有直接的方法来拦截返回。 在 Fragment 类中没有可用的 onBackPressed() 方法，这是为了防止同时存在多个 Fragment 时发生意外行为。 但是，从 AndroidX Activity 1.0.0 开始，您可以使用 OnBackPressedDispatcher 在您可以访问该 Activity 的代码的任何位置（例如，在 Fragment 中）注册 OnBackPressedCallback。 1234567891011class MyFragment : Fragment() &#123; override fun onAttach(context: Context) &#123; super.onAttach(context) val callback = object : OnBackPressedCallback(true) &#123; override fun handleOnBackPressed() &#123; // Do something &#125; &#125; requireActivity().onBackPressedDispatcher.addCallback(this, callback) &#125;&#125; Fragment 使用 ViewBindingAndroid Studio 3.6.0 后提供了 ViewBindind的支持，完整使用流程参见 [译]深入研究ViewBinding 在 include, merge, adapter, fragment, activity 中使用 123456789101112class HomeFragment : Fragment() &#123; private var _binding: FragmentHomeBinding? = null private val binding get() = _binding!! override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123; _binding = FragmentHomeBinding.inflate(inflater, container, false) return binding.root &#125; override fun onDestroyView() &#123; _binding = null &#125;&#125; Fragment 使用 ViewPager2ViewPager使用了三个adapter的抽象类，而ViewPager2中只有两个 ViewPager 中使用 PagerAdaper，ViewPager2 中使用 Recyclerview.Adapter ViewPager 中使用 FragmentPagerAdapter ，ViewPager2中使用 FragmentStateAdapter ViewPager 中使用 FragmentStatePagerAdapter ，ViewPager2中使用 FragmentStateAdapter 12345678910111213// A simple ViewPager adapter class for paging through fragmentsclass ScreenSlidePagerAdapter(fm: FragmentManager) : FragmentStatePagerAdapter(fm) &#123; override fun getCount(): Int = NUM_PAGES override fun getItem(position: Int): Fragment = ScreenSlidePageFragment()&#125;// An equivalent ViewPager2 adapter classclass ScreenSlidePagerAdapter(fa: FragmentActivity) : FragmentStateAdapter(fa) &#123; override fun getItemCount(): Int = NUM_PAGES override fun createFragment(position: Int): Fragment = ScreenSlidePageFragment()&#125; 使用 TabLayout的变化，TabLayout 已从ViewPager2中解耦，如果使用TabLayout，需要引入依赖 1implementation "com.google.android.material:material:1.1.0" 对于ViewPager2 ，TabLayout布局应与ViewPager2在同一级别 1234567891011121314151617181920212223242526272829303132&lt;!-- A ViewPager element with a TabLayout --&gt;&lt;androidx.viewpager.widget.ViewPager xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/pager" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;com.google.android.material.tabs.TabLayout android:id="@+id/tab_layout" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;&lt;/androidx.viewpager.widget.ViewPager&gt;&lt;!-- A ViewPager2 element with a TabLayout --&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;com.google.android.material.tabs.TabLayout android:id="@+id/tab_layout" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;androidx.viewpager2.widget.ViewPager2 android:id="@+id/pager" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" /&gt;&lt;/LinearLayout&gt; 使用ViewPager时，TabLayout与ViewPager联动需要调用 setupWithViewPager，并重写getPageTitle方法，而ViewPager2改为使用TabLayoutMediator对象 12345678910111213141516171819202122232425262728293031// Integrating TabLayout with ViewPagerclass CollectionDemoFragment : Fragment() &#123; ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; val tabLayout = view.findViewById(R.id.tab_layout) tabLayout.setupWithViewPager(viewPager) &#125; ...&#125;class DemoCollectionPagerAdapter(fm: FragmentManager) : FragmentStatePagerAdapter(fm) &#123; override fun getCount(): Int = 4 override fun getPageTitle(position: Int): CharSequence &#123; return "OBJECT $&#123;(position + 1)&#125;" &#125; ...&#125;// Integrating TabLayout with ViewPager2class CollectionDemoFragment : Fragment() &#123; ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; val tabLayout = view.findViewById(R.id.tab_layout) TabLayoutMediator(tabLayout, viewPager) &#123; tab, position -&gt; tab.text = "OBJECT $&#123;(position + 1)&#125;" &#125;.attach() &#125; ...&#125; 不需要重写 onCreateView 了？androidx fragment 1.1.0 后，您可以使用将 layoutId 作为参数的构造函数，这样就无需重写 onCreateView 方法了 123class MyActivity : AppCompatActivity(R.layout.my_activity)class MyFragmentActivity: FragmentActivity(R.layout.my_fragment_activity)class MyFragment : Fragment(R.layout.my_fragment) 使用require_()方法androidx fragment 1.2.2 起，新增了一项lint检查，fragment 建议使用关联的require_()方法获取更多描述性错误消息，而不是使用checkNotNull(get_())，requireNonNull(get_()) 或get()！ 适用于所有包含 get 和 require Fragment API 例如：使用 requireActivity() 替代 getActivity()]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack】Jetpack 主要依赖关系]]></title>
    <url>%2F2020%2F03%2F01%2FJetpack-dependencies%2F</url>
    <content type="text"><![CDATA[在学习和使用 jetpack 组件时，总是被其 gradle 依赖搞的晕头转向，故在此整理 jetpack 主要组件的依赖，及传递关系 jetpcak 组件源码地址 查询 jetpcak 组件 版本: Google’s Maven Repository 查看依赖树：在项目根目录下执行./gradlew :app:dependencies 可直接跳过后续内容前往最后一节查看总结 关于 androidx下 fragment/activity的变化，可查看该文, 【译】AdroidX下使用Activity和Fragment的变化 Appcompat引入1234567dependencies &#123; def appcompat_version = "1.1.0" implementation "androidx.appcompat:appcompat:$appcompat_version" // For loading and tinting drawables on older versions of the platform implementation "androidx.appcompat:appcompat-resources:$appcompat_version"&#125; 依赖树 传递依赖androidx.annotation:annotation:1.1.0 androidx.core:core:1.1.0 androidx.cursoradapter:cursoradapter:1.0.0 androidx.fragment:fragment:1.1.0 androidx.appcompat:appcompat-resources:1.1.0 androidx.drawerlayout:drawerlayout:1.0.0 androidx.collection:collection:1.0.0 appcompat 中默认引入了 fragment 库，如果想使用更新版本的 fragment 库，可以单独引用 appcompat build.gradle 源码地址 Fragment引入12345678910dependencies &#123; def fragment_version = "1.2.2" // Java language implementation implementation "androidx.fragment:fragment:$fragment_version" // Kotlin implementation "androidx.fragment:fragment-ktx:$fragment_version" // Testing Fragments in Isolation implementation "androidx.fragment:fragment-testing:$fragment_version"&#125; ⚠️ Note: The Kotlin dependant libraries of this version (fragment-ktx,fragment-testing) target Java 8 programming language bytecode. Please read Use Java 8 language features to learn how to use it in your project. 依赖树 传递依赖org.jetbrains.kotlin:kotlin-stdlib:1.3.50 androidx.activity:activity-ktx:1.1.0 androidx.core:core-ktx:1.1.0 androidx.collection:collection-ktx:1.1.0 androidx.lifecycle:lifecycle-livedata-core-ktx:2.2.0 androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0 fragment 库默认引入了 activity core-ktx lifecycle-livedata-core-ktx lifecycle-viewmodel-ktx 库 fragment build.grdle 源码地址 Activity引入12345678dependencies &#123; def activity_version = "1.1.0" // Java language implementation implementation "androidx.activity:activity:$activity_version" // Kotlin implementation "androidx.activity:activity-ktx:$activity_version"&#125; ⚠️ Note: The Kotlin dependant libraries of this version (activity-ktx) target Java 8 programming language bytecode. Please read Use Java 8 language features to learn how to use it in your project. 依赖树 依赖传递org.jetbrains.kotlin:kotlin-stdlib:1.3.50 androidx.core:core-ktx:1.1.0 androidx.lifecycle:lifecycle-runtime-ktx:2.2.0 androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0 activity build.gradle 源码地址 Core引入1234567891011dependencies &#123; def core_version = "1.2.0" // Java language implementation implementation "androidx.core:core:$core_version" // Kotlin implementation "androidx.core:core-ktx:$core_version" // To use RoleManagerCompat implementation "androidx.core:core-role:1.0.0-alpha01"&#125; 依赖树 Lifecycle引入12345678910111213141516171819202122232425262728293031dependencies &#123; def lifecycle_version = "2.2.0" def arch_version = "2.1.0" // ViewModel implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version" // LiveData implementation "androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version" // Lifecycles only (without ViewModel or LiveData) implementation "androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version" // Saved state module for ViewModel implementation "androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version" // Annotation processor kapt "androidx.lifecycle:lifecycle-compiler:$lifecycle_version" // alternately - if using Java8, use the following instead of lifecycle-compiler implementation "androidx.lifecycle:lifecycle-common-java8:$lifecycle_version" // optional - helpers for implementing LifecycleOwner in a Service implementation "androidx.lifecycle:lifecycle-service:$lifecycle_version" // optional - ProcessLifecycleOwner provides a lifecycle for the whole application process implementation "androidx.lifecycle:lifecycle-process:$lifecycle_version" // optional - ReactiveStreams support for LiveData implementation "androidx.lifecycle:lifecycle-reactivestreams-ktx:$lifecycle_version" // optional - Test helpers for LiveData testImplementation "androidx.arch.core:core-testing:$arch_version"&#125; ⚠️ lifecycle-extensions 已废弃，如果使用 LifecycleService 请依赖 lifecycle-service；如果使用 ProcessLifecycleOwner 请依赖 lifecycle-process。lifecycle-extensionsl不会有2.3.0版本 2.1.0 后 ViewModelProviders.of() 被废弃。您可以在 FragmentActivity 或者 Fragment 使用 ViewModelProvider(ViewModelStoreOwner) 构造器来实现相同的功能。（Fragment 库 1.2.0以上） 依赖树 Navigation引入1234567891011121314151617dependencies &#123; def nav_version = "2.3.0-alpha02" // Java language implementation implementation "androidx.navigation:navigation-fragment:$nav_version" implementation "androidx.navigation:navigation-ui:$nav_version" // Kotlin implementation "androidx.navigation:navigation-fragment-ktx:$nav_version" implementation "androidx.navigation:navigation-ui-ktx:$nav_version" // Dynamic Feature Module Support implementation "androidx.navigation:navigation-dynamic-features-fragment:$nav_version" // Testing Navigation androidTestImplementation "androidx.navigation:navigation-testing:$nav_version"&#125; 依赖树 Paging引入1234567891011dependencies &#123; def paging_version = "2.1.1" implementation "androidx.paging:paging-runtime:$paging_version" // For Kotlin use paging-runtime-ktx // alternatively - without Android dependencies for testing testImplementation "androidx.paging:paging-common:$paging_version" // For Kotlin use paging-common-ktx // optional - RxJava support implementation "androidx.paging:paging-rxjava2:$paging_version" // For Kotlin use paging-rxjava2-ktx&#125; 依赖树 Room引入123456789101112131415161718dependencies &#123; def room_version = "2.2.4" implementation "androidx.room:room-runtime:$room_version" annotationProcessor "androidx.room:room-compiler:$room_version" // For Kotlin use kapt instead of annotationProcessor // optional - Kotlin Extensions and Coroutines support for Room implementation "androidx.room:room-ktx:$room_version" // optional - RxJava support for Room implementation "androidx.room:room-rxjava2:$room_version" // optional - Guava support for Room, including Optional and ListenableFuture implementation "androidx.room:room-guava:$room_version" // Test helpers testImplementation "androidx.room:room-testing:$room_version"&#125; ⚠️ Note: For Kotlin-based apps, make sure you use kapt instead of annotationProcessor. You should also add the kotlin-kapt plugin. 依赖树 总结版本说明 androidx库遵循严格的语义版本控制。版本字符串（例如 1.0.1-beta02）包含三个数字，分别代表 major 级别、minor 级别和问题修复级别。预发布版本也有一个后缀，用于指定预发布阶段（Alpha 版、Beta 版、候选版本）和版本号（01、02 等）。 库的每个版本都要经历三个预发布阶段，才能成为稳定版本。各预发布阶段的标准如下： Alpha 版 Alpha 版功能稳定，但功能可能不完整。 在版本处于 Alpha 版状态时，可以添加、移除或更改 API。 Beta 版 Beta 版功能稳定，并且具有功能完整的 API Surface。它们可以投入实际使用，但可能包含错误。 Beta 版无法使用实验性编译器功能（例如 @UseExperimental）。 其他库的依赖项必须为 Beta 版、RC 版或稳定版。不允许使用 Alpha 版依赖项。 候选版本 (RC) 候选版本是未来的稳定版。 此版本可能包含在最后一刻提供的重要修复。 此版本的 API Surface 无法更改。 其他库的依赖项只能是 RC 版或稳定版。 一个库可以同时具有多个版本。每个版本都具有不同的发布阶段。例如，虽然 androidx.activity 的稳定版可以是 1.0.0，但也可能还有 1.1.0-beta02 版本以及 2.0.0-alpha01 版本。 kotlin 协程的使用 ViewModel LiveData Activity Fragment Service等均可使用协程 对于 ViewModelScope，请使用 androidx.lifecycle:lifecycle-viewmodel-ktx:2.1.0-beta01 或更高版本。 对于 LifecycleScope，请使用 androidx.lifecycle:lifecycle-runtime-ktx:2.2.0-alpha01 或更高版本。 对于 liveData，请使用 androidx.lifecycle:lifecycle-livedata-ktx:2.2.0-alpha01 或更高版本。 1234567class MyViewModel: ViewModel() &#123; init &#123; viewModelScope.launch &#123; // Coroutine that will be canceled when the ViewModel is cleared. &#125; &#125;&#125; 123456789101112class MyFragment : Fragment() &#123; override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launch &#123; val params = TextViewCompat.getTextMetricsParams(textView) val precomputedText = withContext(Dispatchers.Default) &#123; PrecomputedTextCompat.create(longTextContent, params) &#125; TextViewCompat.setPrecomputedText(textView, precomputedText) &#125; &#125;&#125; 1234val user: LiveData&lt;User&gt; = liveData &#123; val data = database.loadUser() // loadUser is a suspend function. emit(data)&#125; 依赖关系 带有-ktx的库拥有 kotlin 的特性，有很多常用的扩展函数 带有-ktx的库依赖 java 版本， 带有-ktx和 java 版本各自单独使用即可 appcompat 库包含 fragmnet,fragment 包含 activity ，当你引入androidx appcompat 库便可以使用androidx fragment 和 androidx activity 受限于appcompat 稳定版的更新速度，您可以选择单独使用androidx fragment/activity AppCompatActivity 继承自 FragmentActivity， AppCompatActivity可以直接使用 fragment DataBinding ViewBinding 依赖于 android build gradle 插件 ,无需引入其他依赖 androidx fragment/activity下均依赖的ViewModel和 LiveData，您可以直接使用 使用ViewModel和 LiveData完整功能需要单独引入，它们都是lifecycle大家族下的 lifecycle-extensions 已废弃，不要使用它了 如果想使用实现LifecycleOwner 的 Service ，需要引入 lifecycle-service 关于我我是 Flywith24，我的博客内容已经分类整理 在这里，点击右上角的 Watch 可以及时获取我的文章更新哦 😉 掘金 小专栏 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【背上Jetpack】AdroidX下使用Activity和Fragment的变化]]></title>
    <url>%2F2020%2F02%2F29%2FJetpack-androidx-activity-fragment%2F</url>
    <content type="text"><![CDATA[原文：How AndroidX changes the way we work with Activities and Fragments 作者：Miłosz Lewandowski 译者：Fly_with24 过去的一段时间，AndroidX 软件包下的 Activity/Fragmet 的 API 发生了很多变化。让我们看看它们是如何提升Android 的开发效率以及如何适应当下流行的编程规则和模式。 本文中描述的所有功能现在都可以在稳定的 AndroidX 软件包中使用，它们在去年均已发布或移至稳定版本。 在构造器中传入布局 ID从 AndroidX AppCompat 1.1.0 和 Fragment 1.1.0 ( 译者注：AppCompat 包含 Fragment，且 Fragment 包含 Activity，详情见【整理】Jetpack 主要组件的依赖及传递关系 )开始，您可以使用将 layoutId 作为参数的构造函数： 123class MyActivity : AppCompatActivity(R.layout.my_activity)class MyFragmentActivity: FragmentActivity(R.layout.my_fragment_activity)class MyFragment : Fragment(R.layout.my_fragment) 这种方法可以减少 Activity/Fragment 中方法重写的数量，并使类更具可读性。 无需在 Activity 中重写 onCreate() 即可调用 setContentView() 方法。 另外，无需手动在Fragment 中重写 onCreateView 即可手动调用 Inflater 来扩展视图。 扩展 Activity/Fragment 的灵活性借助 AndroidX 新的 API ，可以减少在 Activity/Fragment 处理某些功能的情况。通常，您可以获取提供某些功能的对象并向其注册您的处理逻辑，而不是重写 Activity / Fragment 中的方法。 这样，您现在可以在屏幕上组成几个独立的类，获得更高的灵活性，复用代码，并且通常在不引入自己的抽象的情况下，对代码结构具有更多控制。 让我们看看这在两个示例中如何工作。 1. OnBackPressedDispatcher有时，您需要阻止用户返回上一级。 在这种情况下，您需要在 Activity 中重写 onBackPressed() 方法。 但是，当您使用 Fragment 时，没有直接的方法来拦截返回。 在 Fragment 类中没有可用的 onBackPressed() 方法，这是为了防止同时存在多个 Fragment 时发生意外行为。 但是，从 AndroidX Activity 1.0.0 开始，您可以使用 OnBackPressedDispatcher 在您可以访问该 Activity 的代码的任何位置（例如，在 Fragment 中）注册 OnBackPressedCallback。 1234567891011class MyFragment : Fragment() &#123; override fun onAttach(context: Context) &#123; super.onAttach(context) val callback = object : OnBackPressedCallback(true) &#123; override fun handleOnBackPressed() &#123; // Do something &#125; &#125; requireActivity().onBackPressedDispatcher.addCallback(this, callback) &#125;&#125; 您可能会在这里注意到另外两个有用的功能： OnBackPressedCallback 的构造函数中的布尔类型的参数有助于根据当前状态动态 打开/关闭按下的行为 addCallback() 方法的可选第一个参数是 LifecycleOwner，以确保仅在您的生命周期感知对象（例如，Fragment）至少处于 STARTED 状态时才使用回调。 通过使用 OnBackPressedDispatcher ，您不仅可以获得在 Activity 之外处理返回键的便捷方式。 根据您的需要，您可以在任意位置定义 OnBackPressedCallback，使其可复用，或根据应用程序的架构进行任何操作。 您不再需要重写Activity 中的 onBackPressed 方法，也不必提供自己的抽象的来实现需求的代码。 2. SavedStateRegistry如果您希望 Activity 在终止并重启后恢复之前的状态，则可能要使用 saved state 功能。 过去，您需要在 Activity 中重写两个方法：onSaveInstanceState 和 onRestoreInstanceState。 您还可以在 onCreate 方法中访问恢复的状态。 同样，在 Fragment 中，您可以使用onSaveInstanceState 方法（并且可以在 onCreate，onCreateView 和onActivityCreated方法中恢复状态）。 从 AndroidX SavedState 1.0.0（它是 AndroidX Activity 和 AndroidX Fragment 内部的依赖。译者注：您不需要单独声明它）开始，您可以访问 SavedStateRegistry，它使用了与前面描述的 OnBackPressedDispatcher 类似的机制：您可以从 Activity / Fragment 中获取 SavedStateRegistry，然后 注册您的 SavedStateProvider： 12345678910111213141516171819202122232425262728class MyActivity : AppCompatActivity() &#123; companion object &#123; private const val MY_SAVED_STATE_KEY = "my_saved_state" private const val SOME_VALUE_KEY = "some_value" &#125; private lateinit var someValue: String private val savedStateProvider = SavedStateRegistry.SavedStateProvider &#123; Bundle().apply &#123; putString(SOME_VALUE_KEY, someValue) &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) savedStateRegistry .registerSavedStateProvider(MY_SAVED_STATE_KEY, savedStateProvider) &#125; fun someMethod() &#123; someValue = savedStateRegistry .consumeRestoredStateForKey(MY_SAVED_STATE_KEY) ?.getString(SOME_VALUE_KEY) ?: "" &#125;&#125; 如您所见，SavedStateRegistry 强制您将密钥用于数据。 这样可以防止您的数据被 attach 到同一个 Activity/Fragment的另一个 SavedStateProvider 破坏。 就像在 OnBackPressedDispatcher 中一样，您可以例如将 SavedStateProvider 提取到另一个类，通过使用所需的任何逻辑使其与数据一起使用，从而在应用程序中实现清晰的保存状态行为。 此外，如果您在应用程序中使用 ViewModel，请考虑使用 AndroidX ViewModel-SavedState 使你的ViewModel 可以保存其状态。 为了方便起见，从 AndroidX Activity 1.1.0 和 AndroidX Fragment 1.2.0 开始，启用 SavedState 的SavedStateViewModelFactory 是在获取 ViewModel 的所有方式中使用的默认工厂：委托 ViewModelProvider 构造函数和 ViewModelProviders.of() 方法。 FragmentFactoryFragment 最常提及的问题之一是不能使用带有参数的构造函数。 例如，如果您使用 Dagger2 进行依赖项注入，则无法使用 Inject 注解 Fragment 构造函数并指定参数。 现在，您可以通过指定 FragmentFactory 类来减少 Fragment 创建过程中的类似问题。 通过在 FragmentManager 中注册 FragmentFactory，可以重写实例化 Fragment 的默认方法： 1234567891011121314class MyFragmentFactory : FragmentFactory() &#123; override fun instantiate(classLoader: ClassLoader, className: String): Fragment &#123; // Call loadFragmentClass() to obtain the Class object val fragmentClass = loadFragmentClass(classLoader, className) // Now you can use className/fragmentClass to determine your prefered way // of instantiating the Fragment object and just do it here. // Or just call regular FragmentFactory to instantiate the Fragment using // no arguments constructor return super.instantiate(classLoader, className) &#125;&#125; 如您所见，该API非常通用，因此您可以执行想要创建 Fragment 实例的所有操作。 回到 Dagger2 示例，例如，您可以注入FragmentFactory Provider &lt;Fragment&gt; 并使用它来获取 Fragment 对象。 测试 Fragment从AndroidX Fragment 1.1.0 开始，可以使用 Fragment 测试组件提供 FragmentScenario 类，该类可以帮助在测试中实例化 Fragment 并进行单独测试： 12345678910111213141516// To launch a Fragment with a user interface:val scenario = launchFragmentInContainer&lt;FirstFragment&gt;() // To launch a headless Fragment:val scenario = launchFragment&lt;FirstFragment&gt;() // To move the fragment to specific lifecycle state:scenario.moveToState(CREATED)// Now you can e.g. perform actions using Espresso:onView(withId(R.id.refresh)).perform(click())// To obtain a Fragment instance:scenario.onFragment &#123; fragment -&gt; ...&#125; More Kotlin!很高兴看到 -ktx AndroidX 软件包中提供了许多有用的 Kotlin 扩展方法，并且定期添加了新的方法。 例如，在AndroidX Fragment-KTX 1.2.0 中，使用片段化类型的扩展名可用于 FragmentTransaction 上的 replace() 方法。 将其与 commit() 扩展方法结合使用，我们可以获得以下代码： 12345678910// BeforesupportFragmentManager .beginTransaction() .add(R.id.container, MyFragment::class.java, null) .commit()// AftersupportFragmentManager.commit &#123; replace&lt;MyFragment&gt;(R.id.container)&#125; FragmentContainerView一件小而重要的事情。 如果您将 FrameLayout 用作 Fragment 的容器，则应改用 FragmentContainerView 。 它修复了一些动画 z轴索引顺序问题和窗口插入调度。 从 AndroidX Fragment 1.2.0 开始可以使用 FragmentContainerView。 关于我 我是 Fly_with24 掘金 简书 Github]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>androidx</tag>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【重学Android读书笔记】Activity的任务栈与返回栈]]></title>
    <url>%2F2019%2F11%2F29%2Frelearn-task-back-stack%2F</url>
    <content type="text"><![CDATA[订阅 重学安卓 很久了，最近在整理读书笔记，在此记录之。 在此隆重推荐这位大佬 KunMinX 本文记录Activity任务栈与返回栈相关内容的疑问与探索 该专栏的代码地址： https://github.com/KunMinX/Relearn-Android 疑惑产生根据大佬的代码以及文章描述，有个地方让我很疑惑。 我这里没有过滤当前使用的app，所以app1和app2产生的日志都显示了出来。 大佬在评论区关于此的回答 KunMinX #40 #2楼 @Sky63大概明白你提到的、造成困扰的地方了。D 和 C 是由 app1 启动，在 IDE 中可通过 app1 的视角观察到。同理，当 app2 的 B 唤起 D 时，你在回退 D 的时候能在 app2 和 app1 的视角中同时观察到 D 的销毁。而紧随其后再回退一次， 便能在 app1 中观察到 C 被销毁。再下一次才轮到 app2 中 B 被销毁。 但是根据我操作看到的现象，D的销毁不是在不同app视角观察到的同一次销毁。通过上图可以看出两次销毁是有时间差的，而且经过我的二次确认，的确是关闭两次界面才出现了两次销毁Log。 问题排查通过 adb shell 中的 dumpsys activity activities 命令可以查看 activity 栈信息，故我截取了相关的输出，以下堆栈信息均经过精简。 1. app1 依次打开 SingleTaskOne SingleTaskTwo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364➜ Relearn-Android (master) adb shellsagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #2: type=standard mode=fullscreen Task id #3 Running activities (most recent first): TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; mResumedActivity: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; mLastPausedActivity: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; Stack #1: type=standard mode=fullscreen Task id #2 Running activities (most recent first): TaskRecord&#123;d91b3e8 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125; Run #1: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Run #0: ActivityRecord&#123;d76e9a5 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125; mLastPausedActivity: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;94a7a01 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; ResumedActivity:ActivityRecord&#123; 93c0c72u0com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks &#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks &#125; mCurTaskIdForUser=&#123;0=3&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=3 mHomeStack=ActivityStack&#123; 76ebae7 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks &#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 此时看到堆栈顺序为：Stack #2 -&lt; Stack #1 -&lt; Stack #0 其中 Stack #0 为 launcher 获取焦点的 ActivityStack： 1234mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; 2. 按下HOME键，打开 app2 依次打开 StandardOneActivity StandardTwoActivity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Display #0 (activities from top to bottom): Stack #3: type=standard mode=fullscreen Task id #4 Running activities (most recent first): TaskRecord&#123;718157f #4 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; Run #2: ActivityRecord&#123;648188e u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #1: ActivityRecord&#123;f39ebe9 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #0: ActivityRecord&#123;f02fff8 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t4&#125; mResumedActivity: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; mLastPausedActivity: ActivityRecord&#123;648188e u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;2094d95 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;a7fed1a u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;a7fed1a u0 com.miui.home/.launcher.Launcher t1&#125; Stack #2: type=standard mode=fullscreen Task id #3 Running activities (most recent first): TaskRecord&#123;9d79eaa #3 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;15d3e09 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;20d177c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; mLastPausedActivity: ActivityRecord&#123;15d3e09 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Stack #1: type=standard mode=fullscreen isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #2 Running activities (most recent first): TaskRecord&#123;e526e38 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125; Run #1: ActivityRecord&#123;19055b2 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Run #0: ActivityRecord&#123;5a647a6 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125; mLastPausedActivity: ActivityRecord&#123;19055b2 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; ResumedActivity: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; mFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=4&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123;968fb76 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 这里的堆栈顺序为 Stack #3 -&lt; Stack #0 -&lt; Stack #2 -&lt; Stack #1 Stack #0 为home ，这里反应出点击home键，打开app2 的操作。此时 Stack #3 中有 4 个 ActivityRecord 当前获取焦点的 ActivityStack 12345 mFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=4&#125; 3. 接下来启动 SingleTaskTwoActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172sagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #2: type=standard mode=fullscreen Task id #3 Running activities (most recent first): TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=3&#125; Run #2: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; mResumedActivity: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Stack #3: type=standard mode=fullscreen Task id #4 Running activities (most recent first): TaskRecord&#123;f14a51a #4 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;1838862 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; Run #2: ActivityRecord&#123;bdb3180 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #1: ActivityRecord&#123;7b21450 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125; Run #0: ActivityRecord&#123;ff57abb u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t4&#125; mLastPausedActivity: ActivityRecord&#123;1838862 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;94a7a01 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125; Stack #1: type=standard mode=fullscreen Task id #2 Running activities (most recent first): TaskRecord&#123;d91b3e8 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125; Run #1: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; Run #0: ActivityRecord&#123;d76e9a5 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125; mLastPausedActivity: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125; ResumedActivity: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=4&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123; 76ebae7 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 当前的堆栈顺序 Stack #2 -&lt; Stack #3 -&lt; Stack #0 -&lt;Stack #1 当前获取焦点的 ActivityStack 12345mFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123; 3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;mCurTaskIdForUser=&#123;0=4&#125; Stack #2 中 TaskRecord信息为 1234TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=3&#125; Run #2: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125; Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125; 解惑关键的地方来了 的确有两个 SingleTaskTwoActivity 的 ActivityRecord ，栈顶的属于 app2 第二个属于 app1 由此看出这两个ActivityRecord 不是一个实例，所以这里 app2 启动的 SingleTaskTwoActivity 应该是 app2 自己的activity 废话不说，翻代码！这里截取了 BaseTaskActivity 中的部分代码，app1 和 app2中的 activity 都继承了BaseTaskActivity 12345678910111213141516171819202122232425262728293031323334353637383940@Override public void onClick(View v) &#123; int i = v.getId(); if (i == R.id.btn_standard_one) &#123; Intent intent = new Intent(this, StandardOneActivity.class); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_standard_two) &#123; Intent intent = new Intent(this, StandardTwoActivity.class); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_singletask_one) &#123; Intent intent = new Intent(this, SingleTaskOneActivity.class); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_singletask_two) &#123; Intent intent = new Intent(this, SingleTaskTwoActivity.class); startActivityWithCheck(intent); //以下测试结果证实： //1.在 App2 中启动 App1 的 standard Activity，仍然遵守 standard 的特点：在启动它的 Activity 所在的任务中启动，也即跟随 App2。 //2.在 App2 中启动 App1 的 singleTop Activity，跟随状况同 standard。 //3.在 App2 中启动 App1 的 singleTask Activity，仍然处于 App1 的任务中，并不跟随 App2。 &#125; else if (i == R.id.btn_singletask_a) &#123; Intent intent = new Intent(); ComponentName name = new ComponentName( "com.kunminx.relearn_android", "com.kunminx.relearn_android.SingleTaskAActivity"); intent.setComponent(name); startActivityWithCheck(intent); &#125; else if (i == R.id.btn_singletask_b) &#123; Intent intent = new Intent(); ComponentName name = new ComponentName( "com.kunminx.relearn_android", "com.kunminx.relearn_android.SingleTaskBActivity"); intent.setComponent(name); startActivityWithCheck(intent); &#125; 可以看出这里 app2 启动SingleTaskTwoActivity 的确是自己的 activity 那么它为什么和app1 中的 SingleTaskTwoActivity 是同一个 TaskRecord 呢？ 12345678&lt;activity android:name=".test03_task_test.SingleTaskOneActivity" android:launchMode="singleTask" android:taskAffinity="com.kunminx.task.c" /&gt;&lt;activity android:name=".test03_task_test.SingleTaskTwoActivity" android:launchMode="singleTask" android:taskAffinity="com.kunminx.task.c" /&gt; 它们有着共同的 taskAffinity。至此，我的疑惑已经得到了答案。 拓展我试了以下 app2 中启动 app1 中的Activity的情况 app1 依次启动 StandardOneActivity -&lt; SingleTaskOneActivity -&lt; SingleTaskTwoActivity -&lt; SingleTaskAActivity 其中 SingleTaskOneActivity 与 SingleTaskTwoActivity 设置了相同的 taskAffinity ,StandardOneActivity 与 SingleTaskAActivity 未设置 taskAffinity 接着按 HOME 键，打开 app2 ，依次打开 StandardOneActivity -&lt; StandardOneActivity -&lt; StandardTwoActivity 此时堆栈信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768➜ Relearn-Android (master) adb shellsagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #3: type=standard mode=fullscreen isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #48 Running activities (most recent first): TaskRecord&#123;3b07175 #48 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; Run #2: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #1: ActivityRecord&#123;71254 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #0: ActivityRecord&#123;7c135cf u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t48&#125; mResumedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; mLastPausedActivity: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Stack #0: type=home mode=fullscreen Running activities (most recent first): TaskRecord&#123;185017b #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; Stack #1: type=standard mode=fullscreen Task id #46 Running activities (most recent first): TaskRecord&#123;c374b98 #46 A=com.kunminx.relearn_android U=0 StackId=1 sz=3&#125; Run #2: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Run #1: ActivityRecord&#123;bb0363c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t46&#125; Run #0: ActivityRecord&#123;510711c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t46&#125; mLastPausedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Stack #2: type=standard mode=fullscreen Task id #47 Running activities (most recent first): TaskRecord&#123;3387d6 #47 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; Run #0: ActivityRecord&#123;e9850ca u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t47&#125; mLastPausedActivity: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; ResumedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; mFocusedStack=ActivityStack&#123;ed83a57 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123;ed83a57 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=48&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123;a218944 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 最后在 app2 中启动 app1 的 SingleTaskAActivity 此时堆栈信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465➜ Relearn-Android (master) adb shellsagit:/ $ dumpsys activity activitiesACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #1: type=standard mode=fullscreen Task id #46 Running activities (most recent first): TaskRecord&#123;c374b98 #46 A=com.kunminx.relearn_android U=0 StackId=1 sz=3&#125; Run #2: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Run #1: ActivityRecord&#123;bb0363c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t46&#125; Run #0: ActivityRecord&#123;510711c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t46&#125; mResumedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; Stack #3: type=standard mode=fullscreen Task id #48 Running activities (most recent first): TaskRecord&#123;3b07175 #48 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125; Run #3: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; Run #2: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #1: ActivityRecord&#123;71254 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125; Run #0: ActivityRecord&#123;7c135cf u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t48&#125; mLastPausedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125; Stack #0: type=home mode=fullscreen Task id #1 Running activities (most recent first): TaskRecord&#123;185017b #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125; Run #0: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; mLastPausedActivity: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125; Stack #2: type=standard mode=fullscreen Task id #47 Running activities (most recent first): TaskRecord&#123;3387d6 #47 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125; Run #1: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; Run #0: ActivityRecord&#123;e9850ca u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t47&#125; mLastPausedActivity: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125; ResumedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125; mFocusedStack=ActivityStack&#123;50922c2 stackId=1 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mLastFocusedStack=ActivityStack&#123;50922c2 stackId=1 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; mCurTaskIdForUser=&#123;0=48&#125; mUserStackInFront=&#123;&#125; displayId=0 stacks=4 mHomeStack=ActivityStack&#123;a218944 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125; isHomeRecentsComponent=false KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false mOccluded=false mDismissingKeyguardActivity=null mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 此时 app1 的 taskid 46 的TaskRecord 转移到了 栈顶 接下来返回销毁的逻辑就很清晰了。 最后退到 launcher 界面 app1 的 TaskRecord 转移到了 app2 的返回栈中]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>app</tag>
        <tag>重学Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【流水账】Xposed模块开发]]></title>
    <url>%2F2019%2F08%2F30%2FXposed%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 本篇博客是记录一些学习 Xposed模块开发时知识的整理。 开发前的准备工作查看 Xposed-Framework-API 根据文档进行配置 1234567repositories &#123; jcenter();&#125;dependencies &#123; compileOnly 'de.robv.android.xposed:api:82'&#125; AndroidManifest.xml 中 application 标签下加入 123456789101112&lt;!-- 应用为模块 --&gt;&lt;meta-data android:name="xposedmodule" android:value="true" /&gt;&lt;!-- 版本信息 该版本号与引用的依赖版本相同--&gt;&lt;meta-data android:name="xposedminversion" android:value="82" /&gt;&lt;!-- 模块描述 --&gt;&lt;meta-data android:name="xposeddescription" android:value="Xposed Test" /&gt; 创建 Hook 类，该类是 Xposed 的入口类，用于拦截加载的 package ，实现 IXposedHookLoadPackage 接口 1234567package com.yyz.xposedtest;public class Main implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; // TODO: hook逻辑 &#125; &#125; 在 src/main 目录下创建assets目录，在该目录中创建 xposed_ini t文件，写入上面创建的 Xposed 的入口类，如下： XposedHelpers 常用方法findAndHookMethod Look up a method and hook it. The last argument must be the callback for the hook. 最后一个参数主要有两种 XC_MethodHook 在原有方法逻辑上添加逻辑，代码如下 12345678910111213141516//在原有方法逻辑上添加逻辑/** * 1. 包名 2. classLoader 3. 方法名 4. 参数类型（没有则不添加） 5.Callback */XposedHelpers.findAndHookMethod("cn.bcbook.kaixuetest.MainActivity", lpparam.classLoader, "printViewId", View.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Log.i("yyz", "afterHookedMethod hook success!"); &#125; &#125;); XC_MethodReplacement 替换原有方法逻辑，代码如下 123456789//替换原有方法XposedHelpers.findAndHookMethod("cn.bcbook.kaixuetest.MainActivity", lpparam.classLoader, "printViewId", View.class, new XC_MethodReplacement() &#123; @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable &#123; Log.i("yyz", "hook success!"); return null; &#125; &#125;);]]></content>
      <categories>
        <category>Xposed</category>
      </categories>
      <tags>
        <tag>流水账</tag>
        <tag>Hook</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【流水账】iptables 常用指令]]></title>
    <url>%2F2019%2F08%2F29%2Fiptabels%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 该文总结了 iptables 常用的指令。iptables 详细内容请看双印大佬 iptables 详解系列 规则查询查看指定表中的规则1iptables -t filter -L 使用 -t 选项，指定要操作的表，使用 -L 选项，查看-t选项对应的表的规则， -L 选项的意思是，列出规则。所以，上述命令的含义为列出filter表的所有规则。 filter 可替换为 raw mangle nat 如果仅查看 filter 可以省略 -t filter ，当没有使用 -t 选项指定表时，默认为操作 filter 表，即 iptables -L 表示列出 filter 表中的所有规则。 查看指定表中的指定链的规则1iptables -L INPUT 只查看 filter 表中 INPUT 链的规则 1iptables -vL INPUT 使用 -v 查看更多，更详细的信息 不让ip进行反解1iptables -nvL iptables 默认进行了名称解析，但是在规则非常多的情况下如果进行名称解析，效率会比较低。使用 -n 选项，表示不对 ip 地址进行名称反解，直接显示 ip 地址 只查看某个链的规则，并且不让 ip 进行反解，iptables -nvL INPUT 显示规则编号123iptables --line-number -nvL INPUT或iptables --line -nvL INPUT 规则管理添加规则注意：添加规则时，规则的顺序非常重要 123456789101112131415# 在指定表的指定链的尾部添加一条规则，-A选项表示在对应链的末尾添加规则命令语法：iptables -t 表名 -A 链名 匹配条件 -j 动作示例：iptables -t filter -A OUTPUT -s 192.168.10.225 -j DROP# 在指定表的指定链的首部添加一条规则，-I选型表示在对应链的开头添加规则命令语法：iptables -t 表名 -I 链名 匹配条件 -j 动作示例： iptables -t filter -I OUTPUT -s 192.168.10.225 -j ACCEPT# 在指定表的指定链的指定位置添加一条规则命令语法：iptables -t 表名 -I 链名 规则序号 匹配条件 -j 动作示例： iptables -t filter -I OUTPUT 3 -s 192.168.10.225 -j REJECT# 设置指定表的指定链的默认策略（默认动作），并非添加规则命令语法：iptables -t 表名 -P 链名 动作示例：iptables -t filter -P FORWARD ACCEPT 删除规则注意：如果没有保存规则，删除规则时请慎重 123456789101112131415# 按照规则序号删除规则，删除指定表的指定链的指定规则，-D选项表示删除对应链中的规则命令语法：iptables -t 表名 -D 链名 规则序号示例：iptables -t filter -D INPUT 3# 按照具体的匹配条件与动作删除规则，删除指定表的指定链的指定规则命令语法：iptables -t 表名 -D 链名 匹配条件 -j 动作示例：iptables -t filter -D INPUT -s 192.168.10.225 -j DROP# 删除指定表的指定链中的所有规则，-F选项表示清空对应链中的规则命令语法：iptables -t 表名 -F 链名示例：iptables -t filter -F INPUT# 删除指定表中的所有规则命令语法：iptables -t 表名 -F示例：iptables -t filter -F OUTPUT 修改规则注意：如果使用-R选项修改规则中的动作，那么必须指明原规则中的原匹配条件，例如源ip，目标ip等 123# 修改指定表中指定链的指定规则，-R选项表示修改对应链中的规则，使用-R选项时要同时指定对应的链以及规则对应的序号，并且规则中原本的匹配条件不可省略命令语法：iptables -t 表名 -R 链名 规则序号 规则原本的匹配条件 -j 动作示例：iptables -t filter -R INPUT 3 -s 192.168.10.225 -j ACCEPT 上述示例表示修改 filter 表中 INPUT 链的第3条规则，将这条规则的动作修改为 ACCEPT ， -s 192.168.10.225 为这条规则中原本的匹配条件，如果省略此匹配条件，修改后的规则中的源地址可能会变为 0.0.0.0/0 其他修改规则的方法：先通过编号删除规则，再在原编号位置添加一条规则 123# 修改指定表的指定链的默认策略（默认动作），并非修改规则命令语法：iptables -t 表名 -P 链名 动作示例：iptables -t filter -P FORWARD ACCEPT 保存规则12# 保存规则命令，表示将iptables规则保存至/etc/sysconfig/iptables文件中service iptables save 匹配条件基本匹配条件-s 用于匹配报文的源地址,可以同时指定多个源地址，每个 ip 之间用逗号隔开，也可以指定为一个网段 123iptables -t filter -I INPUT -s 192.168.10.111,192.168.10.225 -j DROPiptables -t filter -I INPUT -s 192.168.10.0/24 -j ACCEPTiptables -t filter -I INPUT ! -s 192.168.10.0/24 -j ACCEPT -d 用于匹配报文的目标地址,可以同时指定多个目标地址，每个 ip 之间用逗号隔开，也可以指定为一个网段 123iptables -t filter -I OUTPUT -d 192.168.10.111,192.168.10.225 -j DROPiptables -t filter -I INPUT -d 192.168.10.0/24 -j ACCEPTiptables -t filter -I INPUT ! -d 192.168.10.0/24 -j ACCEPT -p 用于匹配报文的协议类型,可以匹配的协议类型 tcp 、udp 、udplite 、icmp 、esp 、ah 、sctp 等 12iptables -t filter -I INPUT -p tcp -s 192.168.10.146 -j ACCEPTiptables -t filter -I INPUT ! -p udp -s 192.168.10.146 -j ACCEPT 扩展匹配条件 tcp 扩展模块 -p tcp -m tcp --sport 用于匹配 tcp 协议报文的源端口，可以使用冒号指定一个连续的端口范围-p tcp -m tcp --dport 用于匹配 tcp 协议报文的目标端口，可以使用冒号指定一个连续的端口范围 12345iptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp --sport 22 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 22:25 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport :22 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 80: -j REJECTiptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp ! --sport 22 -j ACCEPT multiport 扩展模块 -p tcp -m multiport --sports 用于匹配报文的源端口，可以指定离散的多个端口号,端口之间用”逗号”隔开-p udp -m multiport --dports 用于匹配报文的目标端口，可以指定离散的多个端口号，端口之间用”逗号”隔开 12345iptables -t filter -I OUTPUT -d 192.168.10.225 -p udp -m multiport --sports 137,138 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport ! --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 80:88 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80:88 -j REJECT udp 模块 --sport 匹配 udp 报文的源地址--dport 匹配 udp 报文的目标地址 123# 可以结合multiport模块指定多个离散的端口iptables -t filter -I INPUT -p udp -m udp --dport 137 -j ACCEPTiptables -t filter -I INPUT -p udp -m udp --dport 137:157 -j ACCEPT icmp 模块 --icmp-type 匹配 icmp 报文的具体类型 12345iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECTiptables -t filter -I INPUT -p icmp --icmp-type 8 -j REJECTiptables -t filter -I OUTPUT -p icmp -m icmp --icmp-type 0/0 -j REJECTiptables -t filter -I OUTPUT -p icmp --icmp-type 0 -j REJECTiptables -t filter -I INPUT -p icmp --icmp-type "echo-request" -j REJECT iprange 模块 --src-range 指定连续的源地址范围--dst-range 指定连续的目标地址范围 123iptables -t filter -I INPUT -m iprange --src-range 192.168.10.127-192.168.10.146 -j DROPiptables -t filter -I OUTPUT -m iprange --dst-range 192.168.10.127-192.168.10.146 -j DROPiptables -t filter -I INPUT -m iprange ! --src-range 192.168.10.127-192.168.10.146 -j DROP stirng 模块 --algo 指定对应的匹配算法，可用算法为 bm 、kmp，此选项为必需选项。--string 指定需要匹配的字符串 12iptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECTiptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECT time 模块 --timestart 用于指定时间范围的开始时间，不可取反--timestop 用于指定时间范围的结束时间，不可取反--weekdays 用于指定”星期几”，可取反--monthdays 用于指定”几号”，可取反--datestart 用于指定日期范围的开始日期，不可取反--datestop 用于指定日期范围的结束时间，不可取反 12345678iptables -t filter -I OUTPUT -p tcp --dport 80 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 443 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --weekdays 6,7 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --monthdays 22,23 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time ! --monthdays 22,23 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --timestart 09:00:00 --timestop 18:00:00 --weekdays 6,7 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --weekdays 5 --monthdays 22,23,24,25,26,27,28 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --datestart 2017-12-24 --datestop 2017-12-27 -j REJECT connlimit 模块 --connlimit-above 单独使用此选项时，表示限制每个 ip 的链接数量。--connlimit-mask 此选项不能单独使用，在使用 --connlimit-above 选项时，配合此选项，则可以针对”某类 ip 段内的一定数量的 ip “进行连接数量的限制 123iptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECTiptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j REJECTiptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 10 --connlimit-mask 27 -j REJECT limit 模块 --limit-burst 此选项用于指定令牌桶中令牌的最大数量--limit 此选项用于指定令牌桶中生成新令牌的频率，可用时间单位有second、minute 、hour、day 12iptables -t filter -I INPUT -p icmp -m limit --limit-burst 3 --limit 10/minute -j ACCEPTiptables -t filter -A INPUT -p icmp -j REJECT 自定义链创建自定义链12# 在filter表中创建yyz自定义链iptables -N yyz 引用自定义链12# 在OUTPUT链中引用刚才创建的自定义链iptables -I OUTPUT -j yyz 重命名自定义链12# 将yyz自定义链重命名为testiptabels -E yyz test 删除自定义链删除自定义链需要满足两个条件 自定义链中没有被引用 自定义链中没有任何规则 12# 删除引用计数为0且不包含任何规则的test链iptabels -X test]]></content>
      <categories>
        <category>ROM</category>
      </categories>
      <tags>
        <tag>ROM</tag>
        <tag>framework</tag>
        <tag>流水账</tag>
        <tag>iptables</tag>
        <tag>网络黑白名单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【流水账】记录Framework开发的常用指令]]></title>
    <url>%2F2019%2F08%2F16%2FFramework-Option%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 本篇博客是记录一些学习 framework 开发时知识的整理。 源码全盘编译指令 source build/envsetup.sh 输入 lunch 同时选择欲编译的源码 编译指令：make -j32 2&gt;&amp;1 | tee build_20190717_1724.log 编译后out目录可查看编译出的镜像 前两步执行完毕即可执行 mmm 等命令，使用 make clean可以在编译前clean源码，该操作会导致编译时间边长。 ROM烧录（mtk） 打开 flash_tool.exe 选择源码的配置文件 切换下载/全部格式化和下 点击下载，同时将已关机的设备连接电脑 等待红条，绿条，黄条走完烧录成功 ROM写号 打开 SN Writer.exe 点击 System Config 配置欲写哪些号，点击AP_DB进行配置文件，点击 Save 点击 Start 将关机的设备连入电脑 源码检出1repo-local init -u git://&#123;ip&#125;/shupai_android7.1/manifests.git &amp;&amp; repo-local sync -j8 &amp;&amp; repo-local start --all master {ip} 使用源码地址替换 开机动画/system/media/ 重新打包 System 生成镜像1make -j8 snod 对 Settings 部分的修改 移除某项（removePreference方法） 禁用某项 （配置enabled属性） 隐藏 Settings 主界面选项：TileUtils 三大金刚键 HOME 和 BACKPhoneWindowManager 类 interceptKeyBeforeDispatching 方法修改 KEYCODE_HOME KEYCODE_BACK case 中的逻辑 RECENTsrc/com/android/systemui/recents/RecentsImpl 类 startRecentsActivity 方法 预装应用device/mediatek/common device.mk 关机 重启操作1base/services/core/java/com/android/server/policy/GloablActions PowerAction]]></content>
      <categories>
        <category>ROM</category>
      </categories>
      <tags>
        <tag>ROM</tag>
        <tag>framework</tag>
        <tag>流水账</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个项目添加依赖同一个模块]]></title>
    <url>%2F2019%2F04%2F13%2Fmulti-project-one-module%2F</url>
    <content type="text"><![CDATA[android Studio 中的项目在正常引用module的时候是用复制到项目中的方式进行，单个项目调用还能适用，但是如果多个项目要引用同一个module的时候，如果module中进行了修改，那么每个项目中的module都要进行修改，这样增加了工作量，并且容易出现bug 因此我们需要引用module ，而不是复制module，实现方法如下 新建项目 TestBase，在其 app build.gradle 中将 apply plugin: &#39;com.android.application&#39; 改为apply plugin: &#39;com.android.library&#39; 删除applicationId 配置项，将module名修改为baselib。 新建项目 TestA 在其settings.gradle 文件中加入下列代码。 123include ':app'include ':baselib'project(':baselib').projectDir=new File("../TestBase", 'baselib') 引用依赖时正常引用即可 1implementation project(&apos;:baselib&apos;) 同步gradle ，此时我们发现baselib出现在TestA项目中。 打开TestA 项目文件夹，我们发现了 baselib 文件夹，下面只有一个baselib.iml文件 在baselib中加入Utils 工具类 切换到TestBase中查看，代码是相同的。 这样就达到了baselib被修改后所有引用baselib的项目会同步变化。 git 同步管理 上述操作都是基于本地的，那么如何加入git管理呢 将TestA和TestBase分别传至github 在TestA项目中打开settings，找到如下位置并将TestBase加入到git管理 然后就可以同步管理这两个项目啦 参考：https://www.jianshu.com/p/47156a6be8cehttps://blog.csdn.net/saintcs/article/details/78567612]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>app</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下Android反编译初探]]></title>
    <url>%2F2017%2F07%2F06%2FMac-decompile%2F</url>
    <content type="text"><![CDATA[工作第四天，被要求学习逆向开发方面的知识，于是先将自己之前写的未经混淆的apk反编译，记录之。 感谢该博文提供的思路 1. 工具准备 需要的三件套，下载请戳 AndroidCrackTool 用于反编译apk文件与直接解压apk不同，用该工具获得的文件资源可以直接打开阅读，而直接解压得到的是字节码。 dex2jar 用于将.dex文件转为jar文件 传统的Java程序经过编译，生成Java字节码保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Davik字节码，所有的Davik字节码由Java字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中，Dalvik虚拟机通过解释DEX文件来执行这些字节码。 jd-gui 用于阅读源码 2. 开始工作使用AndroidCrackTool反编译apk，设置好目录点击执行按钮，出现end字样即成功。在这里可以查看一些资源文件 将apk以普通解压的方式解压出来，找到其中的classes.dex文件，将其复制到dex2jar目录，使用终端进入dex2jar目录并执行如下命令。 1sh dex2jar.sh classes.dex 可以看到在dex2jar目录下生成了classes_dex2jar.jar的文件。 使用 jd-gui打开classes_dex2jar.jar即可看到源码，可以看到我的apk并没有混淆，所以名字都是正常的命名，经过混淆的名字大都是些字母。]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler深入分析]]></title>
    <url>%2F2017%2F07%2F04%2FHandler%2F</url>
    <content type="text"><![CDATA[在android中我们可以有很多方式去实现异步，比如AsyncTask，Rxjava。不过它们底层都是使用的Handler，所以我们来研究一下Handelr的实现。 1. TreadLocal的使用下面我们来写一个小demo，创建两个子线程，在两个子线程中分别为字符串result2，result3赋值，在主线程中调用两个子线程，并且为字符串result1赋值，最后打印输出结果。 最后我们看一下打印结果 很明显，这不是我们想要的结果。看来线程之间相互影响了，那么有没有办法实现上述的功能呢？ 当然有，我们可以使用 TreadLocal 我们可以把TreadLocal看做成一个容器，调用其中的set和get方法，可以设值和取值。下面我们看看是如何实现的。 首先创建一个ThreadLocal对象，并设置泛型为String这里不同的是首先将要打印的字串放入ThreadLocal中，然后从ThreadLocal中取出。 子线程的操作也是类似的。 下面我们看一下打印结果 这样就完成了上述功能。那么这里说的ThreadLocal与Handler有什么关系呢？别急，往下看。 2. 在子线程中创建Handelr我们在子线程中创建一个Handler对象，然后运行程序。 可以看到运行时出现了异常 java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare() 看字面意思是不能在调用Looper.prepare()之前在线程中创建handler。那么我们在创建handler之前去调用Looper.prepare()。之后就能成功运行了。 那么我们来研究一下为什么会这样。鼠标放在Handler()上，win按住control+鼠标左键，Mac按住command+鼠标左键。进入Handler的构造器。点击this 我们找到了源头，如果looper为空则抛出这个异常。 在这里从looper里取出mQueue赋值给mQueue 然后我们看一下这个Looper.prepare方法， 上方的注释说得很清楚，在真正开始这个loop之前，该方法为你提供了创建引用这个looper的handelr的机会。在调用完该方法后，应该确保调用了loop()方法，并且使用quit()方法去结束它。 我们还看到如果多次调用prepare方法会抛出Only one Looper may be created per thread异常。在这里我们看到了熟悉的身影，ThreadLocal。在这里使用ThreadLocal来存looper。 看到这我们不禁要问，在主线程我们并没有调用prepare方法啊，没错，在主线程使用的是prepareMainLooper可以看到这个main looper已经被android environment创建了，所以不需要自己调用该方法。 下面我们来看一下在子线程中创建Handler的标准写法。 123456789101112131415class ThreadLooper extends Thread &#123; public Handler mHandler; @Override public void run() &#123; super.run(); Looper.prepare(); mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; &#125; &#125;; Looper.loop(); &#125; &#125; 3. Message的发送和处理过程Handler里提供了几个消息入队的方法 post()postAtTime()postDelayed()postAtFrontOfQueue()sendMessageAtTime(Message msg , long uptimeMillis) 其中post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法。 下面我们看一下sendMessageAtTime方法 有两个参数，msg 和uptimeMillis ，如果消息队列为空，则打印警告，同时返回false。反之则调用enqueueMessage方法。 下面看一下enqueueMessage 这里有两个比较重要的操作。msg.target赋值为this，有两层含义，一是message的来源是当前handler，二是当前的handler来处理消息。将消息加入到消息队列中，既然是队列就有顺序，那么根据什么来判断顺序呢？就是根据uptimeMillis,这个时间，时间短就在前面，长就在后面。 细心的你可能发现刚刚我提到post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法，那postAtFrontOfQueue()呢？从字面上看该方法是将消息置于消息队列的最前边。是不是这样呢？我们看一下源码。 这里将入队的时间参数直接写死为0，那么肯定就是消息队列的最前边啦。 我们再来分析下入队之后的过程，上文提到调用Looper.prepare()方法后应调用Looper.loop()方法开始消息的轮询。那么我们看看loop方法做了些什么。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 首先从ThreadLocal中取出looper并判断是否为空，之后将looper中的消息队列赋值，再然后进入一个死循环，循环内去不断寻找消息队列的下一项，没有消息发生阻塞。 找到 msg.target.dispatchMessage(msg);这一行，之前我们提到target就是handler对象，这里handler把消息派发出去，接下来就进入消息的处理了。 进入到msg.target.dispatchMessage方法，这里分三步1.判断msg的回调是否为空 如果不为空则直接该回调自己处理，反之判断自己的回调 把Runnable 封装成msg的callback 2.判断自己的回调是否为空3.调用handleMessage方法 这里由子类重写来处理message 4. Handler机制的总结 Thread 负责业务逻辑Handler 负责发送消息和处理消息MessageQueue 负责保存消息Looper 负责轮询消息队列]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>handler</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2从教务系统查询成绩并计算绩点——山东建筑大学为例]]></title>
    <url>%2F2017%2F06%2F18%2F2-2-grade%2F</url>
    <content type="text"><![CDATA[前两天面试时被问到绩点是多少，但学校教务系统不提供绩点查询的功能，那么能不能写一个爬虫程序并计算出绩点呢？答案是肯定的！ 感谢该博客提供的思路 1. 准备HttpFox插件，是一款http协议分析插件，分析页面请求和响应的时间、内容、以及浏览器用到的COOKIE等。是火狐浏览器的插件。谷歌浏览器和Safari都有自带的分析工具，可是感觉太复杂，没有这款好用。不过火狐浏览器对学校的教务系统兼容性不是很好，我还下载了IE tab插件。 可以非常直观的查看相应的信息。点击start是开始检测，点击stop暂停检测，点击clear清除内容。 2. 探究过程下面就去山东建筑大学官网登录到数字校园综合信息门户，看一看在登录的时候，到底发送了那些信息。先来到登录页面，把httpfox打开，clear之后，点击start开启检测： 输入完账号密码，确保httpfox处于开启状态，然后点击登录。这个时候可以看到，httpfox检测到了好多信息： 那么我们来分析一下这些数据 看起来红框里的两条数据比较有意思，先看看这个post PostData中我们看到了比较熟悉的词，username和password，学过java web的我们很清楚这段数据的含义，点击登录后将这用户名和你们提交到服务器比对。 可以看到这里使用get的方式在链接上以?的方式显示的加上了参数，跳转到信息门户。我们的post的数据就发送到了这个地址 1http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal 需要的post数据是用户名密码，也就是说我们需要输入这两种数据来模拟登录过程。 进入教务系统后点击成绩查询，我们看到请求的地址为 1http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690 我们整理一下整个过程的思路。 POST学号和密码—&gt;然后返回cookie的值 发送cookie给服务器—&gt;返回页面信息。 获取到成绩页面的数据，用正则表达式将成绩和学分单独取出并计算加权平均数。 ok，理顺思路后剩下的就只有编码问题了。 3. 实验我们先来实验下是否能够获得查询成绩界面的源码 我们先准备一个POST的数据，再准备一个cookie的接收，然后写出源码如下： 12345678910111213141516171819202122232425262728# coding=utf-8import urllibimport urllib2import cookielibcookie = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))# 需要的POST数据postdata = urllib.urlencode(&#123; &apos;userName&apos;: &apos;20140216064&apos;, &apos;password&apos;: &apos;*********&apos;&#125;)# 自定义一个请求req1 = urllib2.Request( url=&apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos;, data=postdata)req2 = urllib2.Request( url=&apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos;)# 访问登录链接opener.open(req1)result = opener.open(req2)# 打印返回的内容print result.read() 很棒呦，看来跟我们预期的一样。 4. 整理数据 获得了成绩查询界面的源码后我们需要将数据进行整理，获得我们想要的数据，课程名称，学分，成绩。 将网页源码贴到Sublime Text中，方便我们查看源码 通过查看源码我们看到从这个开始到3640行都是关于成绩的代码，而成绩是存放在这个table标签下。红色框中分别为课程名，学分，以及成绩。这些是我们需要抽取出来的数据。看到这里竟然有意外收获！注意黄色框被注释的部分，看来学校的教务系统有计算绩点的功能的，不知由于何种原因不用呢？ 这里是这段程序中最困难的部分，我也踩了很多坑。我参照的博客是使用正则表达式来抽取想要的信息的，但我对正则表达式掌握的并不好，弄了好久也没写出合适的表达式，于是我果断放弃了使用正则表达式，采用BeautifulSoup来进行信息的筛选。BeautifulSoup用法参考 12345678910111213141516171819202122# 将内容从页面源码中提取出来 def deal_data(self, myPage): soup = BeautifulSoup(myPage) # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签) trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;) # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩 for tr in trs: for index, td in enumerate(tr.findAll(&apos;td&apos;)): # enumerate能在for循环中使用下标 if index == 3: print td.text elif index == 7: self.weights.append(td.text.encode(&apos;utf8&apos;)) print td.text elif index == 8: self.points.append(td.text.encode(&apos;utf8&apos;)) print td.text print 整个逻辑我简单说一下，我觉得还可以改进。首先查找title属性为”有效成绩“的标签，通过上文的截图我们可以知道这是那个div标签，之后在该div标签中定位class为t_con的tr标签。你也许会问为什么不直接定位到tr标签，因为后面的网页代码中还存在class 为t_con的tr标签，但不是我们需要的成绩。然后在每个tr标签下抽取下标为3，7，8的标签，这里我是把它存到数组里了。接下来就清晰了，先打印成绩信息，然后计算绩点。 学渣一个，绩点低请忽略。 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# encoding=utf8import urllibimport urllib2import cookielibimport reimport stringfrom BeautifulSoup import BeautifulSoupimport sysreload(sys)sys.setdefaultencoding(&apos;utf8&apos;)class SDJZU_Crawler: # 声明相关的属性 def __init__(self): self.loginUrl = &apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos; # 登录的url self.resultUrl = &apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos; # 查询成绩的url self.cookieJar = cookielib.CookieJar() # 初始化一个CookieJar来处理Cookie的信息 self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: &apos;&apos;, &apos;password&apos;: &apos;&apos;&#125;) # 登录需要POST的数据 self.weights = [] # 存储权重，也就是学分 self.points = [] # 存储分数，也就是成绩 self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.cookieJar)) def sdjzu_init(self): username = raw_input(&apos;请输入学号:&apos;) # 这里不要用input，二者区别请自行查询 password = raw_input(&apos;请输入密码:&apos;) self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: username, &apos;password&apos;: password&#125;) # 将用户名密码加入到POST中 # 初始化链接并且获取cookie myRequest = urllib2.Request(url=self.loginUrl, data=self.postdata) # 自定义一个请求 result = self.opener.open(myRequest) # 访问登录页面，获取到必须的cookie的值 result = self.opener.open(self.resultUrl) # 访问成绩页面，获得成绩的数据 self.deal_data(result.read()) self.calculate_gpa() # 将内容从页面源码中提取出来 def deal_data(self, myPage): soup = BeautifulSoup(myPage) # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签) trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;) # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩 for tr in trs: for index, td in enumerate(tr.findAll(&apos;td&apos;)): # enumerate能在for循环中使用下标 if index == 3: print td.text elif index == 7: self.weights.append(td.text.encode(&apos;utf8&apos;)) print td.text elif index == 8: self.points.append(td.text.encode(&apos;utf8&apos;)) print td.text print # 计算绩点，如果成绩还没出来，就不算该成绩， def calculate_gpa(self): point = 0.0 # 成绩 weight = 0.0 # 学分 for i in range(len(self.points)): if self.points[i].isdigit() and (self.weights[i] != 0): point += string.atof(self.points[i]) * string.atof(self.weights[i]) # 成绩*学分累加求和 weight += string.atof(self.weights[i]) # 学分累加求和 print &quot;绩点为：&quot; print point / weight # 输出绩点 值成绩*学分累加求和 / 学分累加求和# 调用mySpider = SDJZU_Crawler()mySpider.sdjzu_init() 我的github地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1开始第一个爬虫程序]]></title>
    <url>%2F2017%2F06%2F18%2F2-1-first-program%2F</url>
    <content type="text"><![CDATA[1. 安装IDE以及hello world 一个优秀的IDE可以极大地提高工作效率，在这里我选择使用JetBrains公司的PyCharm。是不是有些眼熟？没错，IDEA 和Android Studio就是他们做的，JetBrains出品，必属精品。 点击进入下载链接 点击download选择相应平台及版本，我这里选择的是社区版。 安装过程，切换主题，调整字体之类的都跟跟IDEA类似，不需赘述。 那么开始我们的hello world程序吧。新建一个Python file ，然后写入 1print (&quot;hello world&quot;) 第一次运行在工作区右击 run即可 之后就会在Toolbar上显示run按钮了 很棒有木有 2.1 先爬他一个网页下来敲入如下代码 1234import urllib2response = urllib2.urlopen(&quot;http://www.baidu.com&quot;)print response.read() 点击运行，我们可以得到结果 这个网页的源码被我们爬下来了，是不是很简单！ 2.2 分析代码下面我们来分析下这段代码 1import urllib2 urllib2库是学习Python爬虫最基本的模块，利用这个模块我们可以得到网页的内容，并对内容用正则表达式提取分析，得到我们想要的结果 1response = urllib2.urlopen(&quot;http://www.baidu.com&quot;) 首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，urlopen一般接受三个参数，它的参数如下： 第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。 第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT 第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。 1print response.read() response对象有一个read方法，可以返回获取到的网页内容 2.3 构造Request上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。我们可以将上面的代码改写为 12345import urllib2request = urllib2.Request(&quot;http://www.baidu.com&quot;)response = urllib2.urlopen(request)print response.read() 运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1使用函数]]></title>
    <url>%2F2017%2F06%2F05%2F1-1-use-function%2F</url>
    <content type="text"><![CDATA[我们编程时很容易疲劳，所以让我们来设计一个可以在一段时间后提醒你休息的小程序。比如每隔两个小时打开http://lines.frvr.com 此网站来玩一会儿小游戏。 让我们来分析下需要哪些步骤我们首先要让程序等待两个小时，在需要休息的时候打开浏览器并转到这个小游戏的网站。也许我们一天要休息多次，所以我们需要一个循环来让其实现多次。 1231. 等待两小时2. 打开浏览器重复 现在，让我们开始吧~ 首先让我们google一下如何用Python来打开浏览器 1webbrowser.open(&quot;http://lines.frvr.com&quot;) 可以看到上述代码可以使用默认浏览器打开指定网页。 让我们试试吧~保存并执行 出现了错误，不过学过java的你肯定能看懂是什么原因。 导入webbrowser模块就可以正常运行了，不要被这个网站的小游戏吸引走哦，我们还没有结束。 下面我们看看Python如何能让程序等待2小时，为了方便测试，我们把等待时间设置为3秒 可以看到使用time.sleep()方法可以是程序等待一段时间执行，参数以秒为单位所以我们在程序中添加以下代码 1time.sleep(3) 当然也要导入相应模块。 很简单有没有？ 接下来我们来让其循环3次 输入以下代码 12345678910import webbrowserimport timetotal_breaks = 3break_count = 0print(&quot;This program started on&quot; + time.ctime())while(break_count &lt; total_breaks): time.sleep(3) webbrowser.open(&quot;http://lines.frvr.com&quot;) break_count = break_count + 1 代码很简单，首先我们定义了总的休息次数为3，我们又定义了已休息次数初始值为0。接下来是一个while循环，当已休息次数小于总休息次数时执行循环体。最后将已休息次数加1。 值得注意的是while循环并没有花括号。 学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示： 1234if True: print &quot;True&quot;else: print &quot;False&quot; 以下代码将会执行错误： 12345678910#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：test.py if True: print &quot;Answer&quot; print &quot;True&quot;else: print &quot;Answer&quot; # 没有严格缩进，在执行时会报错 print &quot;False&quot; 执行以上代码，会出现如下错误提醒： 12345$ python test.py File &quot;test.py&quot;, line 5 if True: ^IndentationError: unexpected indent IndentationError: unexpected indent 错误是 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有 python 对格式要求非常严格。如果是 IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。因此，在 Python 的代码块中必须使用相同数目的行首缩进空格数。建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0.从零开始，Python的安装]]></title>
    <url>%2F2017%2F06%2F05%2F0-indtall-python%2F</url>
    <content type="text"><![CDATA[这学期计算机网络课程有一个课程设计，要求使用Python写一个小程序。之前也没接触过Python，从优达学城里看到一个关于Python的课程，在此记录。 Windows安装下载地址：https://www.python.org/downloads/ 确保安装了 pip 并且 Python 添加到了你的 PATH。 要检查安装是否成功，打开 IDLE（Python 安装的一款程序，使你能够轻松地编辑和运行 Python 代码）。 a) Windows 7（及更早版本）：依次点击“开始”菜单&gt;“所有程序”&gt;“Python 2.7”，最后选择 IDLE (Python GUI)。 b) Windows 8/10：搜索 IDLE。目前，你可以从屏幕右侧向左滑动或用鼠标点击屏幕的右下角进行搜索。 MAC安装要在 Mac 机器上安装 Python，你可以采用两种方法：在命令行中使用 Homebrew，或在官网上找到普通的 Python 安装程序。 方法 1：程序包安装程序安装地址：https://www.python.org/downloads/release/python-2713/检查是否安装成功 a) IDLE 应该位于您的应用程序文件夹中。b)通过按下 ⌘+空格键，打开 Spotlight ，并输入“idle”来查找 IDLE 以下是它在我们的计算机上运行的屏幕截图！ 方法 2：Homebrew要通过 Homebrew 安装 Python，只需执行以下两步： 打开终端，并输入命令： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”。 安装过程中，系统会多次发出提示 。安装完 Homebrew 后，你可以通过在命令行中输入 brew help，验证一切是否正常。现在输入 brew install python 获取 Python 2 的最新版本。这样就可以了！ 通过在命令行里输入 python 即可验证 Python 是否安装正确。系统应该欢迎你使用 Python Shell。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
