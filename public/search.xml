<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【流水账】记录Framework开发的常用指令</title>
      <link href="/2019/08/16/%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91%E8%AE%B0%E5%BD%95Framework%E5%BC%80%E5%8F%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2019/08/16/%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91%E8%AE%B0%E5%BD%95Framework%E5%BC%80%E5%8F%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。本篇博客是记录一些学习 <code>framework</code> 开发时知识的整理。</p></blockquote><a id="more"></a><h3 id="1-源码全盘编译指令"><a href="#1-源码全盘编译指令" class="headerlink" title="1. 源码全盘编译指令"></a>1. 源码全盘编译指令</h3><ol><li><code>source build/envsetup.sh</code></li><li>输入 <code>lunch</code> 同时选择欲编译的源码</li><li>编译指令：<code>make -j32 2&gt;&amp;1 | tee build_20190717_1724.log</code></li><li>编译后out目录可查看编译出的镜像</li></ol><p>前两步执行完毕即可执行 <code>mmm</code> 等命令，使用 <code>make clean</code>可以在编译前clean源码，该操作会导致编译时间边长。</p><h3 id="2-ROM烧录（mtk）"><a href="#2-ROM烧录（mtk）" class="headerlink" title="2. ROM烧录（mtk）"></a>2. ROM烧录（mtk）</h3><ol><li>打开 <code>flash_tool.exe</code></li><li>选择源码的配置文件</li><li>切换下载/全部格式化和下</li><li>点击下载，同时将已关机的设备连接电脑</li><li>等待红条，绿条，黄条走完烧录成功</li></ol><h3 id="3-ROM写号"><a href="#3-ROM写号" class="headerlink" title="3. ROM写号"></a>3. ROM写号</h3><ol><li>打开 <code>SN Writer.exe</code></li><li>点击 <code>System Config</code> 配置欲写哪些号，点击AP_DB进行配置文件，点击 <code>Save</code></li><li>点击 <code>Start</code> 将关机的设备连入电脑</li></ol><h3 id="4-源码检出"><a href="#4-源码检出" class="headerlink" title="4. 源码检出"></a>4. 源码检出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo-local init -u git://&#123;ip&#125;/shupai_android7.1/manifests.git &amp;&amp; repo-local sync -j8 &amp;&amp; repo-local start --all master</span><br></pre></td></tr></table></figure><p>{ip} 使用源码地址替换</p><h3 id="5-开机动画"><a href="#5-开机动画" class="headerlink" title="5. 开机动画"></a>5. 开机动画</h3><p><code>/system/media/</code></p><h3 id="6-重新打包-System-生成镜像"><a href="#6-重新打包-System-生成镜像" class="headerlink" title="6. 重新打包 System 生成镜像"></a>6. 重新打包 <code>System</code> 生成镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8 snod</span><br></pre></td></tr></table></figure><h3 id="7-对-Settings-部分的修改"><a href="#7-对-Settings-部分的修改" class="headerlink" title="7. 对 Settings 部分的修改"></a>7. 对 <code>Settings</code> 部分的修改</h3><ol><li>移除某项（removePreference方法）</li><li>禁用某项 （配置enabled属性）</li><li>隐藏 <code>Settings</code> 主界面选项：<code>TileUtils</code></li></ol><h3 id="8-三大金刚键"><a href="#8-三大金刚键" class="headerlink" title="8. 三大金刚键"></a>8. 三大金刚键</h3><ol><li><code>HOME</code> 和  <code>BACK</code><br><code>PhoneWindowManager</code> 类 <code>interceptKeyBeforeDispatching</code> 方法<br>修改 <code>KEYCODE_HOME</code>  <code>KEYCODE_BACK</code> case 中的逻辑 </li><li><code>RECENT</code><br><code>src/com/android/systemui/recents/RecentsImpl</code> 类 <code>startRecentsActivity</code> 方法</li></ol><h3 id="9-预装应用"><a href="#9-预装应用" class="headerlink" title="9. 预装应用"></a>9. 预装应用</h3><p><code>device/mediatek/common device.mk</code></p><h3 id="10-关机-重启操作"><a href="#10-关机-重启操作" class="headerlink" title="10. 关机 重启操作"></a>10. 关机 重启操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base/services/core/java/com/android/server/policy/GloablActions PowerAction</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROM </tag>
            
            <tag> framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多个项目添加依赖同一个模块</title>
      <link href="/2019/04/13/%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/04/13/%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>android Studio  中的项目在正常引用module的时候是用复制到项目中的方式进行，单个项目调用还能适用，但是如果多个项目要引用同一个module的时候，如果module中进行了修改，那么每个项目中的module都要进行修改，这样增加了工作量，并且容易出现bug</p><p>因此我们需要引用module ，而不是复制module，实现方法如下</p></blockquote><a id="more"></a><p>新建项目 <code>TestBase</code>，在其 <code>app build.gradle</code> 中将 <code>apply plugin: &#39;com.android.application&#39;</code> 改为<code>apply plugin: &#39;com.android.library&#39;</code> 删除<code>applicationId</code> 配置项，将<code>module</code>名修改为<code>baselib</code>。</p><p>新建项目 <code>TestA</code> 在其<code>settings.gradle</code> 文件中加入下列代码。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">':app'</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">':baselib'</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">':baselib'</span>).projectDir=<span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"../TestBase"</span>, <span class="string">'baselib'</span>)</span><br></pre></td></tr></table></figure><p>引用依赖时正常引用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation project(&apos;:baselib&apos;)</span><br></pre></td></tr></table></figure><p>同步<code>gradle</code> ，此时我们发现<code>baselib</code>出现在<code>TestA</code>项目中。</p><p><img src="/2019/04/13/多个项目添加依赖同一个模块/TestA%E7%9B%AE%E5%BD%95.png" alt="TestA目录.png"></p><p>打开<code>TestA</code> 项目文件夹，我们发现了 <code>baselib</code> 文件夹，下面只有一个<code>baselib.iml</code>文件</p><p><img src="/2019/04/13/多个项目添加依赖同一个模块/TesA%E5%8E%9F%E7%9B%AE%E5%BD%95.png" alt="TesA原目录.png"></p><p>在<code>baselib</code>中加入<code>Utils</code> 工具类</p><p><img src="/2019/04/13/多个项目添加依赖同一个模块/baselib.png" alt="baselib.png"></p><p>切换到<code>TestBase</code>中查看，代码是相同的。</p><p><img src="/2019/04/13/多个项目添加依赖同一个模块/baselib.png" alt="TestBase目录.png"></p><p>这样就达到了<code>baselib</code>被修改后所有引用<code>baselib</code>的项目会同步变化。</p><h4 id="git-同步管理"><a href="#git-同步管理" class="headerlink" title="git 同步管理"></a>git 同步管理</h4><blockquote><p>上述操作都是基于本地的，那么如何加入git管理呢</p></blockquote><p>将<code>TestA</code>和<code>TestBase</code>分别传至<code>github</code></p><p>在<code>TestA</code>项目中打开<code>settings</code>，找到如下位置并将<code>TestBase</code>加入到<code>git</code>管理</p><p><img src="/2019/04/13/多个项目添加依赖同一个模块/%E6%B7%BB%E5%8A%A0git.png" alt="添加git.png"></p><p>然后就可以同步管理这两个项目啦<br><img src="/2019/04/13/多个项目添加依赖同一个模块/%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86.png" alt="同步管理.png"><br><img src="/2019/04/13/多个项目添加依赖同一个模块/gitlog.png" alt="git log.png"></p><p>参考：<br><a href="https://www.jianshu.com/p/47156a6be8ce" target="_blank" rel="noopener">https://www.jianshu.com/p/47156a6be8ce</a><br>[<a href="https://blog.csdn.net/saintcs/article/details/78567612" target="_blank" rel="noopener">https://blog.csdn.net/saintcs/article/details/78567612</a></p>]]></content>
      
      
      <categories>
          
          <category> app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> app </tag>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下Android反编译初探</title>
      <link href="/2017/07/06/Mac%E4%B8%8BAndroid%E5%8F%8D%E7%BC%96%E8%AF%91%E5%88%9D%E6%8E%A2/"/>
      <url>/2017/07/06/Mac%E4%B8%8BAndroid%E5%8F%8D%E7%BC%96%E8%AF%91%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>工作第四天，被要求学习逆向开发方面的知识，于是先将自己之前写的未经混淆的apk反编译，记录之。</p></blockquote><p><a href="http://blog.csdn.net/wj_november/article/details/51527286" target="_blank" rel="noopener">感谢该博文提供的思路</a></p><a id="more"></a><h3 id="1-工具准备"><a href="#1-工具准备" class="headerlink" title="1. 工具准备"></a>1. 工具准备</h3><p><img src="http://upload-images.jianshu.io/upload_images/3155702-569189364ef992cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工具"></p><p>需要的三件套，<a href="http://download.csdn.net/detail/wj_november/9657372" target="_blank" rel="noopener">下载请戳</a></p><ol><li>AndroidCrackTool 用于反编译apk文件<br>与直接解压apk不同，用该工具获得的文件资源可以直接打开阅读，而直接解压得到的是字节码。</li><li>dex2jar 用于将.dex文件转为jar文件<br> 传统的Java程序经过编译，生成Java字节码保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Davik字节码，所有的Davik字节码由Java字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中，Dalvik虚拟机通过解释DEX文件来执行这些字节码。</li><li>jd-gui 用于阅读源码</li></ol><h3 id="2-开始工作"><a href="#2-开始工作" class="headerlink" title="2. 开始工作"></a>2. 开始工作</h3><p>使用AndroidCrackTool反编译apk，设置好目录点击执行按钮，出现end字样即成功。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-9dde0fe67fd84a07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反编译apk"><br>在这里可以查看一些资源文件</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-33d7aeb6f6b20770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看资源文件"><br>将apk以普通解压的方式解压出来，找到其中的classes.dex文件，<br><img src="http://upload-images.jianshu.io/upload_images/3155702-46a0928132602efb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="classes.dex位置"><br>将其复制到dex2jar目录，使用终端进入dex2jar目录并执行如下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh dex2jar.sh classes.dex</span><br></pre></td></tr></table></figure><p>可以看到在dex2jar目录下生成了classes_dex2jar.jar的文件。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-a489b4dd84c84ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端下操作"></p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-6c746a8c946c3275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成的classes_dex2jar.jar"><br>使用  jd-gui打开classes_dex2jar.jar即可看到源码，可以看到我的apk并没有混淆，所以名字都是正常的命名，经过混淆的名字大都是些字母。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-b7afdfda627a9e6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阅读源码"></p>]]></content>
      
      
      <categories>
          
          <category> app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler深入分析</title>
      <link href="/2017/07/04/Handler%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/2017/07/04/Handler%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在android中我们可以有很多方式去实现异步，比如AsyncTask，Rxjava。不过它们底层都是使用的Handler，所以我们来研究一下Handelr的实现。</p></blockquote><a id="more"></a><h3 id="1-TreadLocal的使用"><a href="#1-TreadLocal的使用" class="headerlink" title="1. TreadLocal的使用"></a>1. TreadLocal的使用</h3><p>下面我们来写一个小demo，创建两个子线程，在两个子线程中分别为字符串result2，result3赋值，在主线程中调用两个子线程，并且为字符串result1赋值，最后打印输出结果。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-2e352e80d8f708cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主线程"></p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-3593c9860a191e71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子线程1"></p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-106032139bef8248.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子线程2"></p><p>最后我们看一下打印结果</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-0fded8b582305652.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试结果"></p><p>很明显，这不是我们想要的结果。看来线程之间相互影响了，那么有没有办法实现上述的功能呢？</p><p>当然有，我们可以使用 TreadLocal</p><blockquote><p>我们可以把TreadLocal看做成一个容器，调用其中的set和get方法，可以设值和取值。下面我们看看是如何实现的。</p></blockquote><p>首先创建一个ThreadLocal对象，并设置泛型为String<br><img src="http://upload-images.jianshu.io/upload_images/3155702-b274968c0d87042d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ThreadLocal"><br>这里不同的是首先将要打印的字串放入ThreadLocal中，然后从ThreadLocal中取出。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-b8a37fcc57787a3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主线程"></p><p>子线程的操作也是类似的。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-9b8b4a3c8f495526.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子线程"></p><p>下面我们看一下打印结果</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-71885237f2c74d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p><p>这样就完成了上述功能。那么这里说的ThreadLocal与Handler有什么关系呢？别急，往下看。</p><h3 id="2-在子线程中创建Handelr"><a href="#2-在子线程中创建Handelr" class="headerlink" title="2. 在子线程中创建Handelr"></a>2. 在子线程中创建Handelr</h3><p>我们在子线程中创建一个Handler对象，然后运行程序。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-4673d3b294d1ff08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子线程中创建Handler对象"></p><p>可以看到运行时出现了异常</p><blockquote><p> java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3155702-42a0e89fbd6cfe2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常"><br>看字面意思是不能在调用Looper.prepare()之前在线程中创建handler。<br>那么我们在创建handler之前去调用Looper.prepare()。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-036e11a4312a1dd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用Looper.prepare()"><br>之后就能成功运行了。</p><p>那么我们来研究一下为什么会这样。<br>鼠标放在Handler()上，win按住control+鼠标左键，Mac按住command+鼠标左键。进入Handler的构造器。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-ddcf57bb316f4d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler构造器"><br>点击this</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-322cff8f6407b3f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更进一步"></p><p>我们找到了源头，如果looper为空则抛出这个异常。</p><p>在这里从looper里取出mQueue赋值给mQueue</p><p>然后我们看一下这个Looper.prepare方法，<br><img src="http://upload-images.jianshu.io/upload_images/3155702-8092676c88450ad6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="prepare"></p><p>上方的注释说得很清楚，在真正开始这个loop之前，该方法为你提供了创建引用这个looper的handelr的机会。在调用完该方法后，应该确保调用了loop()方法，并且使用quit()方法去结束它。</p><p>我们还看到如果多次调用prepare方法会抛出Only one Looper may be created per thread异常。<br>在这里我们看到了熟悉的身影，ThreadLocal。在这里使用ThreadLocal来存looper。</p><p>看到这我们不禁要问，在主线程我们并没有调用prepare方法啊，没错，在主线程使用的是prepareMainLooper<br><img src="http://upload-images.jianshu.io/upload_images/3155702-28263341bcc4e038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="prepareMainLooper"><br>可以看到这个main looper已经被android environment创建了，所以不需要自己调用该方法。</p><p>下面我们来看一下在子线程中创建Handler的标准写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ThreadLooper extends Thread &#123;</span><br><span class="line">        public Handler mHandler;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            Looper.prepare();</span><br><span class="line">            mHandler = new Handler() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void handleMessage(Message msg) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Message的发送和处理过程"><a href="#3-Message的发送和处理过程" class="headerlink" title="3. Message的发送和处理过程"></a>3. Message的发送和处理过程</h3><p>Handler里提供了几个消息入队的方法</p><blockquote><p>post()<br>postAtTime()<br>postDelayed()<br>postAtFrontOfQueue()<br>sendMessageAtTime(Message msg , long uptimeMillis)</p></blockquote><p>其中post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-8f15bc3b507a098f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="post"><br><img src="http://upload-images.jianshu.io/upload_images/3155702-1b8a08501a2a9251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="postAtTime"><br><img src="http://upload-images.jianshu.io/upload_images/3155702-c5ef6085b80726ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="postDelayed"><br><img src="http://upload-images.jianshu.io/upload_images/3155702-dbe0fccf4cc81722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sendMessageDelayed"><br>下面我们看一下sendMessageAtTime方法</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-678aac95b1c8ad85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sendMessageAtTime"></p><p>有两个参数，msg 和uptimeMillis ，如果消息队列为空，则打印警告，同时返回false。反之则调用enqueueMessage方法。</p><p>下面看一下enqueueMessage</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-ba4cd0593a2e8df7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enqueueMessage"><br>这里有两个比较重要的操作。<br>msg.target赋值为this，有两层含义，一是message的来源是当前handler，二是当前的handler来处理消息。<br>将消息加入到消息队列中，既然是队列就有顺序，那么根据什么来判断顺序呢？就是根据uptimeMillis,这个时间，时间短就在前面，长就在后面。</p><p>细心的你可能发现刚刚我提到post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法，那postAtFrontOfQueue()呢？<br>从字面上看该方法是将消息置于消息队列的最前边。是不是这样呢？我们看一下源码。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-76f2c74c7c0a3e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="postAtFrontOfQueue"><br>这里将入队的时间参数直接写死为0，那么肯定就是消息队列的最前边啦。</p><p>我们再来分析下入队之后的过程，上文提到调用Looper.prepare()方法后应调用Looper.loop()方法开始消息的轮询。那么我们看看loop方法做了些什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    if (me == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    // Make sure the identity of this thread is that of the local process,</span><br><span class="line">    // and keep track of what that identity token actually is.</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">        final Printer logging = me.mLogging;</span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final long traceTag = me.mTraceTag;</span><br><span class="line">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (traceTag != 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure that during the course of dispatching the</span><br><span class="line">        // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">        final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        if (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                    + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                    + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                    + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3155702-5797c552356958b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="looper"><br>首先从ThreadLocal中取出looper并判断是否为空，之后将looper中的消息队列赋值，再然后进入一个死循环，循环内去不断寻找消息队列的下一项，没有消息发生阻塞。</p><p>找到 msg.target.dispatchMessage(msg);这一行，<br>之前我们提到target就是handler对象，这里handler把消息派发出去，接下来就进入消息的处理了。</p><p>进入到msg.target.dispatchMessage方法，<br><img src="http://upload-images.jianshu.io/upload_images/3155702-3d37b2fa8bb03c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatchMessage"><br>这里分三步<br>1.判断msg的回调是否为空<br> 如果不为空则直接该回调自己处理，反之判断自己的回调</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-5cabf5368375e861.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="message的回调"><br>把Runnable 封装成msg的callback</p><p>2.判断自己的回调是否为空<br>3.调用handleMessage方法</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-ad49dc188525989f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="handleMessage"><br>这里由子类重写来处理message</p><h3 id="4-Handler机制的总结"><a href="#4-Handler机制的总结" class="headerlink" title="4. Handler机制的总结"></a>4. Handler机制的总结</h3><blockquote><p>Thread 负责业务逻辑<br>Handler 负责发送消息和处理消息<br>MessageQueue 负责保存消息<br>Looper 负责轮询消息队列</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> handler </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
