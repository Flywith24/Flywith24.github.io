<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【流水账】Xposed模块开发]]></title>
    <url>%2F2019%2F08%2F30%2F%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91Xposed%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 本篇博客是记录一些学习 Xposed模块开发时知识的整理。 开发前的准备工作查看 Xposed-Framework-API 根据文档进行配置 1234567repositories &#123; jcenter();&#125;dependencies &#123; compileOnly 'de.robv.android.xposed:api:82'&#125; AndroidManifest.xml 中 application 标签下加入 123456789101112&lt;!-- 应用为模块 --&gt;&lt;meta-data android:name="xposedmodule" android:value="true" /&gt;&lt;!-- 版本信息 该版本号与引用的依赖版本相同--&gt;&lt;meta-data android:name="xposedminversion" android:value="82" /&gt;&lt;!-- 模块描述 --&gt;&lt;meta-data android:name="xposeddescription" android:value="Xposed Test" /&gt; 创建 Hook 类，该类是 Xposed 的入口类，用于拦截加载的 package ，实现 IXposedHookLoadPackage 接口 1234567package com.yyz.xposedtest;public class Main implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; // TODO: hook逻辑 &#125; &#125; 在 src/main 目录下创建assets目录，在该目录中创建 xposed_ini t文件，写入上面创建的 Xposed 的入口类，如下： XposedHelpers 常用方法findAndHookMethod Look up a method and hook it. The last argument must be the callback for the hook. 最后一个参数主要有两种 XC_MethodHook 在原有方法逻辑上添加逻辑，代码如下 12345678910111213141516//在原有方法逻辑上添加逻辑/** * 1. 包名 2. classLoader 3. 方法名 4. 参数类型（没有则不添加） 5.Callback */XposedHelpers.findAndHookMethod("cn.bcbook.kaixuetest.MainActivity", lpparam.classLoader, "printViewId", View.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Log.i("yyz", "afterHookedMethod hook success!"); &#125; &#125;); XC_MethodReplacement 替换原有方法逻辑，代码如下 123456789//替换原有方法XposedHelpers.findAndHookMethod("cn.bcbook.kaixuetest.MainActivity", lpparam.classLoader, "printViewId", View.class, new XC_MethodReplacement() &#123; @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable &#123; Log.i("yyz", "hook success!"); return null; &#125; &#125;);]]></content>
      <categories>
        <category>Xposed</category>
      </categories>
      <tags>
        <tag>Hook</tag>
        <tag>Xposed</tag>
        <tag>流水账</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【流水账】iptables 常用指令]]></title>
    <url>%2F2019%2F08%2F29%2F%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91iptabels%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 该文总结了 iptables 常用的指令。iptables 详细内容请看双印大佬 iptables 详解系列 规则查询查看指定表中的规则1iptables -t filter -L 使用 -t 选项，指定要操作的表，使用 -L 选项，查看-t选项对应的表的规则， -L 选项的意思是，列出规则。所以，上述命令的含义为列出filter表的所有规则。 filter 可替换为 raw mangle nat 如果仅查看 filter 可以省略 -t filter ，当没有使用 -t 选项指定表时，默认为操作 filter 表，即 iptables -L 表示列出 filter 表中的所有规则。 查看指定表中的指定链的规则1iptables -L INPUT 只查看 filter 表中 INPUT 链的规则 1iptables -vL INPUT 使用 -v 查看更多，更详细的信息 不让ip进行反解1iptables -nvL iptables 默认进行了名称解析，但是在规则非常多的情况下如果进行名称解析，效率会比较低。使用 -n 选项，表示不对 ip 地址进行名称反解，直接显示 ip 地址 只查看某个链的规则，并且不让 ip 进行反解，iptables -nvL INPUT 显示规则编号123iptables --line-number -nvL INPUT或iptables --line -nvL INPUT 规则管理添加规则注意：添加规则时，规则的顺序非常重要 123456789101112131415# 在指定表的指定链的尾部添加一条规则，-A选项表示在对应链的末尾添加规则命令语法：iptables -t 表名 -A 链名 匹配条件 -j 动作示例：iptables -t filter -A OUTPUT -s 192.168.10.225 -j DROP# 在指定表的指定链的首部添加一条规则，-I选型表示在对应链的开头添加规则命令语法：iptables -t 表名 -I 链名 匹配条件 -j 动作示例： iptables -t filter -I OUTPUT -s 192.168.10.225 -j ACCEPT# 在指定表的指定链的指定位置添加一条规则命令语法：iptables -t 表名 -I 链名 规则序号 匹配条件 -j 动作示例： iptables -t filter -I OUTPUT 3 -s 192.168.10.225 -j REJECT# 设置指定表的指定链的默认策略（默认动作），并非添加规则命令语法：iptables -t 表名 -P 链名 动作示例：iptables -t filter -P FORWARD ACCEPT 删除规则注意：如果没有保存规则，删除规则时请慎重 123456789101112131415# 按照规则序号删除规则，删除指定表的指定链的指定规则，-D选项表示删除对应链中的规则命令语法：iptables -t 表名 -D 链名 规则序号示例：iptables -t filter -D INPUT 3# 按照具体的匹配条件与动作删除规则，删除指定表的指定链的指定规则命令语法：iptables -t 表名 -D 链名 匹配条件 -j 动作示例：iptables -t filter -D INPUT -s 192.168.10.225 -j DROP# 删除指定表的指定链中的所有规则，-F选项表示清空对应链中的规则命令语法：iptables -t 表名 -F 链名示例：iptables -t filter -F INPUT# 删除指定表中的所有规则命令语法：iptables -t 表名 -F示例：iptables -t filter -F OUTPUT 修改规则注意：如果使用-R选项修改规则中的动作，那么必须指明原规则中的原匹配条件，例如源ip，目标ip等 123# 修改指定表中指定链的指定规则，-R选项表示修改对应链中的规则，使用-R选项时要同时指定对应的链以及规则对应的序号，并且规则中原本的匹配条件不可省略命令语法：iptables -t 表名 -R 链名 规则序号 规则原本的匹配条件 -j 动作示例：iptables -t filter -R INPUT 3 -s 192.168.10.225 -j ACCEPT 上述示例表示修改 filter 表中 INPUT 链的第3条规则，将这条规则的动作修改为 ACCEPT ， -s 192.168.10.225 为这条规则中原本的匹配条件，如果省略此匹配条件，修改后的规则中的源地址可能会变为 0.0.0.0/0 其他修改规则的方法：先通过编号删除规则，再在原编号位置添加一条规则 123# 修改指定表的指定链的默认策略（默认动作），并非修改规则命令语法：iptables -t 表名 -P 链名 动作示例：iptables -t filter -P FORWARD ACCEPT 保存规则12# 保存规则命令，表示将iptables规则保存至/etc/sysconfig/iptables文件中service iptables save 匹配条件基本匹配条件-s 用于匹配报文的源地址,可以同时指定多个源地址，每个 ip 之间用逗号隔开，也可以指定为一个网段 123iptables -t filter -I INPUT -s 192.168.10.111,192.168.10.225 -j DROPiptables -t filter -I INPUT -s 192.168.10.0/24 -j ACCEPTiptables -t filter -I INPUT ! -s 192.168.10.0/24 -j ACCEPT -d 用于匹配报文的目标地址,可以同时指定多个目标地址，每个 ip 之间用逗号隔开，也可以指定为一个网段 123iptables -t filter -I OUTPUT -d 192.168.10.111,192.168.10.225 -j DROPiptables -t filter -I INPUT -d 192.168.10.0/24 -j ACCEPTiptables -t filter -I INPUT ! -d 192.168.10.0/24 -j ACCEPT -p 用于匹配报文的协议类型,可以匹配的协议类型 tcp 、udp 、udplite 、icmp 、esp 、ah 、sctp 等 12iptables -t filter -I INPUT -p tcp -s 192.168.10.146 -j ACCEPTiptables -t filter -I INPUT ! -p udp -s 192.168.10.146 -j ACCEPT 扩展匹配条件 tcp 扩展模块 -p tcp -m tcp --sport 用于匹配 tcp 协议报文的源端口，可以使用冒号指定一个连续的端口范围-p tcp -m tcp --dport 用于匹配 tcp 协议报文的目标端口，可以使用冒号指定一个连续的端口范围 12345iptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp --sport 22 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 22:25 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport :22 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 80: -j REJECTiptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp ! --sport 22 -j ACCEPT multiport 扩展模块 -p tcp -m multiport --sports 用于匹配报文的源端口，可以指定离散的多个端口号,端口之间用”逗号”隔开-p udp -m multiport --dports 用于匹配报文的目标端口，可以指定离散的多个端口号，端口之间用”逗号”隔开 12345iptables -t filter -I OUTPUT -d 192.168.10.225 -p udp -m multiport --sports 137,138 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport ! --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 80:88 -j REJECTiptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80:88 -j REJECT udp 模块 --sport 匹配 udp 报文的源地址--dport 匹配 udp 报文的目标地址 123# 可以结合multiport模块指定多个离散的端口iptables -t filter -I INPUT -p udp -m udp --dport 137 -j ACCEPTiptables -t filter -I INPUT -p udp -m udp --dport 137:157 -j ACCEPT icmp 模块 --icmp-type 匹配 icmp 报文的具体类型 12345iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECTiptables -t filter -I INPUT -p icmp --icmp-type 8 -j REJECTiptables -t filter -I OUTPUT -p icmp -m icmp --icmp-type 0/0 -j REJECTiptables -t filter -I OUTPUT -p icmp --icmp-type 0 -j REJECTiptables -t filter -I INPUT -p icmp --icmp-type "echo-request" -j REJECT iprange 模块 --src-range 指定连续的源地址范围--dst-range 指定连续的目标地址范围 123iptables -t filter -I INPUT -m iprange --src-range 192.168.10.127-192.168.10.146 -j DROPiptables -t filter -I OUTPUT -m iprange --dst-range 192.168.10.127-192.168.10.146 -j DROPiptables -t filter -I INPUT -m iprange ! --src-range 192.168.10.127-192.168.10.146 -j DROP stirng 模块 --algo 指定对应的匹配算法，可用算法为 bm 、kmp，此选项为必需选项。--string 指定需要匹配的字符串 12iptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECTiptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECT time 模块 --timestart 用于指定时间范围的开始时间，不可取反--timestop 用于指定时间范围的结束时间，不可取反--weekdays 用于指定”星期几”，可取反--monthdays 用于指定”几号”，可取反--datestart 用于指定日期范围的开始日期，不可取反--datestop 用于指定日期范围的结束时间，不可取反 12345678iptables -t filter -I OUTPUT -p tcp --dport 80 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 443 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --weekdays 6,7 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --monthdays 22,23 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time ! --monthdays 22,23 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --timestart 09:00:00 --timestop 18:00:00 --weekdays 6,7 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --weekdays 5 --monthdays 22,23,24,25,26,27,28 -j REJECTiptables -t filter -I OUTPUT -p tcp --dport 80 -m time --datestart 2017-12-24 --datestop 2017-12-27 -j REJECT connlimit 模块 --connlimit-above 单独使用此选项时，表示限制每个 ip 的链接数量。--connlimit-mask 此选项不能单独使用，在使用 --connlimit-above 选项时，配合此选项，则可以针对”某类 ip 段内的一定数量的 ip “进行连接数量的限制 123iptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECTiptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j REJECTiptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 10 --connlimit-mask 27 -j REJECT limit 模块 --limit-burst 此选项用于指定令牌桶中令牌的最大数量--limit 此选项用于指定令牌桶中生成新令牌的频率，可用时间单位有second、minute 、hour、day 12iptables -t filter -I INPUT -p icmp -m limit --limit-burst 3 --limit 10/minute -j ACCEPTiptables -t filter -A INPUT -p icmp -j REJECT 自定义链创建自定义链12# 在filter表中创建yyz自定义链iptables -N yyz 引用自定义链12# 在OUTPUT链中引用刚才创建的自定义链iptables -I OUTPUT -j yyz 重命名自定义链12# 将yyz自定义链重命名为testiptabels -E yyz test 删除自定义链删除自定义链需要满足两个条件 自定义链中没有被引用 自定义链中没有任何规则 12# 删除引用计数为0且不包含任何规则的test链iptabels -X test]]></content>
      <categories>
        <category>ROM</category>
      </categories>
      <tags>
        <tag>ROM</tag>
        <tag>framework</tag>
        <tag>iptables</tag>
        <tag>网络黑白名单</tag>
        <tag>流水账</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【流水账】记录Framework开发的常用指令]]></title>
    <url>%2F2019%2F08%2F16%2F%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91%E8%AE%B0%E5%BD%95Framework%E5%BC%80%E5%8F%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 how to 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。 本篇博客是记录一些学习 framework 开发时知识的整理。 源码全盘编译指令 source build/envsetup.sh 输入 lunch 同时选择欲编译的源码 编译指令：make -j32 2&gt;&amp;1 | tee build_20190717_1724.log 编译后out目录可查看编译出的镜像 前两步执行完毕即可执行 mmm 等命令，使用 make clean可以在编译前clean源码，该操作会导致编译时间边长。 ROM烧录（mtk） 打开 flash_tool.exe 选择源码的配置文件 切换下载/全部格式化和下 点击下载，同时将已关机的设备连接电脑 等待红条，绿条，黄条走完烧录成功 ROM写号 打开 SN Writer.exe 点击 System Config 配置欲写哪些号，点击AP_DB进行配置文件，点击 Save 点击 Start 将关机的设备连入电脑 源码检出1repo-local init -u git://&#123;ip&#125;/shupai_android7.1/manifests.git &amp;&amp; repo-local sync -j8 &amp;&amp; repo-local start --all master {ip} 使用源码地址替换 开机动画/system/media/ 重新打包 System 生成镜像1make -j8 snod 对 Settings 部分的修改 移除某项（removePreference方法） 禁用某项 （配置enabled属性） 隐藏 Settings 主界面选项：TileUtils 三大金刚键 HOME 和 BACKPhoneWindowManager 类 interceptKeyBeforeDispatching 方法修改 KEYCODE_HOME KEYCODE_BACK case 中的逻辑 RECENTsrc/com/android/systemui/recents/RecentsImpl 类 startRecentsActivity 方法 预装应用device/mediatek/common device.mk 关机 重启操作1base/services/core/java/com/android/server/policy/GloablActions PowerAction]]></content>
      <categories>
        <category>ROM</category>
      </categories>
      <tags>
        <tag>ROM</tag>
        <tag>framework</tag>
        <tag>流水账</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个项目添加依赖同一个模块]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[android Studio 中的项目在正常引用module的时候是用复制到项目中的方式进行，单个项目调用还能适用，但是如果多个项目要引用同一个module的时候，如果module中进行了修改，那么每个项目中的module都要进行修改，这样增加了工作量，并且容易出现bug 因此我们需要引用module ，而不是复制module，实现方法如下 新建项目 TestBase，在其 app build.gradle 中将 apply plugin: &#39;com.android.application&#39; 改为apply plugin: &#39;com.android.library&#39; 删除applicationId 配置项，将module名修改为baselib。 新建项目 TestA 在其settings.gradle 文件中加入下列代码。 123include ':app'include ':baselib'project(':baselib').projectDir=new File("../TestBase", 'baselib') 引用依赖时正常引用即可 1implementation project(&apos;:baselib&apos;) 同步gradle ，此时我们发现baselib出现在TestA项目中。 打开TestA 项目文件夹，我们发现了 baselib 文件夹，下面只有一个baselib.iml文件 在baselib中加入Utils 工具类 切换到TestBase中查看，代码是相同的。 这样就达到了baselib被修改后所有引用baselib的项目会同步变化。 git 同步管理 上述操作都是基于本地的，那么如何加入git管理呢 将TestA和TestBase分别传至github 在TestA项目中打开settings，找到如下位置并将TestBase加入到git管理 然后就可以同步管理这两个项目啦 参考：https://www.jianshu.com/p/47156a6be8cehttps://blog.csdn.net/saintcs/article/details/78567612]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>app</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下Android反编译初探]]></title>
    <url>%2F2017%2F07%2F06%2FMac%E4%B8%8BAndroid%E5%8F%8D%E7%BC%96%E8%AF%91%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[工作第四天，被要求学习逆向开发方面的知识，于是先将自己之前写的未经混淆的apk反编译，记录之。 感谢该博文提供的思路 1. 工具准备 需要的三件套，下载请戳 AndroidCrackTool 用于反编译apk文件与直接解压apk不同，用该工具获得的文件资源可以直接打开阅读，而直接解压得到的是字节码。 dex2jar 用于将.dex文件转为jar文件 传统的Java程序经过编译，生成Java字节码保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Davik字节码，所有的Davik字节码由Java字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中，Dalvik虚拟机通过解释DEX文件来执行这些字节码。 jd-gui 用于阅读源码 2. 开始工作使用AndroidCrackTool反编译apk，设置好目录点击执行按钮，出现end字样即成功。在这里可以查看一些资源文件 将apk以普通解压的方式解压出来，找到其中的classes.dex文件，将其复制到dex2jar目录，使用终端进入dex2jar目录并执行如下命令。 1sh dex2jar.sh classes.dex 可以看到在dex2jar目录下生成了classes_dex2jar.jar的文件。 使用 jd-gui打开classes_dex2jar.jar即可看到源码，可以看到我的apk并没有混淆，所以名字都是正常的命名，经过混淆的名字大都是些字母。]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler深入分析]]></title>
    <url>%2F2017%2F07%2F04%2FHandler%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在android中我们可以有很多方式去实现异步，比如AsyncTask，Rxjava。不过它们底层都是使用的Handler，所以我们来研究一下Handelr的实现。 1. TreadLocal的使用下面我们来写一个小demo，创建两个子线程，在两个子线程中分别为字符串result2，result3赋值，在主线程中调用两个子线程，并且为字符串result1赋值，最后打印输出结果。 最后我们看一下打印结果 很明显，这不是我们想要的结果。看来线程之间相互影响了，那么有没有办法实现上述的功能呢？ 当然有，我们可以使用 TreadLocal 我们可以把TreadLocal看做成一个容器，调用其中的set和get方法，可以设值和取值。下面我们看看是如何实现的。 首先创建一个ThreadLocal对象，并设置泛型为String这里不同的是首先将要打印的字串放入ThreadLocal中，然后从ThreadLocal中取出。 子线程的操作也是类似的。 下面我们看一下打印结果 这样就完成了上述功能。那么这里说的ThreadLocal与Handler有什么关系呢？别急，往下看。 2. 在子线程中创建Handelr我们在子线程中创建一个Handler对象，然后运行程序。 可以看到运行时出现了异常 java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare() 看字面意思是不能在调用Looper.prepare()之前在线程中创建handler。那么我们在创建handler之前去调用Looper.prepare()。之后就能成功运行了。 那么我们来研究一下为什么会这样。鼠标放在Handler()上，win按住control+鼠标左键，Mac按住command+鼠标左键。进入Handler的构造器。点击this 我们找到了源头，如果looper为空则抛出这个异常。 在这里从looper里取出mQueue赋值给mQueue 然后我们看一下这个Looper.prepare方法， 上方的注释说得很清楚，在真正开始这个loop之前，该方法为你提供了创建引用这个looper的handelr的机会。在调用完该方法后，应该确保调用了loop()方法，并且使用quit()方法去结束它。 我们还看到如果多次调用prepare方法会抛出Only one Looper may be created per thread异常。在这里我们看到了熟悉的身影，ThreadLocal。在这里使用ThreadLocal来存looper。 看到这我们不禁要问，在主线程我们并没有调用prepare方法啊，没错，在主线程使用的是prepareMainLooper可以看到这个main looper已经被android environment创建了，所以不需要自己调用该方法。 下面我们来看一下在子线程中创建Handler的标准写法。 123456789101112131415class ThreadLooper extends Thread &#123; public Handler mHandler; @Override public void run() &#123; super.run(); Looper.prepare(); mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; &#125; &#125;; Looper.loop(); &#125; &#125; 3. Message的发送和处理过程Handler里提供了几个消息入队的方法 post()postAtTime()postDelayed()postAtFrontOfQueue()sendMessageAtTime(Message msg , long uptimeMillis) 其中post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法。 下面我们看一下sendMessageAtTime方法 有两个参数，msg 和uptimeMillis ，如果消息队列为空，则打印警告，同时返回false。反之则调用enqueueMessage方法。 下面看一下enqueueMessage 这里有两个比较重要的操作。msg.target赋值为this，有两层含义，一是message的来源是当前handler，二是当前的handler来处理消息。将消息加入到消息队列中，既然是队列就有顺序，那么根据什么来判断顺序呢？就是根据uptimeMillis,这个时间，时间短就在前面，长就在后面。 细心的你可能发现刚刚我提到post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法，那postAtFrontOfQueue()呢？从字面上看该方法是将消息置于消息队列的最前边。是不是这样呢？我们看一下源码。 这里将入队的时间参数直接写死为0，那么肯定就是消息队列的最前边啦。 我们再来分析下入队之后的过程，上文提到调用Looper.prepare()方法后应调用Looper.loop()方法开始消息的轮询。那么我们看看loop方法做了些什么。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 首先从ThreadLocal中取出looper并判断是否为空，之后将looper中的消息队列赋值，再然后进入一个死循环，循环内去不断寻找消息队列的下一项，没有消息发生阻塞。 找到 msg.target.dispatchMessage(msg);这一行，之前我们提到target就是handler对象，这里handler把消息派发出去，接下来就进入消息的处理了。 进入到msg.target.dispatchMessage方法，这里分三步1.判断msg的回调是否为空 如果不为空则直接该回调自己处理，反之判断自己的回调 把Runnable 封装成msg的callback 2.判断自己的回调是否为空3.调用handleMessage方法 这里由子类重写来处理message 4. Handler机制的总结 Thread 负责业务逻辑Handler 负责发送消息和处理消息MessageQueue 负责保存消息Looper 负责轮询消息队列]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>handler</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2从教务系统查询成绩并计算绩点——山东建筑大学为例]]></title>
    <url>%2F2017%2F06%2F18%2F2-2%E4%BB%8E%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9F%A5%E8%AF%A2%E6%88%90%E7%BB%A9%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%BB%A9%E7%82%B9%E2%80%94%E2%80%94%E5%B1%B1%E4%B8%9C%E5%BB%BA%E7%AD%91%E5%A4%A7%E5%AD%A6%E4%B8%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前两天面试时被问到绩点是多少，但学校教务系统不提供绩点查询的功能，那么能不能写一个爬虫程序并计算出绩点呢？答案是肯定的！ 感谢该博客提供的思路 1. 准备HttpFox插件，是一款http协议分析插件，分析页面请求和响应的时间、内容、以及浏览器用到的COOKIE等。是火狐浏览器的插件。谷歌浏览器和Safari都有自带的分析工具，可是感觉太复杂，没有这款好用。不过火狐浏览器对学校的教务系统兼容性不是很好，我还下载了IE tab插件。 可以非常直观的查看相应的信息。点击start是开始检测，点击stop暂停检测，点击clear清除内容。 2. 探究过程下面就去山东建筑大学官网登录到数字校园综合信息门户，看一看在登录的时候，到底发送了那些信息。先来到登录页面，把httpfox打开，clear之后，点击start开启检测： 输入完账号密码，确保httpfox处于开启状态，然后点击登录。这个时候可以看到，httpfox检测到了好多信息： 那么我们来分析一下这些数据 看起来红框里的两条数据比较有意思，先看看这个post PostData中我们看到了比较熟悉的词，username和password，学过java web的我们很清楚这段数据的含义，点击登录后将这用户名和你们提交到服务器比对。 可以看到这里使用get的方式在链接上以?的方式显示的加上了参数，跳转到信息门户。我们的post的数据就发送到了这个地址 1http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal 需要的post数据是用户名密码，也就是说我们需要输入这两种数据来模拟登录过程。 进入教务系统后点击成绩查询，我们看到请求的地址为 1http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690 我们整理一下整个过程的思路。 POST学号和密码—&gt;然后返回cookie的值 发送cookie给服务器—&gt;返回页面信息。 获取到成绩页面的数据，用正则表达式将成绩和学分单独取出并计算加权平均数。 ok，理顺思路后剩下的就只有编码问题了。 3. 实验我们先来实验下是否能够获得查询成绩界面的源码 我们先准备一个POST的数据，再准备一个cookie的接收，然后写出源码如下： 12345678910111213141516171819202122232425262728# coding=utf-8import urllibimport urllib2import cookielibcookie = cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))# 需要的POST数据postdata = urllib.urlencode(&#123; &apos;userName&apos;: &apos;20140216064&apos;, &apos;password&apos;: &apos;*********&apos;&#125;)# 自定义一个请求req1 = urllib2.Request( url=&apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos;, data=postdata)req2 = urllib2.Request( url=&apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos;)# 访问登录链接opener.open(req1)result = opener.open(req2)# 打印返回的内容print result.read() 很棒呦，看来跟我们预期的一样。 4. 整理数据 获得了成绩查询界面的源码后我们需要将数据进行整理，获得我们想要的数据，课程名称，学分，成绩。 将网页源码贴到Sublime Text中，方便我们查看源码 通过查看源码我们看到从这个开始到3640行都是关于成绩的代码，而成绩是存放在这个table标签下。红色框中分别为课程名，学分，以及成绩。这些是我们需要抽取出来的数据。看到这里竟然有意外收获！注意黄色框被注释的部分，看来学校的教务系统有计算绩点的功能的，不知由于何种原因不用呢？ 这里是这段程序中最困难的部分，我也踩了很多坑。我参照的博客是使用正则表达式来抽取想要的信息的，但我对正则表达式掌握的并不好，弄了好久也没写出合适的表达式，于是我果断放弃了使用正则表达式，采用BeautifulSoup来进行信息的筛选。BeautifulSoup用法参考 12345678910111213141516171819202122# 将内容从页面源码中提取出来 def deal_data(self, myPage): soup = BeautifulSoup(myPage) # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签) trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;) # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩 for tr in trs: for index, td in enumerate(tr.findAll(&apos;td&apos;)): # enumerate能在for循环中使用下标 if index == 3: print td.text elif index == 7: self.weights.append(td.text.encode(&apos;utf8&apos;)) print td.text elif index == 8: self.points.append(td.text.encode(&apos;utf8&apos;)) print td.text print 整个逻辑我简单说一下，我觉得还可以改进。首先查找title属性为”有效成绩“的标签，通过上文的截图我们可以知道这是那个div标签，之后在该div标签中定位class为t_con的tr标签。你也许会问为什么不直接定位到tr标签，因为后面的网页代码中还存在class 为t_con的tr标签，但不是我们需要的成绩。然后在每个tr标签下抽取下标为3，7，8的标签，这里我是把它存到数组里了。接下来就清晰了，先打印成绩信息，然后计算绩点。 学渣一个，绩点低请忽略。 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# encoding=utf8import urllibimport urllib2import cookielibimport reimport stringfrom BeautifulSoup import BeautifulSoupimport sysreload(sys)sys.setdefaultencoding(&apos;utf8&apos;)class SDJZU_Crawler: # 声明相关的属性 def __init__(self): self.loginUrl = &apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos; # 登录的url self.resultUrl = &apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos; # 查询成绩的url self.cookieJar = cookielib.CookieJar() # 初始化一个CookieJar来处理Cookie的信息 self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: &apos;&apos;, &apos;password&apos;: &apos;&apos;&#125;) # 登录需要POST的数据 self.weights = [] # 存储权重，也就是学分 self.points = [] # 存储分数，也就是成绩 self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.cookieJar)) def sdjzu_init(self): username = raw_input(&apos;请输入学号:&apos;) # 这里不要用input，二者区别请自行查询 password = raw_input(&apos;请输入密码:&apos;) self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: username, &apos;password&apos;: password&#125;) # 将用户名密码加入到POST中 # 初始化链接并且获取cookie myRequest = urllib2.Request(url=self.loginUrl, data=self.postdata) # 自定义一个请求 result = self.opener.open(myRequest) # 访问登录页面，获取到必须的cookie的值 result = self.opener.open(self.resultUrl) # 访问成绩页面，获得成绩的数据 self.deal_data(result.read()) self.calculate_gpa() # 将内容从页面源码中提取出来 def deal_data(self, myPage): soup = BeautifulSoup(myPage) # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签) trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;) # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩 for tr in trs: for index, td in enumerate(tr.findAll(&apos;td&apos;)): # enumerate能在for循环中使用下标 if index == 3: print td.text elif index == 7: self.weights.append(td.text.encode(&apos;utf8&apos;)) print td.text elif index == 8: self.points.append(td.text.encode(&apos;utf8&apos;)) print td.text print # 计算绩点，如果成绩还没出来，就不算该成绩， def calculate_gpa(self): point = 0.0 # 成绩 weight = 0.0 # 学分 for i in range(len(self.points)): if self.points[i].isdigit() and (self.weights[i] != 0): point += string.atof(self.points[i]) * string.atof(self.weights[i]) # 成绩*学分累加求和 weight += string.atof(self.weights[i]) # 学分累加求和 print &quot;绩点为：&quot; print point / weight # 输出绩点 值成绩*学分累加求和 / 学分累加求和# 调用mySpider = SDJZU_Crawler()mySpider.sdjzu_init() 我的github地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1开始第一个爬虫程序]]></title>
    <url>%2F2017%2F06%2F18%2F2-1%E5%BC%80%E5%A7%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1. 安装IDE以及hello world 一个优秀的IDE可以极大地提高工作效率，在这里我选择使用JetBrains公司的PyCharm。是不是有些眼熟？没错，IDEA 和Android Studio就是他们做的，JetBrains出品，必属精品。 点击进入下载链接 点击download选择相应平台及版本，我这里选择的是社区版。 安装过程，切换主题，调整字体之类的都跟跟IDEA类似，不需赘述。 那么开始我们的hello world程序吧。新建一个Python file ，然后写入 1print (&quot;hello world&quot;) 第一次运行在工作区右击 run即可 之后就会在Toolbar上显示run按钮了 很棒有木有 2.1 先爬他一个网页下来敲入如下代码 1234import urllib2response = urllib2.urlopen(&quot;http://www.baidu.com&quot;)print response.read() 点击运行，我们可以得到结果 这个网页的源码被我们爬下来了，是不是很简单！ 2.2 分析代码下面我们来分析下这段代码 1import urllib2 urllib2库是学习Python爬虫最基本的模块，利用这个模块我们可以得到网页的内容，并对内容用正则表达式提取分析，得到我们想要的结果 1response = urllib2.urlopen(&quot;http://www.baidu.com&quot;) 首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，urlopen一般接受三个参数，它的参数如下： 第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。 第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT 第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。 1print response.read() response对象有一个read方法，可以返回获取到的网页内容 2.3 构造Request上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。我们可以将上面的代码改写为 12345import urllib2request = urllib2.Request(&quot;http://www.baidu.com&quot;)response = urllib2.urlopen(request)print response.read() 运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1使用函数]]></title>
    <url>%2F2017%2F06%2F05%2F1-1%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我们编程时很容易疲劳，所以让我们来设计一个可以在一段时间后提醒你休息的小程序。比如每隔两个小时打开http://lines.frvr.com 此网站来玩一会儿小游戏。 让我们来分析下需要哪些步骤我们首先要让程序等待两个小时，在需要休息的时候打开浏览器并转到这个小游戏的网站。也许我们一天要休息多次，所以我们需要一个循环来让其实现多次。 1231. 等待两小时2. 打开浏览器重复 现在，让我们开始吧~ 首先让我们google一下如何用Python来打开浏览器 1webbrowser.open(&quot;http://lines.frvr.com&quot;) 可以看到上述代码可以使用默认浏览器打开指定网页。 让我们试试吧~保存并执行 出现了错误，不过学过java的你肯定能看懂是什么原因。 导入webbrowser模块就可以正常运行了，不要被这个网站的小游戏吸引走哦，我们还没有结束。 下面我们看看Python如何能让程序等待2小时，为了方便测试，我们把等待时间设置为3秒 可以看到使用time.sleep()方法可以是程序等待一段时间执行，参数以秒为单位所以我们在程序中添加以下代码 1time.sleep(3) 当然也要导入相应模块。 很简单有没有？ 接下来我们来让其循环3次 输入以下代码 12345678910import webbrowserimport timetotal_breaks = 3break_count = 0print(&quot;This program started on&quot; + time.ctime())while(break_count &lt; total_breaks): time.sleep(3) webbrowser.open(&quot;http://lines.frvr.com&quot;) break_count = break_count + 1 代码很简单，首先我们定义了总的休息次数为3，我们又定义了已休息次数初始值为0。接下来是一个while循环，当已休息次数小于总休息次数时执行循环体。最后将已休息次数加1。 值得注意的是while循环并没有花括号。 学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示： 1234if True: print &quot;True&quot;else: print &quot;False&quot; 以下代码将会执行错误： 12345678910#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：test.py if True: print &quot;Answer&quot; print &quot;True&quot;else: print &quot;Answer&quot; # 没有严格缩进，在执行时会报错 print &quot;False&quot; 执行以上代码，会出现如下错误提醒： 12345$ python test.py File &quot;test.py&quot;, line 5 if True: ^IndentationError: unexpected indent IndentationError: unexpected indent 错误是 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有 python 对格式要求非常严格。如果是 IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。因此，在 Python 的代码块中必须使用相同数目的行首缩进空格数。建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0.从零开始，Python的安装]]></title>
    <url>%2F2017%2F06%2F05%2F0-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%8CPython%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[这学期计算机网络课程有一个课程设计，要求使用Python写一个小程序。之前也没接触过Python，从优达学城里看到一个关于Python的课程，在此记录。 Windows安装下载地址：https://www.python.org/downloads/ 确保安装了 pip 并且 Python 添加到了你的 PATH。 要检查安装是否成功，打开 IDLE（Python 安装的一款程序，使你能够轻松地编辑和运行 Python 代码）。 a) Windows 7（及更早版本）：依次点击“开始”菜单&gt;“所有程序”&gt;“Python 2.7”，最后选择 IDLE (Python GUI)。 b) Windows 8/10：搜索 IDLE。目前，你可以从屏幕右侧向左滑动或用鼠标点击屏幕的右下角进行搜索。 MAC安装要在 Mac 机器上安装 Python，你可以采用两种方法：在命令行中使用 Homebrew，或在官网上找到普通的 Python 安装程序。 方法 1：程序包安装程序安装地址：https://www.python.org/downloads/release/python-2713/检查是否安装成功 a) IDLE 应该位于您的应用程序文件夹中。b)通过按下 ⌘+空格键，打开 Spotlight ，并输入“idle”来查找 IDLE 以下是它在我们的计算机上运行的屏幕截图！ 方法 2：Homebrew要通过 Homebrew 安装 Python，只需执行以下两步： 打开终端，并输入命令： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”。 安装过程中，系统会多次发出提示 。安装完 Homebrew 后，你可以通过在命令行中输入 brew help，验证一切是否正常。现在输入 brew install python 获取 Python 2 的最新版本。这样就可以了！ 通过在命令行里输入 python 即可验证 Python 是否安装正确。系统应该欢迎你使用 Python Shell。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
