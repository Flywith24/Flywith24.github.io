<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨云召 | 博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-28T02:50:23.324Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨云召</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【折腾Framework】源码编译与烧写</title>
    <link href="http://yoursite.com/2020/08/18/Framework-Compile/"/>
    <id>http://yoursite.com/2020/08/18/Framework-Compile/</id>
    <published>2020-08-18T06:11:46.000Z</published>
    <updated>2020-08-28T02:50:23.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>环境搭建等内容网上资料很多，这里不再赘述。</p><p>此处以 Pixel 3a &amp; Android 10 为例介绍如何编译 ROM 包并烧录</p><p>手上没有真机的小伙伴可以选择制作模拟器，本文最后提供了基于 Android 10 编译的自定义 AVD 下载链接</p><a id="more"></a><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p><a href="https://source.android.com/setup/build/initializing" target="_blank" rel="noopener">官方文档</a></p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>这里推荐使用 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">清华镜像</a></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200628155443.png" alt></p><p>下载 <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="noopener">每月更新的初始化包</a> 并解压</p><h2 id="下载驱动（可选）"><a href="#下载驱动（可选）" class="headerlink" title="下载驱动（可选）"></a>下载驱动（可选）</h2><p>如果要刷到真机上，需要下载相应机型的驱动，进入 <a href="https://developers.google.com/android/drivers" target="_blank" rel="noopener">该链接</a>，选择相应的机型对应的 Android 版本号和驱动</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200628160058.png" alt></p><p>我这里选择的是 Android 10.0.0（QQ3A.200605.002.A1）</p><p>将两个驱动文件下载并解压，并执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./extract-qcom-sargo.sh</span><br><span class="line">./extract-google_devices-sargo.sh</span><br></pre></td></tr></table></figure><p>点击 Enter 并输入 I ACCEPT 同意 License</p><p>根据 Build 在 <a href="https://source.android.com/setup/start/build-numbers" target="_blank" rel="noopener">该链接</a> 中找到相匹配的分支，本例中对应 <code>android-10.0.0_r39</code></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200628160259.png" alt="QQ3A.200605.002.A1 对应的分支"></p><h2 id="选择分支"><a href="#选择分支" class="headerlink" title="选择分支"></a>选择分支</h2><p>执行完上述操作如果直接编译的话实际上是编译的 master 分支，我们还需要切换到想要编译的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-10.0.0_r39 --depth=1</span><br><span class="line">repo sync -j8</span><br><span class="line">repo start android-10.0.0_r39 --all</span><br></pre></td></tr></table></figure><h2 id="编译与烧写"><a href="#编译与烧写" class="headerlink" title="编译与烧写"></a>编译与烧写</h2><p>在源码目录执行</p><p><code>source build/envsetup.sh</code></p><p><code>lunch</code> 进入菜单</p><p>选择相应的版本</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200628162935.png" alt></p><p>我这里选择的是 19</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>接着便可以进行编译了，可以使用 <code>make -j</code> 命令，其中 j 代表的是编译 job 的数量</p><p>执行（我这里指定了生成 log 文件）</p><p><code>make -j32 2&gt;&amp;1 | tee build_20200628_1635.log</code></p><p>编译成功后会出现一个 out 目录，ROM 镜像文件就在此处</p><p>例如我的路径为：<code>~/aosp/out/target/product/sargo</code></p><h2 id="烧写"><a href="#烧写" class="headerlink" title="烧写"></a>烧写</h2><p>设备进入 bootloader 并执行：<code>fastboot flashall -w</code>，其中 -w 代表清空数据</p><p>烧写成功，开机！</p><h2 id="制作自定义-AVD（Android-Virtual-Devices）-系统镜像"><a href="#制作自定义-AVD（Android-Virtual-Devices）-系统镜像" class="headerlink" title="制作自定义 AVD（Android Virtual Devices） 系统镜像"></a>制作自定义 AVD（Android Virtual Devices） 系统镜像</h2><p>很多小伙伴没有相应的真机，不过可以制作出自定义的 AVD 作为模拟器使用。</p><p><code>lunch</code> 进入菜单时选择相应的模拟器，例如选择上图的 24，64 位的通用设备</p><p>想要制作 AVD 系统镜像需要制作附加 <code>sdk</code> 和 <code>sdk_repo</code> 软件包</p><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make -j32 sdk sdk_repo</span><br></pre></td></tr></table></figure><p>该操作可能会出现异常，例如</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200818135050.png" alt></p><p>这是由于没有编译这些工具导致的，解决办法是依次编译这些工具</p><p>依次输入如下命令，后面工具视情况而定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make libaapt2_jni</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> make dmtracedump</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> make etc1tool</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> make deployagent</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> make aapt</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> make split-select</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> make bcc_compat</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> make apksigner</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> make dx</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> make layoutlib-legacy</span><br></pre></td></tr></table></figure><p>编译好相关工具我们再次执行 <code>make -j32 sdk sdk_repo</code></p><p>编译成功后会在 <code>out/host/linux-x86/sdk/aosp_x86_64</code> 目录下生成 <code>sdk-repo-linux-system-images-eng.[username].zip</code> 文件</p><p>按照官方文档中使用镜像的方式我没有成功</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200818135851.png" alt></p><p>这里我使用了一个取巧的方式</p><p>我们在 Android Studio 创建 AVD 时可选的镜像一般有三种，这里还是以 Android 10 为例</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200818140305.png" alt></p><p>Google Play，Google APIs，和默认的</p><p>它们会下载到 SDK/system-images/android-29 中</p><p>Google APIs 版本对应的目录就是 google_apis</p><p>我们可以将我们编译出的 AVD 镜像 copy 到其中的一个目录</p><p>例如，我将自定义的 AVD 镜像放置在了这里：</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200818140734.png" alt></p><p>我们在创建模拟器时选择自定义的 AVD 镜像即可创建出自己编译 ROM  的模拟器</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200818141020.png" alt></p><p>这里提供了我编译出来的自定义 AVD，不方便自己编译的小伙伴可以在此处下载</p><p>链接：<a href="https://pan.baidu.com/s/1LIcuycoU4Ou42VsSBM_MuQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1LIcuycoU4Ou42VsSBM_MuQ</a><br>提取码：CAVD</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;环境搭建等内容网上资料很多，这里不再赘述。&lt;/p&gt;
&lt;p&gt;此处以 Pixel 3a &amp;amp; Android 10 为例介绍如何编译 ROM 包并烧录&lt;/p&gt;
&lt;p&gt;手上没有真机的小伙伴可以选择制作模拟器，本文最后提供了基于 Android 10 编译的自定义 AVD 下载链接&lt;/p&gt;
    
    </summary>
    
    
      <category term="ROM" scheme="http://yoursite.com/categories/ROM/"/>
    
    
      <category term="ROM" scheme="http://yoursite.com/tags/ROM/"/>
    
      <category term="framework" scheme="http://yoursite.com/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>【奇技淫巧】使用 ProcessLifecycle 优雅地监听应用前后台切换</title>
    <link href="http://yoursite.com/2020/07/01/Tips-ProcessLifecycle/"/>
    <id>http://yoursite.com/2020/07/01/Tips-ProcessLifecycle/</id>
    <published>2020-07-01T06:11:46.000Z</published>
    <updated>2020-08-28T02:39:35.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴见到你，又来到了「奇技淫巧」系列，本系列介绍一些「骚操作」，可能不适合用于生产，但可以开拓思路</p><p>前些天在群里看到有人讨论通过维护 activity 栈来监听程序前后台切换的问题。其实单纯监听程序的前后台切换完全不需要维护 activity 栈，而现在比较主流的做法是使用 <code>registerActivityLifecycleCallbacks</code>。而今天我来介绍一下使用 ProcessLifecycleOwner 来实现这一功能</p><h2 id="lifecycle-process-库"><a href="#lifecycle-process-库" class="headerlink" title="lifecycle-process 库"></a>lifecycle-process 库</h2><p>Android Jetpack Lifecycle 组件有一个可选库：lifecycle-process，它可以为整个 app 进程提供一个 ProcessLifecycleOwner</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200701110431.png" alt="lifecycle-process 引入"></p><p>该库十分简单，只有四个文件</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200701110904.png" alt="lifecycle-process"></p><p><code>ProcessLifecycleOwnerInitializer</code> 借助 ContentProvider 拿到 Context，用于初始化操作</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200701112017.png" alt="init"></p><p><code>EmptyActivityLifecycleCallbacks</code> 为 <code>Application.ActivityLifecycleCallbacks</code> 的实现类，内部为空实现</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200701112219.png" alt="EmptyActivityLifecycleCallbacks"></p><p><code>LifecycleDispatcher</code> 通过 ReportFragment 来 hook 宿主的生命周期事件</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200701113143.png" alt></p><p>核心逻辑都在 ProcessLifecycleOwner 中</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200701113324.png" alt="ProcessLifecycleOwner "></p><p>该类提供了整个 app 进程的 lifecycle</p><p>可以将其视为所有 activity 的 LifecycleOwner ，其中 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_CREATE" target="_blank" rel="noopener">Lifecycle.Event.ON_CREATE</a> 只会分发一次，而 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_DESTROY" target="_blank" rel="noopener">Lifecycle.Event.ON_DESTROY</a> 则永远不会分发</p><p>其它的生命周期事件将按以下规则分发：</p><p><code>ProcessLifecycleOwner</code> 会分发 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_START" target="_blank" rel="noopener">Lifecycle.Event.ON_START</a> 和 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_RESUME" target="_blank" rel="noopener">Lifecycle.Event.ON_RESUME</a> 事件（在第一个 activity 移动到这些事件时）</p><p><a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_PAUSE" target="_blank" rel="noopener">Lifecycle.Event.ON_PAUSE</a> 与 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_STOP" target="_blank" rel="noopener">Lifecycle.Event.ON_STOP</a> 会在最后一个 activity 移动到这些状态后 <strong>延迟</strong> 分发，该延迟足够长，以确保由于配置更改等操作重建 activity 后不会分发任何事件</p><p>对于监听应用在前后台切换且不需要毫秒级的精度的场景，这十分有用</p><h2 id="ProcessLifecycleOwner-源码解析"><a href="#ProcessLifecycleOwner-源码解析" class="headerlink" title="ProcessLifecycleOwner  源码解析"></a>ProcessLifecycleOwner  源码解析</h2><p>根据上图我们得知 <code>ProcessLifecycleOwner</code>  实现了 LifecycleOwner 接口</p><p>由于在 <code>ProcessLifecycleOwnerInitializer</code> 中初始化时传入了 Context，因此 <code>ProcessLifecycleOwner</code>  在 attach 方法中借助 Context 拿到了 Application 实例，并调用了 <code>registerActivityLifecycleCallbacks</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">    mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    Application app = (Application) context.getApplicationContext();</span><br><span class="line">    app.registerActivityLifecycleCallbacks(<span class="keyword">new</span> EmptyActivityLifecycleCallbacks() </span><br><span class="line">        <span class="meta">@RequiresApi</span>(<span class="number">29</span>)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPreCreated</span><span class="params">(@NonNull Activity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">                @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//我们需要 ProcessLifecycleOwner 刚好在第一个 activity 的 LifecycleOwner started/resumed 之前获取 ON_START 和 ON_RESUME。</span></span><br><span class="line">            <span class="comment">//activity 的 LifecycleOwner 通过在 onCreate() 中添加 activity 注册的 callback 来获取 started/resumed 状态。</span></span><br><span class="line">            <span class="comment">//通过在 onActivityPreCreated() 中添加我们自己的 activity 注册的 callback，我们首先获得了回调，同时与 Activity 的 onStart()/ onResume()回调相比仍具有正确的相对顺序</span></span><br><span class="line">     </span><br><span class="line">            activity.registerActivityLifecycleCallbacks(<span class="keyword">new</span> EmptyActivityLifecycl</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostStarted</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">                    activityStarted();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostResumed</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">                    activityResumed();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceStat</span></span></span><br><span class="line"><span class="function"><span class="params">            //仅在API <span class="number">29</span> 之前使用 ReportFragment，在此之后，我们可以使用在 onActivityPreCreated()</span> 中注册的 onActivityPostStarted 和 onActivityPostResumed 回调</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(Build.VERSION.SDK_INT &lt; <span class="number">29</span>)</span> </span>&#123;</span><br><span class="line">                ReportFragment.get(activity).setProcessListener(mInitializationLi</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            activityPaused();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            activityStopped();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部维护了 Started 和 Resumed 的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mStartedCounter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mResumedCounter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mPauseSent = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mStopSent = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>并在 activityStarted 和 activityResumed 方法中对 这两个数值进行 ++，并更改 lifecycle 状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mStartedCounter++;</span><br><span class="line">    <span class="keyword">if</span> (mStartedCounter == <span class="number">1</span> &amp;&amp; mStopSent) &#123;</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">        mStopSent = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityResumed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mResumedCounter++;</span><br><span class="line">    <span class="keyword">if</span> (mResumedCounter == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPauseSent) &#123;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class="line">            mPauseSent = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mHandler.removeCallbacks(mDelayedPauseRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 activityPaused 和 activityStopped 方法对这两个数值进行 –</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mResumedCounter--;</span><br><span class="line">    <span class="keyword">if</span> (mResumedCounter == <span class="number">0</span>) &#123;</span><br><span class="line">        mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityStopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mStartedCounter--;</span><br><span class="line">    dispatchStopIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这里我们看到了上文提到的延迟操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 handler 进行延迟操作</span></span><br><span class="line">mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟 700 ms</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMEOUT_MS = <span class="number">700</span>; <span class="comment">//mls</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Runnable mDelayedPauseRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据需要分发事件</span></span><br><span class="line">        dispatchPauseIfNeeded();</span><br><span class="line">        dispatchStopIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchPauseIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mResumedCounter == <span class="number">0</span>) &#123;</span><br><span class="line">        mPauseSent = <span class="keyword">true</span>;</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchStopIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStartedCounter == <span class="number">0</span> &amp;&amp; mPauseSent) &#123;</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class="line">        mStopSent = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码就解析到这里，接下来我们看看如何使用吧</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先引入该库</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-process:2.3.0-alpha05"</span></span><br></pre></td></tr></table></figure><p>由于我们要自定义 lifecycleObserver，因此还需引入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-common-java8:2.3.0-alpha05"</span></span><br></pre></td></tr></table></figure><p>首先创建 <code>ProcessLifecycleObserver</code> 类，实现 <code>DefaultLifecycleObserver</code> 接口，在相应的生命周期中打印 log</p><p>接着在自定义 Application 中加入</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200701121028.png" alt></p><p>这样便完成了！</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/1/173089686a09e8f3?w=1854&h=999&f=gif&s=2823298" alt="演示"></p><p><a href="https://github.com/Flywith24/ProcessLifecycle-Demo" target="_blank" rel="noopener">Demo 在这里</a></p><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案</a></li></ul><ul><li><a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></li></ul><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你</a></li></ul><ul><li><a href="https://juejin.im/post/5e967f35f265da47d77cd4c3" target="_blank" rel="noopener">【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转</a></li></ul><ul><li><a href="https://juejin.im/post/5ebdfb0b6fb9a0436153db22" target="_blank" rel="noopener">【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil</a></li></ul><ul><li><a href="https://juejin.im/post/5ec50ae46fb9a047a862124f" target="_blank" rel="noopener">【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化</a></li></ul><ul><li><a href="https://juejin.im/post/5ecde219e51d457841190d08" target="_blank" rel="noopener">【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</a></li></ul><ul><li><a href="https://juejin.im/post/5ed9c92ce51d45789b35afa9" target="_blank" rel="noopener">【奇技淫巧】巧用 kotlin 扩展函数和 typealias 封装 带网络状态和解决「粘性」事件的 LiveData</a></li></ul><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;很高兴见到你，又来到了「奇技淫巧」系列，本系列介绍一些「骚操作」，可能不适合用于生产，但可以开拓思路&lt;/p&gt;
&lt;p&gt;前些天在群里看到有人讨论
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/categories/Tips/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="http://yoursite.com/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化</title>
    <link href="http://yoursite.com/2020/05/20/Tips-Navagion+DynamicFeatureModule/"/>
    <id>http://yoursite.com/2020/05/20/Tips-Navagion+DynamicFeatureModule/</id>
    <published>2020-05-20T06:11:46.000Z</published>
    <updated>2020-08-28T02:36:26.651Z</updated>
    
    <content type="html"><![CDATA[<p><code>androidx navigation 2.3.0</code> 加入了对 <code>dynamic feature module</code> 的导航支持，因此我们利用这个来分离出多个功能 module 来实现模块化</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520170621.png" alt="navigation 2.3.0 更新"></p><a id="more"></a><h2 id="国内基本不用的-dynamic-feature-module"><a href="#国内基本不用的-dynamic-feature-module" class="headerlink" title="国内基本不用的 dynamic feature module"></a>国内基本不用的 dynamic feature module</h2><p><a href="https://developer.android.com/guide/app-bundle" target="_blank" rel="noopener">Android App Bundle</a> 是官方 18 年推出的动态发布方案，类似国内各种插件化方案。不过它需要 Google Play Store 支持，这导致在国内无法使用</p><p>借着 navigation 组件支持 <code>dynamic feature module</code> 间导航的契机，我们可以使用 <code>dynamic feature module</code> 来拆分功能模块以实现模块化</p><p>传统的拆分方案大概是这样，feature module 之间相互隔离，app module 依赖各个 feature module 间接依赖 base 库，公共库</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520165717.png" alt="传统架构"></p><p>而使用 <code>dynamic feature module</code> ，其结构是这样的</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520172609.png" alt="dynamic feature 架构"></p><p><code>dynamic feature module</code> 也可以按需安装，也就是说，它们可能不包含在用户最初下载的 APK 中，而是在运行时安装。而我们可以直接将它们包含到 APK 中</p><h2 id="使用-dynamic-feature-module"><a href="#使用-dynamic-feature-module" class="headerlink" title="使用 dynamic feature module"></a>使用 dynamic feature module</h2><p>首先我们在 base lib 中引入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> nav_version = <span class="string">"2.3.0-alpha06"</span></span><br><span class="line"></span><br><span class="line">    api <span class="string">"androidx.navigation:navigation-fragment-ktx:$nav_version"</span></span><br><span class="line">    api <span class="string">"androidx.navigation:navigation-ui-ktx:$nav_version"</span></span><br><span class="line">    api <span class="string">"androidx.navigation:navigation-dynamic-features-fragment:$nav_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 app module 中的 res/navigation 目录下创建 main_nav.xml</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520173227.png" alt="main_nav.xml"></p><p>接着我们在 activity_main 中设置默认的 host</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520173336.png" alt="默认 host"></p><blockquote><p>这里不同于正常 navigation 的用法，没有使用 NavHostFragment，而是使用 DynamicNavHostFragment</p></blockquote><h3 id="直接跳转-fragment"><a href="#直接跳转-fragment" class="headerlink" title="直接跳转 fragment"></a>直接跳转 fragment</h3><p>我们创建 dynamic feature module ，取名为 feature1</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520174302.gif" alt="创建 dynamic feature module"></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520174505.png" alt="包名前部分需保证与 applicationId 相同"></p><blockquote><p>这里 <code>dynamic feature module</code> 的包名前部分要和 applicationId 即 app module 包名相同，否则后续的 include 操作会有问题</p></blockquote><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520174757.png" alt="选择加载模式"></p><p>这里我们选择在安装时集成该 module</p><p>接着我们在该 module 下创建一个 fragment 取名为 <code>Feature1OneFragment</code></p><p>之后我们直接在 main_nav.xml 中引入 该 fragment 并加入 action</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520175351.png" alt="直接引入 fragment"></p><p>接着我们就可以在 app 下的 MainFragment 打开 Feature1OneFragment</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520175841.gif" alt="启动 fragment"></p><blockquote><p>我的 demo 中 feature2 是直接引入 fragment，因此跳转的是 Feature2OneFragment</p></blockquote><h3 id="直接跳转-activity"><a href="#直接跳转-activity" class="headerlink" title="直接跳转 activity"></a>直接跳转 activity</h3><p>在 feature1 中创建 activity (demo 中为 feature2)</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520180201.png" alt="跳转 activity"></p><p>同样需要指定 moduleName</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520180434.gif" alt="启动activity"></p><h3 id="使用-dynamic-feature-module-内部的-graph"><a href="#使用-dynamic-feature-module-内部的-graph" class="headerlink" title="使用 dynamic feature module 内部的 graph"></a>使用 dynamic feature module 内部的 graph</h3><p>我们可以为 dynamic feature module 单独配置 navigation graph，这样就可以处理 dynamic feature module 内部的跳转了</p><p>在 feature1 中创建 feature1_nav.xml ，其中 startDestination 为 Feature1OneFragment</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520181021.png" alt="feature1_nav.xml"></p><p>在 main_nav.xml 我们需要使用另外一种方式来使用该 graph</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520181145.png" alt="include-dynamic"></p><p>我们使用了一个新的标签 <code>include-dynamic</code>，同时我们看到了几个没用过的属性</p><ul><li><code>graphPackage</code> 为 <code>dynamic feature module</code> 的包名</li><li><code>graphResName</code> 为 <code>dynamic feature module</code> 内部 graph 的名字</li><li><code>moduleName</code> 为 module 名</li></ul><blockquote><p>注意：这里的 graphPackage 可以省略</p><ol><li>如果 module 的包名没用按照前文的格式配置会导致无法找到 graphId 的异常</li><li>include-dynamic 标签的 id 要与 <code>feature1_nav.xml</code> navigation 标签下的 id 一致，或者后者不设置 id</li></ol></blockquote><p>这样从 app module 导航到 feature1 的 startDestination 后便可使用其内部的逻辑进行后续的导航了</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520182339.gif" alt="include 跳转"></p><h2 id="feature-module-间跳转"><a href="#feature-module-间跳转" class="headerlink" title="feature module 间跳转"></a>feature module 间跳转</h2><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200520182529.png" alt="暂不支持 deep link"></p><p>Navigation 组件暂不支持 Dynamic include graph 的 deep link</p><p>因此我目前也没有找到特别优雅的方式，已知的方案如下</p><ul><li>反射</li><li>使用 <a href="https://developer.android.com/reference/java/util/ServiceLoader" target="_blank" rel="noopener">ServiceLoader</a></li><li>使用依赖注入</li></ul><p><a href="https://github.com/Flywith24/DynamicFeatureDemo" target="_blank" rel="noopener">demo</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;androidx navigation 2.3.0&lt;/code&gt; 加入了对 &lt;code&gt;dynamic feature module&lt;/code&gt; 的导航支持，因此我们利用这个来分离出多个功能 module 来实现模块化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/flywith24/Album/raw/master/img/20200520170621.png&quot; alt=&quot;navigation 2.3.0 更新&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/categories/Tips/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="http://yoursite.com/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil</title>
    <link href="http://yoursite.com/2020/05/18/Tips-Coil/"/>
    <id>http://yoursite.com/2020/05/18/Tips-Coil/</id>
    <published>2020-05-18T06:11:46.000Z</published>
    <updated>2020-08-28T02:36:58.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新的图片加载库——Coil"><a href="#新的图片加载库——Coil" class="headerlink" title="新的图片加载库——Coil"></a>新的图片加载库——Coil</h2><p><a href="https://coil-kt.github.io/coil/" target="_blank" rel="noopener">Coil</a> 是 <a href="https://www.instacart.com/" target="_blank" rel="noopener">Instacart</a> 团队研发的新的的图片加载库，它使用了很多高级功能，例如协程，<code>Okhttp</code>，<code>androidx.lifecycle</code>。<code>Coil</code> 还包括一些高级功能，例如图像采样，有效的内存使用以及请求的自动取消/暂停</p><p>默认情况下 <code>Coil</code> 与 R8 完全兼容，开箱即用，不需要添加额外的规则。如果使用 Proguard ，您可能需要为 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/resources/META-INF/proguard/coroutines.pro" target="_blank" rel="noopener">Coroutines</a>, <a href="https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro" target="_blank" rel="noopener">OkHttp</a> 和 <a href="https://github.com/square/okio/blob/master/okio/src/jvmMain/resources/META-INF/proguard/okio.pro" target="_blank" rel="noopener">Okio</a> 添加规则</p><h2 id="Coil-的优势"><a href="#Coil-的优势" class="headerlink" title="Coil 的优势"></a>Coil 的优势</h2><ul><li>快速：<code>Coil</code> 进行了很多优化，包括内存和磁盘缓存，对内存中的图像进行采样，重新使用位图，自动暂停/取消请求等等</li><li>轻量：<code>Coil</code> 在您的APK中添加了约 2000 种方法（对于已经使用 <code>OkHttp</code> 和 <code>Coroutines</code> 的应用程序），与 <code>Picasso</code> 相当，远少于 <code>Glide</code> 和 <code>Fresco</code></li><li>易用：<code>Coil</code> 的 API 利用 Kotlin 的特性简化了样板代码</li><li>现代：<code>Coil</code> 是 <code>Kotlin-first</code>，使用现代化的库，例如 <code>Coroutines</code>, <code>OkHttp</code>, <code>Okio</code>, 以及 <code>AndroidX Lifecycles</code></li></ul><p><code>Coil</code> 是以下名称的缩写：<strong>Coroutine Image Loader</strong></p><h2 id="Artifacts"><a href="#Artifacts" class="headerlink" title="Artifacts"></a>Artifacts</h2><p><code>Coil</code> 拥有 5 个 artifact 并发布在 <code>mavenCentral()</code></p><ul><li><code>io.coil-kt:coil</code>：依赖于  <code>io.coil-kt:coil-base</code> 并且包含了 <code>Coil</code> 的单例和  <code>ImageView.load</code> 的扩展函数</li><li><code>io.coil-kt:coil-base</code>：base 库，<strong>不包含</strong> <code>Coil</code> 的单例和  <code>ImageView.load</code> 的扩展函数，如果使用依赖注入，则可以使用该库</li><li><code>io.coil-kt:coil-gif</code>：引入一系列解码器以支持解码 gif</li><li><code>io.coil-kt:coil-svg</code>：引入一系列解码器以支持 svg</li><li><code>io.coil-kt:coil-video</code>：包括两个 <a href="https://coil-kt.github.io/coil/api/coil-base/coil.fetch/-fetcher" target="_blank" rel="noopener">fetchers</a> ，以支持从 Android 支持的任何视频格式中提取和解码帧</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通使用引用</span></span><br><span class="line">implementation <span class="string">"io.coil-kt:coil:0.11.0"</span></span><br><span class="line"><span class="comment">// 使用依赖注入时或者制作基于 coil 的库引用</span></span><br><span class="line">implementation <span class="string">"io.coil-kt:coil-base:0.11.0"</span></span><br></pre></td></tr></table></figure><h2 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h2><p><code>Coil</code> 要求 Java 8，要通过 D8 启用 Java 8 调试，请将以下内容添加到 Gradle 脚本</p><p>Gradle (<code>.gradle</code>)</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        jvmTarget = <span class="string">"1.8"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gradle Kotlin DSL (<code>.gradle.kts</code>)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType&lt;KotlinCompile&gt; &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        jvmTarget = <span class="string">"1.8"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="ImageView-扩展函数"><a href="#ImageView-扩展函数" class="headerlink" title="ImageView 扩展函数"></a>ImageView 扩展函数</h3><p><code>io.coil-kt:coil</code> 提供了 类型安全的 ImageView 扩展函数</p><p>在 ImageView 中加载图片，只需调用 load 扩展函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL</span></span><br><span class="line">imageView.load(<span class="string">"https://www.example.com/image.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resource</span></span><br><span class="line">imageView.load(R.drawable.image)</span><br><span class="line"></span><br><span class="line"><span class="comment">// File</span></span><br><span class="line">imageView.load(File(<span class="string">"/path/to/image.jpg"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// And more...</span></span><br></pre></td></tr></table></figure><p>上面的请求等价于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> imageLoader = Coil.imageLoader(context)</span><br><span class="line"><span class="keyword">val</span> request = LoadRequest.Builder(imageView.context)</span><br><span class="line">    .<span class="keyword">data</span>(<span class="string">"https://www.example.com/image.jpg"</span>)</span><br><span class="line">    .target(imageView)</span><br><span class="line">    .build()</span><br><span class="line">imageLoader.execute(request)</span><br></pre></td></tr></table></figure><p>可选的请求配置可以通过 lambda 来操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">imageView.load(<span class="string">"https://www.example.com/image.jpg"</span>) &#123;</span><br><span class="line">    crossfade(<span class="literal">true</span>)</span><br><span class="line">    placeholder(R.drawable.image)</span><br><span class="line">    transformations(CircleCropTransformation())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Image-Loaders¶"><a href="#Image-Loaders¶" class="headerlink" title="Image Loaders¶"></a>Image Loaders<a href="https://coil-kt.github.io/coil/#image-loaders" target="_blank" rel="noopener">¶</a></h3><p><code>ImageLoader</code> 是执行请求的服务类。 他们处理缓存，数据获取，图像解码，请求管理，bitmap pool，内存管理等。 可以使用 builder 来创建和配置新实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> imageLoader = ImageLoader.Builder(context)</span><br><span class="line">    .availableMemoryPercentage(<span class="number">0.25</span>)</span><br><span class="line">    .crossfade(<span class="literal">true</span>)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure><p>imageView.load 使用单例 <code>ImageLoader</code> 执行 <code>LoadRequest</code> 。 可以使用以下方式访问单例 <code>ImageLoader</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> imageLoader = Coil.imageLoader(context)</span><br></pre></td></tr></table></figure><p>（可选）您可以创建自己的ImageLoader实例，并通过依赖项注入将它们注入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> imageLoader = ImageLoader(context)</span><br></pre></td></tr></table></figure><p>当您创建单个 <code>ImageLoader</code> 并在整个应用程序中共享时，<code>Coil</code> 的性能最佳。 这是因为每个 <code>ImageLoader</code> 都有自己的内存缓存，bitmap pool 和网络监听</p><h3 id="Requests¶"><a href="#Requests¶" class="headerlink" title="Requests¶"></a>Requests<a href="https://coil-kt.github.io/coil/#requests" target="_blank" rel="noopener">¶</a></h3><p>有两种 Request 类型</p><ul><li><a href="https://coil-kt.github.io/coil/api/coil-base/coil.request/-load-request/" target="_blank" rel="noopener"><code>LoadRequest</code></a> 是一个生命周期范围的 request，支持 <a href="https://coil-kt.github.io/coil/api/coil-base/coil.target/-target/" target="_blank" rel="noopener"><code>Target</code></a>，<a href="https://coil-kt.github.io/coil/api/coil-base/coil.transition/-transition/" target="_blank" rel="noopener"><code>Transition</code></a> 等等</li><li><a href="https://coil-kt.github.io/coil/api/coil-base/coil.request/-get-request/" target="_blank" rel="noopener"><code>GetRequest</code></a> 挂起并返回  <a href="https://coil-kt.github.io/coil/api/coil-base/coil.request/-request-result/" target="_blank" rel="noopener"><code>RequestResult</code></a></li></ul><p>如果要加载到自定义 target 中，可以执行 <code>LoadRequest</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = LoadRequest.Builder(context)</span><br><span class="line">    .<span class="keyword">data</span>(<span class="string">"https://www.example.com/image.jpg"</span>)</span><br><span class="line">    .target &#123; drawable -&gt;</span><br><span class="line">        <span class="comment">// Handle the result.</span></span><br><span class="line">    &#125;</span><br><span class="line">    .build()</span><br><span class="line">imageLoader.execute(request)</span><br></pre></td></tr></table></figure><p>要强制获取图像，请执行GetRequest：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = GetRequest.Builder(context)</span><br><span class="line">    .<span class="keyword">data</span>(<span class="string">"https://www.example.com/image.jpg"</span>)</span><br><span class="line">    .build()</span><br><span class="line"><span class="keyword">val</span> drawable = imageLoader.execute(request).drawable</span><br></pre></td></tr></table></figure><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>如果您使用的是 <code>io.coil-kt:coil</code> ，您可以使用以下任意方式设置 <code>ImageLoader</code> 的实例</p><p>在 Application 中实现 <code>ImageLoaderFactory</code>（推荐）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="type">Application</span></span>(), ImageLoaderFactory &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newImageLoader</span><span class="params">()</span></span>: ImageLoader &#123;</span><br><span class="line">        <span class="keyword">return</span> ImageLoader.Builder(context)</span><br><span class="line">            .crossfade(<span class="literal">true</span>)</span><br><span class="line">            .okHttpClient &#123;</span><br><span class="line">                OkHttpClient.Builder()</span><br><span class="line">                    .cache(CoilUtils.createDefaultCache(context))</span><br><span class="line">                    .build()</span><br><span class="line">            &#125;</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 Coil.setImageLoader</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> imageLoader = ImageLoader.Builder(context)</span><br><span class="line">    .crossfade(<span class="literal">true</span>)</span><br><span class="line">    .okHttpClient &#123;</span><br><span class="line">        OkHttpClient.Builder()</span><br><span class="line">            .cache(CoilUtils.createDefaultCache(context))</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line">    .build()</span><br><span class="line">Coil.setImageLoader(imageLoader)</span><br></pre></td></tr></table></figure><p>默认的 <code>ImageLoader</code> 可以通过这样取回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> imageLoader = Coil.imageLoader(context)</span><br></pre></td></tr></table></figure><p>设置默认的 <code>ImageLoader</code> 是可选的。 如果未设置，则 <code>Coil</code> 会延迟创建具有默认值的 <code>ImageLoader</code></p><p>如果您使用的是 <code>io.coil-kt:coil-base</code>，您应创建自己的 <code>ImageLoader</code> 实例并通过依赖注入将它注入到 app 中</p><blockquote><p>注意：如果设置自定义OkHttpClient，则必须设置缓存实现，否则ImageLoader将没有磁盘缓存。 可以使用CoilUtils.createDefaultCache 创建默认的 Coil 缓存实例</p></blockquote><h2 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h2><p>ImageLoader 支持的数据类型为</p><ul><li>String (mapped to a Uri)</li><li>HttpUrl</li><li>Uri (<code>android.resource</code>, <code>content</code>, <code>file</code>, <code>http</code>, and <code>https</code> schemes only)</li><li>File</li><li>@DrawableRes Int</li><li>Drawable</li><li>Bitmap</li></ul><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>如果要预加载到内存中，执行一个不带 target 的 <code>LoadRequest</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = LoadRequest.Builder(context)</span><br><span class="line">    .<span class="keyword">data</span>(<span class="string">"https://www.example.com/image.jpg"</span>)</span><br><span class="line">    <span class="comment">// 可选的，但是设置 ViewSizeResolver 可以通过限制预加载的大小来节省内存</span></span><br><span class="line">    .size(ViewSizeResolver(imageView))</span><br><span class="line">    .build()</span><br><span class="line">imageLoader.execute(request)</span><br></pre></td></tr></table></figure><p>如果只想将网络图片预加载到磁盘中，可以为 request 关闭内存缓存</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = LoadRequest.Builder(context)</span><br><span class="line">    .<span class="keyword">data</span>(<span class="string">"https://www.example.com/image.jpg"</span>)</span><br><span class="line">    .memoryCachePolicy(CachePolicy.DISABLED)</span><br><span class="line">    .build()</span><br><span class="line">imageLoader.execute(request)</span><br></pre></td></tr></table></figure><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><p><code>LoadRequest</code> 会自动取消在以下几种情况下</p><ul><li><p>关联的 view detached，</p></li><li><p>关联的 lifecycle destroyed</p></li><li><p>另一个 request  在相同的 view 中开启</p></li></ul><p>此外，每个 <code>LoadRequest</code> 返回一个 <code>RequestDisposable</code>，可用于检查请求是否在运行中或处理该请求（有效地取消请求并释放其关联资源）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> disposable = imageView.load(<span class="string">"https://www.example.com/image.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel the request.</span></span><br><span class="line">disposable.dispose()</span><br></pre></td></tr></table></figure><p><code>GetRequest</code> 仅当协程的上下文被取消时才会取消</p><h2 id="图片采样"><a href="#图片采样" class="headerlink" title="图片采样"></a>图片采样</h2><p>假设磁盘上有一个 500x500 的映像，但是只需要以 100x100 的大小将其加载到内存中即可在视图中显示。 <code>Coil</code> 会将图像加载到内存中，但是如果您需要 500x500 的图像会怎样呢？ 从磁盘读取还有更好的「质量」，但是图像已经以 100x100 加载到内存中。 理想情况下，当我们从磁盘以 500x500 读取图像时，我们将使用 100x100 图像作为占位符。</p><p>这正是 <code>Coil</code> 所做的，并且 <code>Coil</code> 自动为所有 <code>BitmapDrawables</code> 处理此过程。 与 <code>crossfade(true)</code> 搭配使用时，可以创建视觉效果，使图像细节看起来像淡入淡出，类似于渐进式 JPEG</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/15/1721615615eb45ef?w=600&h=1067&f=gif&s=4714987" alt></p><h2 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h2><ul><li>AndroidX</li><li>Min SDK 14+</li><li>Compile SDK: 29+</li><li><a href="https://coil-kt.github.io/coil/getting_started/#java-8" target="_blank" rel="noopener">Java 8+</a></li></ul><p>详细内容移步 <a href="https://coil-kt.github.io/coil/" target="_blank" rel="noopener">官方文档</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;新的图片加载库——Coil&quot;&gt;&lt;a href=&quot;#新的图片加载库——Coil&quot; class=&quot;headerlink&quot; title=&quot;新的图片加载库——Coil&quot;&gt;&lt;/a&gt;新的图片加载库——Coil&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://coil-kt.g
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/categories/Tips/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="http://yoursite.com/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>【Jetpack更新之Fragment】setRetainInstance 被弃用，那么 fragment 是如何保存状态的？</title>
    <link href="http://yoursite.com/2020/04/30/Jetpack-fragment-savestate/"/>
    <id>http://yoursite.com/2020/04/30/Jetpack-fragment-savestate/</id>
    <published>2020-04-29T16:10:35.000Z</published>
    <updated>2020-08-28T02:06:52.108Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道 fragment 中的 <code>setRetainInstance</code> 用于控制是否在 activity 保留 fragment 实例，具体内容可参见 <a href="https://www.wanandroid.com/wenda/show/12574" target="_blank" rel="noopener">WanAndroid 的每日一问：Fragment 是如何被存储与恢复的？</a></p><p>但是该方法已于 <code>androidx fragment 1.3.0-alpha01</code> 弃用了</p><a id="more"></a><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200422093129.png" alt></p><p>老规矩，我们查看一下 commit log</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200422094533.png" alt></p><p>简单概况一下</p><p><code>SetRetainInstance</code> 尝试在 activity 重建时保存状态。但它带来了很多副作用。</p><p>随着 <code>ViewModel</code> 的引入，开发者拥有一个特定的 API，用于保留与 Activity，Fragments 和 Navigation 相关联的状态。 这使开发者可以使用正常的，不需要保留 fragment ，从而在保存单个需要的属性时避免了常见的泄漏源，并且可以销毁保存的状态（即 <code>ViewModel</code> 的构造器和 <code>onCleared</code> 回调）</p><p>详情可参见 <a href="https://juejin.im/post/5e738d12518825495d69cfb9" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a> 和 <a href="https://juejin.im/post/5e786d415188255e00661a4e" target="_blank" rel="noopener">【背上Jetpack之ViewModel】即使您不使用MVVM也要了解ViewModel ——ViewModel 的职能边界</a></p><p>从这个改动可以看出官方正致力于保证逻辑的单一性，状态保存交给 <code>ViewModel</code> ，减少这种特殊的例外情况，从而消除一些不符合预期的问题</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img src="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道 fragment 中的 &lt;code&gt;setRetainInstance&lt;/code&gt; 用于控制是否在 activity 保留 fragment 实例，具体内容可参见 &lt;a href=&quot;https://www.wanandroid.com/wenda/show/12574&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WanAndroid 的每日一问：Fragment 是如何被存储与恢复的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是该方法已于 &lt;code&gt;androidx fragment 1.3.0-alpha01&lt;/code&gt; 弃用了&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
      <category term="Fragment" scheme="http://yoursite.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>【Jetpack更新之Fragment】1.3.0-alpha04 来袭，Fragment 间通信的新姿势</title>
    <link href="http://yoursite.com/2020/04/30/Jetpack-fragment-ResultAPI/"/>
    <id>http://yoursite.com/2020/04/30/Jetpack-fragment-ResultAPI/</id>
    <published>2020-04-29T16:10:35.000Z</published>
    <updated>2020-08-28T01:59:56.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>fragment 1.3.0-alpha04</code> 发布了，其中有很多变动，其中提供了 fragment 间传递数据的新方式</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200430090529.png" alt="1.3.0-alpha04 更新"></p><a id="more"></a><h3 id="API-更改"><a href="#API-更改" class="headerlink" title="API 更改"></a>API 更改</h3><p>首先我们介绍一下 API 更改</p><ul><li><code>startActivityForResult()</code>/<code>onActivityResult()</code> 和 <code>requestPermissions()</code>/<code>onRequestPermissionsResult()</code> 弃用</li><li><code>prepareCall()</code> 重命名为 <code>registerForActivityResult()</code> </li><li><code>target fragment API</code> 被弃用</li></ul><h3 id="Activity-Result-API-上位"><a href="#Activity-Result-API-上位" class="headerlink" title="Activity Result API 上位"></a>Activity Result API 上位</h3><p>由于官方提供了 <strong>Activity Result API</strong> 来替换 <strong>onActivityResult</strong>  机制，因此 fragment 的  <code>startActivityForResult()</code>/<code>onActivityResult()</code> 和 <code>requestPermissions()</code>/<code>onRequestPermissionsResult()</code> 方法被标记弃用了</p><p><strong>Activity Result API</strong> 详情可参考 <a href="https://juejin.im/user/586eff908d6d81005879507d" target="_blank" rel="noopener">秉心说</a> 的 <a href="https://juejin.im/post/5e80cb1ee51d45471654fae7" target="_blank" rel="noopener">是时候丢掉 onActivityResult 了 ！</a></p><p>文章介绍的很详尽，这里不再赘述</p><h3 id="prepareCall-重命名"><a href="#prepareCall-重命名" class="headerlink" title="prepareCall 重命名"></a>prepareCall 重命名</h3><p>值得注意的地方是 <code>prepareCall()</code> 被命名为 <code>registerForActivityResult()</code> </p><blockquote><p>注意：在版本处于 Alpha 版状态时，可以添加、移除或更改 API。因此 Alpha 版本不适合在生产上使用</p></blockquote><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200430091418.png" alt="来自我的另一篇博客"></p><h3 id="target-fragment-API-被弃用"><a href="#target-fragment-API-被弃用" class="headerlink" title="target fragment API 被弃用"></a>target fragment API 被弃用</h3><p>其实 <code>target fragment API</code> 早已被弃用</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200430092548.png" alt="setTargetFragment 被弃用"></p><p><code>target fragment</code> 需要直接访问另一个 fragment 的实例，这是十分危险的，因为你不知道目标 fragment 处于什么状态。而且 <code>target fragment</code> 不支持 Navigation</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200430092824.png" alt="弃用 target fragment API"></p><p>那么，fragment 之间传递数据更干净的方式是什么呢？</p><h3 id="fragment-之间传递数据的新方式"><a href="#fragment-之间传递数据的新方式" class="headerlink" title="fragment 之间传递数据的新方式"></a>fragment 之间传递数据的新方式</h3><p>前文提到，在相同的 FragmentManager 中可以使用 target fragment API 来在 fragment 间传递数据，但这种方式需要直接访问目标fragment 的实例，这很危险，因为目标 fragment 的状态是未知的</p><p>因此官方提供了这样的 API，它允许在一个 fragment 上设置结果，并将该结果在 fragment 的适当的生命周期中使用。</p><p>这种传递数据的方式适用于 DialogFragment ，Navigation 中的 fragment</p><p>此更改还包括 -ktx 扩展功能以确保 kotlin 用户可以将 FragmentResultListener 作为 lambda 传递</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200430105343.png" alt="FragmentA 源码"></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200430105411.png" alt="FragmentB 源码"></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200430105045.gif" alt="demo"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>老规矩，我们沿着官方的 commit log 来看看官方实现该功能的思路</p><p>首先，添加了 FragmentResultOwner 这样的的抽象，用于处理 fragment result，其内部有两个方法</p><ul><li>setResult</li><li>setResultListener</li></ul><p>前者用于发送数据，后者用于接收数据</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200430110206.png" alt="FragmentResultOwner"></p><p>而其实现类为 FragmentManager</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200430110412.png" alt="FragmentManager implement FragmentResultOwner "></p><p>我们来看看 FragmentManager 两个方法的具体实现</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200430111003.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setFragmentResultListener</span><span class="params">(@NonNull <span class="keyword">final</span> String requestKey,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> LifecycleOwner lifecycleOwner,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable <span class="keyword">final</span> FragmentResultListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置的 listener 为空时将 requestKey 对应的 listener 移除</span></span><br><span class="line">    <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mResultListeners.remove(requestKey);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当fragment 处于DESTROYED 状态时 直接 return ，避免了异常</span></span><br><span class="line">    <span class="keyword">final</span> Lifecycle lifecycle = lifecycleOwner.getLifecycle();</span><br><span class="line">    <span class="keyword">if</span> (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 观察生命周期，fragment started 后接收回调，destroyed 移除回调</span></span><br><span class="line">    LifecycleEventObserver observer = <span class="keyword">new</span> LifecycleEventObserver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(@NonNull LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">                @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event == Lifecycle.Event.ON_START) &#123;</span><br><span class="line">                <span class="comment">// once we are started, check for any stored results</span></span><br><span class="line">                Bundle storedResult = mResults.get(requestKey);</span><br><span class="line">                <span class="keyword">if</span> (storedResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// if there is a result, fire the callback</span></span><br><span class="line">                    listener.onFragmentResult(requestKey, storedResult);</span><br><span class="line">                    <span class="comment">// and clear the result</span></span><br><span class="line">                    setFragmentResult(requestKey, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                lifecycle.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">                mResultListeners.remove(requestKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    lifecycle.addObserver(observer);</span><br><span class="line">    mResultListeners.put(requestKey, <span class="keyword">new</span> LifecycleAwareResultListener(lifecycle, listener));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上便是这部分的源码</p><blockquote><p>这里要注意一点的是 <code>fragment result api</code> 是基于同一 <code>FragmentManager</code> 的</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>官方一直致力于将 fragment 的 api 变得更好用</p><p><a href="https://medium.com/@ianhlake" target="_blank" rel="noopener">Ian Lake</a> 在 <a href="https://www.youtube.com/watch?v=RS1IACnZLy4" target="_blank" rel="noopener">Fragments: Past, Present, and Future (Android Dev Summit ‘19)</a> 中提到了 fragment 间通信的问题，未来 fragment 会整合 fragment 自身和其内部 view 的生命周期，提供同一 FragmentManager 多返回栈的支持</p><p>看到 <code>fragment result API</code> ，我突然有个想法，如果将其应用到 Navigation 中是否是解决 Navigation 跳转返回后状态重置的一个方法呢？</p><p>各位小伙伴有什么想法欢迎评论区留言</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img src="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg"></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;fragment 1.3.0-alpha04&lt;/code&gt; 发布了，其中有很多变动，其中提供了 fragment 间传递数据的新方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/flywith24/Album/raw/master/img/20200430090529.png&quot; alt=&quot;1.3.0-alpha04 更新&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
      <category term="Fragment" scheme="http://yoursite.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>【Jetpack更新之Fragment】setMaxLifecycle 上位，setUserVisibleHint 被弃用</title>
    <link href="http://yoursite.com/2020/04/29/Jetpack-fragment-setMaxLifecycle/"/>
    <id>http://yoursite.com/2020/04/29/Jetpack-fragment-setMaxLifecycle/</id>
    <published>2020-04-28T16:10:35.000Z</published>
    <updated>2020-08-28T02:02:34.629Z</updated>
    
    <content type="html"><![CDATA[<p>很多情况下，fragment 的生命周期上限应该低于 FragmentManager/Activity。例如，<code>ViewPager</code> 屏幕外的界面不应被 <code>resumed</code></p><p>理想状态下，可以通过以下 API 实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">supportFragmentManager</span><br><span class="line">  .beginTransaction()</span><br><span class="line">      .setMaxLifecycle(fragment, Lifecycle.State.RESUMED)</span><br><span class="line">      .commit()</span><br></pre></td></tr></table></figure><p>将最大生命周期设置为 <code>Lifecycle.State.RESUMED</code> 将有效地消除限制（因为这是最高生命周期状态）</p><p>这将允许废弃 <code>setUserVisibleHint()</code> API</p><a id="more"></a><h2 id="setMaxLifecycle-出现始末"><a href="#setMaxLifecycle-出现始末" class="headerlink" title="setMaxLifecycle 出现始末"></a>setMaxLifecycle 出现始末</h2><p>该功能应如何实现的？我们沿着 <code>commit log</code> 来理一下官方的思路</p><p>将 <code>BackStackRecord</code> 的部分逻辑转移至父类 <code>FragmentTransaction</code> 中</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423094356.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423101522.png" alt></p><p>在 <code>FragmentTransaction</code> 中添加 <code>setMaxLifecycle</code> API</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423101908.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423102052.png" alt></p><p>保存 fragment <code>maxState</code></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423103245.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423103057.png" alt></p><p>弃用 <code>setUserVisibleHint</code></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423103528.png" alt></p><p><code>FragmentPagerAdapter</code> 构造器新增参数，使用 <code>setMaxLifecycle()</code> API 确保 fragment <code>resumed</code> 时对用户可见</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423104355.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423104634.png" alt></p><p>弃用 <code>FragmentStatePagerAdapter</code> 原来的单参构造器，推荐使用新的构造</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423105038.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423105144.png" alt></p><p><strong>随着 <code>ViewPager2 1.0.0</code> 正式版发布，与 <code>ViewPager</code> 交互的<code>FragmentPagerAdapter</code> 和 <code>FragmentStatePagerAdapter</code> 被弃用了</strong></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423111201.png" alt></p><p>至此我们捋顺了 <code>setMaxLifecycle</code> 的出现，<code>setUserVisibleHint</code> 的弃用以及与<code>ViewPager</code> 相关的 <code>FragmentPagerAdapter</code> 和 <code>FragmentStatePagerAdapter</code> 的弃用</p><h2 id="setMaxLifecycle-内部逻辑"><a href="#setMaxLifecycle-内部逻辑" class="headerlink" title="setMaxLifecycle 内部逻辑"></a>setMaxLifecycle 内部逻辑</h2><p>接下来我们看看 <code>setMaxLifecycle</code>  是如何发挥作用的</p><p>首先我们要研究一下 fragment 的状态管理，为了更好的管理 fragment 的状态，官方添加了 <code>FragmentStateManager</code> 类来专门管理 fragment 的状态，职能单一原则哈</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423113312.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423113509.png" alt></p><p>接着在该类中添加了计算 fragment 最大生命周期的方法 <code>computeMaxState()</code> </p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423114557.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423114615.png" alt></p><p>后来该方法改名为 <code>computeExpectedState()</code> 并加入了 <code>moveToExpectedState()</code> 方法</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423115055.png" alt></p><p><code>computeExpectedState()</code>  方法会根据 fragment <code>mMaxState</code> 计算 fragment 应该所处的生命周期</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423115521.png" alt></p><p>而 fragment 的 <code>mMaxState</code> 是通过 <code>FragmentManager</code> 的 <code>setMaxLifecycle()</code> 方法设置的 ，而该方法是 <code>BackStackRecord</code> 执行 OP 时调用的，而 OP 值正是通过 <code>FragmentTransaction</code> 的 <code>setMaxLifecycle()</code> 设置的</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423115744.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200423115928.png" alt></p><p>至此，我们理清了 <code>setMaxLifecycle()</code> 的内部逻辑</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以看到官方为了使 fragment 能够在正确的生命周期上，引入了 <code>setMaxLifecycle()</code> 方法，同时为了更好的管理 fragment 的状态，抽象出了 <code>FragmentStateManager</code> 。<em>更少的代码，更少的职责</em>，fragment 的内部逻辑会越来越清晰</p><ul><li><p>关于如何迁移至 ViewPager2 ，请移步 <a href="https://www.bilibili.com/video/BV1uJ411C7S4?from=search&seid=7755962876168902731" target="_blank" rel="noopener">官方视频</a></p></li><li><p>关于新的 API 下懒加载实现，请移步 <a href="https://juejin.im/post/5e232d01e51d455801624c06" target="_blank" rel="noopener">Androidx 下 Fragment 懒加载的新实现</a></p></li></ul><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img src="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多情况下，fragment 的生命周期上限应该低于 FragmentManager/Activity。例如，&lt;code&gt;ViewPager&lt;/code&gt; 屏幕外的界面不应被 &lt;code&gt;resumed&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;理想状态下，可以通过以下 API 实现&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;supportFragmentManager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  .beginTransaction()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      .setMaxLifecycle(fragment, Lifecycle.State.RESUMED)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      .commit()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;将最大生命周期设置为 &lt;code&gt;Lifecycle.State.RESUMED&lt;/code&gt; 将有效地消除限制（因为这是最高生命周期状态）&lt;/p&gt;
&lt;p&gt;这将允许废弃 &lt;code&gt;setUserVisibleHint()&lt;/code&gt; API&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
      <category term="Fragment" scheme="http://yoursite.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>【奇技淫巧】巧用 kotlin 扩展函数和 typealias 封装 LiveData</title>
    <link href="http://yoursite.com/2020/04/15/Tips-StateLiveData/"/>
    <id>http://yoursite.com/2020/04/15/Tips-StateLiveData/</id>
    <published>2020-04-15T06:11:46.000Z</published>
    <updated>2020-08-28T02:40:56.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-LiveData-两个常用的姿势"><a href="#关于-LiveData-两个常用的姿势" class="headerlink" title="关于 LiveData 两个常用的姿势"></a>关于 LiveData 两个常用的姿势</h2><h3 id="使用包装类传递事件"><a href="#使用包装类传递事件" class="headerlink" title="使用包装类传递事件"></a>使用包装类传递事件</h3><p>我们在使用 LiveData 时可能会遇到「粘性」事件的问题，该问题可以使用包装类的方式解决。解决方案见 <a href="https://juejin.im/post/5b2b1b2cf265da5952314b63#heading-7" target="_blank" rel="noopener">[译] 在 SnackBar，Navigation 和其他事件中使用 LiveData（SingleLiveEvent 案例）</a></p><p>使用时是这样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListViewModel</span> : <span class="type">ViewModel &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _navigateToDetails</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">userClicksOnButton</span><span class="params">(itemId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _navigateToDetails.value = Event(itemId)  <span class="comment">// Trigger the event by setting a new Event as a new value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myViewModel.navigateToDetails.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">    it.getContentIfNotHandled()?.let &#123; <span class="comment">// Only proceed if the event has never been handled</span></span><br><span class="line">        startActivity(DetailsActivity...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不过这样写甚是繁琐，我们可以使用更优雅的方式解决该问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为 LiveData&lt;Event&lt;T&gt;&gt;提供类型别名，使用 EventLiveData&lt;T&gt; 即可</span></span><br><span class="line"><span class="keyword">typealias</span> EventMutableLiveData&lt;T&gt; = MutableLiveData&lt;Event&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> EventLiveData&lt;T&gt; = LiveData&lt;Event&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure><p>使用 <code>typealias</code> 关键字，我们可以提供一个类型别名，可以这样使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于 MutableLiveData&lt;Event&lt;Boolean&gt;&gt;(Event(false))</span></span><br><span class="line"><span class="keyword">val</span> eventContent = EventMutableLiveData&lt;<span class="built_in">Boolean</span>&gt;(Event(<span class="literal">false</span>))</span><br></pre></td></tr></table></figure><p>现在声明时不用多加一层泛型了，那么使用时还是很繁琐</p><p>我们可以借助 kotlin 的 扩展函数更优雅的使用</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200605115649.png" alt="event 扩展函数"></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200605121030.png" alt="使用"></p><p>demo 中封装了两种形式的 LiveData，一种为 <code>LiveData&lt;Boolean&gt;</code>，一种为 <code>EventLiveData&lt;Boolean&gt;</code>，当屏幕旋转时，前者会再次回调结果，而后者由于事件已被处理而不执行 onChanged，我们通过 Toast 可观察到这一现象</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200605121634.gif" alt></p><p><a href="https://github.com/KunMinX/Jetpack-MVVM-Best-Practice" target="_blank" rel="noopener">java 版的可参考</a></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200605122206.png" alt></p><h3 id="封装带网络状态的数据"><a href="#封装带网络状态的数据" class="headerlink" title="封装带网络状态的数据"></a>封装带网络状态的数据</h3><p>很多时候我们在获取网络数据时要封装一层网络状态，例如：加载中，成功，失败</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200605115950.png" alt></p><p>在使用时我们遇到了和上面一样的问题，多层泛型用起来很麻烦</p><p>我们依然可以使用 typealias + 扩展函数来优雅的处理该问题</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200605120336.png" alt="typealias"></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200605120400.png" alt="扩展函数"></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200605120455.png" alt="使用"></p><p>demo 截图</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200605120721.gif" alt="demo"></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>demo <a href="https://github.com/Flywith24/WrapperLiveDataDemo" target="_blank" rel="noopener">在这</a>，如果感觉这个思路对你有帮助的话，点一颗小星星吧～ 😉</p><p>另外我还将它传到了 JitPack 上，引入姿势如下：</p><p><a href="https://jitpack.io/#Flywith24/WrapperLiveData" target="_blank" rel="noopener"><img src="https://jitpack.io/v/Flywith24/WrapperLiveData.svg" alt></a></p><ol><li><p>在项目根目录的 <code>build.gradle</code> 加入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    maven &#123; url <span class="string">'https://jitpack.io'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>添加依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation <span class="string">'com.github.Flywith24:WrapperLiveData:$version'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="往期文章"><a href="#往期文章" class="headerlink" title="往期文章"></a>往期文章</h2><p>该系列主要介绍一些「骚操作」，它未必适合生产环境使用，但是是一些比较新颖的思路</p><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案</a></li></ul><ul><li><a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></li></ul><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你</a></li></ul><ul><li><a href="https://juejin.im/post/5e967f35f265da47d77cd4c3" target="_blank" rel="noopener">【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转</a></li></ul><ul><li><a href="https://juejin.im/post/5ebdfb0b6fb9a0436153db22" target="_blank" rel="noopener">【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil</a></li></ul><ul><li><p><a href="https://juejin.im/post/5ec50ae46fb9a047a862124f" target="_blank" rel="noopener">【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化</a></p></li><li><p><a href="https://juejin.im/post/5ecde219e51d457841190d08" target="_blank" rel="noopener">【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</a></p></li></ul><p>我的其他系列文章 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于-LiveData-两个常用的姿势&quot;&gt;&lt;a href=&quot;#关于-LiveData-两个常用的姿势&quot; class=&quot;headerlink&quot; title=&quot;关于 LiveData 两个常用的姿势&quot;&gt;&lt;/a&gt;关于 LiveData 两个常用的姿势&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/categories/Tips/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="http://yoursite.com/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转</title>
    <link href="http://yoursite.com/2020/04/15/Tips-Components-Jump/"/>
    <id>http://yoursite.com/2020/04/15/Tips-Components-Jump/</id>
    <published>2020-04-15T06:11:46.000Z</published>
    <updated>2020-08-28T02:36:40.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>越来越多的项目使用了组件化，组件之间的通信是一个比较重要的问题。<code>ARouter</code> 等路由方案为我们提供了解决办法。那么如果不使用 Router 如何实现组件间的界面跳转呢？</p><h2 id="万能的-setClassName"><a href="#万能的-setClassName" class="headerlink" title="万能的 setClassName"></a>万能的 <code>setClassName</code></h2><p>从一个 Activity 跳转到另一个Activity 的最直接方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, TestActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>但是，采用这种方法，当原 activity 位于一个 module（例如 <code>FeatureA</code> ）中，而目标 activity 位于另一个 module（<code>FeatureB</code>）中时，该怎么办？</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200415110401.png" alt></p><p>我们可以使用 Intent 的 <code>setClassName</code> 方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent()</span><br><span class="line">intent.setClassName(<span class="keyword">this</span>, “com.flywith24.demo.TestActivity”)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>但是这种方式硬编码目标 activity 的完整类名，如果 activity 的类名被更改或者移动，而且没有更改硬编码，则编译可以通过，但是运行时崩溃</p><p>如果可以自动生成 activity 完整类名就好了</p><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>我们知道 activity 作为 Android 的组件之一需要在 Manifest 文件中声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">”com.flywith24.demo.MainActivity”</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">”com.flywith24.demo.TestActivity”</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们的数据是从 Manifest 中获得的，那么就解决了硬编码的问题了</p><p>有这样一个<a href="https://github.com/gaelmarhic/Quadrant" target="_blank" rel="noopener">插件</a> ，在 build 时会将所有在 Manifest 中声明的 activity 的完整类名以静态常量的形式罗列到一个静态类中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> QuadrantConstants &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">val</span> MAIN_ACTIVITY: String = <span class="string">"com.gaelmarhic.quadrant.MainActivity"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">val</span> SECONDARY_ACTIVITY: String = <span class="string">"com.gaelmarhic.quadrant.SecondaryActivity"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">val</span> TERTIARY_ACTIVITY: String = <span class="string">"com.gaelmarhic.quadrant.TertiaryActivity"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在使用时就避免了硬编码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent()</span><br><span class="line">intent.setClassName(context, QuadrantConstants.MAIN_ACTIVITY)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><h2 id="使用依赖注入"><a href="#使用依赖注入" class="headerlink" title="使用依赖注入"></a>使用依赖注入</h2><p>组件化中 <code>app</code> module 会依赖所有的功能 module ，因此如果我们使用依赖注入在 <code>app</code> 中将所有的目标 activity 的完整类名声明出来，也能达到解决硬编码的问题</p><p>这里以 <a href="https://insert-koin.io/" target="_blank" rel="noopener">koin</a> 为例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> myModule = module &#123;</span><br><span class="line">        single &#123; Feature2Activity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">name</span> &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        startKoin &#123;</span><br><span class="line">            androidContext(<span class="keyword">this</span><span class="symbol">@MyApplication</span>)</span><br><span class="line">            modules(myModule)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过 get() 方法即可拿到 <code>Feature2Activity</code> 的完整类名</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent()</span><br><span class="line">    .setClassName(<span class="keyword">this</span><span class="symbol">@Feature1Activity</span>, <span class="keyword">get</span>())</span><br><span class="line">    .putExtra(<span class="string">"key"</span>, <span class="string">"value"</span>)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/Flywith24/MultitableModuleApp" target="_blank" rel="noopener">Demo 地址</a></p><p>各位有什么想法欢迎在评论区留言</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;越来越多的项目使用了组件化，组件之间的通信是一个比较重要的问题。&lt;code&gt;ARouter&lt;/code&gt; 等路由方案为我们提供了解决办法。那
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/categories/Tips/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="http://yoursite.com/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</title>
    <link href="http://yoursite.com/2020/04/15/Tips-includeBuild/"/>
    <id>http://yoursite.com/2020/04/15/Tips-includeBuild/</id>
    <published>2020-04-15T06:11:46.000Z</published>
    <updated>2020-08-28T02:35:57.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="buildSrc-的缺陷"><a href="#buildSrc-的缺陷" class="headerlink" title="buildSrc 的缺陷"></a>buildSrc 的缺陷</h2><p>Android 开发中统一不同 module 的依赖版本十分重要，传统的方式是使用 ext 的方式</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200527111409.png" alt="ext"></p><p>之前我发过关于使用 buildSrc 简化项目中 gradle 代码的译文：<a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></p><p>该种方式可以很好的管理 gradle 的公共配置，这其中当然包括依赖版本</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200527111722.gif" alt="配置依赖"></p><p>如图，在使用依赖时有代码提示，而且可以点击进入查看</p><p>但是由于 buildSrc 是对全局的所有 module 的配置，因此在构建速度上会慢一些。那么有没有一个更纯净的方式来配置依赖版本呢？</p><p>今天我们来介绍一种新的方式</p><h2 id="自定义-plugin-includeBuild"><a href="#自定义-plugin-includeBuild" class="headerlink" title="自定义 plugin + includeBuild"></a>自定义 plugin + includeBuild</h2><p>使用 <a href="https://docs.gradle.org/current/userguide/composite_builds.html" target="_blank" rel="noopener">Gradle Composite builds</a> 可以很容易解决这一问题</p><p>我们新建一个 module，命名为 version ，并将原来的 buildSrc 的代码转移过来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependencyVersionPlugin</span> : <span class="type">Plugin</span>&lt;<span class="type">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 version 的 build.gradle 文件加入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gradlePlugin &#123;</span><br><span class="line">    plugins &#123;</span><br><span class="line">        version &#123;</span><br><span class="line">            id = <span class="string">'com.flywith24.version'</span></span><br><span class="line">            implementationClass = <span class="string">'com.flywith24.version.DependencyVersionPlugin'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 settings.gradle 加入 <code>includeBuild(&quot;version&quot;)</code> （<strong>重点</strong>）</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">includeBuild(<span class="string">"version"</span>)</span><br><span class="line"></span><br><span class="line">rootProject.name=<span class="string">'VersionControlDemo'</span></span><br><span class="line">include <span class="string">':app'</span></span><br><span class="line">include <span class="string">':lib'</span></span><br></pre></td></tr></table></figure><p>接下来在需要引用的 module 中引入该插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">"com.flywith24.version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们就可以使用了</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200527113952.png" alt="demo代码截图"></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200527114023.png" alt="demo代码截图"></p><p><a href="https://github.com/Flywith24/VersionControlDemo" target="_blank" rel="noopener">demo 在这</a></p><h2 id="往期文章"><a href="#往期文章" class="headerlink" title="往期文章"></a>往期文章</h2><p>该系列主要介绍一些「骚操作」，它未必适合生产环境使用，但是是一些比较新颖的思路</p><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案</a></li></ul><ul><li><a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></li></ul><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你</a></li></ul><ul><li><a href="https://juejin.im/post/5e967f35f265da47d77cd4c3" target="_blank" rel="noopener">【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转</a></li></ul><ul><li><a href="https://juejin.im/post/5ebdfb0b6fb9a0436153db22" target="_blank" rel="noopener">【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil</a></li></ul><ul><li><a href="https://juejin.im/post/5ec50ae46fb9a047a862124f" target="_blank" rel="noopener">【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化</a></li></ul><p>我的其他系列文章 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;buildSrc-的缺陷&quot;&gt;&lt;a href=&quot;#buildSrc-的缺陷&quot; class=&quot;headerlink&quot; title=&quot;buildSrc 的缺陷&quot;&gt;&lt;/a&gt;buildSrc 的缺陷&lt;/h2&gt;&lt;p&gt;Android 开发中统一不同 module 的依赖版本十分
      
    
    </summary>
    
    
      <category term="Tips" scheme="http://yoursite.com/categories/Tips/"/>
    
    
      <category term="Tips" scheme="http://yoursite.com/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="http://yoursite.com/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>【Jetpack更新之Recyclerview】更优雅地恢复 recyclerview 的滚动位置</title>
    <link href="http://yoursite.com/2020/04/09/Jetpack-Recyclerview-Scoroll/"/>
    <id>http://yoursite.com/2020/04/09/Jetpack-Recyclerview-Scoroll/</id>
    <published>2020-04-08T16:10:35.000Z</published>
    <updated>2020-08-28T02:13:11.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="被我忽视的更新"><a href="#被我忽视的更新" class="headerlink" title="被我忽视的更新"></a>被我忽视的更新</h2><p><code>androidx recyclerview 1.2.0-alpha02</code> 版本添加了新功能 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" target="_blank" rel="noopener">MergeAdapter</a>，帮助开发者更容易地为 RecyclerView 添加 Header 和 Footer。详情参见 <a href="https://juejin.im/post/5e86ffea51882573ba207a19" target="_blank" rel="noopener">【译】MergeAdapter 的使用 使用官方 API 为 Recyclerview 添加 Header 和 Footer</a></p><p>该版本中还有一个改动：<strong><code>RecyclerView.Adapter</code> lazy state restoration</strong>，帮助开发者恢复 RecyclerView 的状态</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512105548.png" alt="recyclerview update"></p><p>我对这个功能并没有什么感觉。众所周知，Android 中的 View 内部是有着状态保存和恢复的方法的。RecyclerView 也是如此，它可以恢复自身已滚动的位置</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512110411.png" alt="View 内部恢复状态"></p><p>有关状态保存的内容可以参见 <a href="https://juejin.im/post/5e738d12518825495d69cfb9" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a></p><p>真实情况也是如此</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512111315.gif" alt="RecyclerView 内部可以恢复滚动位置"></p><h2 id="意外发现"><a href="#意外发现" class="headerlink" title="意外发现"></a>意外发现</h2><p>最近看到 <a href="https://medium.com/@florina.muntenescu?source=post_page-----a8fbdc9a9334----------------------" target="_blank" rel="noopener">Florina Muntenescu</a> 的 <a href="https://medium.com/androiddevelopers/restore-recyclerview-scroll-position-a8fbdc9a9334" target="_blank" rel="noopener">Restore RecyclerView scroll position</a> ，其中介绍了 <strong><code>RecyclerView.Adapter</code> lazy state restoration</strong>，这勾起了我的兴趣</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512111720.png" alt="意外发现"></p><p>如文中描述，RecyclerView 在 activity/fragment 重建时失去滚动位置是因为 Adapter 中的数据是 <strong>异步</strong> 加载的，当 RecyclerView layout 时数据并没有加载，因此也恢复不了之前的位置状态。一个比较简单的例子是使用 Navigation 组件进行导航，返回时 fragment 中的 RecyclerView 由于再次调用接口获取数据，导致其滑动位置失去</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512113141.gif" alt="延迟加载数据，无法恢复滚动位置"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有几种方法可以保证 RecyclerView 恢复到正确的滚动位置，最好的办法是借助缓存，ViewModel 或 Repository 中缓存要显示的数据，确保始终在第一个布局传入前在 Adapter 上设置数据。也有一些其他的方案，这些方案要么太复杂，要么不够优雅</p><p><code>recyclerview:1.2.0-alpha02</code> 中的解决方案是提供一个新的 Adapter 方法，该方法允许设置状态恢复策略，它有三个选项</p><ul><li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter.StateRestorationPolicy#ALLOW" target="_blank" rel="noopener">ALLOW</a></li><li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter.StateRestorationPolicy#PREVENT_WHEN_EMPTY" target="_blank" rel="noopener">PREVENT_WHEN_EMPTY</a></li><li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter.StateRestorationPolicy#PREVENT" target="_blank" rel="noopener">PREVENT</a></li></ul><h3 id="ALLOW"><a href="#ALLOW" class="headerlink" title="ALLOW"></a>ALLOW</h3><p>这是 <strong>默认</strong> 的状态，它会立即恢复 RecyclerView 的状态，该种策略无法解决延迟加载的数据的问题，可以使用 <code>PREVENT_WHEN_EMPTY</code></p><h3 id="PREVENT-WHEN-EMPTY"><a href="#PREVENT-WHEN-EMPTY" class="headerlink" title="PREVENT_WHEN_EMPTY"></a>PREVENT_WHEN_EMPTY</h3><p>仅当 Adapter 不为空（adapter.getItemCount() &gt; 0）时，才恢复 RecyclerView 状态。 如果您的数据是异步加载的，那么 RecyclerView 会一直等到数据加载完毕，然后状态才能恢复。 如果您有默认 item（例如 Header 或 加载指示器）作为适配器的一部分，则应该使用<code>PREVENT</code> 选项，除非使用 MergeAdapter 添加了默认 item。 MergeAdapter 等待所有适配器准备就绪，然后才恢复状态</p><h3 id="PREVENT"><a href="#PREVENT" class="headerlink" title="PREVENT"></a>PREVENT</h3><p>状态不会恢复，直到配置了 <code>ALLOW</code> 或者 <code>PREVENT_WHEN_EMPTY</code></p><p>使用方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adapter.stateRestorationPolicy = PREVENT_WHEN_EMPTY</span><br></pre></td></tr></table></figure><p><strong>加入了上面的配置后即使是异步加载数据也能恢复 RecyclerView 的位置</strong></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512114332.gif" alt="设置 PREVENT_WHEN_EMPTY"></p><h2 id="追踪引入过程"><a href="#追踪引入过程" class="headerlink" title="追踪引入过程"></a>追踪引入过程</h2><p>老规矩，我们沿着官方的 commit log 来看看其实现原理</p><p>首先我们看看 <a href="https://issuetracker.google.com/issues/146365793" target="_blank" rel="noopener">IssueTracker 上提的 Feature</a></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512115048.png" alt="IssueTracker"></p><p>表达的意思也很简单，就是当加载异步数据时 RecyclerView 的位置状态无法恢复，Adapter 应该提供相关的解决方案</p><p>有意思的是，实现该功能时还重新实现了前一个版本的逻辑，我在 git commit log 中看到了 revert 操作</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512140140.png" alt="revert操作"></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512120004.png" alt></p><p>为了防止 <code>LayoutManager#onRestore</code> 执行多次，没有采用最开始的实现方式。但 Yigit Boyar (这个提交的开发者) 仍然希望使用最开始的实现方式，但是  <code>LayoutManager#onRestoreInstance</code> 的状态时 public ，因此只能选取一个折中的方案</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512141210.png" alt="新的实现方案"></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512141445.png" alt="无奈之举"></p><p>过去，开发者会无意间调用 <code>onRestoreInstanceState(State)</code> 方法。例如，一些开发者已使用它来手动设置自己更新的状态，这样即使在此状态之前已恢复，在此处传递状态也将导致 LayoutManager 接收它并相应地更新其内部状态。因此，即使看起来好像很奇怪，也必须始终调用 <code>requestLayout</code> 来保留功能</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>接下来我们来分析这部分源码，内容很少，所以我们详细看下</p><p>首先是引入 <code>StateRestorationPolicy</code>的枚举</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512143600.png" alt></p><p>然后需要提供 <code>setStateRestorationPolicy</code> 和 <code>getStateRestorationPolicy</code> 方法，此时我们还需要一个方法来判断是否要将 SavedState 传递给 LayoutManager</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512143459.png" alt></p><p>前面的 <code>setStateRestorationPolicy</code> 方法中 调用了 <code>notifyStateRestorationPolicyChanged</code>，而 <code>notifyStateRestorationPolicyChanged</code> 为静态类 <code>AdapterDataObservable</code> 中的方法，该类中的其他方法我们也很熟悉，均是刷新 Adapter 中数据的方法。</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512143858.png" alt="notifyStateRestorationPolicyChanged"></p><p>而 <code>notifyStateRestorationPolicyChanged</code> 中调用了 mObservers list 中元素的 <code>onStateRestorationPolicyChanged</code> 方法，通过源码我们得知该 list 中的元素类型为 <code>AdapterDataObserver</code>，因此还需要在 <code>AdapterDataObserver</code> 中加入 <code>onStateRestorationPolicyChanged</code> 方法</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512144501.png" alt="onStateRestorationPolicyChanged "></p><p>该方法是个空实现，而 <code>RecyclerViewDataObserver</code> 重写了该方法</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512144716.png" alt="RecyclerViewDataObserver "></p><p>配置恢复策略以及恢复策略变化时的监听都有了，接下来要做的就是如果之前有待恢复的装则恢复之前的状态</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200512145152.png" alt="恢复状态"></p><blockquote><p>注意：发布之前 <code>StateRestorationPolicy</code> 叫做 <code>StateRestorationStrategy</code>，后来命名为 <code>StateRestorationPolicy</code>，alpha 版本的库可能随时更改 API 的命名和删除 API，因此查看这部分源码的同学请注意</p></blockquote><p>至此，相关的源码都在这里了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>StateRestorationPolicy</code> 提供了 RecyclerView 异步加载数据恢复滚动位置的解决方案。原理就是通过配置 <code>StateRestorationPolicy</code> 来改变恢复策略，同时在策略改变时调用 <code>requestLayout</code> 方法。在 <code>dispatchLayoutStep2()</code> (该方法会在 onLayout 和 measure 方法中调用) 方法中恢复状态(如果 <code>canRestoreState()</code> 返回 true)</p><p><a href="https://github.com/Flywith24/Flywith24-Jetpack-Demo/tree/master/demo_recyclerview_scroll" target="_blank" rel="noopener">demo 地址</a></p><p><strong>一点思考：我们都知道 ViewPager2 是使用 RecyclerView 实现的，那么借助本文介绍的 API 可以做点什么吗？</strong></p><p>欢迎各位小伙伴在评论区留言，说说你的想法</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200508153754.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;被我忽视的更新&quot;&gt;&lt;a href=&quot;#被我忽视的更新&quot; class=&quot;headerlink&quot; title=&quot;被我忽视的更新&quot;&gt;&lt;/a&gt;被我忽视的更新&lt;/h2&gt;&lt;p&gt;&lt;code&gt;androidx recyclerview 1.2.0-alpha02&lt;/code&gt; 版
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
      <category term="RecyclerView" scheme="http://yoursite.com/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>【Jetpack更新之Fragment】终于动手了，onActivityCreated 被弃用</title>
    <link href="http://yoursite.com/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/"/>
    <id>http://yoursite.com/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/</id>
    <published>2020-04-08T16:10:35.000Z</published>
    <updated>2020-08-28T02:11:05.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章介绍 Jetpack 组件库的更新<br><br>一直以来， fragment 的 api 都非常难用，官方也承认这一点。一个月前，fragment 中的 <code>onActivityCreated()</code> 被弃用了</p></blockquote><a id="more"></a><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p><code>fragment 1.3.0-alpha02</code> 中 <code>onActivityCreated()</code> 方法被弃用了</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200421095145.png" alt></p><p>让我们来看一下提交 log </p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200421092105.png" alt></p><p>简单翻译一下</p><p><code>onActivityCreated()</code> 最初的目的是让 fragment 的逻辑与其宿主 activity 创建建立关联，我们不鼓励这种耦合</p><p>我们应该传递外部依赖来作为 <code>FragmentFactory</code> 参数。view 相关的代码应该放置在 <code>onViewCreated()</code> 完成，其他的初始化代码应该在 <code>onCreate()</code> 中完成。为了在 <code>activity onCreate()</code> 完成后接收回调，可以添加一个 activity 生命周期的 <code>LifecycleObserver</code> ，并且接收到 <code>Lifecycle.State#CREATED</code> 回调时将其移除</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttach(context)</span><br><span class="line">    requireActivity().lifecycle.addObserver(<span class="keyword">object</span> : DefaultLifecycleObserver &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 想做啥做点啥</span></span><br><span class="line">            owner.lifecycle.removeObserver(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DialogFragment"><a href="#DialogFragment" class="headerlink" title="DialogFragment"></a>DialogFragment</h2><p>那么 <code>DialogFragment</code> 怎么办？其 <code>onActivityCreated</code> 变为可选的</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200421101629.png" alt></p><p>简单翻译一下</p><p><code>DialogFragment</code> 使用 <code>onActivityCreated</code>() 帮助创建 dialog。onActivityCreated() 弃用后我们应当寻找一个更好的方式来执行这部分逻辑</p><p>关于 view 相关的代码已经转移至 <code>DialogFragment</code></p><p> 的 <code>viewLifecycleOwnerLiveData</code> ，其他初始化逻辑可以放在 <code>onGetLayoutInflater</code></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200421103420.png" alt></p><p>我们仍支持为自定义 dialog 在 <code>onActivityCreated()</code> 中配置 dialog</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>查看 <code>Jetpack fragment</code> 的变动，不难看出官方正致力于为 fragment 「减负」，将小的，独立的功能从 fragment 中抽离出去，降低耦合，后续文章我们介绍其他的改动</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img src="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg"></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列文章介绍 Jetpack 组件库的更新&lt;br&gt;&lt;br&gt;一直以来， fragment 的 api 都非常难用，官方也承认这一点。一个月前，fragment 中的 &lt;code&gt;onActivityCreated()&lt;/code&gt; 被弃用了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
      <category term="Fragment" scheme="http://yoursite.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之DataBinding】数据驱动魔法师 何时迎来翻身日？</title>
    <link href="http://yoursite.com/2020/04/09/Jetpack-DataBinding/"/>
    <id>http://yoursite.com/2020/04/09/Jetpack-DataBinding/</id>
    <published>2020-04-08T16:10:35.000Z</published>
    <updated>2020-04-10T08:49:44.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://juejin.im/post/5e834bb5f265da480d61668d" target="_blank" rel="noopener">LiveData 篇</a> 我们提到 Android 开发的主要工作内容是将数据转换为 UI ，同时我们也介绍了数据驱动 UI 的思想，使用 ViewModel + LiveData，可以安全地在订阅者的生命周期内分发正确的数据。但是 activity 和 fragment 充斥着大量的模板代码，铺天盖地的 findViewById，以及各种 set （根据数据设置 UI）。如果能够消灭掉这些模板代码就好了</p></blockquote><a id="more"></a><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200402101708.gif" alt="他来了他来了"></p><p>他来了他来了，他欢快地走来了</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200402101727.png" alt="DataBinding"></p><p>然而，很多开发者对 DataBinding 存在偏见，「DataBinding 不是个好东西，在声明式编程中书写 UI 逻辑，既不可调试，也不便于察觉和追踪，万一出现问题就麻烦了。」</p> <img src="https://gitee.com/flywith24/Album/raw/master/img/20200402165235.png" style="zoom:200%;"><p>本文主要介绍 DataBinding 的解决的问题以及其背后的逻辑，带您对 DataBinding 有一个感性的认识。本文末尾会对各个 findViewById 的替代方案进行对比</p><p>DataBinding 的相关资源</p><ul><li><a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://codelabs.developers.google.com/codelabs/android-databinding/#0" target="_blank" rel="noopener">codelab</a></li><li><a href="https://github.com/android/databinding-samples" target="_blank" rel="noopener">官方示例</a></li></ul><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 数据驱动魔法师</span></h2><p>DataBinding 允许使用声明性格式而不是通过编程方式将布局中的 UI 组件与数据源绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">TextView textView = findViewById(R.id.sample_text);</span><br><span class="line">textView.setText(viewModel.getUserName());</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.userName&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>通过在布局文件中绑定组件，您可以删除 activity 中的许多设置 UI 调用，从而使它们更易于维护。 这也可以提高应用程序的性能，并有助于防止内存泄漏和空指针异常</p><blockquote><p>如果仅替换 findViewById 而不需要数据的绑定，可以使用 ViewBinding，它使用起来更简单，性能也更好。</p><p>使用方法参见 <a href="https://juejin.im/post/5e4806f3e51d4526c550a2ef" target="_blank" rel="noopener">[译]深入研究ViewBinding 在 include, merge, adapter, fragment, activity 中使用</a></p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> DataBinding 基础</span></h2><p>详细内容参见 <a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">官方文档</a> ，这里只简单介绍 DataBinding</p><h3 id="DataBinding-引入"><a href="#DataBinding-引入" class="headerlink" title="DataBinding 引入"></a>DataBinding 引入</h3><p>app build.gradle 中加入 </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android Studio 4.0</span></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        dataBinding = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>必须在 app module 中声明，声明后其他子 module 可直接使用 DataBinding</p></blockquote><p>使用 DataBinding 无需开发者手动引入库，android build gradle plugin 内部已经引入了</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200402115116.png" alt></p><p>DataBinding 中使用了注解，因此在构建速度上比 ViewBinding 差些（不过功能这么强大要啥自行车）</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>DataBinding 布局文件略有不同，它们以 layout 的根标记开始，后跟一个 data 元素和一个 view 根元素。 view 元素是您的根将位于非绑定布局文件中的元素。 以下代码显示了一个示例布局文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"viewmodel"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"com.myapp.data.ViewModel"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintLayout...</span> /&gt;</span> <span class="comment">&lt;!-- UI layout's root element --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="生成绑定类"><a href="#生成绑定类" class="headerlink" title="生成绑定类"></a>生成绑定类</h3><p>DataBinding 会为每个在布局声明 layout 标签的 xml 布局文件生成一个绑定类。 默认情况下，类的名称基于布局文件的名称。 上面的布局文件名是 activity_main.xml，因此相应的生成类是 ActivityMainBinding。 此类包含从布局属性（例如，viewmodel 变量）到布局视图的所有绑定，并且知道如何为绑定表达式分配值</p><h3 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment">// before</span></span><br><span class="line">    <span class="comment">// setContentView(R.layout.activity_main)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// after</span></span><br><span class="line">    val binding : ActivityMainBinding =</span><br><span class="line">    DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_main)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 使用DataBinding 解决的问题及实现原理</span></h2><p>不知道你是否有这些烦恼：activity 和 fragment 中有着大量的模板代码，即使使用 ButterKnife 等工具写起代码来也很繁琐。而且 View id 与 View 的类型不匹配时，只有在运行期才能发现；旋转屏幕后如果新的布局中不存在之前 id 的 view ，可能还导致空指针异常；项目中使用各类 bus 通知 UI 刷新，但是有时 UI 的显示并不符合预期，而排查起来特别困难，因为数据源很多…</p><p>不要慌，DataBinding 可以解决以下问题</p><ul><li><p>替换 findViewById ，减少模板代码</p></li><li><p>解决类型安全问题</p></li><li><p>解决空安全问题</p></li><li><p>保证了数据的一致性</p></li></ul><h3 id="魔法的背后"><a href="#魔法的背后" class="headerlink" title="魔法的背后"></a>魔法的背后</h3><p>com.android.tools.build:gradle 插件中封装了 DataBinding 的魔法</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200402162010.png" alt></p><p>查看 com.android.tools.build:gradle:3.6.2 的源码，找到 DataBinding 配置项的类 DataBindingOptions</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataBindingOptions.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DataBinding 是否开启，对应上面在 build.gradle 中的配置</span></span><br><span class="line">    <span class="keyword">return</span> enabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的调用者很多，在 TaskManager 中的 createDataBindingTasksIfNecessary</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskManager </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">createDataBindingTasksIfNecessary</span><span class="params">(@NonNull VariantScope scope)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否开启 DataBinding</span></span><br><span class="line">    <span class="keyword">boolean</span> dataBindingEnabled = extension.getDataBinding().isEnabled();</span><br><span class="line">    <span class="keyword">boolean</span> viewBindingEnabled = extension.getViewBinding().isEnabled();</span><br><span class="line">    <span class="keyword">if</span> (!dataBindingEnabled &amp;&amp; !viewBindingEnabled) &#123;</span><br><span class="line">        <span class="comment">// DataBinding 和 ViewBinding 均未开启则直接 return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    createDataBindingMergeBaseClassesTask(scope);</span><br><span class="line">    createDataBindingMergeArtifactsTask(scope);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 构建 DataBinding 相应绑定类</span></span><br><span class="line">    taskFactory.register(<span class="keyword">new</span> DataBindingGenBaseClassesTask.CreationAction(scope));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CreationAction</span></span><br><span class="line"><span class="function">override fun <span class="title">handleProvider</span><span class="params">(taskProvider: TaskProvider&lt;out DataBindingGenBaseClassesTask&gt;)</span> </span>&#123;</span><br><span class="line">    variantScope.artifacts.producesDir(</span><br><span class="line">        <span class="comment">// DATA_BINDING_BASE_CLASS_SOURCE_OUT</span></span><br><span class="line">        InternalArtifactType.DATA_BINDING_BASE_CLASS_SOURCE_OUT,</span><br><span class="line">        BuildArtifactsHolder.OperationType.INITIAL,</span><br><span class="line">        taskProvider,</span><br><span class="line">        DataBindingGenBaseClassesTask::sourceOutFolder</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到生成 DataBinding 绑定类的 task 为 DataBindingGenBaseClassesTask，而InternalArtifactType.DATA_BINDING_BASE_CLASS_SOURCE_OUT 则对应着 build 目录生成的 DataBinding 类的</p><p>data_binding_base_class_source_out 目录</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200402161451.png" alt></p><p>这里可以简单看一下，感兴趣的小伙伴可以自己查看源码</p><h3 id="DataBinding-如何解决上述问题的"><a href="#DataBinding-如何解决上述问题的" class="headerlink" title="DataBinding 如何解决上述问题的"></a>DataBinding 如何解决上述问题的</h3><p>我们可以查看 DataBinding 生成的绑定类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentSingleChildBinding</span> <span class="keyword">implements</span> <span class="title">ViewBinding</span> </span>&#123;</span><br><span class="line">  <span class="comment">// NonNull 注解标记</span></span><br><span class="line">  <span class="comment">// 如果存在不同配置的不同布局文件（如横竖屏）且该控件不是存在于所有布局，该处使用 Nullable注解标记</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> MaterialButton button;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FragmentSingleChildBinding <span class="title">bind</span><span class="params">(@NonNull View rootView)</span> </span>&#123;</span><br><span class="line">    String missingId;</span><br><span class="line">    missingId: &#123;</span><br><span class="line">      <span class="comment">//其内部也是使用 findViewById</span></span><br><span class="line">      MaterialButton button = rootView.findViewById(R.id.button);</span><br><span class="line">      <span class="keyword">if</span> (button == <span class="keyword">null</span>) &#123;</span><br><span class="line">        missingId = <span class="string">"button"</span>;</span><br><span class="line">        <span class="keyword">break</span> missingId;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FragmentSingleChildBinding((MaterialButton) rootView, button);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Missing required view with ID: "</span>.concat(missingId));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Binding 类内部的也是使用 findViewById ，因此 DataBinding 可以代替 findViewById ，并且减少模板代码</p></li><li><p>View 控件变量类型是固定的，因此不会出现类型安全问题</p></li><li><p>View 控件变量由空/非空注解修饰，（如果为 Nullable java 中会有 lint 警告，而 kotlin 直接调用时无法通过编译的）因此 不会出现空安全问题</p></li><li><p>通过声明式的配置，UI 完全来自唯一可信的数据源配置，保证了数据的一致性</p></li></ul><blockquote><p>注意：以上分析同样适用于 ViewBinding</p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 感受魔法的魅力</span></h2><p>这里简单展示一下 DataBinding 的「魔法」</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">"@+id/firstName"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">"@+id/lastName"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before Data Binding</span></span><br><span class="line"><span class="comment">//setContentView(R.layout.activity_main);</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//TextView firstName = (TextView) findViewById(R.id.firstName);</span></span><br><span class="line"><span class="comment">//TextView lastName = (TextView) findViewById(R.id.lastName);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//firstName.setText("xxx");</span></span><br><span class="line"><span class="comment">//lastName.setText("xxx");</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// After Data Binding</span></span><br><span class="line">        ActivityMainBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        binding.firstName.setText(<span class="string">"xxx"</span>);</span><br><span class="line">        binding.lastName.setText(<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面展示了 DataBinding 的基础操作（单纯的替换 findViewById），如果仅使用 DataBinding 这部分功能，可以考虑使用 ViewBinding</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409114053.png" alt></p><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p>在之前的布局的基础上绑定数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">"@+id/firstName"</span>      </span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">"@+id/lastName"</span>      </span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ActivityMainBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_main);</span><br><span class="line">binding.user = <span class="keyword">new</span> User(<span class="string">"xxx"</span>,<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式也可以用在 recyclerview adapter 中，adapter 中的代码大大减少</p><h3 id="Binding-Adapter"><a href="#Binding-Adapter" class="headerlink" title="Binding Adapter"></a>Binding Adapter</h3><p>您可能会好奇配置 <code>android:text=&quot;@{user.firstName}</code> 后内部发生了什么</p><p>DataBinding 中使用 <code>Binding Adapter</code> 来处理，它主要处理「属性」和「事件」，前者如  <code>setText()</code> ，后者如 <code>setOnClickListener()</code>。上面的 <code>android:text</code> 实际上调用的是下面的方法</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409145551.png" alt></p><p>DataBinding 中提供了很多 <code>Binding Adapter</code></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200410160031.png" alt></p><p>如果官方提供的 <code>Binding Adapter</code> 不满足您的需求，您还可以自定义 <code>Binding Adapter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter</span>(&#123;<span class="string">"imageUrl"</span>, <span class="string">"error"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(ImageView view, String url, Drawable error)</span> </span>&#123;</span><br><span class="line">  Glide.with(view).load(url).error(error).into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">app:imageUrl</span>=<span class="string">"@&#123;venue.imageUrl&#125;"</span> <span class="attr">app:error</span>=<span class="string">"@&#123;@drawable/venueError&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DadaBinding-LiveData"><a href="#DadaBinding-LiveData" class="headerlink" title="DadaBinding + LiveData"></a>DadaBinding + LiveData</h3><p>要将 LiveData 与 DataBinding 一起使用，需要指定生命周期所有者来定义 LiveData 对象的范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        UserBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user);</span><br><span class="line"></span><br><span class="line">        binding.setLifecycleOwner(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>使用单向 DataBinding，可以在属性上设置一个值，并设置一个对该属性的更改做出反应的监听器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">"@&#123;viewmodel.rememberMe&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onCheckedChanged</span>=<span class="string">"@&#123;viewmodel.rememberMeChanged&#125;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>使用双向绑定可以简化该过程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">"@=&#123;viewmodel.rememberMe&#125;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>@={}</code> 接收对该属性的数据更改，并同时监听用户更新（注意，这里有 <code>=</code> ）</p><p>那么究竟什么是双向绑定呢？</p><p>所谓的「数据驱动」就是数据驱动视图的变化，而 DataBinding 的单向绑定就是如此。反过来讲，有些时候我们需要视图来驱动数据的变化（例如当我们在 EditText 上输入了文字，我们希望对应的 ViewModel 的 LiveData 的值能够及时响应该变化）</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409161036.jpg" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409110254.gif" alt></p><p>如图，绿色部分为独立的 fragment ，内部存在两个 TextView，用于显示外部 fragment EditText 输入的文字</p><p>如果实现上述功能，传统做法可能是使用 activity 级别的 ViewModel 进行两个 fragment 之间的通信，通过监听 EditText 文字的变化改变 ViewModel 中 LiveData 的值，并在绿色 fragment 中观察 LiveData 并显示到 TextView 中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> firstName = MutableLiveData&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> lastName = MutableLiveData&lt;String&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalDetailFragment</span> : <span class="type">Fragment</span></span>(R.layout.fragment_normal_detail) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> activityViewModels&lt;NormalViewModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        mViewModel.firstName.observe(viewLifecycleOwner) &#123;</span><br><span class="line">            tvFirstName.text = it</span><br><span class="line">        &#125;</span><br><span class="line">        mViewModel.lastName.observe(viewLifecycleOwner) &#123;</span><br><span class="line">            tvLastName.text = it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalFragment</span> : <span class="type">Fragment</span></span>(R.layout.fragment_normal) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> activityViewModels&lt;NormalViewModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        etFirstName.addTextChangedListener &#123;</span><br><span class="line">            mViewModel.firstName.value = it.toString()</span><br><span class="line">        &#125;</span><br><span class="line">        etLastName.addTextChangedListener &#123;</span><br><span class="line">            mViewModel.lastName.value = it.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得益于 kotlin ，上面的代码以及很简洁了，如果使用 java 代码片段只会更长。</p><p>不过使用 DataBinding，还可以更简洁</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textview.MaterialTextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/tvFirstName"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;vm.firstName&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textview.MaterialTextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/tvLastName"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;vm.lastName&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputEditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/etFirstName"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@=&#123;vm.firstName&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputEditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/etLastName"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@=&#123;vm.lastName&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>只需配置好双向绑定（EditText 驱动 ViewModel 的 LiveData 的值变化，ViewModel 再驱动 TextView 显示数据），并在 fragment 通过固定的模板代码设置好 ViewModel 即可</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409112128.jpg" alt></p><p>这里的魔法还是来自 Binding Adapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TextViewBindingAdapter.java</span></span><br><span class="line"><span class="meta">@BindingAdapter</span>(value = &#123;<span class="string">"android:beforeTextChanged"</span>, <span class="string">"android:onTextChanged"</span>,</span><br><span class="line">        <span class="string">"android:afterTextChanged"</span>, <span class="string">"android:textAttrChanged"</span>&#125;, requireAll = <span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTextWatcher</span><span class="params">(TextView view, <span class="keyword">final</span> BeforeTextChanged before,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> OnTextChanged on, <span class="keyword">final</span> AfterTextChanged after,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> InverseBindingListener textAttrChanged)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TextWatcher newValue;</span><br><span class="line">    <span class="keyword">if</span> (before == <span class="keyword">null</span> &amp;&amp; after == <span class="keyword">null</span> &amp;&amp; on == <span class="keyword">null</span> &amp;&amp; textAttrChanged == <span class="keyword">null</span>) &#123;</span><br><span class="line">        newValue = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newValue = <span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (before != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    before.beforeTextChanged(s, start, count, after);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (on != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    on.onTextChanged(s, start, before, count);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (textAttrChanged != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//通知发生变化</span></span><br><span class="line">                    textAttrChanged.onChange();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (after != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    after.afterTextChanged(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);</span><br><span class="line">    <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.removeTextChangedListener(oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.addTextChangedListener(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 InverseBindingListener （调用 <code>textAttrChanged.onChange()</code>）来通知 LiveData 数据发生变化</p><p>而变化后的值 通过 @InverseBindingAdapter 注解标记的方法处理，这里的 event 与上面的标记匹配（<code>android:textAttrChanged</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TextViewBindingAdapter.java</span></span><br><span class="line"><span class="meta">@InverseBindingAdapter</span>(attribute = <span class="string">"android:text"</span>, event = <span class="string">"android:textAttrChanged"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTextString</span><span class="params">(TextView view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> view.getText().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>view 层变化通知数据变化，数据变化再通知 view 层变化，仿佛是个套娃</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409163420.jpg" alt></p><p>因此避免这种死循环十分重要，setText 方法判断了新旧值是否相等来避免死循环</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409163541.png" alt></p><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 总结</span></h2><p>DataBinding 主要提供两部分功能</p><ul><li>替换 findViewById ，如果只用这部分功能可以使用 ViewBinding</li><li>进行 data 和 UI 的绑定，使用「数据驱动」的思想解决了视图的一致性问题</li></ul><h3 id="各种-findViewById-替代方案对比"><a href="#各种-findViewById-替代方案对比" class="headerlink" title="各种 findViewById 替代方案对比"></a>各种 findViewById 替代方案对比</h3><ul><li>findViewById </li><li>Butterknife</li><li>Kotlin Synthetics</li><li>Data Binding</li><li>View Binding</li></ul><h4 id="findViewById"><a href="#findViewById" class="headerlink" title="findViewById"></a>findViewById</h4><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409170514.png" alt></p><p>findViewById 有两个问题</p><ol><li>当不能在 Activity/Fragment/ViewGroup 中定位到指定 id 的 View，会在运行期间崩溃，即非空安全</li><li>如果某个 view 为 TextView 类型，而在使用中将其指定为其他类型不会在编译器报错，即非类型安全</li></ol><p>在 compileSdk 的 API 级别 26 中，对该方法的定义稍作更改以消除强制类型转换问题</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409171139.png" alt></p><p>现在，开发人员无需在代码中手动转换 view 类型。 如果您引用 id 指向类型 TextView 的 View 并将其指定为 Button，则 Android SDK 会尝试查找具有提供的 id 的 Button，并且它将返回 Null，因为它将无法找到它</p><p>但是在 Kotlin 中，您仍然需要提供诸如 findViewById<textview>(R.id.txtUsername) 之类的类型。 如果您不检查视图是否具有 null 安全，则可能出现 NullPointerException，但是此方法不会像以前那样抛出ClassCastException</textview></p><h4 id="Butterknife"><a href="#Butterknife" class="headerlink" title="Butterknife"></a>Butterknife</h4><p><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">Butterknife</a> 是 <a href="https://medium.com/u/8ddd94878165?source=post_page-----98b8ef5b9249----------------------" target="_blank" rel="noopener">Jake Wharton</a> 大神写的替代 findViewById 的库，该库使用注解处理并生成 findViewById 代码</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409171316.png" alt></p><p>它具有与 findViewById 几乎相似的问题。 但是，它在运行时添加了null 安全检查以避免 NullPointerException</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409171554.jpg" alt></p><p>由于 DataBinding 和 ViewBinding 的出现，沃神已经宣布弃用该库</p><h4 id="Kotlin-Synthetics"><a href="#Kotlin-Synthetics" class="headerlink" title="Kotlin Synthetics"></a>Kotlin Synthetics</h4><p>Kotlin 引入的最大功能之一是 Kotlin 扩展方法。 在它的帮助下，Kotlin Synthetics 诞生了。 Kotlin Synthetics 通过自动生成的 Kotlin 扩展方法，使开发人员可以从 xml 布局直接访问其内部的 view</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409171843.png" alt></p><p>Kotlin Synthetics 第一次调用 findViewById 方法，然后默认情况下将 view 实例缓存在 HashMap 中。 可以通过Gradle 设置将此缓存配置更改为 SparseArray 或不缓存</p><p>总体而言，Kotlin Synthetics 是一种很好的选择，因为它类型安全，并且通过 Kotlin 的 ？进行空检查。 它不需要开发人员的额外代码。 但这仅适用于 Kotlin 项目</p><p>但是，在使用 Kotlin Synthetics 时遇到了一个小问题。 例如，如果将内容视图设置为布局，然后使用仅存在于其他布局中的 id ，则 IDE 可让您自动完成并添加新的 import 语句。 除非您专门检查以确保其 import 语句仅导入正确的 view，否则没有安全的方法来验证这不会导致运行时问题</p><h4 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h4><p>DataBinding 在功能上比其他方法优越得多，因为它不仅为您提供类型安全和空安全的 view 引用，而且还允许您直接在 xml 布局内使用数据驱动视图变化</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409172613.png" alt></p><h4 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h4><p>最近在 Android Studio 3.6 中引入的 ViewBinding 是 DataBinding 库的子集。 由于不需要注解处理，因此可以缩短构建时间。详细的使用可以参见 <a href="https://juejin.im/post/5e4806f3e51d4526c550a2ef" target="_blank" rel="noopener">这篇文章</a></p><table><thead><tr><th align="center"></th><th align="center">findViewById</th><th align="center">Butterknife</th><th align="center">Kotlin Synthetics</th><th align="center">DataBinding</th><th align="center">ViewBinding</th></tr></thead><tbody><tr><td align="center">一直空安全</td><td align="center">❌</td><td align="center">部分</td><td align="center">部分</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td align="center">类型安全</td><td align="center">❌</td><td align="center">❌</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td align="center">样板代码</td><td align="center"><font color="#CA0C16">多</font></td><td align="center"><font color="#0DD613">少</font></td><td align="center"><font color="#0DD613">少</font></td><td align="center"><font color="#B77441">中等</font></td><td align="center"><font color="#0DD613">少</font></td></tr><tr><td align="center">构建时间</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td></tr><tr><td align="center">支持语音</td><td align="center">java/kotlin</td><td align="center">java/kotlin</td><td align="center">kotlin</td><td align="center">java/kotlin</td><td align="center">java/kotlin</td></tr></tbody></table><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 关于我</span></h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e834bb5f265da480d61668d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LiveData 篇&lt;/a&gt; 我们提到 Android 开发的主要工作内容是将数据转换为 UI ，同时我们也介绍了数据驱动 UI 的思想，使用 ViewModel + LiveData，可以安全地在订阅者的生命周期内分发正确的数据。但是 activity 和 fragment 充斥着大量的模板代码，铺天盖地的 findViewById，以及各种 set （根据数据设置 UI）。如果能够消灭掉这些模板代码就好了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之LiveData】ViewModel的左膀右臂 数据驱动真的香</title>
    <link href="http://yoursite.com/2020/03/31/Jetpack-LiveData/"/>
    <id>http://yoursite.com/2020/03/31/Jetpack-LiveData/</id>
    <published>2020-03-30T16:10:35.000Z</published>
    <updated>2020-04-20T09:10:31.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>之前我们讨论过 <a href="https://juejin.im/post/5e786d415188255e00661a4e" target="_blank" rel="noopener">ViewModel 的职能边界</a> ，得益于 ViewModel 的生命周期更长，我们可以在 activity 重建后将数据传递给 activity ，也可以避免内存泄漏。但是如果不是每次需要就获取数据，而是当每次有新数据时通知我们，应该怎么办？</p></blockquote><p>本文介绍 <code>LiveData</code> ，一个 <strong>生命周期感知的，可观察的，数据持有者</strong>。同时还会简单分析 <code>LiveData</code> 的源码实现</p><a id="more"></a><h2 id="我们都是-Adapter"><a href="#我们都是-Adapter" class="headerlink" title="我们都是 Adapter"></a>我们都是 Adapter</h2><p>在谈 <code>LiveData</code> 前我们来思考一个问题</p><p><strong>Android 开发（亦或者说前端开发）的本质工作内容是什么？</strong></p><p>对于应用层 app 开发者，开发者的工作主要工作就是 Adapter </p><p>什么是 Adapter ，下图可能比较直观</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330153727.png" alt="Adapter"></p><blockquote><p>图片来自 google image</p></blockquote><p>我们的工作本质是 <strong>将数据转换成 UI</strong> </p><p>数据可能来自网络，来自本地数据库，来自内存，而 UI 可能是 activity 或 fragment。</p><h2 id="理想的数据模型"><a href="#理想的数据模型" class="headerlink" title="理想的数据模型"></a>理想的数据模型</h2><p>上面我们提到 Android 开发者的核心工作就是将数据转换为 UI 。这个过程比较理想的状态是：当数据发生变化时，UI 跟随变化。我们还可以进一步展开：当 UI 对用户可见时，数据发生变化时 UI 跟随变化；当 UI 对用户不可见时，我们希望数据变化时什么都不做，当 UI 再次对用户可见时根据最新的数据进行 UI 的处理。</p><p>而 <code>LiveData</code> 就是我们理想中的数据模型</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330160205.png" alt="LiveData"></p><blockquote><p>图片来自 <a href="https://www.youtube.com/watch?v=2rO4r-JOQtA&list=PLWz5rJ2EKKc_dskHzXdKHB2ZvAlMyFwZe&index=2&t=0s" target="_blank" rel="noopener">Android Dev Summit ‘18-Fun with LiveData</a></p></blockquote><p> LiveData 可以三个关键词概括</p><ul><li><p>lifecycle-aware</p></li><li><p>observable</p></li><li><p>data holder</p></li></ul><h3 id="observable"><a href="#observable" class="headerlink" title="observable"></a>observable</h3><p>Android 中不同的组件有着不同的生命周期，不同的存活时间</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321140641.png" alt="ViewModel"></p><p>因此我们不会在 <code>ViewModel</code> 中持有 <code>Activity</code> 的引用，因为这会导致当 <code>Activity</code> 重建时内存泄漏，甚至出现空指针的情况</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330161100.png" alt="observable"></p><p>通常我们会在 <code>Activity</code> 中持有 <code>ViewModel</code> 的引用，那么如何进行二者间的通信，如何向 <code>Activity</code> 发送 <code>ViewModel</code> 中的数据？</p><p>答案是让 <code>Activity</code> 观察 <code>ViewModel</code></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330161411.png" alt></p><p><code>LiveData</code> 是 <code>observable</code></p><h3 id="lifecycle-aware"><a href="#lifecycle-aware" class="headerlink" title="lifecycle-aware"></a>lifecycle-aware</h3><p>当观察者观察着某个数据时，该数据必须保留对观察者的引用才能调用它，为了解决这个问题，<code>LiveData</code> 被设计成可感知生命周期</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330162126.png" alt></p><p>当 activity / fragment 被销毁后，它会自动的取消订阅</p><h3 id="data-holder"><a href="#data-holder" class="headerlink" title="data holder"></a>data holder</h3><p><code>LiveData</code> 仅持有 <strong>单个且最新</strong> 的数据</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330214220.gif" alt="data holder"></p><p>上图中，最右侧是在 <code>ViewModel</code> 中的 <code>LiveData</code>，左侧为观察这个 <code>LiveData</code> 的 activity / fragment 。一旦我们为 <code>LiveData</code> 设值，该值会传递到 activity。简而言之，<code>LiveData</code> 值改变，activity 收到最新的值的变化。但是当观察者不再处于活动状态（STARTED 到 RESUMED ），数据 C 不会被发送到 activity 。当 activity 回到前台，它将收到最新的值，数据 D。<strong>LiveData 仅持有单个且最新的数据</strong>。当 activity 执行销毁流程时，此时的数据 E 也不会产生任何影响</p><h2 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h2><p><code>LiveData</code> 提供 两种 transformation ，<code>map</code> 和 <code>switch map</code>。开发者也可以创建自定义的  <code>MediatorLiveData</code> </p><p>我们都知道 <code>LiveData</code> 可以为 View 和 ViewModel 提供通信，但如果有一个第三方组件（例如 repository ）也持有 <code>LiveData</code>。那么它应该如何在 <code>ViewModel</code> 中订阅？该组件并没有 lifecycle </p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331090310.png" alt></p><p>一旦我们的应用愈发复杂，repository 可能会观察数据源</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331090412.png" alt></p><p>那么 view 如何获取 repository 中的 <code>LiveData</code>？</p><h3 id="一对一的静态转换（map）"><a href="#一对一的静态转换（map）" class="headerlink" title="一对一的静态转换（map）"></a>一对一的静态转换（map）</h3><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331090941.png" alt="one-to-one static transformation"></p><p>在上面的示例中，<code>ViewModel</code> 仅将数据从 repository 转发到 view，然后将其转换为 UI Model。 每当 repository 中有新数据时，<code>ViewModel</code> 只需 <code>map</code> </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> viewModelResult = Transformations.map(repository.getDataForUser()) &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">     convertDataToMainUIModel(<span class="keyword">data</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数为 <code>LiveData</code> 源（来自 repository ），第二个参数是一个转换函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的转换为将 X 转换为 Y</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;X, Y&gt;</span> LiveData<span class="type">&lt;X&gt;</span>.<span class="title">map</span><span class="params">(<span class="keyword">crossinline</span> transform: (<span class="type">X</span>)</span></span> -&gt; Y): LiveData&lt;Y&gt; =</span><br><span class="line">        Transformations.map(<span class="keyword">this</span>) &#123; transform(it) &#125;</span><br></pre></td></tr></table></figure><h3 id="一对一的动态转换（switchMap）"><a href="#一对一的动态转换（switchMap）" class="headerlink" title="一对一的动态转换（switchMap）"></a>一对一的动态转换（switchMap）</h3><p>假如您正在观察一个提供用户的用户管理器，并且需要提供用户的 id 才能开始观察 repository </p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331091954.png" alt></p><p>您不能将其写到 <code>ViewModel</code> 初始化的过程中，因为此时用户的 id 还不可用</p><p>这时 <code>switchMap</code> 就派上用场了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> repositoryResult = Transformations.switchMap(userManager.userId) &#123; userId -&gt;</span><br><span class="line">     repository.getDataForUser(userId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switchMap</code> 在内部使用 <code>MediatorLiveData</code>，因此了解它非常重要，因为当您要组合多个 <code>LiveData</code> 源时需要使用它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的转换为将 X 转换为 LiveData&lt;Y&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;X, Y&gt;</span> LiveData<span class="type">&lt;X&gt;</span>.<span class="title">switchMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">crossinline</span> transform: (<span class="type">X</span>)</span></span> -&gt; LiveData&lt;Y&gt;</span><br><span class="line">): LiveData&lt;Y&gt; = Transformations.switchMap(<span class="keyword">this</span>) &#123; transform(it) &#125;</span><br></pre></td></tr></table></figure><h3 id="一对多依赖（MediatorLiveData）"><a href="#一对多依赖（MediatorLiveData）" class="headerlink" title="一对多依赖（MediatorLiveData）"></a>一对多依赖（MediatorLiveData）</h3><p><code>MediatorLiveData</code> 允许您将一个或多个数据源添加到单个可观察的 <code>LiveData</code> 中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> liveData1: LiveData&lt;<span class="built_in">Int</span>&gt; = ...</span><br><span class="line"><span class="keyword">val</span> liveData2: LiveData&lt;<span class="built_in">Int</span>&gt; = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = MediatorLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">result.addSource(liveData1) &#123; value -&gt;</span><br><span class="line">    result.setValue(value)</span><br><span class="line">&#125;</span><br><span class="line">result.addSource(liveData2) &#123; value -&gt;</span><br><span class="line">    result.setValue(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，当任何一个数据源变化时，result 会更新。</p><blockquote><p>注意：数据并不是合并，MediatorLiveData 只是处理通知</p></blockquote><p>为了实现示例中的转换，我们需要将两个不同的 LiveData 组合为一个</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331094815.png" alt></p><blockquote><p>图片来自 <a href="https://medium.com/androiddevelopers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7" target="_blank" rel="noopener">LiveData beyond the ViewModel — Reactive patterns using Transformations and MediatorLiveData</a></p></blockquote><p>使用 <code>MediatorLiveData</code> 合并数据的一种方法是添加源并以其他方法设置值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">blogpostBoilerplateExample</span><span class="params">(newUser: <span class="type">String</span>)</span></span>: LiveData&lt;UserDataResult&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> liveData1 = userOnlineDataSource.getOnlineTime(newUser)</span><br><span class="line">    <span class="keyword">val</span> liveData2 = userCheckinsDataSource.getCheckins(newUser)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = MediatorLiveData&lt;UserDataResult&gt;()</span><br><span class="line"></span><br><span class="line">    result.addSource(liveData1) &#123; value -&gt;</span><br><span class="line">        result.value = combineLatestData(liveData1, liveData2)</span><br><span class="line">    &#125;</span><br><span class="line">    result.addSource(liveData2) &#123; value -&gt;</span><br><span class="line">        result.value = combineLatestData(liveData1, liveData2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据的实际组合是在 <code>combineLatestData</code> 方法中完成的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">combineLatestData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        onlineTimeResult: <span class="type">LiveData</span>&lt;<span class="type">Long</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">        checkinsResult: <span class="type">LiveData</span>&lt;<span class="type">CheckinsResult</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: UserDataResult &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> onlineTime = onlineTimeResult.value</span><br><span class="line">    <span class="keyword">val</span> checkins = checkinsResult.value</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't send a success until we have both results</span></span><br><span class="line">    <span class="keyword">if</span> (onlineTime == <span class="literal">null</span> || checkins == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDataLoading()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Check for errors and return UserDataError if any.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UserDataSuccess(timeOnline = onlineTime, checkins = checkins)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查值是否准备好并发出结果（加载中，失败或成功）</p><h2 id="LiveData-的错误用法"><a href="#LiveData-的错误用法" class="headerlink" title="LiveData 的错误用法"></a>LiveData 的错误用法</h2><h3 id="错误地使用-var-LiveData"><a href="#错误地使用-var-LiveData" class="headerlink" title="错误地使用 var LiveData"></a>错误地使用 var LiveData</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">lateinit</span> randomNumber: LiveData&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onGetNumber</span><span class="params">()</span></span> &#123;</span><br><span class="line">   randomNumber = Transformations.map(numberGenerator.getNumber()) &#123;</span><br><span class="line">       it</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个重要的问题需要理解：转换会在调用时（<code>map</code> 和 <code>switchMap</code>）会创建一个新的 <code>LiveData</code>。 在此示例中，randomNumber 公开给 View ，但是每次用户单击按钮时都会对其进行重新赋值。 观察者只会在订阅时收到分配给 var 的 <code>LiveData</code> 更新的信息</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只会收到第一次分配的值</span></span><br><span class="line">viewmodel.randomNumber.observe(<span class="keyword">this</span>, Observer &#123; number -&gt;</span><br><span class="line">    numberTv.text = resources.getString(R.string.random_text, number)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果 viewmodel.randomNumber <code>LiveData</code> 实例发生更改，这里永远不会回调。而且这里泄漏了之前的 <code>LiveData</code> ，这些 <code>LiveData</code> 不会再发送更新</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331111630.gif" alt></p><p>一言以蔽之，<strong>不要在 var 中使用 Livedata</strong></p><p>正确示例见  <a href="https://github.com/Flywith24/Flywith24-Jetpack-Demo/tree/master/demo_livedata" target="_blank" rel="noopener">demo</a></p><h3 id="LiveData-粘性事件"><a href="#LiveData-粘性事件" class="headerlink" title="LiveData 粘性事件"></a>LiveData 粘性事件</h3><p>一般来说我们使用 LiveData 持有 UI 数据和状态，但是如果通过它来发送事件，可能会出现一些问题。这些问题及解决方案 <a href="https://juejin.im/post/5b2b1b2cf265da5952314b63" target="_blank" rel="noopener">在这</a></p><h3 id="fragment-中错误地传入-LifecycleOwner"><a href="#fragment-中错误地传入-LifecycleOwner" class="headerlink" title="fragment 中错误地传入 LifecycleOwner"></a>fragment 中错误地传入 LifecycleOwner</h3><p><code>androidx fragment 1.2.0</code> 起，添加了新的 Lint 检查，以确保您在从 onCreateView()、onViewCreated() 或 onActivityCreated() 观察 <code>LiveData</code> 时使用 getViewLifecycleOwner()</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331152505.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331205402.gif" alt="bug"></p><p>如图，我们有一个 fragment ，onCreate 观察 <code>LiveData</code>，通过正常的生命周期创建了 View ，接着进入了 resume 状态。此时你使用了 <code>LiveData</code>，UI 将开始展示它。之后，用户点击了按钮，由于跳转了另一个 fragment，所以要 detach 该 fragment，一旦 fragment stop 我们就不需要其中的 view 了，因此 destroyView 。之后用户点击了返回按钮回到了上一个 fragment，由于我们已经 destroyView，因此我们需要创建一个新的 view ，接着进入正常的生命周期，但此时，出现了一个 bug 。这个新 View 不会恢复 <code>LiveData</code> 的状态，因为我们使用的是 fragment 的 lifecycle observe 的 <code>LiveData</code></p><p>我们有两种选择，在 onCreate 或者在 onCreateView 中使用 fragment 的 lifecycle observe LiveData</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331171844.png" alt></p><p>前者的优点是一次注册，缺点是当 recreate 时有bug；后者优点是能够解决 recreate 的 bug，但会导致重复注册</p><p><strong>该问题的核心是 fragment 拥有两个生命周期：fragment 自身和 fragment 内部 view 的生命周期</strong></p><p><code>androidx fragment 1.0</code> 和 <code>support library 28</code> 了 viewLifecycle</p><p><strong>因此，当需要观察 view 相关的 LiveData ，可以在 onCreateView()、onViewCreated() 或 onActivityCreated()  中 LiveData observe 方法中传入 viewLifecycleOwner 而不是传入 this</strong></p><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p>首先来看 <code>LiveData</code> 主要的源码结构</p><ul><li>LiveData </li><li>MutableLiveData</li><li>Observer</li></ul><h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p><code>LiveData</code> 是可以在给定生命周期内观察到的数据持有者类。 这意味着可以将一个<code>Observer</code> 与 <code>LifecycleOwner</code> 成对添加，并且只有在配对的 <code>LifecycleOwner</code> 处于活动状态时，才会向该观察者通知有关包装数据的修改。 如果 LifecycleOwner 的状态为 <code>Lifecycle.State.STARTED</code> 或 <code>Lifecycle.State.RESUMED</code>，则将其视为活动状态。 通过 <code>observeForever</code>（Observer）添加的观察者被视为始终处于活动状态，因此将始终收到有关修改的通知。 对于那些观察者，需要手动调用 <code>removeObserver</code>（Observer）</p><p>如果相应的生命周期移至 <code>Lifecycle.State.DESTROYED</code> 状态，则添加了生命周期的观察者将被自动删除。 这对于 activity 和 fragment 可以安全地观察 <code>LiveData</code> 而不用担心泄漏</p><p>此外，<code>LiveData</code> 具有 onActive() 和 onInactive() 方法，以便在活动观察者的数量在 0 到 1 之间变化时得到通知。这使 <code>LiveData</code> 在没有任何活动观察者的情况下可以释放大量资源。</p><p>主要方法有：</p><ul><li>T getValue() 获取LiveData 包装的数据</li><li>observe(LifecycleOwner owner, Observer&lt;? super T&gt; observer) 设置观察者（主线程调用）</li><li>setValue(T value)  设值（主线程调用），可见性为 protected 无法直接使用</li><li>postValue(T value) 设置（其他线程调用），可见性为 protected 无法直接使用</li></ul><h3 id="MutableLiveData"><a href="#MutableLiveData" class="headerlink" title="MutableLiveData"></a>MutableLiveData</h3><p><code>LiveData</code> 实现类，公开了 <code>setValue</code> 和 <code>postValue</code> 方法</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>接口，内部只有 onChanged(T t) 方法，在数据变化时该方法会被调用</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们通过源码来看看 <code>LiveData</code> 如何实现它的特性的</p><ul><li><ol><li>如何控制在 activity 或 fragment 活动状态时接收回调，否则不接收？</li></ol></li><li><ol start="2"><li>如何在 activity 或 fragment 销毁时自动取消注册观察者？</li></ol></li><li><ol start="3"><li>如何保证 <code>LiveData</code> 持有最新的数据？</li></ol></li></ul><p>我们查看 <code>LiveData</code> 的 observe 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LiveData.java</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(LifecycleOwner owner, Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// 如果 owner 已经是 DESTROYED 状态，则忽略</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 LifecycleBoundObserver 包装 owner 和 observer</span></span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="comment">// 如果已经添加过直接 return </span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LifecycleBoundObserver.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line">    LifecycleBoundObserver(LifecycleOwner owner, Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们知道，当我们调用 observe 方法时，内部是通过 <code>LifecycleBoundObserver</code> 将 owner 和 observer 包裹起来并通过 <code>addObserver</code> 方法添加观察者的，因而当数据变化时，会调用 <code>LifecycleBoundObserver</code> 的 <code>onStateChanged</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LiveData.LifecycleBoundObserver.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(@NonNull LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// 自动移除观察者，问题 2 得到解释</span></span><br><span class="line">        removeObserver(mObserver);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activeStateChanged(shouldBeActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当什么周期所有者处于 <code>DESTROYED</code> 状态时，会调用 <code>removeObserver</code> 方法，因此问题 2  得到解释</p><p>我们继续向下看，<code>activeStateChanged</code> 方法调用时传入了 <code>shouldBeActive()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 至少是 STARTED 状态 返回 true</span></span><br><span class="line">    <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">        <span class="comment">// 与上次值相同，则直接 return （两次均为活动状态或均为非活动状态）</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mActive = newActive;</span><br><span class="line">    <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据 mActive 修改活动状态观察者的数量（加 1 或减 1 ）</span></span><br><span class="line">    LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">        onActive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">        onInactive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">        <span class="comment">// 如果是活动状态，则发送数据，问题 1 得到解释</span></span><br><span class="line">        dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里牵扯了 <code>Lifecycle State</code> 比较的知识，<a href="https://juejin.im/post/5e8348bef265da47e02a6ce2#heading-11" target="_blank" rel="noopener">详情在这</a></p><p>只有 <code>STARTED</code> 和 <code>RESUMED</code> 状态 <code>shouldBeActive()</code> 才返回 true，至此问题 1 得到解释</p><p><code>dispatchingValue</code> 方法内部调用了 <code>considerNotify</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再次判断生命周期所有者状态</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较版本号</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    <span class="comment">// 调用我们传入的 mObserver 的 onChanged 方法</span></span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>considerNotify</code> 中比较了 observer 的版本号，如果是最新的数据，直接 return</p><p>而 <code>mVersion</code> 在 <code>setValue</code> 方法中 进行更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每次设置对 mVersion 进行++</span></span><br><span class="line">    mVersion++;</span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 <code>LiveData</code> 每次都持有最新的数据，问题 3 得到解释</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到本文开头的思考，Android 开发者的主要工作是将数据转换成 UI ，而 <code>LiveData</code> 本质上是一种「数据驱动」，即通过改变状态数据，来驱动视图树中绑定了相应状态数据的控件重新发生绘制。Flutter 和未来的  Jetpack Compose 采用的都是这种机制。使用 ViewModel + LiveData，可以 <strong>安全地在订阅者的生命周期内分发正确的数据</strong>，使开发者不知不觉中完成了 <code>UI -&gt; ViewModel -&gt; Data</code> 的单向依赖。</p><p><strong>所谓架构，很多时候不是使用它能做什么，更多的是不要做什么，使用它时开发者能够得到约束，以便产出更健壮的代码</strong></p><p>各位小伙伴如果有什么想法欢迎在评论区留言</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;之前我们讨论过 &lt;a href=&quot;https://juejin.im/post/5e786d415188255e00661a4e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ViewModel 的职能边界&lt;/a&gt; ，得益于 ViewModel 的生命周期更长，我们可以在 activity 重建后将数据传递给 activity ，也可以避免内存泄漏。但是如果不是每次需要就获取数据，而是当每次有新数据时通知我们，应该怎么办？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文介绍 &lt;code&gt;LiveData&lt;/code&gt; ，一个 &lt;strong&gt;生命周期感知的，可观察的，数据持有者&lt;/strong&gt;。同时还会简单分析 &lt;code&gt;LiveData&lt;/code&gt; 的源码实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之Lifecycle】万物基于Lifecycle 默默无闻大作用</title>
    <link href="http://yoursite.com/2020/03/30/Jetpack-Lifecycle/"/>
    <id>http://yoursite.com/2020/03/30/Jetpack-Lifecycle/</id>
    <published>2020-03-29T16:10:35.000Z</published>
    <updated>2020-04-10T08:45:39.764Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> Android 中有一个比较重要的概念：「生命周期」。刚毕业去面试，总会被问到「四大组件的生命周期」这类的问题。17年的 IO 大会上，Google 推出了 Lifecycle-Aware Components（生命周期感知组件），帮助开发者组织更好，更轻量，易于维护的代码</p></blockquote><p>本文介绍 <code>Lifecycle</code> 的职责以及简单分析 lifecycle 如何感知 activity 和 fragment ，帮助您对 <code>Lifecycle</code> 有一个感性的认识</p><a id="more"></a><h2 id="万物基于-Lifecycle"><a href="#万物基于-Lifecycle" class="headerlink" title="万物基于 Lifecycle"></a>万物基于 <strong>Lifecycle</strong></h2><h3 id="手动管理生命周期的痛苦你不懂"><a href="#手动管理生命周期的痛苦你不懂" class="headerlink" title="手动管理生命周期的痛苦你不懂"></a>手动管理生命周期的痛苦你不懂</h3><p><img src="https://user-gold-cdn.xitu.io/2020/3/30/1712bbbbf69f3b1e?w=2407&h=5062&f=jpeg&s=2270014" alt="lifecycles"></p><blockquote><p> 鲁迅曾说过：万物基于 Lifecycle</p></blockquote><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331214314.jpeg" alt></p><p>哦不对</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331214054.jpeg" alt></p><p>Android 中的视图控制器就有这么多生命周期的情况，所以处理好生命周期十分重要，否则会导致内存泄漏甚至是程序崩溃。这里引用 <a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">官方文档</a> 的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 连接系统的定位服务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 与系统的定位服务断开连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, (location) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 更新 UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        myLocationListener.start();</span><br><span class="line">        <span class="comment">//管理其他需要响应 activity 生命周期的组件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">        <span class="comment">//管理其他需要响应 activity 生命周期的组件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此示例看起来不错，在实际的应用程序中，您仍然会响应生命周期的当前状态而进行过多的调用来管理 UI 和其他组件。 管理多个组件会在生命周期方法中放置大量代码，例如 onStart() 和 onStop()，这使它们难以维护</p><p>而且，不能保证组件在 activity 或 fragment 停止之前就已启动。 如果我们需要执行长时间运行的操作（例如onStart() 中的某些配置检查），则可能会导致争用情况，其中onStop() 方法在 onStart() 之前完成，从而使组件的生存期超过了所需的生存期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, location -&gt; &#123;</span><br><span class="line">            <span class="comment">// 更新 UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果在 activity 停止后调用此回调怎么办？</span></span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有所有的组件，都能感知外部的生命周期，能在相应的时机释放资源，并且在错过生命周期时能及时叫停异步的任务就好了，</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200326095005.gif" alt></p><p>我们不妨先思考一下，如果实现这样的想法，应该如何做</p><h3 id="按照惯例的思考"><a href="#按照惯例的思考" class="headerlink" title="按照惯例的思考"></a>按照惯例的思考</h3><p>首先我们先来整理一下我们的需求</p><ul><li>内部组件能够感知外部的生命周期</li><li>能够统一地管理，做到一处修改，处处生效</li><li>能够及时叫停错过的任务</li></ul><p>针对需求1，可以用观察者模式，内部组件能够在外部生命周期变化时做出相应</p><p>针对需求2，可以将依赖组件的代码移出生命周期方法内，然后移入组件本身，这样只需修改组件内部逻辑即可</p><p>针对需求3，可以在合适的时机移除观察者</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>关于开发者模式，我第一次比较详细的了解是在 <a href="https://juejin.im/user/552f20a7e4b060d72a89d87f" target="_blank" rel="noopener">扔物线</a> 的 <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a>。</p><blockquote><p>观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者（例如 A 不需要每过 2ms 就检查一次 B 的状态），而是采用<strong>注册</strong>(Register)<strong>或者称为</strong>订阅<strong>(Subscribe)</strong>的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 <code>OnClickListener</code> 。对设置 <code>OnClickListener</code> 来说， <code>View</code> 是被观察者， <code>OnClickListener</code> 是观察者，二者通过 <code>setOnClickListener()</code> 方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 <code>OnClickListener</code> 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷『你在作案的时候务必通知我』。</p></blockquote><p>OnClickListener 的模式大致如下图：</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200326103024.jpg" alt></p><blockquote><p>上述描述及图片均来自 <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></p></blockquote><p><strong>因此在生命周期组件的生命周期发生变化时告诉观察者，内部组件即可感知外部的生命周期</strong></p><h3 id="引入-Lifecycle-后"><a href="#引入-Lifecycle-后" class="headerlink" title="引入 Lifecycle 后"></a>引入 Lifecycle 后</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnectListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myLifecycleOwner.getLifecycle().addObserver(<span class="keyword">new</span> MyObserver());</span><br></pre></td></tr></table></figure><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200326134237.png" alt></p><p>这是 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>  的结构，抽象类，其内部有两个枚举，分别代表着「事件」和「状态」，此外还有三个方法，添加/移除观察者，获取当前状态</p><blockquote><p><strong>注意，这里 State 中的枚举顺序是有意义的，后文详细介绍</strong></p></blockquote><p>其实现类为  <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleRegistry" target="_blank" rel="noopener">LifecycleRegistry</a> ，可以处理多个观察者</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200326135029.png" alt="LifecycleRegistry"></p><p>其内部持有当前的状态 mState ，LifecycleOwner 以及观察者的自定义列表，同时重写了父类的添加/删除观察者的方法</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200326135636.png" alt="LifecycleOwner"></p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a> ，具有 Android 的生命周期，定制组件可以使用这些事件来处理生命周期更改，而无需在 Activity 或 Fragment 中实现任何代码</p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="noopener">LifecycleObserver</a> ，将一个类标记为 <code>LifecycleObserver</code>。 它没有任何方法，而是依赖于 OnLifecycleEvent 注解的方法</p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver" target="_blank" rel="noopener">LifecycleEventObserver</a> ，可以接收任何生命周期更改并将其分派给接收方。</p><p><strong>如果一个类实现此接口并同时使用 OnLifecycleEvent，则注解将被忽略</strong></p><p><a href="https://developer.android.com/reference/androidx/lifecycle/DefaultLifecycleObserver" target="_blank" rel="noopener">DefaultLifecycleObserver</a> ，用于监听 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a> 状态更改的回调接口。</p><p>如果一个类同时实现了此接口和 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver" target="_blank" rel="noopener">LifecycleEventObserver</a>，则将首先调用<code>DefaultLifecycleObserver</code> 的方法，然后再调用LifecycleEventObserver.onStateChanged（LifecycleOwner，Lifecycle.Event）</p><blockquote><p>注意：使用 <a href="https://developer.android.com/reference/androidx/lifecycle/DefaultLifecycleObserver" target="_blank" rel="noopener">DefaultLifecycleObserver</a> 需引入</p><p> implementation “androidx.lifecycle:lifecycle-common-java8:$lifecycle_version”</p></blockquote><h2 id="简单的源码分析"><a href="#简单的源码分析" class="headerlink" title="简单的源码分析"></a>简单的源码分析</h2><h3 id="activity-生命周期处理"><a href="#activity-生命周期处理" class="headerlink" title="activity 生命周期处理"></a>activity 生命周期处理</h3><p>首先我们还是来看 <strong>androidx.activity.ComponentActivity</strong> ，这个类我们这个系列的文章里提到多次，第一次提及是在 <a href="https://juejin.im/post/5e738d12518825495d69cfb9#heading-2" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a> ，感兴趣的小伙伴可以看看。</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200327104836.png" alt="ComponentActivity"></p><p>其实现的接口大多数我们都已经探讨过了，今天我们来看看 LifecycleOwner</p><blockquote><p>ActivityResultCaller 为 activity 1.2.0-alpha02 推出的，旨在统一 onActivityResult ，这里暂时不讨论它</p></blockquote><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200327105352.png" alt></p><p>既然实现了 <code>LifecycleOwner</code> 接口，必定重写 getLifecycle() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.ComponentActivity.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回的 <code>Lifecycle</code> 为 实现类 <code>LifecycleRegistry</code> 的实例</p><p>而 activity 操作生命周期是通过 <code>ReportFragment</code> 处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.ComponentActivity.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReportFragment</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">        <span class="comment">// api 29 及以上 直接注册正确的生命周期回调</span></span><br><span class="line">        activity.registerActivityLifecycleCallbacks(</span><br><span class="line">                <span class="keyword">new</span> LifecycleCallbacks());</span><br><span class="line">    &#125;</span><br><span class="line">    android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">    <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">        manager.executePendingTransactions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200327113340.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReportFragment.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(@NonNull Activity activity, @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(@NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">        dispatch(getActivity(), event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LifecycleCallbacks</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleCallbacks</span> <span class="keyword">implements</span> <span class="title">Application</span>.<span class="title">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostCreated</span><span class="params">(@NonNull Activity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostStarted</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostResumed</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPrePaused</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPreStopped</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPreDestroyed</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 activity 的 onCreate 方法中，调用了 <code>ReportFragment</code> 中的静态方法 <code>injectIfNeededIn()</code> 。而其内部，<strong>如果 api 29 及以上的设备上直接注册正确的生命周期回调，低版本通过启动 ReportFragment ，借助 fragment 各个生命周期来处理生命周期回调</strong></p><h3 id="fragment-生命周期处理"><a href="#fragment-生命周期处理" class="headerlink" title="fragment 生命周期处理"></a>fragment 生命周期处理</h3><p>在 fragment 内部，每个生命周期节点调用 <code>handleLifecycleEvent</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Fragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initLifecycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    onCreate(savedInstanceState);</span><br><span class="line">mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    onStart();</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    onResume();</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    onPause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class="line">    onStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lifecycle-State-大小比较"><a href="#Lifecycle-State-大小比较" class="headerlink" title="Lifecycle State 大小比较"></a>Lifecycle State 大小比较</h3><p><code>Lifecycle.State</code>  中有一个 <code>isAtLeast</code> 方法，用于判断当前状态是否不小于传入的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lifecycle.State</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(@NonNull State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举的 compareTo 方法其实是比较的枚举声明的顺序</strong></p><p>而 State 的顺序为 DESTROYED -&gt; INITIALIZED -&gt; CREATED -&gt; STARTED -&gt; RESUMED</p><blockquote><p>如果传入的 state 为 STARTED，则当前状态为 STARTED 或 RESUMED 时返回 true ，否则返回 false</p><p>LiveData 篇会用到这个知识点</p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 关于我</span></h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; Android 中有一个比较重要的概念：「生命周期」。刚毕业去面试，总会被问到「四大组件的生命周期」这类的问题。17年的 IO 大会上，Google 推出了 Lifecycle-Aware Components（生命周期感知组件），帮助开发者组织更好，更轻量，易于维护的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文介绍 &lt;code&gt;Lifecycle&lt;/code&gt; 的职责以及简单分析 lifecycle 如何感知 activity 和 fragment ，帮助您对 &lt;code&gt;Lifecycle&lt;/code&gt; 有一个感性的认识&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之ViewModel】即使您不使用MVVM也要了解ViewModel ViewModel的职能边界</title>
    <link href="http://yoursite.com/2020/03/23/Jetpack-ViewModel/"/>
    <id>http://yoursite.com/2020/03/23/Jetpack-ViewModel/</id>
    <published>2020-03-22T16:10:35.000Z</published>
    <updated>2020-03-24T01:26:41.168Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324083031.png" alt="目录"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Android 开发时，我们使用 activity 和 fragment 作为视图控制器， 可能还会使用有一些类可以存储和提供 UI 数据（例如MVP中的 <code>Presenter</code> ）</p></blockquote><p>但是 当配置更改时（如旋转屏幕），activity 会重建，但对于 UI 数据的持有者呢？</p><ul><li>开发者需要重新保存相关的信息并传递给重建的 activity ，否则开发者必须再次获取数据（通过网络请求或本地数据库）</li><li>由于 UI 数据的持有者的生命周期可能比 activity 长，因此开发者还需要避免出现内存泄漏的问题</li></ul><p>如何解决上述问题？ViewModel</p><p><strong>本文重点介绍 ViewModel 的职责（what）以及重点功能的实现原理（how），即使您不使用 <code>Jetpack MVVM</code> 架构，也要了解一下 ViewModel</strong></p><p>ViewModel 的原理部分要求您了解 activity 的启动流程，这部分内容网上文章很多，本文不再赘述</p><a id="more"></a><h2 id="ViewModel-的职责"><a href="#ViewModel-的职责" class="headerlink" title="ViewModel 的职责"></a>ViewModel 的职责</h2><p>我先上个 <a href="https://www.bilibili.com/video/av97794796/" target="_blank" rel="noopener">视频</a> ，这个小姐姐表述的比文字更形象</p><p><a href="https://www.bilibili.com/video/av97794796/" target="_blank" rel="noopener"><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321135602.png" alt></a></p><p><code>ViewModel</code> 主要用于存储 UI 数据以及生命周期感知的数据</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321140300.gif" alt></p><blockquote><p>图片来自 <a href="https://android.jlelse.eu/android-architecture-components-viewmodel-e74faddf5b94" target="_blank" rel="noopener">Android Architecture Components: ViewModel</a></p></blockquote><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321140641.png" alt="ViewModel生命周期"></p><blockquote><p><code>ViewModel</code> 的生命周期 ，图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#lifecycle" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="作为数据持有者"><a href="#作为数据持有者" class="headerlink" title="作为数据持有者"></a>作为数据持有者</h3><p><code>ViewModel</code> 能够实时进行配置更改。 这意味着即使在手机旋转后销毁并重新创建 activity 之后，您仍然拥有相同的 <code>ViewModel</code> 和相同的数据。 因此：</p><ul><li>您无需担心 UI 数据持有者的生命周期。 <code>ViewModel</code> 将由工厂自动创建，您无需自行创建和销毁</li><li>数据将始终更新，旋转手机后，您将获得与以前相同的数据。 因此，您无需手动将数据传递给新的 activity 实例或再次调用网络或数据库来获取数据。 </li></ul><h3 id="Fragment-间共享数据"><a href="#Fragment-间共享数据" class="headerlink" title="Fragment 间共享数据"></a>Fragment 间共享数据</h3><p>一个 activity 中的两个或更多 fragment 需要相互通信是很常见的。例如您有一个片段，用户在其中从列表中选择一个 item，另一个片段显示了所选 item 的内容。 传统做法两个 fragment 都需要定义一些接口，并且宿主 activity 必须将两者绑定在一起。 此外，两个 fragment 都必须处理另一个 fragment 尚未创建或不可见的情况。</p><p>可以通过使用 <code>ViewModel</code> 对象解决此问题。 这些 fragment 可以使用 activity 范围内共享一个 <code>ViewModel</code> 来处理此通信，如以下示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="keyword">new</span> MutableLiveData&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;Item&gt; <span class="title">getSelected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SharedViewModel model;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(@NonNull View view, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        model = <span class="keyword">new</span> ViewModelProvider(requireActivity()).get(SharedViewModel.class);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(@NonNull View view, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        SharedViewModel model = <span class="keyword">new</span> ViewModelProvider(requireActivity()).get(SharedViewModel.class);</span><br><span class="line">        model.getSelected().observe(getViewLifecycleOwner(), &#123; item -&gt;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于 两个 fragment 使用的都是 activity 范围的 <code>ViewModel</code> （<code>ViewModelProvider</code> 构造器传入的 activity ），因此它们获得了相同的 ViewModel 实例，自然其持有的数据也是相同的，这也 <strong>保证了数据的一致性</strong></p></blockquote><p>这种方法具有以下优点：</p><ul><li><p>宿主 activity 无需执行任何操作，也无需了解此通信。</p></li><li><p>除 <code>SharedViewModel</code> 外，fragment 不需要彼此了解。 如果其中一个 fragment 消失了，则另一个继续照常工作。</p></li><li><p>每个 fragment 都有其自己的生命周期，并且不受另一个 fragment 的生命周期影响。 如果一个 fragment 替换了另一个 fragment，则 UI 可以继续正常工作而不会出现任何问题。</p></li></ul><h3 id="代替-Loader"><a href="#代替-Loader" class="headerlink" title="代替 Loader"></a>代替 Loader</h3><p><code>CursorLoader</code> 这样的 Loader 类经常用于使应用程序 UI 中的数据与数据库保持同步。您可以使用 <code>ViewModel</code> 和其他一些类来替换 Loader。 使用 <code>ViewModel</code> 可将视图控制器与数据加载操作分开，这意味着您在类之间的强引用较少。</p><p>在使用 Loader 的一种常见方法中，应用程序可能会使用 <code>CursorLoader</code> 来观察数据库的内容。 当数据库中的值更改时，加载程序会自动触发数据的重新加载并更新 UI</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321144832.png" alt></p><blockquote><p>图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#loaders" target="_blank" rel="noopener">官方文档</a></p></blockquote><p><code>ViewModel</code> 与 <code>Room</code> 和 <code>LiveData</code> 一起使用以替换 Loader。 <code>ViewModel</code> 确保数据在设备配置更改后仍然存在。 当数据库发生更改时，<code>Room</code> 会通知 <code>LiveData</code> ，然后 <code>LiveData</code> 会使用修改后的数据更新 UI</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321144949.png" alt></p><blockquote><p>图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#loaders" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>ViewModel 可作为 UI 数据的持有者，在 activity/fragment 重建时 ViewModel 中的数据不受影响，同时可以避免内存泄漏</strong></li><li><strong>可以通过 ViewModel 来进行 activity 和 fragment ，fragment 和 fragment 之间的通信，无需关心通信的对方是否存在，使用 application 范围的 ViewModel 可以进行全局通信</strong></li><li><strong>可以代替 Loader</strong></li></ul><h2 id="ViewModel-源码分析"><a href="#ViewModel-源码分析" class="headerlink" title="ViewModel 源码分析"></a>ViewModel 源码分析</h2><p>分析源码时我们可以不计较细枝末节，只分析主要的逻辑即可。因此我们来思考几个问题，并从源码中寻找答案</p><ul><li><p>如何做到 activity 重建后 <code>ViewModel</code> 仍然存在？</p></li><li><p>如何做到 fragment 重建后 <code>ViewModel</code> 仍然存在？</p></li><li><p>如何控制作用域？（即保证相同作用域获取的 <code>ViewModel</code> 实例相同）</p></li><li><p>如何避免内存泄漏？</p></li></ul><p>维持我们一贯的风格，我们先来大胆地猜一猜</p><p>对于问题1 ：activity 有着 <code>saveInstanceState</code> 机制，因此可能通过该机制来处理（<strong>事实证明不是</strong>）</p><p>对于问题2：可能 fragment 通过 宿主 activity 或 父 fragment 的帮助来确保 <code>ViewModel</code> 实例在重建后仍然存在</p><p>对于问题3：实现一个类似单例的效果，相同作用域获取的对象是相同的</p><p>对于问题4：避免 <code>ViewModel</code> 持有 view 或 context 的引用</p><p>首先我们要先了解一下 <code>ViewModel</code> 的结构</p><ul><li><p><code>ViewModel</code>：抽象类，主要有 clear 方法，它是 final 级，不可修改，clear 方法中包含 onClear 钩子，开发者可重写 onClear 方法来自定义数据的清空</p></li><li><p><code>ViewModelStore</code>：内部维护一个 HashMap 以管理 <code>ViewModel</code></p></li><li><p><code>ViewModelStoreOwner</code>：接口，<code>ViewModelStore</code> 的作用域，实现类为 <code>ComponentActivity</code> 和 <code>Fragment</code>，此外还有 <code>FragmentActivity.HostCallbacks</code></p></li><li><p><code>ViewModelProvider</code>：用于创建 <code>ViewModel</code>，其构造方法有两个参数，第一个参数传入 <code>ViewModelStoreOwner</code> ，确定了 <code>ViewModelStore</code> 的作用域，第二个参数为 <code>ViewModelProvider.Factory</code>，用于初始化 <code>ViewModel</code> 对象，默认为 <code>getDefaultViewModelProviderFactory()</code> 方法获取的 factory</p></li></ul><p>简单来说 <strong>ViewModelStoreOwner 持有 ViewModelStore 持有 ViewModel</strong></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321152406.png" alt></p><h3 id="1-如何做到-activity-重建后-ViewModel-仍然存在？"><a href="#1-如何做到-activity-重建后-ViewModel-仍然存在？" class="headerlink" title="1. 如何做到 activity 重建后 ViewModel 仍然存在？"></a>1. 如何做到 activity 重建后 ViewModel 仍然存在？</h3><p>在 <a href="https://juejin.im/post/5e738d12518825495d69cfb9" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a> 中我们提到了 androidx.core.app.ComponentActivity 的引入并探讨了其作为中间层的作用</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321155215.png" alt></p><p>我们已经讲过 <code>SavedStateRegistryOwner</code> 和 <code>OnBackPressedDispatcherOwner</code> 这两种角色，而今天我们来聊一下</p><p><code>ViewModelStoreOwner</code> 和 <code>HasDefaultViewModelProviderFactory</code> 。其中前者代表着 <code>ViewModelStore</code> 的作用域，后者来标记 <code>ViewModelStoreOwner</code> 拥有默认的 <code>ViewModelProvider.Factory</code></p><p>那么 <code>ViewModel</code> 的逻辑肯定就在该类了</p><p><code>ComponentActivity</code> 实现了 <code>ViewModelStoreOwner</code>  接口，意味着需要重写 <code>getViewModelStore()</code> 方法，该方法为 <code>ComponentActivity</code>  的 <code>mViewModelStore</code> 变量赋值。<strong>activity 重建后 ViewModel 仍然存在，只要保证 activity 重建后 mViewModelStore 变量值不变即可</strong></p><p>顺着这个思路，我们来看一下 <code>getViewModelStore()</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">        NonConfigurationInstances nc =</span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//核心，在该位置重置 mViewModelStore</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mViewModelStore = <span class="keyword">new</span> ViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即 <code>mViewModelStore</code> 的值由 <code>getLastNonConfigurationInstance()</code> 返回的 <code>NonConfigurationInstances</code> 对象中的 <code>viewModelStore</code> 赋值，如果此时还为空才去 new ViewModelStore 对象。因此我们只需找到 </p><p><code>getLastNonConfigurationInstance</code> 中的 <code>NonConfigurationInstances</code> 在哪里保存的即可</p><p><code>getLastNonConfigurationInstance</code> 为平台 activity 中的方法，返回 <code>mLastNonConfigurationInstances.activity</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getLastNonConfigurationInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLastNonConfigurationInstances != <span class="keyword">null</span></span><br><span class="line">            ? mLastNonConfigurationInstances.activity : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们看一下 <code>mLastNonConfigurationInstances</code> 的赋值位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略其他参数</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(NonConfigurationInstances lastNonConfigurationInstances)</span></span>&#123;</span><br><span class="line">mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解过 activity 的启动流程的小伙伴肯定知道，这个 attach 方法是 <code>ActivityThread</code> 中的 <code>performLaunchActivity</code> 调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line">    <span class="comment">//省略其他参数</span></span><br><span class="line">    activity.attach(r.lastNonConfigurationInstances);</span><br><span class="line">    r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深入追踪源码我们整理一下调用流程</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200323114334.png" alt></p><p>由于 <code>ActivityThread</code> 中的 <code>ActivityClientRecord</code> 不受 activity 重建的影响，所以 activity 重建时 <code>mLastNonConfigurationInstances</code> 能够得到上一次的值，使得 <code>ViewModelStore</code> 值不变 ，问题1就解决了</p><h3 id="2-如何做到-fragment-重建后-ViewModel-仍然存在？"><a href="#2-如何做到-fragment-重建后-ViewModel-仍然存在？" class="headerlink" title="2. 如何做到 fragment 重建后 ViewModel 仍然存在？"></a>2. 如何做到 fragment 重建后 ViewModel 仍然存在？</h3><p>对于问题2，有了上面的思路我们可以认定 fragment 重建后其内部的 <code>getViewModelStore()</code> 方法返回的对象是相同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mFragmentManager.getViewModelStore(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>getViewModelStore()</code> 内部调用的是 <code>mFragmentManager</code>（普通fragment 对应 activity 中的 <code>FragmentManager</code>，子 fragment 则对应父 fragment 的 <code>childFragmentManager</code>）的 <code>getViewModelStore()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentManager.java</span></span><br><span class="line"><span class="keyword">private</span> FragmentManagerViewModel mNonConfig;</span><br><span class="line"></span><br><span class="line"><span class="function">ViewModelStore <span class="title">getViewModelStore</span><span class="params">(@NonNull Fragment f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mNonConfig.getViewModelStore(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>而 FragmentManager 中的 getViewModelStore 使用的是 mNonConfig ，mNonConfig 竟然是个 ViewModel！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentManagerViewModel.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModelStore&gt; mViewModelStores = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p><code>FragmentManagerViewModel</code> 管理着内部的 <code>ViewModelStore</code> 和 child 的 <code>FragmentManagerViewModel</code> 。因此保证 mNonConfig   值不变即能确保 fragment 中的 <code>getViewModelStore()</code>  不变。那么看看 mNonConfig  赋值的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachController</span><span class="params">(@NonNull FragmentHostCallback&lt;?&gt; host, @NonNull FragmentContainer container, @Nullable <span class="keyword">final</span> Fragment parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 嵌套 fragment 的情况，有父 fragment</span></span><br><span class="line">        mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (host <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">        <span class="comment">// host 是 FragmentActivity.HostCallbacks</span></span><br><span class="line">        ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();</span><br><span class="line">        mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNonConfig = <span class="keyword">new</span> FragmentManagerViewModel(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// FragmentManagerViewModel.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FragmentManagerViewModel <span class="title">getInstance</span><span class="params">(ViewModelStore viewModelStore)</span> </span>&#123;</span><br><span class="line">    ViewModelProvider viewModelProvider = <span class="keyword">new</span> ViewModelProvider(viewModelStore,</span><br><span class="line">            FACTORY);</span><br><span class="line">    <span class="keyword">return</span> viewModelProvider.get(FragmentManagerViewModel.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看 fragment 的直接宿主是 activity （即没有嵌套）的情况，mNonConfig 由<code>FragmentManagerViewModel.getInstance(viewModelStore)</code> 赋值，而 getInstance 中使用的是 <code>ViewModelProvider</code> 获取 <code>ViewModel</code> ，根据我们上面的分析，<strong>只要保证作用域（viewModelStore）相同，即可获取相同的 <code>ViewModel</code> 实例</strong>，因此我们需要看一下 host 的 getViewModelStore 方法。经过一番寻找，host 是 <code>FragmentActivity.HostCallbacks</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentActivity.java 内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HostCallbacks</span> <span class="keyword">extends</span> <span class="title">FragmentHostCallback</span>&lt;<span class="title">FragmentActivity</span>&gt; <span class="keyword">implements</span> <span class="title">ViewModelStoreOwner</span>, <span class="title">OnBackPressedDispatcherOwner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 宿主 activity 的 getViewModelStore</span></span><br><span class="line">    <span class="keyword">return</span> FragmentActivity.<span class="keyword">this</span>.getViewModelStore();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>host 的 getViewModelStore 方法返回的是宿主 activity 的 <code>getViewModelStore()</code> ，而 activity 重建后其内部的 <code>mViewModelStore</code> 是不变的，因此即使 activity 重建，其内部的 FragmentManager 对象变化，但 FragmentManager 内部的  FragmentManagerViewModel 的实例（<code>mNonConfig</code>）不变，mNonConfig.getViewModelStore 不变，fragment 的 <code>getViewModelStore()</code> 亦不变，fragment 重建后其内部的 <code>ViewModel</code> 仍然存在</p><p>对于嵌套 fragment ，mNonConfig 通过 parent.mFragmentManager.getChildNonConfig(parent) 获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> FragmentManagerViewModel <span class="title">getChildNonConfig</span><span class="params">(@NonNull Fragment f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mNonConfig.getChildNonConfig(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文提到 <code>FragmentManagerViewModel</code> 管理着 mChildNonConfigs Map，因此子 fragment 重置后其内部的 mNonConfig 对象也是相同的</p><p>至此问题 2 就解决了</p><h3 id="3-如何控制作用域？"><a href="#3-如何控制作用域？" class="headerlink" title="3. 如何控制作用域？"></a>3. 如何控制作用域？</h3><p>对于问题3，我们知道 <code>ViewModelStoreOwner</code> 代表着作用域，其内部唯一的方法返回 <code>ViewModelStore</code> 对象，也即不同的作用域对应不同的 <code>ViewModelStore</code> ，而 <code>ViewModelStore</code>  内部维护着 <code>ViewModel</code> 的 HashMap ，因此只要保证相同作用域的 <code>ViewModelStore</code> 对象相同就能保证相同作用域获取到相同的 <code>ViewModel</code> 对象，而问题1我们已经解释了重建时如何保证 <code>ViewModelStore</code>  对象不变。</p><p>因此问题3也解决了。</p><h3 id="4-如何避免内存泄漏？"><a href="#4-如何避免内存泄漏？" class="headerlink" title="4. 如何避免内存泄漏？"></a>4. 如何避免内存泄漏？</h3><p>对于问题4，由于 <code>ViewModel</code> 的设计，使得 activity/fragment 依赖它，而 <code>ViewModel</code> 不依赖视图控制器。因此只要不让 <code>ViewModel</code> 持有 context 或 view 的引用，就不会造成内存泄漏</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>简单的总结一下：</p><ul><li><p><strong>activity 重建后 mViewModelStore 通过 ActivityThread 的一系列方法能够保持不变，从而当 activity 重建时 ViewModel 中的数据不受影响</strong></p></li><li><p><strong>通过宿主 activity 范围内共享的 FragmentManagerViewModel 来存储 fragment 的 ViewModelStore 和子fragment 的 FragmentManagerViewModel ，而 activity 重建后 FragmentManagerViewModel  中的数据不受影响，因此 fragment 内部的 ViewModel 的数据也不受影响</strong></p></li><li><p><strong>通过同一 ViewModelStoreOwner 获取的 ViewModelStore 相同，从而保证同一作用域通过 ViewModelProvider 获取的ViewModel 对象是相同的</strong></p></li><li><p><strong>通过单向依赖（视图控制器持有 ViewModel ）来解决内存泄漏的问题</strong></p></li></ul><h2 id="ViewModel-和-onSaveInstanceState"><a href="#ViewModel-和-onSaveInstanceState" class="headerlink" title="ViewModel 和 onSaveInstanceState"></a>ViewModel 和 onSaveInstanceState</h2><p><code>ViewModel</code> 和 <code>onSaveInstanceState</code> 的功能有些类似，但它们也有很多差异</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200323160417.png" alt></p><p>从存储位置上来说，<code>ViewModel</code> 是在内存中，因此其读写速度更快，但当进程被系统杀死后，<code>ViewModel</code> 中的数据也不存在了。从数据存储的类型上来看，<code>ViewModel</code> 适合存储相对较重的数据，例如网络请求到的 list 数据，而 <code>onSaveInstanceState</code> 适合存储轻量可序列化的数据</p><p>那么我们该如何使用呢？可以使用 <code>viewmodel-savedstate</code> 库，详情参考 <a href="https://juejin.im/post/5e738d12518825495d69cfb9#heading-10" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a></p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/flywith24/Album/raw/master/img/20200324083031.png&quot; alt=&quot;目录&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Android 开发时，我们使用 activity 和 fragment 作为视图控制器， 可能还会使用有一些类可以存储和提供 UI 数据（例如MVP中的 &lt;code&gt;Presenter&lt;/code&gt; ）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是 当配置更改时（如旋转屏幕），activity 会重建，但对于 UI 数据的持有者呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发者需要重新保存相关的信息并传递给重建的 activity ，否则开发者必须再次获取数据（通过网络请求或本地数据库）&lt;/li&gt;
&lt;li&gt;由于 UI 数据的持有者的生命周期可能比 activity 长，因此开发者还需要避免出现内存泄漏的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何解决上述问题？ViewModel&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文重点介绍 ViewModel 的职责（what）以及重点功能的实现原理（how），即使您不使用 &lt;code&gt;Jetpack MVVM&lt;/code&gt; 架构，也要了解一下 ViewModel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ViewModel 的原理部分要求您了解 activity 的启动流程，这部分内容网上文章很多，本文不再赘述&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之ViewModel】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</title>
    <link href="http://yoursite.com/2020/03/19/Jetpack-ViewModel-SaveState/"/>
    <id>http://yoursite.com/2020/03/19/Jetpack-ViewModel-SaveState/</id>
    <published>2020-03-18T16:10:35.000Z</published>
    <updated>2020-03-24T01:27:06.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>大家都知道 activity 有着一套 <code>onSaveInstanceState-onRestoreInstanceState</code> 状态保存机制，旨在「系统资源回收」或「配置发生变化」保存状态，为用户提供更好的体验</p><p>在 androidx 下，提供了 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 库帮助 activity 和 fragment 处理状态保存和恢复</p></blockquote><p>本文默认您对状态保存机制有一定了解，这部分内容请移步 <a href="https://developer.android.com/topic/libraries/architecture/saving-states" target="_blank" rel="noopener">Saving UI States</a></p><p>此外，关于 android 下的进程管理，推荐 Ian Lake 的 <a href="https://medium.com/androiddevelopers/who-lives-and-who-dies-process-priorities-on-android-cb151f39044f" target="_blank" rel="noopener">Who lives and who dies? Process priorities on Android</a></p><p>本文介绍了 androidx 下 <code>SavedState</code> 如何帮助 activity 和 fragment 处理状态的保存和恢复，同时介绍 <code>viewmodel-savedstate</code> 库，以及在开发过程中正确使用状态保存的姿势</p><a id="more"></a><h2 id="软件工程中没有什么是中间层解决不了的"><a href="#软件工程中没有什么是中间层解决不了的" class="headerlink" title="软件工程中没有什么是中间层解决不了的"></a>软件工程中没有什么是中间层解决不了的</h2><p>在分析 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 库之前我们需要简单聊一聊 <code>ComponentActivity</code></p><p>androidx activity 1.0.0 时，<code>ComponentActivity</code> 成为了 <code>FragmentActivity</code> 和 <code>AppCompatActivity</code> 的基类。</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318211230.png" alt="androidx activity 1.0.0 "></p><p>俗话说「百因必有果」，带着强烈的好奇心，我查了一下 ComponentActivity 引入的原因。</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318211823.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318211806.png" alt></p><p>可以看到 <code>ComponentActivity</code> 继承了 androidx.core.app.ComponentActivity(在fragment库中)，并且最初仅实现了<code>LifecycleOwner</code> 接口</p><p>我们创建的 activity 的继承关系现在变成了这样：</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318213053.png" alt></p><p>那么回到最初的问题，为什么要引入 <code>ComponentActivity</code> ？其实看看现在 <code>ComponentActivity</code> 的类结构答案就很清楚了</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318213151.png" alt></p><p><code>ComponentActivity</code> 实现了五个接口，代表着其除了 activity 还充当着五种角色。本着职能单一原则，官方通过建立一个中间层将部分功能分别交于专门的类来负责，OnBackPressedDispatcherOwner 就是我们讲 fragment 返回栈（<a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇</a>）时提到的结构，而其中的 <code>SavedStateRegistryOwner</code> 则是我们今天要讲的主角  <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 中的成员</p><h2 id="SavedState"><a href="#SavedState" class="headerlink" title="SavedState"></a>SavedState</h2><p>引入 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.savedstate:savedstate:1.0.0"</span></span><br></pre></td></tr></table></figure><p>其实您不需要显示地声明，因为 activity 库内部已经引入了。jetpack 组件依赖关系可参考 <a href="https://juejin.im/post/5e567ee1518825494466a938" target="_blank" rel="noopener">【背上Jetpack】Jetpack 主要组件的依赖及传递关系</a></p><p>这是一个很小的库</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318215718.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318215746.png" alt></p><blockquote><p>图片来自 <a href="https://proandroiddev.com/viewmodels-state-persistence-savedstate-54d015acad82" target="_blank" rel="noopener">Android ViewModels: State persistence — SavedState</a></p></blockquote><h3 id="SavedStateProvider"><a href="#SavedStateProvider" class="headerlink" title="SavedStateProvider"></a>SavedStateProvider</h3><p>保存状态的组件，此状态将在以后恢复并使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SavedStateProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Bundle <span class="title">saveState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SavedStateRegistry"><a href="#SavedStateRegistry" class="headerlink" title="SavedStateRegistry"></a>SavedStateRegistry</h3><p>管理 <code>SavedStateProvider</code> 列表的组件，此注册表绑定了其所有者的生命周期（即 activity 或 fragment）。每次创建生命周期所有者都会创建一个新的实例</p><p>创建注册表的所有者后（例如，在调用 activity 的 <code>onCreate(savedInstanceState)</code> 方法之后），将调用其 <code>performRestore(state)</code> 方法，以恢复系统杀死其所有者之前保存的任何状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performRestore</span><span class="params">(@NonNull Lifecycle lifecycle, @Nullable Bundle savedState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (savedState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRestoredState = savedState.getBundle(SAVED_COMPONENTS_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个注册表的 <code>SavedStateProvider</code> 都由用于注册它的唯一密钥标识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SafeIterableMap&lt;String, SavedStateProvider&gt; mComponents = <span class="keyword">new</span> SafeIterableMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSavedStateProvider</span><span class="params">(@NonNull String key, @NonNull SavedStateProvider provider)</span> </span>&#123;</span><br><span class="line">    SavedStateProvider previous = mComponents.putIfAbsent(key, provider);</span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"SavedStateProvider with the given key is already registered"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterSavedStateProvider</span><span class="params">(@NonNull String key)</span> </span>&#123;</span><br><span class="line">    mComponents.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦完成注册，就可以通过<code>consumeRestoredStateForKey(key)</code> 来使用特定密钥的还原状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">consumeRestoredStateForKey</span><span class="params">(@NonNull String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRestoredState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Bundle result = mRestoredState.getBundle(key);</span><br><span class="line">        <span class="comment">//调用后就会清空，第二次调用返回null</span></span><br><span class="line">        mRestoredState.remove(key);</span><br><span class="line">        <span class="keyword">if</span> (mRestoredState.isEmpty()) &#123;</span><br><span class="line">            mRestoredState = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，此方法检索保存的状态，然后清除其内部引用，这意味着用相同的键调用它两次将在第二次调用中返回 null</p><p>一旦注册表恢复了其保存状态，则由提供者决定是否要求其恢复的数据。 如果没有，下次注册表的所有者被系统杀死时，未使用的还原数据将再次保存到保存状态</p></blockquote><p>已注册的 provider 能够在其所有者被系统杀死之前保存状态。 发生这种情况时，将调用其 <code>Bundle saveState()</code> 方法。 对于每个已注册的 <code>SavedStateProvider</code>，都可以像这样保存状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">savedState.putBundle(savedStateProviderKey, savedStateProvider.saveState());</span><br></pre></td></tr></table></figure><p><code>performSave(outBundle)</code> 方法的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSave</span><span class="params">(@NonNull Bundle outBundle)</span> </span>&#123;</span><br><span class="line">    Bundle components = <span class="keyword">new</span> Bundle();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.保存未使用的状态</span></span><br><span class="line">    <span class="keyword">if</span> (mRestoredState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        components.putAll(mRestoredState);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 通过 SavedStateProvider 保存状态</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;String, SavedStateProvider&gt;&gt; it = mComponents.iteratorWithAdditions(); it.hasNext(); ) &#123;</span><br><span class="line">        Map.Entry&lt;String, SavedStateProvider&gt; entry1 = it.next();</span><br><span class="line">        components.putBundle(entry1.getKey(), entry1.getValue().saveState());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 将bundle 保存到 outBundle 对象中</span></span><br><span class="line">    outBundle.putBundle(SAVED_COMPONENTS_KEY, components);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行状态保存将所有未使用的状态与注册表提供的状态合并。 此 outBundle 是 activity 的 <code>onSaveInstanceState</code> 中传入的 bundle 。</p><h3 id="SavedStateRegistryController"><a href="#SavedStateRegistryController" class="headerlink" title="SavedStateRegistryController"></a>SavedStateRegistryController</h3><p>一个包装 <code>SavedStateRegistry</code> 并允许通过其2个主要方法对其进行控制的组件：performRestore(savedState) 和 <code>performSave(outBundle )</code>。 这两个方法将内部通过 <code>SavedStateRegistry</code> 中的方法处理 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedStateRegistryController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SavedStateRegistryOwner mOwner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SavedStateRegistry mRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performRestore</span><span class="params">(@Nullable Bundle savedState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        mRegistry.performRestore(lifecycle, savedState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performSave</span><span class="params">(@NonNull Bundle outBundle)</span> </span>&#123;</span><br><span class="line">        mRegistry.performSave(outBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SavedStateRegistryOwner"><a href="#SavedStateRegistryOwner" class="headerlink" title="SavedStateRegistryOwner"></a>SavedStateRegistryOwner</h3><p>持有 <code>SavedStateRegistry</code> 的组件。 默认情况下，androidx 包中的<code>ComponentActivity</code> 和 <code>Fragment</code> 都实现此接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SavedStateRegistryOwner</span> <span class="keyword">extends</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">SavedStateRegistry <span class="title">getSavedStateRegistry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Activity-的状态保存"><a href="#Activity-的状态保存" class="headerlink" title="Activity 的状态保存"></a>Activity 的状态保存</h2><p>这里我们要明确一件事情，activity 保存的状态究竟都有什么？</p><p>这部分内容可以参见 <a href="https://developer.android.com/guide/components/activities/activity-lifecycle.html#saras" target="_blank" rel="noopener">官方文档</a> </p><p>简单来说，<strong>activity 的状态保存分为 view 状态和成员状态</strong></p><p>默认情况下，系统使用 Bundle 实例状态来保存有关 activity 布局中每个 View 对象的信息（例如，输入到 EditText 中的文本值或 recyclerview 的滚动位置）。 因此，如果 activity 实例被销毁并重新创建，则布局状态将恢复为之前的状态，而无需您执行任何代码。（<strong>注意，需要恢复状态的 view 需要配置 id</strong> ）</p><p>这部分逻辑在 activity 中的 <code>onSaveInstanceState</code> 方法内实现</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319115543.png" alt="onSaveInstanceState "></p><blockquote><p>不同平台 <code>onSaveInstanceState</code>  方法的执行时机稍有不同，android P 之前 <code>onSaveInstanceState</code> 执行在 <code>onStop</code> 之前，但不限于在 <code>onPause</code> 之前或之后。android P 及之后该方法在 <code>onStop</code> 后执行</p></blockquote><p>前面我们提到 <code>ComponentActivity</code> 实现了 <code>SavedStateRegistryOwner</code> ，下面我们来看一看 activity 如何利用该库来实现状态的保存与恢复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">androidx</span>.<span class="title">core</span>.<span class="title">app</span>.<span class="title">ComponentActivity</span> <span class="keyword">implements</span> <span class="title">SavedStateRegistryOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SavedStateRegistryController mSavedStateRegistryController = SavedStateRegistryController.create(<span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(@NonNull Bundle outState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">//这里先调用父类的 onSaveInstanceState 保存 view 状态</span></span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        mSavedStateRegistryController.performSave(outState);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SavedStateRegistry <span class="title">getSavedStateRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mSavedStateRegistryController.getSavedStateRegistry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部持有 <code>SavedStateRegistryController</code> 的实例 <code>mSavedStateRegistryController</code> ，在 activity 的 <code>onCreate</code> 方法中 通过 controller 的 <code>performRestore</code> 方法来查询已保存的状态，在 <code>onSaveInstanceState</code> 中 使用 controller  的 <code>performSave</code> 方法来保存状态</p><p><strong>除了 view 状态和成员状态，activity 还负责保存其内部的 fragment 的状态</strong>。<code>FragmentActivity</code> 的 <code>onSaveInstanceState</code> 方法有对其内部 fragment 的状态进行保存，并在 onCreate 方法中对已保存的 fragment 进行恢复。这解释了如果操作不当会导致 fragment 重叠的问题</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319140343.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319140801.png" alt></p><h2 id="Fragment-的状态保存"><a href="#Fragment-的状态保存" class="headerlink" title="Fragment 的状态保存"></a>Fragment 的状态保存</h2><p>androidx fragment 使用 <code>FragmentStateManager</code> 来处理 fragment 的状态保存</p><p>其内部有四个保存相关的方法</p><ul><li><code>saveState</code></li><li><code>saveBasicState</code></li><li><code>saveViewState</code></li><li><code>saveInstanceState</code></li></ul><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319142729.png" alt="FragmentStateManager"></p><p>其调用链为 activity 通过 <code>FragmentController</code> 间接 调用 <code>FragmentManager</code> 的 <code>saveAllState</code>，接着依次调用后面的save 方法</p><p>Fragment 的状态保存可分为 view 状态，成员状态，child fragment 状态</p><p>关于 view 状态 , <code>FragmentStateManager</code> 提供了 <code>saveViewSate</code> 方法，它的调用有两处：</p><ol><li>在 activity 或父 fragment 触发状态保存时调用，即上述流程</li><li>在 fragment 即将进入 <code>onDestroyView</code> 生命周期时调用，其位置在 <code>FragmentManager</code> moveToState 方法内部，这解释了为什么加入返回栈的 replace 操作在返回时 view 状态可以自动恢复</li></ol><p>关于成员状态，由 activity 中的状态机制处理，即上节内容</p><p>关于 child  fragment 状态，fragment 的 <code>onCreate</code> 方法会调用 <code>restoreChildFragmentState</code> 来恢复 child  fragment 的状态，并在 <code>FragmentStateManager</code>  中的 <code>saveBasicState</code> 方法中 调用 <code>performSaveInstanceState</code> 来保存 child  fragment 的状态</p><h2 id="Viewmodel-SavedState"><a href="#Viewmodel-SavedState" class="headerlink" title="Viewmodel-SavedState"></a>Viewmodel-SavedState</h2><p>2020-01-22，<code>ViewModel-SavedState 1.0.0</code> 正式版发布，02-05 发布了 <code>2.2.0</code> 正式版</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-savedstate:2.2.0"</span></span><br></pre></td></tr></table></figure><blockquote><p>您不需要手动引入该库，因为 fragment 库以及内部引入该库</p></blockquote><p><code>Jetpack MVVM</code> 下 UI State 通常被 <code>ViewModel</code> 持有并存储，因此该模块出现了，配置该模块后，<code>ViewModel</code> 对象将通过其构造函数接收 <code>SavedStateHandle</code> 对象（键值映射），可让您保存状态并查询已保存的状态。 这些值将在系统终止进程后继续存在，并可以通过同一对象使用。</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319165450.png" alt="ViewModel-SavedState"></p><blockquote><p>图片来自 <a href="https://proandroiddev.com/viewmodels-state-persistence-savedstate-54d015acad82" target="_blank" rel="noopener">Android ViewModels: State persistence — SavedState</a></p></blockquote><h3 id="SavedStateHandle"><a href="#SavedStateHandle" class="headerlink" title="SavedStateHandle"></a>SavedStateHandle</h3><p>内部持有已保存状态 key-value 的 map，允许读取和写入状态，这些状态在应用进程被杀死后仍然存在</p><p><code>SavedStateHandle</code> 通过 <code>ViewModel</code> 的构造器传入，下面是其主要的主要的几个方法</p><ul><li>T get(String key)</li><li>MutableLiveData<t> getLiveData(String key)</t></li><li>void set(String key, T value)</li></ul><p><code>SavedStateHandle</code> 还包含 <code>SavedStateProvider</code> 的实例，用于帮助 <code>ViewModel</code> 的 owner 保存状态</p><h3 id="AbstractSavedStateViewModelFactory"><a href="#AbstractSavedStateViewModelFactory" class="headerlink" title="AbstractSavedStateViewModelFactory"></a>AbstractSavedStateViewModelFactory</h3><p>一个实现 <code>ViewModelFactory.KeyedFactory</code> 的 <code>ViewModel Factory</code>，它会创建一个与实例化的请求的 ViewModel 关联的 <code>SavedStateHandle</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSavedStateViewModelFactory</span> <span class="keyword">extends</span> <span class="title">ViewModelProvider</span>.<span class="title">KeyedFactory</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SavedStateRegistry mSavedStateRegistry;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Default state used when the saved state is empty</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Bundle mDefaultArgs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读取保存的状态</span></span><br><span class="line">        Bundle restoredState = mSavedStateRegistry.consumeRestoredStateForKey(key);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 创建保存状态的 handle</span></span><br><span class="line">        SavedStateHandle handle = SavedStateHandle.createHandle(restoredState, mDefaultArgs);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 创建 viewModel</span></span><br><span class="line">        T viewmodel = create(key, modelClass, handle);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> viewmodel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SavedStateViewModelFactory"><a href="#SavedStateViewModelFactory" class="headerlink" title="SavedStateViewModelFactory"></a>SavedStateViewModelFactory</h3><p><code>AbstractSavedStateViewModelFactory</code> 的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedStateViewModelFactory</span> <span class="keyword">extends</span> <span class="title">AbstractSavedStateVMFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SavedStateViewModelFactory</span><span class="params">(@NonNull Application application,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull SavedStateRegistryOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(application, owner, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SavedStateViewModelFactory</span><span class="params">(@NonNull Application application, @NonNull SavedStateRegistryOwner owner, @Nullable Bundle defaultArgs)</span> </span>&#123;</span><br><span class="line">        mSavedStateRegistry = owner.getSavedStateRegistry();</span><br><span class="line">        mLifecycle = owner.getLifecycle();</span><br><span class="line">        mDefaultArgs = defaultArgs;</span><br><span class="line">        mApplication = application;</span><br><span class="line">        mFactory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);</span><br><span class="line">        Constructor&lt;T&gt; constructor;</span><br><span class="line">        <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// doesn't need SavedStateHandle</span></span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mFactory.create(modelClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SavedStateHandleController controller = SavedStateHandleController.create(</span><br><span class="line">                mSavedStateRegistry, mLifecycle, key, mDefaultArgs);        </span><br><span class="line">        T viewmodel;</span><br><span class="line">        <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">            viewmodel = constructor.newInstance(mApplication, controller.getHandle());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            viewmodel = constructor.newInstance(controller.getHandle());</span><br><span class="line">        &#125;</span><br><span class="line">        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);</span><br><span class="line">        <span class="keyword">return</span> viewmodel;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319174431.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewModelProvider(<span class="keyword">this</span>).get(MyViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure><p>在 activity 中创建 ViewModel 实例，传入 this （<code>SavedStateRegistryOwner</code> ）作为参数，该参数可以访问其 <code>SavedStateRegistry</code>，如果没有传入 factory 会通过 activity 重写的 <code>getDefaultViewModelProviderFactory</code> 方法来获取默认的 factory 。然后 factory 将使用保存的状态， 将其包装在 <code>SavedStateHandle</code> 中，并将其传递给 ViewModel。 ViewModel 可以读取和写入该 handle</p><p>当 activity 的 <code>onSaveInstanceState(outState)</code> 方法被调用，其 <code>SavedStateRegistry</code> 的 <code>performSave(outState)</code> 方法将被执行，其内部的所有 <code>SavedStateProvider</code> 的 <code>saveState</code> 方法均被执行，一旦执行完毕，<code>outState</code> 就包含了已保存的状态</p><p>当 app 被重启后，activity 和新的 registry  将被创建，activity 的 <code>onCreate(savedInstanceState)</code> 方法会被调用，然后 registry 的 <code>performRestore(savedInstanceState)</code> 将被调用以便恢复之前保存的状态</p><h2 id="状态保存的正确姿势"><a href="#状态保存的正确姿势" class="headerlink" title="状态保存的正确姿势"></a>状态保存的正确姿势</h2><p><code>ViewModel</code> 构造器加入 <code>SavedStateHandle</code> 参数，并将想要保存的数据使用该 handle 保存</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithSavedStateViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> state: SavedStateHandle) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> key = <span class="string">"key"</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(value: <span class="type">String</span>)</span></span> = state.<span class="keyword">set</span>(key, value)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">()</span></span>: LiveData&lt;String&gt; = state.getLiveData(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>无需重写 <code>onSaveInstanceState/onRestoreInstanceState</code>  方法</strong></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319231231.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319231451.png" alt="运行示意图"></p><p><a href="https://github.com/Flywith24/Flywith24-Jetpack-Demo" target="_blank" rel="noopener">Demo 地址</a></p><blockquote><p>SavedState 仅适合保存轻量级的数据，重量级操作请考虑持sp，数据库等持久化方案</p></blockquote><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="http://www.yangyunzhao.com" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;大家都知道 activity 有着一套 &lt;code&gt;onSaveInstanceState-onRestoreInstanceState&lt;/code&gt; 状态保存机制，旨在「系统资源回收」或「配置发生变化」保存状态，为用户提供更好的体验&lt;/p&gt;
&lt;p&gt;在 androidx 下，提供了 &lt;a href=&quot;https://developer.android.com/jetpack/androidx/releases/savedstate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SavedState&lt;/a&gt; 库帮助 activity 和 fragment 处理状态保存和恢复&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文默认您对状态保存机制有一定了解，这部分内容请移步 &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/saving-states&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Saving UI States&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此外，关于 android 下的进程管理，推荐 Ian Lake 的 &lt;a href=&quot;https://medium.com/androiddevelopers/who-lives-and-who-dies-process-priorities-on-android-cb151f39044f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Who lives and who dies? Process priorities on Android&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 androidx 下 &lt;code&gt;SavedState&lt;/code&gt; 如何帮助 activity 和 fragment 处理状态的保存和恢复，同时介绍 &lt;code&gt;viewmodel-savedstate&lt;/code&gt; 库，以及在开发过程中正确使用状态保存的姿势&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之Fragment】从源码的角度看Fragment 返回栈</title>
    <link href="http://yoursite.com/2020/03/16/Jetpack-fragment-back-stack/"/>
    <id>http://yoursite.com/2020/03/16/Jetpack-fragment-back-stack/</id>
    <published>2020-03-15T16:10:35.000Z</published>
    <updated>2020-03-24T01:27:49.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p><a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">上一篇</a> 我们介绍了 <code>OnBackPressedDispather</code> ，那么今天我们来正式地从源码的角度看看 fragment 的返回栈吧。由于其主流程和生命周期差不多，因此本文将详细地分析返回栈相关的源码，并插入大量源码。建议将生命周期流程熟悉后阅读本文。文末提供单返回栈和多返回栈的 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">demo</a></p></blockquote><p>如果您对 activity 对任务栈和返回栈不是很了解，可以移步  <a href="https://medium.com/androiddevelopers/tasks-and-the-back-stack-dbb7c3b0f6d4" target="_blank" rel="noopener">Tasks and the Back Stack</a></p><a id="more"></a><h2 id="小问号你是否有很多朋友？"><a href="#小问号你是否有很多朋友？" class="headerlink" title="小问号你是否有很多朋友？"></a>小问号你是否有很多朋友？</h2><p>在分析源码之前，我们先来思考几个问题。</p><ul><li>返回栈中的元素是什么？</li><li>谁来管理 fragment 的返回栈？</li><li>如何返回？</li></ul><h3 id="返回栈中的元素是什么？"><a href="#返回栈中的元素是什么？" class="headerlink" title="返回栈中的元素是什么？"></a>返回栈中的元素是什么？</h3><p>返回栈，顾名思义，是一个栈结构。所以我们要搞清楚，这个栈结构到底存的是什么。</p><p>我们都知道，使用 fragment 的返回栈需要调用 <code>addToBackStack(&quot;&quot;)</code> 方法</p><p>在 <a href="https://juejin.im/post/5e67523551882549003d2c4f" target="_blank" rel="noopener">从源码角度看 Fragment 生命周期</a> 一文中，我们提到了 FragmentTransaction ，它是一个「事务」的模型，事务可以回滚到之前的状态。所以当触发返回操作时，就是将之前提交的事务进行回滚。</p><p><code>FragmentTransaction</code> 的实现类为 <code>BackStackRecord</code> ，所以 <strong>fragment 的返回栈其实存放的就是 BackStackRecord</strong> </p><p>作为返回栈的元素，BackStackRecord 实现了FragmentManager.BackStackEntry 接口</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0e912bd4?w=748&h=171&f=png&s=27904" alt="BackStackRecord"></p><p>从 <code>BackStackRecord</code> 的定义我们可以发现 <code>BackStackRecord</code> 有三种身份</p><ul><li>继承了 <code>FragmentTransaction</code>，即是事务，保存了整个事务的全部操作</li><li>实现了 <code>FragmentManager.BackStackEntry</code> ，作为回退栈的元素</li><li>实现了<code>OpGenerator</code> ，可以生成 <code>BackStackRecord</code> 列表，后文详细介绍</li></ul><h3 id="谁来管理-fragment-的返回栈？"><a href="#谁来管理-fragment-的返回栈？" class="headerlink" title="谁来管理 fragment 的返回栈？"></a>谁来管理 fragment 的返回栈？</h3><p>我们已经知道 fragment 的返回栈其实存放的是 BackSrackRecord , 那么谁来管理 fragment 的返回栈？</p><p><code>FragmentManager</code> 用于管理 fragment ，所以 <strong>fragment 返回栈也应该由 FragmentManager 管理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FragmentManager.java</span></span><br><span class="line">ArrayList&lt;BackStackRecord&gt; mBackStack;</span><br></pre></td></tr></table></figure><p>其实触发 fragment 的返回逻辑有两种途径</p><ul><li><p>开发主动调用 fragment 的返回方法</p></li><li><p>用户按返回键触发</p></li></ul><p>后文我们会从这两个角度分析一下 fragment 中的返回栈逻辑究竟是怎样的</p><h3 id="如何返回？"><a href="#如何返回？" class="headerlink" title="如何返回？"></a>如何返回？</h3><p>我们已经知道返回栈中的元素是 <code>BackStackRecord</code> ，也清楚了是 <code>FragmentManager</code> 来管理返回栈。那么如果让我们来实现「返回」逻辑，应该如何做？</p><p>首先我们要清楚所谓的「返回」是对事务的回滚，即 <strong>对 commit 事务的内部逻辑执行相应的「逆操作」</strong>。</p><p>例如</p><p>addFragment←→removeFragment</p><p>showFragment←→hideFragment</p><p>attachFragment←→detachFragment</p><p>有的小伙伴可能会疑惑 replace 呢？</p><p><code>expandReplaceOps</code> 方法会把 replace 替换(目标 fragment 已经被 add )成相应的 remove 和 add 两个操作，或者(目标 fragment 没有被 add )只替换成 add 操作</p><h2 id="popBackStack-系列方法"><a href="#popBackStack-系列方法" class="headerlink" title="popBackStack 系列方法"></a>popBackStack 系列方法</h2><p><code>FragmentManager</code> 中提供了<code>popBackStack</code> 系列方法</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0f7fecec?w=523&h=207&f=png&s=41693" alt="popBackStack系列方法"></p><p>是否觉得很眼熟？提交事务也有类似的api，commit 系列方法</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0f5fe236?w=425&h=116&f=png&s=19768" alt="commit系列方法"></p><p>这里分别提供了同步和异步的方法，可能有读者会疑惑，同样是对事务的操作，一个为提交，一个为回滚，为什么一个封装到了 <code>FragmentManager</code> 中，一个却在 <code>FragmentTransaction</code> 中。既然都是对事务的操作，应该都放在FragmentManager 中。我认为可能为了api使用的方便，使得 <code>FragmentManager</code> 开启事务的链式调用一气呵成。各位有什么想法欢迎在评论区留言。</p><p>这里主要介绍一下 popBackStack(String name, int flag)</p><p>name 为 addToBackStack(String name) 的参数，通过 name 能找到回退栈的特定元素，flag可以为 0 或者<code>FragmentManager.POP_BACK_STACK_INCLUSIVE</code>，0 表示只弹出该元素以上的所有元素，<code>POP_BACK_STACK_INCLUSIVE</code> 表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。如果这么说比较抽象的话，看图</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag 传入0，弹出 ♥2 上的所有元素</span></span><br><span class="line">childFragmentManager.popBackStack(<span class="string">"♥"</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf111e4eca?w=544&h=968&f=gif&s=332027" alt="flag为0"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag 为 POP_BACK_STACK_INCLUSIVE 弹出包括该元素及及以上的元素</span></span><br><span class="line">childFragmentManager.popBackStack(<span class="string">"♥"</span>,  androidx.fragment.app.FragmentManager.POP_BACK_STACK_INCLUSIVE)</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf11573c7e?w=544&h=968&f=gif&s=307357" alt="flag为1"></p><h2 id="走进源码"><a href="#走进源码" class="headerlink" title="走进源码"></a>走进源码</h2><h3 id="1-popBackStack-逻辑"><a href="#1-popBackStack-逻辑" class="headerlink" title="1. popBackStack() 逻辑"></a>1. popBackStack() 逻辑</h3><p>在分析返回栈源码之前我们回顾一下 FragmentManager 提交事务到 fragment 各个生命周期的流程</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf128028ab?w=1137&h=1745&f=png&s=148227" alt="异步"></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf3c14d698?w=1078&h=1232&f=png&s=120922" alt="commitNow"></p><p>下面我们看看 popBackStack 的源码</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf3e264529?w=1111&h=744&f=png&s=152765" alt="popBackStack源码"></p><p>等等，这个 enqueueAction 有些眼熟…</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf4261e2a2?w=582&h=144&f=png&s=16887" alt="commit"></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf43057f36?w=792&h=404&f=png&s=74980" alt="commitInternal"></p><p>看来提交事务和回滚事务的流程基本是相同的，只是传递的 action 不同</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf463c7504?w=818&h=722&f=png&s=108117" alt="enqueueAction"></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170df028ee01dd57?w=1081&h=713&f=png&s=131939" alt="OpGenerator"></p><p>由源码可知，<code>OpGenerator</code> 是一个接口，其内只有一个 <code>generateOps</code> 方法，用于生成事务列表以及对应的该事务是否是弹出的。有两个实现类</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf5579b571?w=1319&h=139&f=png&s=46323" alt="OpGenerator实现类"></p><p>由此可见 commit 调用的为 <code>BackStackRecord</code> 的 <code>generateOps</code> 方法，<code>popBackStack</code> 调用的是 <code>PopBackStackState</code> 中的  <code>generateOps</code> </p><p>前者的逻辑很简单，向 records list 中添加数据， isRecordPop list 全部传入 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">records.add(<span class="keyword">this</span>);</span><br><span class="line">isRecordPop.add(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>后者的逻辑稍微复杂些，其内部调用了 <code>popBackStackState</code> 方法</p><p>如果是 <code>popBackStack</code> 方法 ，则将 <code>FragmentManager</code> 的返回栈列表（<code>mBackStack</code>）的栈顶移除， <code>isRecordPop</code> list 全部传入 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last = mBackStack.size() - <span class="number">1</span>;</span><br><span class="line">records.add(mBackStack.remove(last));</span><br><span class="line">isRecordPop.add(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>如果传入的 name 或 id 有值，且 flag 为 0，则找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置，并将该位置上方的所有 <code>BackStackRecord</code> 并添加到 <code>record</code> list 中，同时 <code>isRecordPop</code> list 全部传入 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">index = mBackStack.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    BackStackRecord bss = mBackStack.get(index);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.equals(bss.getName())) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (id &gt;= <span class="number">0</span> &amp;&amp; id == bss.mIndex) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mBackStack.size() - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">  records.add(mBackStack.remove(i));</span><br><span class="line">  isRecordPop.add(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入的 name 或 id 有值，且 flag 为 <code>POP_BACK_STACK_INCLUSIVE</code>，则在上一条获取位置的基础上继续遍历，直至栈底或者遇到不匹配的跳出循环，接着出栈所有 <code>BackStackRecord</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index 操作与上方相同，先找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; POP_BACK_STACK_INCLUSIVE) != <span class="number">0</span>) &#123;</span><br><span class="line">    index--;</span><br><span class="line">    <span class="comment">// 继续遍历 mBackStack 直至栈底或者遇到不匹配的跳出循环</span></span><br><span class="line">    <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        BackStackRecord bss = mBackStack.get(index);</span><br><span class="line">        <span class="keyword">if</span> ((name != <span class="keyword">null</span> &amp;&amp; name.equals(bss.getName()))</span><br><span class="line">                || (id &gt;= <span class="number">0</span> &amp;&amp; id == bss.mIndex)) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后续出栈逻辑与上方相同</span></span><br></pre></td></tr></table></figure><p>可以配合上面的动图理解</p><p>入栈和出栈后续的逻辑大体是相同的，只是根据 isPop 的正负出现了分支，出栈调用的是 executePopOps</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170df06c04191fff?w=972&h=682&f=png&s=132928" alt></p><p>上文我们有提到，「返回」逻辑实际上就是执行提交事务内部操作逻辑的「逆操作」</p><p>那么接下的逻辑就很清晰了，根据不同的 mCmd 执行相应的逆操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executePopOps</span><span class="params">(<span class="keyword">boolean</span> moveToState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> opNum = mOps.size() - <span class="number">1</span>; opNum &gt;= <span class="number">0</span>; opNum--) &#123;</span><br><span class="line">        <span class="keyword">final</span> Op op = mOps.get(opNum);</span><br><span class="line">        Fragment f = op.mFragment;</span><br><span class="line">        <span class="keyword">switch</span> (op.mCmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> OP_ADD:</span><br><span class="line">                mManager.removeFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REMOVE:</span><br><span class="line">                mManager.addFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_HIDE:</span><br><span class="line">                mManager.showFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_SHOW:</span><br><span class="line">                mManager.hideFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_DETACH:</span><br><span class="line">                mManager.attachFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ATTACH:</span><br><span class="line">                mManager.detachFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_SET_PRIMARY_NAV:</span><br><span class="line">                mManager.setPrimaryNavigationFragment(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_UNSET_PRIMARY_NAV:</span><br><span class="line">                mManager.setPrimaryNavigationFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_SET_MAX_LIFECYCLE:</span><br><span class="line">                mManager.setMaxLifecycle(f, op.mOldMaxState);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.mCmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mReorderingAllowed &amp;&amp; op.mCmd != OP_REMOVE &amp;&amp; f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mManager.moveFragmentToExpectedState(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mReorderingAllowed &amp;&amp; moveToState) &#123;</span><br><span class="line">        mManager.moveToState(mManager.mCurState, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面的逻辑就完全一样了</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf65e331c7?w=1137&h=1585&f=png&s=127564" alt="popBackStack"></p><h3 id="2-fragment-是怎样拦截-activity-的返回逻辑的？"><a href="#2-fragment-是怎样拦截-activity-的返回逻辑的？" class="headerlink" title="2. fragment 是怎样拦截 activity 的返回逻辑的？"></a>2. fragment 是怎样拦截 activity 的返回逻辑的？</h3><p>在 <a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇</a> 一文中我们介绍了 <code>OnBackPressedDispatcher</code> </p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf6fd444f6?w=1138&h=544&f=png&s=96482" alt="ComponetActivity"></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf70da7341?w=642&h=512&f=png&s=71452" alt></p><p>activity 的 <code>onBackPressed</code> 的逻辑主要分为两部分，判断所有注册的 <code>OnBackPressedCallback</code> 是否有 enabled 的，如果有则拦截，不执行后续逻辑；</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170df0d07750776b?w=801&h=765&f=png&s=137606" alt="fragment 拦截返回逻辑"></p><p>否则着执行 mFallbackOnBackPressed.run() ，其内部逻辑为调用 ComponentActivity 父类的 <code>onBackPressed</code> 方法</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf7443eb77?w=715&h=275&f=png&s=39938" alt></p><p><strong>所以我们只需看 mOnBackPressedCallbacks（ArrayDeque&lt;OnBackPressedCallback） 是怎样被添加的以及 isEnabled 何时赋值为 true</strong></p><p>经过查找我们发现它是在 FragmentManager 的 attachController 调用 <code>addCallback</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mOnBackPressedDispatcher.addCallback(owner,mOnBackPressedCallback)</span><br></pre></td></tr></table></figure><p>进而执行了</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170df099d16ae502?w=1000&h=425&f=png&s=75605" alt><br><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf7c970039?w=822&h=233&f=png&s=41860" alt></p><p>而 <code>mOnBackPressedCallback</code> 在初始化时 enabled 赋值为 false </p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf8362798b?w=954&h=194&f=png&s=42041" alt="mOnBackPressedCallback"></p><p><code>isEnadbled</code> 会在返回栈数量大于 0 且其 mParent 为 <code>PrimaryNavigation</code> 时赋值为true</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9805eb1e?w=796&h=555&f=png&s=94237" alt></p><p>而返回栈（<code>mBackStack</code>）的赋值在 <code>BackStackRecord</code> 的 <code>generateOps</code> 方法中，且是否添加到返回栈由 <code>mAddToBackStack</code> 这个布尔类型的属性控制</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170df0f5d77e3c7f?w=891&h=544&f=png&s=94633" alt></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9a0dfa56?w=548&h=215&f=png&s=28095" alt></p><p><strong>mAddToBackStack 的赋值在 addToBackStack 方法中，这也解释了为何调用 addToBackStack 方法就能将事务加入返回栈</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9eb75bde?w=841&h=306&f=png&s=47458" alt></p><blockquote><p> 我们来总结一下，fragment 拦截 activity 返回栈是通过 <code>OnBackPressedDispatcher</code> 实现的，如果开启事务调用了 <code>addToBackStack</code> 方法，则 <code>mOnBackPressedCallback</code> 的 <code>isEnabled</code> 属性会赋值为 true，进而起到拦截 activity 返回逻辑的作用。拦截后执行 <code>popBackStackImmediate</code> 方法</p><p>而 popBackStack系列方法会调用 popBackStackState 构造 <code>records</code> 和 <code>isRecordPop</code> 列表，<code>isRecordPop</code> 的内部元素的值均为true 后续流程和提交事务是一样的，根据 <code>isRecordPop</code> 值的不同选择执行 <code>executePopOps</code> 或 <code>executeOps</code> 方法</p></blockquote><h2 id="单返回栈和多返回栈的实现"><a href="#单返回栈和多返回栈的实现" class="headerlink" title="单返回栈和多返回栈的实现"></a>单返回栈和多返回栈的实现</h2><p><a href="https://medium.com/@ianhlake" target="_blank" rel="noopener">Ian Lake</a> 在 <a href="https://www.youtube.com/watch?v=RS1IACnZLy4" target="_blank" rel="noopener">Fragments: Past, Present, and Future (Android Dev Summit ‘19)</a> </p><p>有提到未来会提供多返回栈的 api</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeafa780da77?w=1844&h=948&f=png&s=634511" alt></p><p>那么以现有的 api 如何实现多返回栈呢？</p><p>首先我要弄清楚怎样才会有多返回栈，根据上文我们知道 <code>FragmentManager</code> 内部持有<code>mBackStack</code> list，这对应着一个返回栈，<strong>如果想要实现多返回栈，则需要多个 FragmentManager</strong>，而多 <code>FragmentManager</code> 则对应多个 fragment</p><p>因此我们可以创建多个宿主 frament 作为导航 fragment 这样就可以用不同的宿主 fragment 的 独立的<code>FragmentManager</code> 分别管理各自的返回栈，如果这样说比较抽象，可以参考下图</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170defa88bc0e5f9?w=488&h=750&f=gif&s=4633102" alt></p><p>图中有四个返回栈，其中最外部有一个宿主 fragment ，内部有四个负责导航的 fragment 管理其内部的返回栈，外部的宿主负责协调各个返回栈为空后如何切换至其他返回栈</p><p>单返回栈就很容易了，我们只需在同一个 <code>FragmentManager</code> 上添加返回栈即可</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200312175950" alt></p><p>详情参照 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">demo</a></p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e6bae35f265da572a0d11ad&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇&lt;/a&gt; 我们介绍了 &lt;code&gt;OnBackPressedDispather&lt;/code&gt; ，那么今天我们来正式地从源码的角度看看 fragment 的返回栈吧。由于其主流程和生命周期差不多，因此本文将详细地分析返回栈相关的源码，并插入大量源码。建议将生命周期流程熟悉后阅读本文。文末提供单返回栈和多返回栈的 &lt;a href=&quot;https://github.com/Flywith24/Flywith24-Fragment-Demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果您对 activity 对任务栈和返回栈不是很了解，可以移步  &lt;a href=&quot;https://medium.com/androiddevelopers/tasks-and-the-back-stack-dbb7c3b0f6d4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tasks and the Back Stack&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack】Fragment返回栈预备篇 OnBackPressedDispatcher</title>
    <link href="http://yoursite.com/2020/03/14/Jetpack-OnBackPressedDispatcher/"/>
    <id>http://yoursite.com/2020/03/14/Jetpack-OnBackPressedDispatcher/</id>
    <published>2020-03-13T16:10:35.000Z</published>
    <updated>2020-03-24T01:19:53.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天在准备写 fragment 返回栈的文章，但是发现必须先介绍一下 OnBackPressedDispatcher ，所以这是一篇介绍 what 的文章，喜欢一手资料的可以移步 <a href="https://developer.android.google.cn/reference/kotlin/androidx/activity/OnBackPressedDispatcher" target="_blank" rel="noopener">官方文档</a></p></blockquote><a id="more"></a><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><blockquote><p><a href="https://juejin.im/post/5e567ee1518825494466a938" target="_blank" rel="noopener">【背上Jetpack】Jetpack 主要组件的依赖及传递关系</a><br></p><p><a href="https://juejin.im/post/5e5a0c316fb9a07cd248d29e" target="_blank" rel="noopener">【背上Jetpack】AdroidX下使用Activity和Fragment的变化</a><br></p><p><a href="https://juejin.im/post/5e5cd8686fb9a07cbc269d10" target="_blank" rel="noopener">【背上Jetpack之Fragment】你真的会用Fragment吗？Fragment常见问题以及androidx下Fragment的使用新姿势</a><br></p><p><a href="https://juejin.im/post/5e67523551882549003d2c4f" target="_blank" rel="noopener">【背上Jetpack之Fragment】从源码角度看 Fragment 生命周期 AndroidX Fragment1.2.2源码分析</a></p></blockquote><h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><p><code>OnBackPressedDispatcher</code> 在 <code>androidx activity 1.0.0</code> 加入，旨在处理返回逻辑。您不仅可以获得在 <code>Activity</code> 之外处理返回键的便捷方式。 根据您的需要，您可以在任意位置定义 <code>OnBackPressedCallback</code>，使其可复用，或根据应用程序的架构进行任何操作。 您不再需要重写<code>Activity</code> 中的 <code>onBackPressed</code> 方法，也不必提供自己的抽象的来实现需求的代码。</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d4a399942581f?w=1778&h=1246&f=png&s=339228" alt="OnBackPressedDispatcher"></p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p><code>ComponentActivity</code> 是 <code>FragmentActivity</code> 和 <code>AppCompatActivity</code> 的基类，它使您可以通过使用其 <code>OnBackPressedDispatcher</code>（可以通过调用 <code>getOnBackPressedDispatcher()</code> ）来控制返回按钮的行为。</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d4a9d225a9575?w=2168&h=1150&f=png&s=238889" alt="ComponentActivity-onBackPressed"></p><p><code>OnBackPressedDispatcher</code> 控制如何将返回按钮事件分配给一个或多个<code>OnBackPressedCallback</code> 对象。 <code>OnBackPressedCallback</code> 的构造函数将布尔值用于初始启用状态。 仅当启用了回调（即 <code>isEnabled()</code> 返回true）时，调度程序才会调用回调的<code>handleOnBackPressed()</code> 来处理返回按钮事件。 您可以通过调用 <code>setEnabled()</code> 来更改启用状态。</p><p>回调是通过 <code>addCallback</code> 方法添加的。 强烈建议使用采用 LifecycleOwner 的<code>addCallback()</code> 方法。 这样可以确保仅在 LifecycleOwner 为 Lifecycle.State.STARTED 时才添加<code>OnBackPressedCallback</code>。 当关联的 LifecycleOwner 被销毁时，该 activity 会删除已注册的回调，以防止内存泄漏，并使其适用于寿命比该 <code>activity</code> 短的 <code>fragment</code> 或其他生命周期所有者。</p><p>下面是一个示例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此 callback 仅当 MyFragment 至少是 Started 状态下调用</span></span><br><span class="line">        <span class="keyword">val</span> callback = requireActivity().onBackPressedDispatcher.addCallback(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//拦截返回事件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此 callback 可以在这里或者上面的 lambda 中开启和关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以通过 <code>addCallback()</code> 提供多个回调。 这样做时，将按照添加回调的相反顺序调用回调，即最后添加的回调是第一个给予处理返回按钮事件的机会的回调。 例如，如果您依次添加了三个分别名为1、2和3的回调，则将分别以3、2和1的顺序调用它们。</p><p>回调遵循“责任链”模式。 仅当未启用前一个回调时，才调用链中的每个回调。 这意味着在前面的示例中，仅当未启用回调3时，才会调用回调2。 仅当未启用回调2时，才调用回调1，依此类推。</p><p>请注意，通过 <code>addCallback()</code> 添加回调时，直到 LifecycleOwner 进入Lifecycle.State.STARTED 状态，才将回调添加到责任链中。</p><p>强烈建议更改 <code>OnBackPressedCallback</code> 的启用状态以进行临时更改(即更改 isEnabled 的值)，因为它可以保持上述顺序，如果您在多个不同的嵌套生命周期所有者上注册了回调，这尤其重要。</p><p>但是，如果要完全删除 <code>OnBackPressedCallback</code>，则应调用 remove()。 但是，这通常不是必需的，因为在销毁关联的 <code>LifecycleOwner</code> 时会自动删除其回调。</p><h2 id="Activity-onBackPressed"><a href="#Activity-onBackPressed" class="headerlink" title="Activity onBackPressed()"></a>Activity onBackPressed()</h2><p>如果您使用 <code>onBackPressed()</code> 处理返回按钮事件，建议您改用 <code>OnBackPressedCallback</code> 。 但是，如果您无法进行此更改，则适用以下规则：</p><ul><li><p>当您调用 <code>super.onBackPressed()</code> 时，将通过 <code>addCallback</code> 注册的所有回调。</p></li><li><p>无论 <code>OnBackPressedCallback</code> 的任何注册实例，始终会调用 <code>onBackPressed</code>。</p></li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>关于 fragment 返回栈的 demo 已经写好了，感兴趣的小伙伴可以 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">在这</a> 找到它。</p><p>我们下一篇再见。</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这两天在准备写 fragment 返回栈的文章，但是发现必须先介绍一下 OnBackPressedDispatcher ，所以这是一篇介绍 what 的文章，喜欢一手资料的可以移步 &lt;a href=&quot;https://developer.android.google.cn/reference/kotlin/androidx/activity/OnBackPressedDispatcher&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之Fragment】从源码角度看Fragment的启动流程及生命周期 基于AndroidX Fragment1.2.2</title>
    <link href="http://yoursite.com/2020/03/10/Jetpack-fragment-lifecycle/"/>
    <id>http://yoursite.com/2020/03/10/Jetpack-fragment-lifecycle/</id>
    <published>2020-03-09T16:10:35.000Z</published>
    <updated>2020-03-24T01:19:13.928Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔者看过不少源码分析类的文章，动辄贴上大段代码，这种方式很容易打断读者的思路，所以很多时候看过这类文章感叹好文好文，却感觉什么都没记住，亦或者默默加入收藏却不知何时能去细心地研读。</p><p>所以本文不会过多介绍源码的细节，更多地是抛砖引玉，如果您看过本文后能够跟着本文的思路自己翻一下源码相信您就不会有我上述的体验了。</p><p>本文默认您已对 fragment 的生命周期有所了解，并清楚fragment的缘起与职责。这部分基础内容可移步 <a href="https://developer.android.com/guide/components/fragments" target="_blank" rel="noopener">fragment 官方文档</a> </p><p><strong>也即本文不会介绍 “what”，而是介绍 “how” 并且探讨一下 “why”</strong></p></blockquote><a id="more"></a><p>这里贴一下 androidx fragment 源码地址</p><p><a href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/fragment/" target="_blank" rel="noopener">androidx fragment 官方源码地址</a></p><p>本文基于 androidx fragment 1.2.2 源码分析</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.fragment:fragment-ktx:1.2.2"</span></span><br></pre></td></tr></table></figure><p>本文主要介绍fragment的启动流程，其他内容例如返回栈，会后续更新，敬请关注。欢迎在评论区下讨论。<a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">本文demo</a></p><p>既然我们都知道 “what”，不妨我们来思考一下 “how”</p><h2 id="分析前的思考"><a href="#分析前的思考" class="headerlink" title="分析前的思考"></a>分析前的思考</h2><p>请大家思考一个问题，我们知道fragment 的生命周期是与其宿主 activity 的生命周期息息相关的，也即 activity 的每次生命周期回调都会引发每个fragment的类似回调。</p><p>那么，如果让我们来实现这样的操作，应该怎么做？</p><blockquote><p> 猜测：在activity每个生命周期的节点，去操作fragment，让其执行相应的生命周期方法。</p></blockquote><p>思路有了，下面进行一些细节的确认。</p><ol><li>activity 要能操作 fragment，fragment 亦可操作 fragment，所以需要抽象出一个管理 fragment 的模型</li><li>activity 操作 fragment 的一系列动作，应该是互为可逆一组操作。例如添加 fragment 后，也应能移除 fragment</li><li>activity 对 fragment 的每组操作不应是单一的，例如可以在一次操作中在 activity 不同位置添加两个 fragment，同时该操作还应满足 2 ，具有可逆性</li></ol><p>对于第一条，我们抽象出一个可以管理 fragment 的模型，加入上下级的关系，即 activity 可管理其内部的 fragment，fragment 亦可管理其内部的 fragment。因此 fragment 同时充当着管理者与被管理者两种角色</p><p>对于后两条，相信在大学学过数据库的人会想到一种结构：<strong>事务（Transaction）</strong></p><blockquote><p> 事务是指一组原子性的操作，这些操作是不可分割的整体，要么全完成，要么全不完成，完成后可以回滚到完成前的状态</p></blockquote><p>因此，fragment 中两个最重要的概念出现了，<code>FragmentManager</code> 和 <code>FragmentTransaction</code></p><p><code>FragmentManager</code>  封装着对 fragment 操作的各种方法，<code>addFragment</code> <code>removeFragment</code> 等等，而 <code>FragmentActivity</code> 通过 <code>FragmentController</code> 来操作 <code>FragmentManager</code>  </p><p><code>FragmentTransaction</code> 封装对 fragment 容器进行的 fragment 操作，例如在容器1内添加一个 fragment，同时在容器2内替换fragment。</p><p>它们均为抽象类，需要具体的实现类。</p><p><code>FragmentManager</code> 的实现类为 <code>FragmentManagerImpl</code>，其内部逻辑已全部移至 <code>FragmentManager</code>  中，是个空实现。</p><p><code>FragmentTransaction</code> 的实现类为 <code>BackStackRecord</code> ，其内部引用了 <code>FragmentManager</code> 的实例 ，同时重写了父类的 四个 <code>commit</code> 相关的方法。</p><h2 id="看似最简单的启动流程"><a href="#看似最简单的启动流程" class="headerlink" title="看似最简单的启动流程"></a>看似最简单的启动流程</h2><p>现在让我们看一部分代码，平时在activity中我们是这样填充一个fragment的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">       <span class="comment">//避免旋转屏幕等场景 fragment 重叠的问题</span></span><br><span class="line">       <span class="keyword">if</span> (savedInstanceState == <span class="literal">null</span>) &#123;</span><br><span class="line">           supportFragmentManager<span class="comment">//步骤1</span></span><br><span class="line">               .beginTransaction()<span class="comment">//步骤2</span></span><br><span class="line">               .add(R.id.container, BlankFragment.newInstance())<span class="comment">//步骤3</span></span><br><span class="line">               .commitNow()<span class="comment">//步骤4</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>步骤1，实例化 <code>FragmentManagerImpl</code> 对象 (内部经历了一些转换，详情参见源码或查看demo注释)</p></li><li><p>步骤2，实例化 <code>BackStackRecord</code>对象，并在构造器中传入 <code>FragmentManager</code> 实例</p></li><li><p>步骤3，调用事务方法，对 fragment 容器进行相应的操作，本例表示在 id 为 <code>container</code> 容器内添加 <code>BlankFragment</code></p></li><li><p>步骤4，提交事务，交于 <code>FragmentManager</code> 处理</p></li></ul><p>在 terminal 敲入 <code>adb shell setprop log.tag.FragmentManager VERBOSE</code> 可开启<code>FragmentManager</code>的日志功能，过滤 <code>FragmentManager</code> ，日志如下：</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084150.png" alt="单fragment启动日志"></p><p>绿色部分为笔者手动添加的log，灰色和蓝色部分为 fragment 源码中的log</p><p>根据日志显示的流程，我们的猜测看似是正确的，“在 activity 每个生命周期的节点，去操作 fragment ，让其执行相应的生命周期方法”</p><p>其实这里是有干扰的，因为我们是在activity 的 <code>onCreate</code> 方法里 创建并提交 <code>FragmentTransaction</code> ，如果在 <code>onResume</code> 里调用呢？</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084240.png" alt="单fragment启动日志2"></p><p>WTF！</p><p>或许，我们的猜测有问题？看似调用 <code>commitNow</code> 后 fragment 的生命流程是自发进行的</p><p>那如果我们把调用挪到 <code>onPause</code> 呢？</p><p>打开 activity 并按下 home 键</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084122.png" alt="单fragment启动日志-onPause"></p><p>我知道好奇的读者会尝试在 <code>onStop</code> 中尝试一下，有惊喜。手动滑稽。</p><p>从这几段日志上来看，fragment 在提交事务后会自发进入自己的生命周期流程，而当其宿主 activity  生命周期发生变化时，fragment 的生命周期也跟随变化。</p><p>如果这么说比较抽象的话，我们可以看在 onPause 中显示fragment 的日志，当 Fragment 进入 onStart 生命周期后，如果是正常流程应该进入 onResume，但由于按下 home 键 activity进入onStop，fragment 也进入了 onStop 状态</p><p>因此，我们将之前的猜测进行扩展：</p><blockquote><ol><li>在activity每个生命周期的节点，去操作fragment，让其执行相应的生命周期方法</li><li>FragmentTransaction  被提交后 fragment 会进入自己的生命周期流程，但受 1 约束</li></ol></blockquote><p>那么我们的源码解读就从两个方向入手</p><h2 id="Activity-操作-Fragment-生命周期"><a href="#Activity-操作-Fragment-生命周期" class="headerlink" title="Activity 操作 Fragment 生命周期"></a>Activity 操作 Fragment 生命周期</h2><p>activity 是通过 <code>FragmentController</code>  操作  <code>FragmentManager</code>  进而操作 fragment 的。</p><p>具体点就是在 activity 各个生命周期节点通过调用 <code>FragmentController</code> 中的各个 <code>dispatch-</code> 方法进而调用 <code>FragmentManager</code> 中的各个 <code>dispatch-</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FragmentActivity.java</span></span><br><span class="line"><span class="keyword">final</span> FragmentController mFragments = FragmentController.createController(<span class="keyword">new</span> HostCallbacks());</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码省略部分逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFragments.dispatchStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//onResume 彻底执行完毕的回调</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFragments.dispatchResume();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFragments.dispatchPause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFragments.dispatchStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    mFragments.dispatchDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样猜测 1 就被证实了</p><p><strong>activity 会在各个生命周期节点通过 <code>FragmentController</code> 间接调用 <code>FragmentManager</code>  中的 各种 <code>dispatch-</code> 方法，进而影响 fragment 的生命周期</strong></p><p>那么嵌套 fragment 呢？</p><p>嵌套 fragment 也应该是宿主使用 <code>FragmentManager</code>  中的各种 <code>dispatch-</code> 方法，基于这个想法我们可以看一下 <code>FragmentManager</code>  中 <code>dispatch-</code> 方法的调用</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084349.png" alt="dispatch-方法的引用"></p><p>可以看到这里有两处调用，第二处为activity 通过 <code>FragmentController</code> 间接调用，第一处使用的是 <code>mChildFragmentManager</code></p><p><strong>这里引出 fragment 中另外两个比较重要的概念，<code>getParentFragmentManager()</code> 和 <code>getChildFragmentManager()</code></strong></p><blockquote><p>注意：<code>requireFragmentManager()</code> 和 <code>getFragmentManager</code> 已弃用</p></blockquote><p><code>getChildFragmentManager()</code>获取的是fragment 中的 <code>mChildFragmentManager</code></p><p><code>getParentFragmentManager()</code> 获取的是fragment 中的 <code>mFragmentManager</code></p><p><code>mChildFragmentManager</code> 为fragment内部的 <code>fragmentManager</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Private fragment manager for child fragments inside of this one.</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">FragmentManager mChildFragmentManager = <span class="keyword">new</span> FragmentManagerImpl();</span><br></pre></td></tr></table></figure><p><code>mFragmentManager</code> 稍显复杂，</p><ol><li>如果 fragment 的直接宿主是 activity ，则返回的是 activity 中的<code>getSupportFragmentManager()</code> 返回的 <code>fragmentManager</code></li><li>如果 fragment 的直接宿主是 fragment，即该 fragment 是其他 fragment 的子 fragment，则返回的是其父 fragment 的 <code>getChildFragmentManager</code></li></ol><p><strong>所以 嵌套fragment 的生命周期是父 fragment 在各个生命周期节点上通过 <code>mChildFragmentManager</code> 调用 <code>dispatch-</code>  以影响其子 fragment 的生命周期</strong></p><p>这样我们第一部分的解读就告一段落了, 这里点到为止,一些细节需要您自己亲自看看源码</p><h2 id="Fragment-的生命周期自治"><a href="#Fragment-的生命周期自治" class="headerlink" title="Fragment 的生命周期自治"></a>Fragment 的生命周期自治</h2><p>在 <code>看似最简单的启动流程</code> 一节中我们分别在 activity 的 onCreate ，onResume，onPause 中分别开启并提交事务，来观察 fragment 的生命周期日志。</p><p>在没有 activity 干扰的情况下，fragment 的生命周期是自治的。</p><p>那么我们继续思考一个问题</p><p>Fragment 的生命周期是如何一环扣一环的执行的？</p><p>从上面的日志，我们看到很多 “moveto-” 的日志，</p><p><strong>我们可以继续大胆地猜测，一个生命周期节点结束后调用进入另一个生命周期节点的方法</strong></p><p>基于这个猜测，我们确认一些细节</p><p>fragment 应该有自己的状态，它可能自己管理内部的状态，也可能会有封装着状态转移的逻辑的专门管理状态的抽象</p><p>这里引出另外一个概念 <code>FragmentStateManager</code></p><p><code>FragmentStateManager</code> 中持有 fragment 的引用 <code>mFragment</code> 以及 <code>FragmentManager</code> 的状态 <code>mFragmentManagerState</code></p><p>这里fragment的状态值为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIALIZING = -<span class="number">1</span>;    <span class="comment">// Not yet attached.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTACHED = <span class="number">0</span>;         <span class="comment">// Attached to the host.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATED = <span class="number">1</span>;          <span class="comment">// Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTIVITY_CREATED = <span class="number">2</span>; <span class="comment">// Fully created, not started.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">3</span>;          <span class="comment">// Created and started, not resumed.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESUMED = <span class="number">4</span>;          <span class="comment">// Created started and resumed.</span></span><br></pre></td></tr></table></figure><p><code>FragmentStateManager</code> 还封装着 fragment 状态转移的方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"moveto ACTIVITY_CREATED: "</span> + mFragment);</span><br><span class="line">    &#125;</span><br><span class="line">    mFragment.performActivityCreated(mFragment.mSavedFragmentState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"moveto STARTED: "</span> + mFragment);</span><br><span class="line">    &#125;</span><br><span class="line">    mFragment.performStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fragment 生命周期自治的核心逻辑封装在 <code>FragmentManager</code> 中的 <code>void moveToState(@NonNull Fragment f, int newState)</code>  内，主要代码为(精简后)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(@NonNull Fragment f, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho);</span><br><span class="line"></span><br><span class="line">    newState = Math.min(newState, fragmentStateManager.computeMaxState());</span><br><span class="line">    <span class="keyword">if</span> (f.mState &lt;= newState) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> Fragment.INITIALIZING:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.INITIALIZING) &#123;</span><br><span class="line">                    fragmentStateManager.attach(mHost, <span class="keyword">this</span>, mParent);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.ATTACHED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.ATTACHED) &#123;</span><br><span class="line">                    fragmentStateManager.create();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.INITIALIZING) &#123;</span><br><span class="line">                    fragmentStateManager.ensureInflatedView();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">                    fragmentStateManager.createView(mContainer);</span><br><span class="line">                    fragmentStateManager.activityCreated();</span><br><span class="line">                    fragmentStateManager.restoreViewState();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                    fragmentStateManager.start();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.STARTED) &#123;</span><br><span class="line">                    fragmentStateManager.resume();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的switch 没有 break</p></blockquote><p>细心的读者可能发现了，fragment 中的状态怎么只到 resume ，后续的状态呢？</p><p>我们可以看一下 <code>FragmentManager</code> 中的 <code>dispatchPause</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dispatchStateChange(Fragment.STARTED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 dispatch 了 <code>STARTED</code> 的状态？其实刚刚 <code>moveToState</code> 方法我精简掉了一部分代码，留下的只有 <code>f.mState &lt;= newState</code> 的逻辑，即 <strong>dispatch 的新状态大于等于当前的状态</strong></p><p>而现在dispatch 的新状态比当前状态值小，则走了下面的逻辑，例如当前状态为 RESUMED ，新传递的状态为 STARTED，执行了 <code>fragmentStateManager.pause();</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(@NonNull Fragment f, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho);</span><br><span class="line"></span><br><span class="line">    newState = Math.min(newState, fragmentStateManager.computeMaxState());</span><br><span class="line">    <span class="keyword">if</span> (f.mState &lt;= newState) &#123;</span><br><span class="line">    <span class="comment">//省略...   </span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> Fragment.RESUMED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.RESUMED) &#123;</span><br><span class="line">                    fragmentStateManager.pause();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.STARTED) &#123;</span><br><span class="line">                    fragmentStateManager.stop();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"movefrom ACTIVITY_CREATED: "</span> + f);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mHost.onShouldSaveFragmentState(f) &amp;&amp; f.mSavedViewState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            fragmentStateManager.saveViewState();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (mExitAnimationCancellationSignals.get(f) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        destroyFragmentView(f);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        f.setStateAfterAnimating(newState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.CREATED) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack();</span><br><span class="line">                    <span class="keyword">if</span> (beingRemoved || mNonConfig.shouldDestroy(f)) &#123;</span><br><span class="line">                        makeInactive(fragmentStateManager);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (f.mTargetWho != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            Fragment target = findActiveFragment(f.mTargetWho);</span><br><span class="line">                            <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; target.getRetainInstance()) &#123;</span><br><span class="line">                                f.mTarget = target;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (mExitAnimationCancellationSignals.get(f) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        f.setStateAfterAnimating(newState);</span><br><span class="line">                        newState = Fragment.CREATED;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        fragmentStateManager.destroy(mHost, mNonConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.ATTACHED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.ATTACHED) &#123;</span><br><span class="line">                    fragmentStateManager.detach(mNonConfig);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的switch 还是没有 break</p></blockquote><p>这里有个细节，由于activity没有 onDestroyView 的生命周期，所以 <code>FragmentController</code> 中的 <code>dispatchDestroyView</code> 是没有调用的</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084417.png" alt="dispatchOnDestroyView"></p><p> 在 activity 中的 destroy 方法中通过 <code>fragmentController</code> 调用了 <code>dispatchDestroy</code> 内部调用 <code>dispatchStateChange(Fragment.INITIALIZING)</code> ，而此时的fragment 的 mState 为 <code>ACTIVITY_CREATED</code>，所以 <code>moveToState</code> 方法会走到 <code>ACTIVITY_CREATED</code> 的 case 并执行到底</p><p>这样 fragment 最简单场景的生命周期就结束了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们做一个总结：activity 和 fragment 会在各个生命周期节点通过被调用 fragment 的 <code>parentFragmentManager</code>（或者说父 fragment 的 <code>childFragmentManager</code> 和 activity 的 <code>supportFragmentManager</code>）中的各种 <code>dispatch-</code> 方法以影响子 fragment 的 生命周期，同时子 fragment 也拥有自己生命周期的调用链（从状态A转移至状态B）</p><p>不得不说 fragment 的很多 API 并不是很好用，从 androidx fragment 的更新频率也可以看出。比如 fragment 中的 view 和 fragment本身的生命周期是不一致的，存在onDestroyView 但 fragment没有销毁的情况</p><p><a href="https://medium.com/@ianhlake" target="_blank" rel="noopener">Ian Lake</a> 在 <a href="https://www.youtube.com/watch?v=RS1IACnZLy4" target="_blank" rel="noopener">Fragments: Past, Present, and Future (Android Dev Summit ‘19)</a> 中提到未来官方会将二者合并，届时 fragment 的使用会更加简洁</p><p>这里引用 <a href="https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iii-fragments-afc87d4f37fd" target="_blank" rel="noopener">The Android Lifecycle cheat sheet — part III : Fragments</a> 文中的图片 ，和我画的commit <code>FragmentTransaction</code>  的脑图（略简陋），帮您更好的理解</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084444.png" alt=" [The Android Lifecycle cheat sheet — part III : Fragments](https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iii-fragments-afc87d4f37fd)"></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084515.png" alt="fragment脑图"></p><p>强烈建议您自己亲自看一看源码，不然就变为我文章开头时说的状态了。</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔者看过不少源码分析类的文章，动辄贴上大段代码，这种方式很容易打断读者的思路，所以很多时候看过这类文章感叹好文好文，却感觉什么都没记住，亦或者默默加入收藏却不知何时能去细心地研读。&lt;/p&gt;
&lt;p&gt;所以本文不会过多介绍源码的细节，更多地是抛砖引玉，如果您看过本文后能够跟着本文的思路自己翻一下源码相信您就不会有我上述的体验了。&lt;/p&gt;
&lt;p&gt;本文默认您已对 fragment 的生命周期有所了解，并清楚fragment的缘起与职责。这部分基础内容可移步 &lt;a href=&quot;https://developer.android.com/guide/components/fragments&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fragment 官方文档&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也即本文不会介绍 “what”，而是介绍 “how” 并且探讨一下 “why”&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
</feed>
