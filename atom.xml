<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨云召 | 博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://flywith24.gitee.io/"/>
  <updated>2020-10-15T00:43:00.476Z</updated>
  <id>https://flywith24.gitee.io/</id>
  
  <author>
    <name>杨云召</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 AccountManager 实现系统内共享账号</title>
    <link href="https://flywith24.gitee.io/2020/09/04/AccountManager/"/>
    <id>https://flywith24.gitee.io/2020/09/04/AccountManager/</id>
    <published>2020-09-04T06:11:46.000Z</published>
    <updated>2020-10-15T00:43:00.476Z</updated>
    
    <content type="html"><![CDATA[<p>使用 AccountManager 实现系统内共享账号</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发过程中我们可能遇到自家应用间共享账号的场景。例如 APP1 登录成功后，启动 APP2 时自动完成登录并与 APP1 共享账号信息。</p><p>Android 为我们提供了AccountManager 来管理账号信息。</p><p><a href="https://github.com/Flywith24/AccountManagerDemo" target="_blank" rel="noopener">demo 地址</a></p><h2 id="共享前提"><a href="#共享前提" class="headerlink" title="共享前提"></a>共享前提</h2><ol><li>两个 app 在一个用户组内</li><li>使用相同的签名（使用 debug 默认签名也可以共享）</li><li>accountType 相同</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>AccountManager是一个面向应用程序开发的组件，它提供了一套对应于 IAccountManager 协议的应用程序接口；这组接口通过Binder机制与系统服务AccountManagerService进行通信，协作完成帐号相关的操作。同时，AccountManager接收authenticators 提供的回调，以便在帐号操作完成之后向<em>调用此帐号服务的业务</em>返回对应的接口，同时触发这个业务对结果的处理。<br>- authenticators 即注册帐号服务的app；<br>- 业务调用方 即使用authenticators提供的帐号服务的第三方，也可以是authenticator自己</p><p>摘自：<a href="https://blog.csdn.net/dzkdxyx/article/details/78569867" target="_blank" rel="noopener">Android AccountManager帐号管理（一）</a></p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>该项目中有两个 module ，app 对应注册账号服务的app，app1 对应使用账号服务的第三方应用</p><ul><li><p>在两个应用的 manifest 中加入 <code>&lt;uses-permission android:name=&quot;android.permission.GET_ACCOUNTS&quot; /&gt;</code> 权限</p></li><li><p>在 app 中创建 <code>authenticator.xml</code> 文件，注意 accountType 的配置，这里的应用名及 icon 会在设备的 设置 -&gt; 账号 中显示</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904152225.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p></li><li><p>在 app 中注册一个 action 为“android.accounts.AccountAuthenticator”的 authenticator service，引入上一步创建的 xml 文件</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904152006.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904152029.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p></li></ul><ul><li><p>在 app 中创建  authenticator</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904151929.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p></li></ul><h2 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904153019.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h2 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904153112.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h2 id="第三方-app-获取-用户，token-等信息"><a href="#第三方-app-获取-用户，token-等信息" class="headerlink" title="第三方 app 获取 用户，token 等信息"></a>第三方 app 获取 用户，token 等信息</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200904154855.png" src="/2020/09/04/AccountManager/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 AccountManager 实现系统内共享账号&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201014232756.png" type="image" />
    
    
      <category term="ROM" scheme="https://flywith24.gitee.io/categories/ROM/"/>
    
    
      <category term="ROM" scheme="https://flywith24.gitee.io/tags/ROM/"/>
    
      <category term="framework" scheme="https://flywith24.gitee.io/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>源码编译与烧写</title>
    <link href="https://flywith24.gitee.io/2020/08/18/Framework-Compile/"/>
    <id>https://flywith24.gitee.io/2020/08/18/Framework-Compile/</id>
    <published>2020-08-18T06:11:46.000Z</published>
    <updated>2020-10-15T02:52:53.009Z</updated>
    
    <content type="html"><![CDATA[<p>基于 Android 10 的源码编译与烧写。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>环境搭建等内容网上资料很多，这里不再赘述。</p><p>此处以 Pixel 3a &amp; Android 10 为例介绍如何编译 ROM 包并烧录</p><p>手上没有真机的小伙伴可以选择制作模拟器，本文最后提供了基于 Android 10 编译的自定义 AVD 下载链接</p><h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><p><a href="https://source.android.com/setup/build/initializing" target="_blank" rel="noopener">官方文档</a></p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>这里推荐使用 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">清华镜像</a></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200628155443.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>下载 <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="noopener">每月更新的初始化包</a> 并解压</p><h2 id="下载驱动（可选）"><a href="#下载驱动（可选）" class="headerlink" title="下载驱动（可选）"></a>下载驱动（可选）</h2><p>如果要刷到真机上，需要下载相应机型的驱动，进入 <a href="https://developers.google.com/android/drivers" target="_blank" rel="noopener">该链接</a>，选择相应的机型对应的 Android 版本号和驱动</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200628160058.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我这里选择的是 Android 10.0.0（QQ3A.200605.002.A1）</p><p>将两个驱动文件下载并解压，并执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">./extract-qcom-sargo.sh<br>./extract-google_devices-sargo.sh<br></code></pre></td></tr></table></figure><p>点击 Enter 并输入 I ACCEPT 同意 License</p><p>根据 Build 在 <a href="https://source.android.com/setup/start/build-numbers" target="_blank" rel="noopener">该链接</a> 中找到相匹配的分支，本例中对应 <code>android-10.0.0_r39</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200628160259.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="QQ3A.200605.002.A1 对应的分支"></p><h2 id="选择分支"><a href="#选择分支" class="headerlink" title="选择分支"></a>选择分支</h2><p>执行完上述操作如果直接编译的话实际上是编译的 master 分支，我们还需要切换到想要编译的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-10.0.0_r39 --depth=1<br>repo sync -j8<br>repo start android-10.0.0_r39 --all<br></code></pre></td></tr></table></figure><h2 id="编译与烧写"><a href="#编译与烧写" class="headerlink" title="编译与烧写"></a>编译与烧写</h2><p>在源码目录执行</p><p><code>source build/envsetup.sh</code></p><p><code>lunch</code> 进入菜单</p><p>选择相应的版本</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200628162935.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我这里选择的是 19</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>接着便可以进行编译了，可以使用 <code>make -j</code> 命令，其中 j 代表的是编译 job 的数量</p><p>执行（我这里指定了生成 log 文件）</p><p><code>make -j32 2&gt;&amp;1 | tee build_20200628_1635.log</code></p><p>编译成功后会出现一个 out 目录，ROM 镜像文件就在此处</p><p>例如我的路径为：<code>~/aosp/out/target/product/sargo</code></p><h2 id="烧写"><a href="#烧写" class="headerlink" title="烧写"></a>烧写</h2><p>设备进入 bootloader 并执行：<code>fastboot flashall -w</code>，其中 -w 代表清空数据</p><p>烧写成功，开机！</p><h2 id="制作自定义-AVD（Android-Virtual-Devices）-系统镜像"><a href="#制作自定义-AVD（Android-Virtual-Devices）-系统镜像" class="headerlink" title="制作自定义 AVD（Android Virtual Devices） 系统镜像"></a>制作自定义 AVD（Android Virtual Devices） 系统镜像</h2><p>很多小伙伴没有相应的真机，不过可以制作出自定义的 AVD 作为模拟器使用。</p><p><code>lunch</code> 进入菜单时选择相应的模拟器，例如选择上图的 24，64 位的通用设备</p><p>想要制作 AVD 系统镜像需要制作附加 <code>sdk</code> 和 <code>sdk_repo</code> 软件包</p><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span> make -j32 sdk sdk_repo<br></code></pre></td></tr></table></figure><p>该操作可能会出现异常，例如</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200818135050.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这是由于没有编译这些工具导致的，解决办法是依次编译这些工具</p><p>依次输入如下命令，后面工具视情况而定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span> make libaapt2_jni<br><span class="hljs-meta"><br>$</span> make dmtracedump<br><span class="hljs-meta"><br>$</span> make etc1tool<br><span class="hljs-meta"><br>$</span> make deployagent<br><span class="hljs-meta"><br>$</span> make aapt<br><span class="hljs-meta"><br>$</span> make split-select<br><span class="hljs-meta"><br>$</span> make bcc_compat<br><span class="hljs-meta"><br>$</span> make apksigner<br><span class="hljs-meta"><br>$</span> make dx<br><span class="hljs-meta"><br>$</span> make layoutlib-legacy<br></code></pre></td></tr></table></figure><p>编译好相关工具我们再次执行 <code>make -j32 sdk sdk_repo</code></p><p>编译成功后会在 <code>out/host/linux-x86/sdk/aosp_x86_64</code> 目录下生成 <code>sdk-repo-linux-system-images-eng.[username].zip</code> 文件</p><p>按照官方文档中使用镜像的方式我没有成功</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200818135851.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这里我使用了一个取巧的方式</p><p>我们在 Android Studio 创建 AVD 时可选的镜像一般有三种，这里还是以 Android 10 为例</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200818140305.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>Google Play，Google APIs，和默认的</p><p>它们会下载到 SDK/system-images/android-29 中</p><p>Google APIs 版本对应的目录就是 google_apis</p><p>我们可以将我们编译出的 AVD 镜像 copy 到其中的一个目录</p><p>例如，我将自定义的 AVD 镜像放置在了这里：</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200818140734.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我们在创建模拟器时选择自定义的 AVD 镜像即可创建出自己编译 ROM  的模拟器</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200818141020.png" src="/2020/08/18/Framework-Compile/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这里提供了我编译出来的自定义 AVD，不方便自己编译的小伙伴可以在此处下载</p><p>链接：<a href="https://pan.baidu.com/s/1LIcuycoU4Ou42VsSBM_MuQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1LIcuycoU4Ou42VsSBM_MuQ</a><br>提取码：CAVD</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于 Android 10 的源码编译与烧写。&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201014220906.png" type="image" />
    
    
      <category term="ROM" scheme="https://flywith24.gitee.io/categories/ROM/"/>
    
    
      <category term="ROM" scheme="https://flywith24.gitee.io/tags/ROM/"/>
    
      <category term="framework" scheme="https://flywith24.gitee.io/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>使用 ProcessLifecycle 优雅地监听应用前后台切换</title>
    <link href="https://flywith24.gitee.io/2020/07/01/Tips-ProcessLifecycle/"/>
    <id>https://flywith24.gitee.io/2020/07/01/Tips-ProcessLifecycle/</id>
    <published>2020-07-01T06:11:46.000Z</published>
    <updated>2020-10-15T02:49:52.951Z</updated>
    
    <content type="html"><![CDATA[<p>使用 ProcessLifecycle 优雅地监听应用前后台切换</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴见到你，又来到了「奇技淫巧」系列，本系列介绍一些「骚操作」，可能不适合用于生产，但可以开拓思路</p><p>前些天在群里看到有人讨论通过维护 activity 栈来监听程序前后台切换的问题。其实单纯监听程序的前后台切换完全不需要维护 activity 栈，而现在比较主流的做法是使用 <code>registerActivityLifecycleCallbacks</code>。而今天我来介绍一下使用 ProcessLifecycleOwner 来实现这一功能</p><h2 id="lifecycle-process-库"><a href="#lifecycle-process-库" class="headerlink" title="lifecycle-process 库"></a>lifecycle-process 库</h2><p>Android Jetpack Lifecycle 组件有一个可选库：lifecycle-process，它可以为整个 app 进程提供一个 ProcessLifecycleOwner</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701110431.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="lifecycle-process 引入"></p><p>该库十分简单，只有四个文件</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701110904.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="lifecycle-process"></p><p><code>ProcessLifecycleOwnerInitializer</code> 借助 ContentProvider 拿到 Context，用于初始化操作</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701112017.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="init"></p><p><code>EmptyActivityLifecycleCallbacks</code> 为 <code>Application.ActivityLifecycleCallbacks</code> 的实现类，内部为空实现</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701112219.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="EmptyActivityLifecycleCallbacks"></p><p><code>LifecycleDispatcher</code> 通过 ReportFragment 来 hook 宿主的生命周期事件</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701113143.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>核心逻辑都在 ProcessLifecycleOwner 中</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701113324.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ProcessLifecycleOwner "></p><p>该类提供了整个 app 进程的 lifecycle</p><p>可以将其视为所有 activity 的 LifecycleOwner ，其中 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_CREATE" target="_blank" rel="noopener">Lifecycle.Event.ON_CREATE</a> 只会分发一次，而 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_DESTROY" target="_blank" rel="noopener">Lifecycle.Event.ON_DESTROY</a> 则永远不会分发</p><p>其它的生命周期事件将按以下规则分发：</p><p><code>ProcessLifecycleOwner</code> 会分发 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_START" target="_blank" rel="noopener">Lifecycle.Event.ON_START</a> 和 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_RESUME" target="_blank" rel="noopener">Lifecycle.Event.ON_RESUME</a> 事件（在第一个 activity 移动到这些事件时）</p><p><a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_PAUSE" target="_blank" rel="noopener">Lifecycle.Event.ON_PAUSE</a> 与 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event#ON_STOP" target="_blank" rel="noopener">Lifecycle.Event.ON_STOP</a> 会在最后一个 activity 移动到这些状态后 <strong>延迟</strong> 分发，该延迟足够长，以确保由于配置更改等操作重建 activity 后不会分发任何事件</p><p>对于监听应用在前后台切换且不需要毫秒级的精度的场景，这十分有用</p><h2 id="ProcessLifecycleOwner-源码解析"><a href="#ProcessLifecycleOwner-源码解析" class="headerlink" title="ProcessLifecycleOwner  源码解析"></a>ProcessLifecycleOwner  源码解析</h2><p>根据上图我们得知 <code>ProcessLifecycleOwner</code>  实现了 LifecycleOwner 接口</p><p>由于在 <code>ProcessLifecycleOwnerInitializer</code> 中初始化时传入了 Context，因此 <code>ProcessLifecycleOwner</code>  在 attach 方法中借助 Context 拿到了 Application 实例，并调用了 <code>registerActivityLifecycleCallbacks</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>    mHandler = <span class="hljs-keyword">new</span> Handler();<br>    mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);<br>    Application app = (Application) context.getApplicationContext();<br>    app.registerActivityLifecycleCallbacks(<span class="hljs-keyword">new</span> EmptyActivityLifecycleCallbacks() <br>        <span class="hljs-meta">@RequiresApi</span>(<span class="hljs-number">29</span>)<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPreCreated</span><span class="hljs-params">(@NonNull Activity activity,<br>                @Nullable Bundle savedInstanceState)</span> </span>&#123;<br>            <span class="hljs-comment">//我们需要 ProcessLifecycleOwner 刚好在第一个 activity 的 LifecycleOwner started/resumed 之前获取 ON_START 和 ON_RESUME。</span><br>            <span class="hljs-comment">//activity 的 LifecycleOwner 通过在 onCreate() 中添加 activity 注册的 callback 来获取 started/resumed 状态。</span><br>            <span class="hljs-comment">//通过在 onActivityPreCreated() 中添加我们自己的 activity 注册的 callback，我们首先获得了回调，同时与 Activity 的 onStart()/ onResume()回调相比仍具有正确的相对顺序</span><br>     <br>            activity.registerActivityLifecycleCallbacks(<span class="hljs-keyword">new</span> EmptyActivityLifecycl<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPostStarted</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>                    activityStarted();<br>                &#125;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPostResumed</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>                    activityResumed();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(Activity activity, Bundle savedInstanceStat<br>            //仅在API <span class="hljs-number">29</span> 之前使用 ReportFragment，在此之后，我们可以使用在 onActivityPreCreated()</span> 中注册的 onActivityPostStarted 和 onActivityPostResumed 回调<br>            <span class="hljs-title">if</span> <span class="hljs-params">(Build.VERSION.SDK_INT &lt; <span class="hljs-number">29</span>)</span> </span>&#123;<br>                ReportFragment.get(activity).setProcessListener(mInitializationLi<br>            &#125;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPaused</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>            activityPaused();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityStopped</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>            activityStopped();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>内部维护了 Started 和 Resumed 的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mStartedCounter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mResumedCounter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> mPauseSent = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> mStopSent = <span class="hljs-keyword">true</span>;<br></code></pre></td></tr></table></figure><p>并在 activityStarted 和 activityResumed 方法中对 这两个数值进行 ++，并更改 lifecycle 状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activityStarted</span><span class="hljs-params">()</span> </span>&#123;<br>    mStartedCounter++;<br>    <span class="hljs-keyword">if</span> (mStartedCounter == <span class="hljs-number">1</span> &amp;&amp; mStopSent) &#123;<br>        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);<br>        mStopSent = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activityResumed</span><span class="hljs-params">()</span> </span>&#123;<br>    mResumedCounter++;<br>    <span class="hljs-keyword">if</span> (mResumedCounter == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mPauseSent) &#123;<br>            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);<br>            mPauseSent = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mHandler.removeCallbacks(mDelayedPauseRunnable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 activityPaused 和 activityStopped 方法对这两个数值进行 –</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activityPaused</span><span class="hljs-params">()</span> </span>&#123;<br>    mResumedCounter--;<br>    <span class="hljs-keyword">if</span> (mResumedCounter == <span class="hljs-number">0</span>) &#123;<br>        mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activityStopped</span><span class="hljs-params">()</span> </span>&#123;<br>    mStartedCounter--;<br>    dispatchStopIfNeeded();<br>&#125;<br></code></pre></td></tr></table></figure><p>而在这里我们看到了上文提到的延迟操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 handler 进行延迟操作</span><br>mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);<br><br><span class="hljs-comment">// 延迟 700 ms</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> TIMEOUT_MS = <span class="hljs-number">700</span>; <span class="hljs-comment">//mls</span><br><br><span class="hljs-keyword">private</span> Runnable mDelayedPauseRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 根据需要分发事件</span><br>        dispatchPauseIfNeeded();<br>        dispatchStopIfNeeded();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchPauseIfNeeded</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mResumedCounter == <span class="hljs-number">0</span>) &#123;<br>        mPauseSent = <span class="hljs-keyword">true</span>;<br>        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchStopIfNeeded</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mStartedCounter == <span class="hljs-number">0</span> &amp;&amp; mPauseSent) &#123;<br>        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);<br>        mStopSent = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码就解析到这里，接下来我们看看如何使用吧</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先引入该库</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-process:2.3.0-alpha05"</span><br></code></pre></td></tr></table></figure><p>由于我们要自定义 lifecycleObserver，因此还需引入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-common-java8:2.3.0-alpha05"</span><br></code></pre></td></tr></table></figure><p>首先创建 <code>ProcessLifecycleObserver</code> 类，实现 <code>DefaultLifecycleObserver</code> 接口，在相应的生命周期中打印 log</p><p>接着在自定义 Application 中加入</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200701121028.png" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这样便完成了！</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/7/1/173089686a09e8f3?w=1854&h=999&f=gif&s=2823298" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="演示"></p><p><a href="https://github.com/Flywith24/ProcessLifecycle-Demo" target="_blank" rel="noopener">Demo 在这里</a></p><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案</a></li></ul><ul><li><a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></li></ul><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你</a></li></ul><ul><li><a href="https://juejin.im/post/5e967f35f265da47d77cd4c3" target="_blank" rel="noopener">【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转</a></li></ul><ul><li><a href="https://juejin.im/post/5ebdfb0b6fb9a0436153db22" target="_blank" rel="noopener">【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil</a></li></ul><ul><li><a href="https://juejin.im/post/5ec50ae46fb9a047a862124f" target="_blank" rel="noopener">【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化</a></li></ul><ul><li><a href="https://juejin.im/post/5ecde219e51d457841190d08" target="_blank" rel="noopener">【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</a></li></ul><ul><li><a href="https://juejin.im/post/5ed9c92ce51d45789b35afa9" target="_blank" rel="noopener">【奇技淫巧】巧用 kotlin 扩展函数和 typealias 封装 带网络状态和解决「粘性」事件的 LiveData</a></li></ul><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/07/01/Tips-ProcessLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 ProcessLifecycle 优雅地监听应用前后台切换&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015104945.png" type="image" />
    
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
      <category term="Tips" scheme="https://flywith24.gitee.io/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>使用 Navigation + Dynamic Feature Module 实现模块化</title>
    <link href="https://flywith24.gitee.io/2020/05/20/Tips-Navagion+DynamicFeatureModule/"/>
    <id>https://flywith24.gitee.io/2020/05/20/Tips-Navagion+DynamicFeatureModule/</id>
    <published>2020-05-20T06:11:46.000Z</published>
    <updated>2020-10-15T02:46:09.711Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Navigation + Dynamic Feature Module 实现模块化</p><a id="more"></a><p><code>androidx navigation 2.3.0</code> 加入了对 <code>dynamic feature module</code> 的导航支持，因此我们利用这个来分离出多个功能 module 来实现模块化</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520170621.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="navigation 2.3.0 更新"></p><h2 id="国内基本不用的-dynamic-feature-module"><a href="#国内基本不用的-dynamic-feature-module" class="headerlink" title="国内基本不用的 dynamic feature module"></a>国内基本不用的 dynamic feature module</h2><p><a href="https://developer.android.com/guide/app-bundle" target="_blank" rel="noopener">Android App Bundle</a> 是官方 18 年推出的动态发布方案，类似国内各种插件化方案。不过它需要 Google Play Store 支持，这导致在国内无法使用</p><p>借着 navigation 组件支持 <code>dynamic feature module</code> 间导航的契机，我们可以使用 <code>dynamic feature module</code> 来拆分功能模块以实现模块化</p><p>传统的拆分方案大概是这样，feature module 之间相互隔离，app module 依赖各个 feature module 间接依赖 base 库，公共库</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520165717.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="传统架构"></p><p>而使用 <code>dynamic feature module</code> ，其结构是这样的</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520172609.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="dynamic feature 架构"></p><p><code>dynamic feature module</code> 也可以按需安装，也就是说，它们可能不包含在用户最初下载的 APK 中，而是在运行时安装。而我们可以直接将它们包含到 APK 中</p><h2 id="使用-dynamic-feature-module"><a href="#使用-dynamic-feature-module" class="headerlink" title="使用 dynamic feature module"></a>使用 dynamic feature module</h2><p>首先我们在 base lib 中引入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    <span class="hljs-keyword">def</span> nav_version = <span class="hljs-string">"2.3.0-alpha06"</span><br><br>    api <span class="hljs-string">"androidx.navigation:navigation-fragment-ktx:$nav_version"</span><br>    api <span class="hljs-string">"androidx.navigation:navigation-ui-ktx:$nav_version"</span><br>    api <span class="hljs-string">"androidx.navigation:navigation-dynamic-features-fragment:$nav_version"</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 app module 中的 res/navigation 目录下创建 main_nav.xml</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520173227.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="main_nav.xml"></p><p>接着我们在 activity_main 中设置默认的 host</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520173336.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="默认 host"></p><blockquote><p>这里不同于正常 navigation 的用法，没有使用 NavHostFragment，而是使用 DynamicNavHostFragment</p></blockquote><h3 id="直接跳转-fragment"><a href="#直接跳转-fragment" class="headerlink" title="直接跳转 fragment"></a>直接跳转 fragment</h3><p>我们创建 dynamic feature module ，取名为 feature1</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520174302.gif" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="创建 dynamic feature module"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520174505.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="包名前部分需保证与 applicationId 相同"></p><blockquote><p>这里 <code>dynamic feature module</code> 的包名前部分要和 applicationId 即 app module 包名相同，否则后续的 include 操作会有问题</p></blockquote><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520174757.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="选择加载模式"></p><p>这里我们选择在安装时集成该 module</p><p>接着我们在该 module 下创建一个 fragment 取名为 <code>Feature1OneFragment</code></p><p>之后我们直接在 main_nav.xml 中引入 该 fragment 并加入 action</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520175351.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="直接引入 fragment"></p><p>接着我们就可以在 app 下的 MainFragment 打开 Feature1OneFragment</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520175841.gif" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="启动 fragment"></p><blockquote><p>我的 demo 中 feature2 是直接引入 fragment，因此跳转的是 Feature2OneFragment</p></blockquote><h3 id="直接跳转-activity"><a href="#直接跳转-activity" class="headerlink" title="直接跳转 activity"></a>直接跳转 activity</h3><p>在 feature1 中创建 activity (demo 中为 feature2)</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520180201.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="跳转 activity"></p><p>同样需要指定 moduleName</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520180434.gif" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="启动activity"></p><h3 id="使用-dynamic-feature-module-内部的-graph"><a href="#使用-dynamic-feature-module-内部的-graph" class="headerlink" title="使用 dynamic feature module 内部的 graph"></a>使用 dynamic feature module 内部的 graph</h3><p>我们可以为 dynamic feature module 单独配置 navigation graph，这样就可以处理 dynamic feature module 内部的跳转了</p><p>在 feature1 中创建 feature1_nav.xml ，其中 startDestination 为 Feature1OneFragment</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520181021.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="feature1_nav.xml"></p><p>在 main_nav.xml 我们需要使用另外一种方式来使用该 graph</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520181145.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="include-dynamic"></p><p>我们使用了一个新的标签 <code>include-dynamic</code>，同时我们看到了几个没用过的属性</p><ul><li><code>graphPackage</code> 为 <code>dynamic feature module</code> 的包名</li><li><code>graphResName</code> 为 <code>dynamic feature module</code> 内部 graph 的名字</li><li><code>moduleName</code> 为 module 名</li></ul><blockquote><p>注意：这里的 graphPackage 可以省略</p><ol><li>如果 module 的包名没用按照前文的格式配置会导致无法找到 graphId 的异常</li><li>include-dynamic 标签的 id 要与 <code>feature1_nav.xml</code> navigation 标签下的 id 一致，或者后者不设置 id</li></ol></blockquote><p>这样从 app module 导航到 feature1 的 startDestination 后便可使用其内部的逻辑进行后续的导航了</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520182339.gif" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="include 跳转"></p><h2 id="feature-module-间跳转"><a href="#feature-module-间跳转" class="headerlink" title="feature module 间跳转"></a>feature module 间跳转</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200520182529.png" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="暂不支持 deep link"></p><p>Navigation 组件暂不支持 Dynamic include graph 的 deep link</p><p>因此我目前也没有找到特别优雅的方式，已知的方案如下</p><ul><li>反射</li><li>使用 <a href="https://developer.android.com/reference/java/util/ServiceLoader" target="_blank" rel="noopener">ServiceLoader</a></li><li>使用依赖注入</li></ul><p><a href="https://github.com/Flywith24/DynamicFeatureDemo" target="_blank" rel="noopener">demo</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/05/20/Tips-Navagion+DynamicFeatureModule/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Navigation + Dynamic Feature Module 实现模块化&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015104605.png" type="image" />
    
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
      <category term="Tips" scheme="https://flywith24.gitee.io/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>新的图片加载库？基于Kotlin协程的图片加载库——Coil</title>
    <link href="https://flywith24.gitee.io/2020/05/18/Tips-Coil/"/>
    <id>https://flywith24.gitee.io/2020/05/18/Tips-Coil/</id>
    <published>2020-05-18T06:11:46.000Z</published>
    <updated>2020-10-15T02:38:00.947Z</updated>
    
    <content type="html"><![CDATA[<p>新的图片加载库？基于 Kotlin 协程的图片加载库——Coil</p><a id="more"></a><h2 id="新的图片加载库——Coil"><a href="#新的图片加载库——Coil" class="headerlink" title="新的图片加载库——Coil"></a>新的图片加载库——Coil</h2><p><a href="https://coil-kt.github.io/coil/" target="_blank" rel="noopener">Coil</a> 是 <a href="https://www.instacart.com/" target="_blank" rel="noopener">Instacart</a> 团队研发的新的的图片加载库，它使用了很多高级功能，例如协程，<code>Okhttp</code>，<code>androidx.lifecycle</code>。<code>Coil</code> 还包括一些高级功能，例如图像采样，有效的内存使用以及请求的自动取消/暂停</p><p>默认情况下 <code>Coil</code> 与 R8 完全兼容，开箱即用，不需要添加额外的规则。如果使用 Proguard ，您可能需要为 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/resources/META-INF/proguard/coroutines.pro" target="_blank" rel="noopener">Coroutines</a>, <a href="https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro" target="_blank" rel="noopener">OkHttp</a> 和 <a href="https://github.com/square/okio/blob/master/okio/src/jvmMain/resources/META-INF/proguard/okio.pro" target="_blank" rel="noopener">Okio</a> 添加规则</p><h2 id="Coil-的优势"><a href="#Coil-的优势" class="headerlink" title="Coil 的优势"></a>Coil 的优势</h2><ul><li>快速：<code>Coil</code> 进行了很多优化，包括内存和磁盘缓存，对内存中的图像进行采样，重新使用位图，自动暂停/取消请求等等</li><li>轻量：<code>Coil</code> 在您的APK中添加了约 2000 种方法（对于已经使用 <code>OkHttp</code> 和 <code>Coroutines</code> 的应用程序），与 <code>Picasso</code> 相当，远少于 <code>Glide</code> 和 <code>Fresco</code></li><li>易用：<code>Coil</code> 的 API 利用 Kotlin 的特性简化了样板代码</li><li>现代：<code>Coil</code> 是 <code>Kotlin-first</code>，使用现代化的库，例如 <code>Coroutines</code>, <code>OkHttp</code>, <code>Okio</code>, 以及 <code>AndroidX Lifecycles</code></li></ul><p><code>Coil</code> 是以下名称的缩写：<strong>Coroutine Image Loader</strong></p><h2 id="Artifacts"><a href="#Artifacts" class="headerlink" title="Artifacts"></a>Artifacts</h2><p><code>Coil</code> 拥有 5 个 artifact 并发布在 <code>mavenCentral()</code></p><ul><li><code>io.coil-kt:coil</code>：依赖于  <code>io.coil-kt:coil-base</code> 并且包含了 <code>Coil</code> 的单例和  <code>ImageView.load</code> 的扩展函数</li><li><code>io.coil-kt:coil-base</code>：base 库，<strong>不包含</strong> <code>Coil</code> 的单例和  <code>ImageView.load</code> 的扩展函数，如果使用依赖注入，则可以使用该库</li><li><code>io.coil-kt:coil-gif</code>：引入一系列解码器以支持解码 gif</li><li><code>io.coil-kt:coil-svg</code>：引入一系列解码器以支持 svg</li><li><code>io.coil-kt:coil-video</code>：包括两个 <a href="https://coil-kt.github.io/coil/api/coil-base/coil.fetch/-fetcher" target="_blank" rel="noopener">fetchers</a> ，以支持从 Android 支持的任何视频格式中提取和解码帧</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 普通使用引用</span><br>implementation <span class="hljs-string">"io.coil-kt:coil:0.11.0"</span><br><span class="hljs-comment">// 使用依赖注入时或者制作基于 coil 的库引用</span><br>implementation <span class="hljs-string">"io.coil-kt:coil-base:0.11.0"</span><br></code></pre></td></tr></table></figure><h2 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h2><p><code>Coil</code> 要求 Java 8，要通过 D8 启用 Java 8 调试，请将以下内容添加到 Gradle 脚本</p><p>Gradle (<code>.gradle</code>)</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    compileOptions &#123;<br>        sourceCompatibility JavaVersion.VERSION_1_8<br>        targetCompatibility JavaVersion.VERSION_1_8<br>    &#125;<br>&#125;<br><br>tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all &#123;<br>    kotlinOptions &#123;<br>        jvmTarget = <span class="hljs-string">"1.8"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Gradle Kotlin DSL (<code>.gradle.kts</code>)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">android &#123;<br>    compileOptions &#123;<br>        sourceCompatibility = JavaVersion.VERSION_1_8<br>        targetCompatibility = JavaVersion.VERSION_1_8<br>    &#125;<br>&#125;<br><br>tasks.withType&lt;KotlinCompile&gt; &#123;<br>    kotlinOptions &#123;<br>        jvmTarget = <span class="hljs-string">"1.8"</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="ImageView-扩展函数"><a href="#ImageView-扩展函数" class="headerlink" title="ImageView 扩展函数"></a>ImageView 扩展函数</h3><p><code>io.coil-kt:coil</code> 提供了 类型安全的 ImageView 扩展函数</p><p>在 ImageView 中加载图片，只需调用 load 扩展函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// URL</span><br>imageView.load(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br><br><span class="hljs-comment">// Resource</span><br>imageView.load(R.drawable.image)<br><br><span class="hljs-comment">// File</span><br>imageView.load(File(<span class="hljs-string">"/path/to/image.jpg"</span>))<br><br><span class="hljs-comment">// And more...</span><br></code></pre></td></tr></table></figure><p>上面的请求等价于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = Coil.imageLoader(context)<br><span class="hljs-keyword">val</span> request = LoadRequest.Builder(imageView.context)<br>    .<span class="hljs-keyword">data</span>(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br>    .target(imageView)<br>    .build()<br>imageLoader.execute(request)<br></code></pre></td></tr></table></figure><p>可选的请求配置可以通过 lambda 来操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">imageView.load(<span class="hljs-string">"https://www.example.com/image.jpg"</span>) &#123;<br>    crossfade(<span class="hljs-literal">true</span>)<br>    placeholder(R.drawable.image)<br>    transformations(CircleCropTransformation())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Image-Loaders¶"><a href="#Image-Loaders¶" class="headerlink" title="Image Loaders¶"></a>Image Loaders<a href="https://coil-kt.github.io/coil/#image-loaders" target="_blank" rel="noopener">¶</a></h3><p><code>ImageLoader</code> 是执行请求的服务类。 他们处理缓存，数据获取，图像解码，请求管理，bitmap pool，内存管理等。 可以使用 builder 来创建和配置新实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = ImageLoader.Builder(context)<br>    .availableMemoryPercentage(<span class="hljs-number">0.25</span>)<br>    .crossfade(<span class="hljs-literal">true</span>)<br>    .build()<br></code></pre></td></tr></table></figure><p>imageView.load 使用单例 <code>ImageLoader</code> 执行 <code>LoadRequest</code> 。 可以使用以下方式访问单例 <code>ImageLoader</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = Coil.imageLoader(context)<br></code></pre></td></tr></table></figure><p>（可选）您可以创建自己的ImageLoader实例，并通过依赖项注入将它们注入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = ImageLoader(context)<br></code></pre></td></tr></table></figure><p>当您创建单个 <code>ImageLoader</code> 并在整个应用程序中共享时，<code>Coil</code> 的性能最佳。 这是因为每个 <code>ImageLoader</code> 都有自己的内存缓存，bitmap pool 和网络监听</p><h3 id="Requests¶"><a href="#Requests¶" class="headerlink" title="Requests¶"></a>Requests<a href="https://coil-kt.github.io/coil/#requests" target="_blank" rel="noopener">¶</a></h3><p>有两种 Request 类型</p><ul><li><a href="https://coil-kt.github.io/coil/api/coil-base/coil.request/-load-request/" target="_blank" rel="noopener"><code>LoadRequest</code></a> 是一个生命周期范围的 request，支持 <a href="https://coil-kt.github.io/coil/api/coil-base/coil.target/-target/" target="_blank" rel="noopener"><code>Target</code></a>，<a href="https://coil-kt.github.io/coil/api/coil-base/coil.transition/-transition/" target="_blank" rel="noopener"><code>Transition</code></a> 等等</li><li><a href="https://coil-kt.github.io/coil/api/coil-base/coil.request/-get-request/" target="_blank" rel="noopener"><code>GetRequest</code></a> 挂起并返回  <a href="https://coil-kt.github.io/coil/api/coil-base/coil.request/-request-result/" target="_blank" rel="noopener"><code>RequestResult</code></a></li></ul><p>如果要加载到自定义 target 中，可以执行 <code>LoadRequest</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> request = LoadRequest.Builder(context)<br>    .<span class="hljs-keyword">data</span>(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br>    .target &#123; drawable -&gt;<br>        <span class="hljs-comment">// Handle the result.</span><br>    &#125;<br>    .build()<br>imageLoader.execute(request)<br></code></pre></td></tr></table></figure><p>要强制获取图像，请执行GetRequest：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> request = GetRequest.Builder(context)<br>    .<span class="hljs-keyword">data</span>(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br>    .build()<br><span class="hljs-keyword">val</span> drawable = imageLoader.execute(request).drawable<br></code></pre></td></tr></table></figure><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>如果您使用的是 <code>io.coil-kt:coil</code> ，您可以使用以下任意方式设置 <code>ImageLoader</code> 的实例</p><p>在 Application 中实现 <code>ImageLoaderFactory</code>（推荐）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> : <span class="hljs-type">Application</span></span>(), ImageLoaderFactory &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newImageLoader</span><span class="hljs-params">()</span></span>: ImageLoader &#123;<br>        <span class="hljs-keyword">return</span> ImageLoader.Builder(context)<br>            .crossfade(<span class="hljs-literal">true</span>)<br>            .okHttpClient &#123;<br>                OkHttpClient.Builder()<br>                    .cache(CoilUtils.createDefaultCache(context))<br>                    .build()<br>            &#125;<br>            .build()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 Coil.setImageLoader</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = ImageLoader.Builder(context)<br>    .crossfade(<span class="hljs-literal">true</span>)<br>    .okHttpClient &#123;<br>        OkHttpClient.Builder()<br>            .cache(CoilUtils.createDefaultCache(context))<br>            .build()<br>    &#125;<br>    .build()<br>Coil.setImageLoader(imageLoader)<br></code></pre></td></tr></table></figure><p>默认的 <code>ImageLoader</code> 可以通过这样取回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> imageLoader = Coil.imageLoader(context)<br></code></pre></td></tr></table></figure><p>设置默认的 <code>ImageLoader</code> 是可选的。 如果未设置，则 <code>Coil</code> 会延迟创建具有默认值的 <code>ImageLoader</code></p><p>如果您使用的是 <code>io.coil-kt:coil-base</code>，您应创建自己的 <code>ImageLoader</code> 实例并通过依赖注入将它注入到 app 中</p><blockquote><p>注意：如果设置自定义OkHttpClient，则必须设置缓存实现，否则ImageLoader将没有磁盘缓存。 可以使用CoilUtils.createDefaultCache 创建默认的 Coil 缓存实例</p></blockquote><h2 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h2><p>ImageLoader 支持的数据类型为</p><ul><li>String (mapped to a Uri)</li><li>HttpUrl</li><li>Uri (<code>android.resource</code>, <code>content</code>, <code>file</code>, <code>http</code>, and <code>https</code> schemes only)</li><li>File</li><li>@DrawableRes Int</li><li>Drawable</li><li>Bitmap</li></ul><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>如果要预加载到内存中，执行一个不带 target 的 <code>LoadRequest</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> request = LoadRequest.Builder(context)<br>    .<span class="hljs-keyword">data</span>(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br>    <span class="hljs-comment">// 可选的，但是设置 ViewSizeResolver 可以通过限制预加载的大小来节省内存</span><br>    .size(ViewSizeResolver(imageView))<br>    .build()<br>imageLoader.execute(request)<br></code></pre></td></tr></table></figure><p>如果只想将网络图片预加载到磁盘中，可以为 request 关闭内存缓存</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> request = LoadRequest.Builder(context)<br>    .<span class="hljs-keyword">data</span>(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br>    .memoryCachePolicy(CachePolicy.DISABLED)<br>    .build()<br>imageLoader.execute(request)<br></code></pre></td></tr></table></figure><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><p><code>LoadRequest</code> 会自动取消在以下几种情况下</p><ul><li><p>关联的 view detached，</p></li><li><p>关联的 lifecycle destroyed</p></li><li><p>另一个 request  在相同的 view 中开启</p></li></ul><p>此外，每个 <code>LoadRequest</code> 返回一个 <code>RequestDisposable</code>，可用于检查请求是否在运行中或处理该请求（有效地取消请求并释放其关联资源）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> disposable = imageView.load(<span class="hljs-string">"https://www.example.com/image.jpg"</span>)<br><br><span class="hljs-comment">// Cancel the request.</span><br>disposable.dispose()<br></code></pre></td></tr></table></figure><p><code>GetRequest</code> 仅当协程的上下文被取消时才会取消</p><h2 id="图片采样"><a href="#图片采样" class="headerlink" title="图片采样"></a>图片采样</h2><p>假设磁盘上有一个 500x500 的映像，但是只需要以 100x100 的大小将其加载到内存中即可在视图中显示。 <code>Coil</code> 会将图像加载到内存中，但是如果您需要 500x500 的图像会怎样呢？ 从磁盘读取还有更好的「质量」，但是图像已经以 100x100 加载到内存中。 理想情况下，当我们从磁盘以 500x500 读取图像时，我们将使用 100x100 图像作为占位符。</p><p>这正是 <code>Coil</code> 所做的，并且 <code>Coil</code> 自动为所有 <code>BitmapDrawables</code> 处理此过程。 与 <code>crossfade(true)</code> 搭配使用时，可以创建视觉效果，使图像细节看起来像淡入淡出，类似于渐进式 JPEG</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/5/15/1721615615eb45ef?w=600&h=1067&f=gif&s=4714987" src="/2020/05/18/Tips-Coil/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h2 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h2><ul><li>AndroidX</li><li>Min SDK 14+</li><li>Compile SDK: 29+</li><li><a href="https://coil-kt.github.io/coil/getting_started/#java-8" target="_blank" rel="noopener">Java 8+</a></li></ul><p>详细内容移步 <a href="https://coil-kt.github.io/coil/" target="_blank" rel="noopener">官方文档</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/05/18/Tips-Coil/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新的图片加载库？基于 Kotlin 协程的图片加载库——Coil&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015103748.png" type="image" />
    
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
      <category term="Tips" scheme="https://flywith24.gitee.io/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>1.3.0-alpha04 来袭，Fragment 间通信的新姿势</title>
    <link href="https://flywith24.gitee.io/2020/04/30/Jetpack-fragment-ResultAPI/"/>
    <id>https://flywith24.gitee.io/2020/04/30/Jetpack-fragment-ResultAPI/</id>
    <published>2020-04-29T16:10:35.000Z</published>
    <updated>2020-10-15T02:26:02.014Z</updated>
    
    <content type="html"><![CDATA[<p>Fragment 间通信的新姿势 —— Result API</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>fragment 1.3.0-alpha04</code> 发布了，其中有很多变动，其中提供了 fragment 间传递数据的新方式</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430090529.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="1.3.0-alpha04 更新"></p><!-- more--><h3 id="API-更改"><a href="#API-更改" class="headerlink" title="API 更改"></a>API 更改</h3><p>首先我们介绍一下 API 更改</p><ul><li><code>startActivityForResult()</code>/<code>onActivityResult()</code> 和 <code>requestPermissions()</code>/<code>onRequestPermissionsResult()</code> 弃用</li><li><code>prepareCall()</code> 重命名为 <code>registerForActivityResult()</code> </li><li><code>target fragment API</code> 被弃用</li></ul><h3 id="Activity-Result-API-上位"><a href="#Activity-Result-API-上位" class="headerlink" title="Activity Result API 上位"></a>Activity Result API 上位</h3><p>由于官方提供了 <strong>Activity Result API</strong> 来替换 <strong>onActivityResult</strong>  机制，因此 fragment 的  <code>startActivityForResult()</code>/<code>onActivityResult()</code> 和 <code>requestPermissions()</code>/<code>onRequestPermissionsResult()</code> 方法被标记弃用了</p><p><strong>Activity Result API</strong> 详情可参考 <a href="https://juejin.im/user/586eff908d6d81005879507d" target="_blank" rel="noopener">秉心说</a> 的 <a href="https://juejin.im/post/5e80cb1ee51d45471654fae7" target="_blank" rel="noopener">是时候丢掉 onActivityResult 了 ！</a></p><p>文章介绍的很详尽，这里不再赘述</p><h3 id="prepareCall-重命名"><a href="#prepareCall-重命名" class="headerlink" title="prepareCall 重命名"></a>prepareCall 重命名</h3><p>值得注意的地方是 <code>prepareCall()</code> 被命名为 <code>registerForActivityResult()</code> </p><blockquote><p>注意：在版本处于 Alpha 版状态时，可以添加、移除或更改 API。因此 Alpha 版本不适合在生产上使用</p></blockquote><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430091418.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="来自我的另一篇博客"></p><h3 id="target-fragment-API-被弃用"><a href="#target-fragment-API-被弃用" class="headerlink" title="target fragment API 被弃用"></a>target fragment API 被弃用</h3><p>其实 <code>target fragment API</code> 早已被弃用</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430092548.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="setTargetFragment 被弃用"></p><p><code>target fragment</code> 需要直接访问另一个 fragment 的实例，这是十分危险的，因为你不知道目标 fragment 处于什么状态。而且 <code>target fragment</code> 不支持 Navigation</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430092824.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="弃用 target fragment API"></p><p>那么，fragment 之间传递数据更干净的方式是什么呢？</p><h3 id="fragment-之间传递数据的新方式"><a href="#fragment-之间传递数据的新方式" class="headerlink" title="fragment 之间传递数据的新方式"></a>fragment 之间传递数据的新方式</h3><p>前文提到，在相同的 FragmentManager 中可以使用 target fragment API 来在 fragment 间传递数据，但这种方式需要直接访问目标fragment 的实例，这很危险，因为目标 fragment 的状态是未知的</p><p>因此官方提供了这样的 API，它允许在一个 fragment 上设置结果，并将该结果在 fragment 的适当的生命周期中使用。</p><p>这种传递数据的方式适用于 DialogFragment ，Navigation 中的 fragment</p><p>此更改还包括 -ktx 扩展功能以确保 kotlin 用户可以将 FragmentResultListener 作为 lambda 传递</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430105343.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="FragmentA 源码"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430105411.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="FragmentB 源码"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430105045.gif" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="demo"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>老规矩，我们沿着官方的 commit log 来看看官方实现该功能的思路</p><p>首先，添加了 FragmentResultOwner 这样的的抽象，用于处理 fragment result，其内部有两个方法</p><ul><li>setResult</li><li>setResultListener</li></ul><p>前者用于发送数据，后者用于接收数据</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430110206.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="FragmentResultOwner"></p><p>而其实现类为 FragmentManager</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430110412.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="FragmentManager implement FragmentResultOwner "></p><p>我们来看看 FragmentManager 两个方法的具体实现</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200430111003.png" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFragmentResultListener</span><span class="hljs-params">(@NonNull <span class="hljs-keyword">final</span> String requestKey,<br>        @NonNull <span class="hljs-keyword">final</span> LifecycleOwner lifecycleOwner,<br>        @Nullable <span class="hljs-keyword">final</span> FragmentResultListener listener)</span> </span>&#123;<br>    <span class="hljs-comment">// 设置的 listener 为空时将 requestKey 对应的 listener 移除</span><br>    <span class="hljs-keyword">if</span> (listener == <span class="hljs-keyword">null</span>) &#123;<br>        mResultListeners.remove(requestKey);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 当fragment 处于DESTROYED 状态时 直接 return ，避免了异常</span><br>    <span class="hljs-keyword">final</span> Lifecycle lifecycle = lifecycleOwner.getLifecycle();<br>    <span class="hljs-keyword">if</span> (lifecycle.getCurrentState() == Lifecycle.State.DESTROYED) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 观察生命周期，fragment started 后接收回调，destroyed 移除回调</span><br>    LifecycleEventObserver observer = <span class="hljs-keyword">new</span> LifecycleEventObserver() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(@NonNull LifecycleOwner source,<br>                @NonNull Lifecycle.Event event)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (event == Lifecycle.Event.ON_START) &#123;<br>                <span class="hljs-comment">// once we are started, check for any stored results</span><br>                Bundle storedResult = mResults.get(requestKey);<br>                <span class="hljs-keyword">if</span> (storedResult != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// if there is a result, fire the callback</span><br>                    listener.onFragmentResult(requestKey, storedResult);<br>                    <span class="hljs-comment">// and clear the result</span><br>                    setFragmentResult(requestKey, <span class="hljs-keyword">null</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;<br>                lifecycle.removeObserver(<span class="hljs-keyword">this</span>);<br>                mResultListeners.remove(requestKey);<br>            &#125;<br>        &#125;<br>    &#125;;<br>    lifecycle.addObserver(observer);<br>    mResultListeners.put(requestKey, <span class="hljs-keyword">new</span> LifecycleAwareResultListener(lifecycle, listener));<br>&#125;<br></code></pre></td></tr></table></figure><p>以上便是这部分的源码</p><blockquote><p>这里要注意一点的是 <code>fragment result api</code> 是基于同一 <code>FragmentManager</code> 的</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>官方一直致力于将 fragment 的 api 变得更好用</p><p><a href="https://medium.com/@ianhlake" target="_blank" rel="noopener">Ian Lake</a> 在 <a href="https://www.youtube.com/watch?v=RS1IACnZLy4" target="_blank" rel="noopener">Fragments: Past, Present, and Future (Android Dev Summit ‘19)</a> 中提到了 fragment 间通信的问题，未来 fragment 会整合 fragment 自身和其内部 view 的生命周期，提供同一 FragmentManager 多返回栈的支持</p><p>看到 <code>fragment result API</code> ，我突然有个想法，如果将其应用到 Navigation 中是否是解决 Navigation 跳转返回后状态重置的一个方法呢？</p><p>各位小伙伴有什么想法欢迎评论区留言</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg" src="/2020/04/30/Jetpack-fragment-ResultAPI/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fragment 间通信的新姿势 —— Result API&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015102553.png" type="image" />
    
    
      <category term="Jetpack 更新" scheme="https://flywith24.gitee.io/categories/Jetpack-%E6%9B%B4%E6%96%B0/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
      <category term="Fragment" scheme="https://flywith24.gitee.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>setRetainInstance 被弃用，那么 fragment 是如何保存状态的？</title>
    <link href="https://flywith24.gitee.io/2020/04/30/Jetpack-fragment-savestate/"/>
    <id>https://flywith24.gitee.io/2020/04/30/Jetpack-fragment-savestate/</id>
    <published>2020-04-29T16:10:35.000Z</published>
    <updated>2020-10-15T02:33:22.616Z</updated>
    
    <content type="html"><![CDATA[<p>setRetainInstance 被弃用，那么 fragment 是如何保存状态的？</p><a id="more"></a><p>我们都知道 fragment 中的 <code>setRetainInstance</code> 用于控制是否在 activity 保留 fragment 实例，具体内容可参见 <a href="https://www.wanandroid.com/wenda/show/12574" target="_blank" rel="noopener">WanAndroid 的每日一问：Fragment 是如何被存储与恢复的？</a></p><p>但是该方法已于 <code>androidx fragment 1.3.0-alpha01</code> 弃用了</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200422093129.png" src="/2020/04/30/Jetpack-fragment-savestate/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>老规矩，我们查看一下 commit log</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200422094533.png" src="/2020/04/30/Jetpack-fragment-savestate/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>简单概况一下</p><p><code>SetRetainInstance</code> 尝试在 activity 重建时保存状态。但它带来了很多副作用。</p><p>随着 <code>ViewModel</code> 的引入，开发者拥有一个特定的 API，用于保留与 Activity，Fragments 和 Navigation 相关联的状态。 这使开发者可以使用正常的，不需要保留 fragment ，从而在保存单个需要的属性时避免了常见的泄漏源，并且可以销毁保存的状态（即 <code>ViewModel</code> 的构造器和 <code>onCleared</code> 回调）</p><p>详情可参见 <a href="https://juejin.im/post/5e738d12518825495d69cfb9" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a> 和 <a href="https://juejin.im/post/5e786d415188255e00661a4e" target="_blank" rel="noopener">【背上Jetpack之ViewModel】即使您不使用MVVM也要了解ViewModel ——ViewModel 的职能边界</a></p><p>从这个改动可以看出官方正致力于保证逻辑的单一性，状态保存交给 <code>ViewModel</code> ，减少这种特殊的例外情况，从而消除一些不符合预期的问题</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg" src="/2020/04/30/Jetpack-fragment-savestate/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;setRetainInstance 被弃用，那么 fragment 是如何保存状态的？&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015102738.png" type="image" />
    
    
      <category term="Jetpack 更新" scheme="https://flywith24.gitee.io/categories/Jetpack-%E6%9B%B4%E6%96%B0/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
      <category term="Fragment" scheme="https://flywith24.gitee.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>setMaxLifecycle 上位，setUserVisibleHint 被弃用</title>
    <link href="https://flywith24.gitee.io/2020/04/29/Jetpack-fragment-setMaxLifecycle/"/>
    <id>https://flywith24.gitee.io/2020/04/29/Jetpack-fragment-setMaxLifecycle/</id>
    <published>2020-04-28T16:10:35.000Z</published>
    <updated>2020-10-15T02:29:42.052Z</updated>
    
    <content type="html"><![CDATA[<p>setUserVisibleHint 被弃用</p><a id="more"></a><p>很多情况下，fragment 的生命周期上限应该低于 FragmentManager/Activity。例如，<code>ViewPager</code> 屏幕外的界面不应被 <code>resumed</code></p><p>理想状态下，可以通过以下 API 实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">supportFragmentManager<br>  .beginTransaction()<br>      .setMaxLifecycle(fragment, Lifecycle.State.RESUMED)<br>      .commit()<br></code></pre></td></tr></table></figure><p>将最大生命周期设置为 <code>Lifecycle.State.RESUMED</code> 将有效地消除限制（因为这是最高生命周期状态）</p><p>这将允许废弃 <code>setUserVisibleHint()</code> API</p><!-- more--><h2 id="setMaxLifecycle-出现始末"><a href="#setMaxLifecycle-出现始末" class="headerlink" title="setMaxLifecycle 出现始末"></a>setMaxLifecycle 出现始末</h2><p>该功能应如何实现的？我们沿着 <code>commit log</code> 来理一下官方的思路</p><p>将 <code>BackStackRecord</code> 的部分逻辑转移至父类 <code>FragmentTransaction</code> 中</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423094356.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423101522.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>在 <code>FragmentTransaction</code> 中添加 <code>setMaxLifecycle</code> API</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423101908.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423102052.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>保存 fragment <code>maxState</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423103245.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423103057.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>弃用 <code>setUserVisibleHint</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423103528.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><code>FragmentPagerAdapter</code> 构造器新增参数，使用 <code>setMaxLifecycle()</code> API 确保 fragment <code>resumed</code> 时对用户可见</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423104355.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423104634.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>弃用 <code>FragmentStatePagerAdapter</code> 原来的单参构造器，推荐使用新的构造</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423105038.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423105144.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><strong>随着 <code>ViewPager2 1.0.0</code> 正式版发布，与 <code>ViewPager</code> 交互的<code>FragmentPagerAdapter</code> 和 <code>FragmentStatePagerAdapter</code> 被弃用了</strong></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423111201.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>至此我们捋顺了 <code>setMaxLifecycle</code> 的出现，<code>setUserVisibleHint</code> 的弃用以及与<code>ViewPager</code> 相关的 <code>FragmentPagerAdapter</code> 和 <code>FragmentStatePagerAdapter</code> 的弃用</p><h2 id="setMaxLifecycle-内部逻辑"><a href="#setMaxLifecycle-内部逻辑" class="headerlink" title="setMaxLifecycle 内部逻辑"></a>setMaxLifecycle 内部逻辑</h2><p>接下来我们看看 <code>setMaxLifecycle</code>  是如何发挥作用的</p><p>首先我们要研究一下 fragment 的状态管理，为了更好的管理 fragment 的状态，官方添加了 <code>FragmentStateManager</code> 类来专门管理 fragment 的状态，职能单一原则哈</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423113312.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423113509.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>接着在该类中添加了计算 fragment 最大生命周期的方法 <code>computeMaxState()</code> </p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423114557.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423114615.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>后来该方法改名为 <code>computeExpectedState()</code> 并加入了 <code>moveToExpectedState()</code> 方法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423115055.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><code>computeExpectedState()</code>  方法会根据 fragment <code>mMaxState</code> 计算 fragment 应该所处的生命周期</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423115521.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>而 fragment 的 <code>mMaxState</code> 是通过 <code>FragmentManager</code> 的 <code>setMaxLifecycle()</code> 方法设置的 ，而该方法是 <code>BackStackRecord</code> 执行 OP 时调用的，而 OP 值正是通过 <code>FragmentTransaction</code> 的 <code>setMaxLifecycle()</code> 设置的</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423115744.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200423115928.png" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>至此，我们理清了 <code>setMaxLifecycle()</code> 的内部逻辑</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以看到官方为了使 fragment 能够在正确的生命周期上，引入了 <code>setMaxLifecycle()</code> 方法，同时为了更好的管理 fragment 的状态，抽象出了 <code>FragmentStateManager</code> 。<em>更少的代码，更少的职责</em>，fragment 的内部逻辑会越来越清晰</p><ul><li><p>关于如何迁移至 ViewPager2 ，请移步 <a href="https://www.bilibili.com/video/BV1uJ411C7S4?from=search&seid=7755962876168902731" target="_blank" rel="noopener">官方视频</a></p></li><li><p>关于新的 API 下懒加载实现，请移步 <a href="https://juejin.im/post/5e232d01e51d455801624c06" target="_blank" rel="noopener">Androidx 下 Fragment 懒加载的新实现</a></p></li></ul><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg" src="/2020/04/29/Jetpack-fragment-setMaxLifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;setUserVisibleHint 被弃用&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015102938.png" type="image" />
    
    
      <category term="Jetpack 更新" scheme="https://flywith24.gitee.io/categories/Jetpack-%E6%9B%B4%E6%96%B0/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
      <category term="Fragment" scheme="https://flywith24.gitee.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</title>
    <link href="https://flywith24.gitee.io/2020/04/15/Tips-includeBuild/"/>
    <id>https://flywith24.gitee.io/2020/04/15/Tips-includeBuild/</id>
    <published>2020-04-15T06:11:46.000Z</published>
    <updated>2020-10-15T02:42:15.114Z</updated>
    
    <content type="html"><![CDATA[<p>除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</p><a id="more"></a><h2 id="buildSrc-的缺陷"><a href="#buildSrc-的缺陷" class="headerlink" title="buildSrc 的缺陷"></a>buildSrc 的缺陷</h2><p>Android 开发中统一不同 module 的依赖版本十分重要，传统的方式是使用 ext 的方式</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200527111409.png" src="/2020/04/15/Tips-includeBuild/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ext"></p><p>之前我发过关于使用 buildSrc 简化项目中 gradle 代码的译文：<a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></p><p>该种方式可以很好的管理 gradle 的公共配置，这其中当然包括依赖版本</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200527111722.gif" src="/2020/04/15/Tips-includeBuild/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="配置依赖"></p><p>如图，在使用依赖时有代码提示，而且可以点击进入查看</p><p>但是由于 buildSrc 是对全局的所有 module 的配置，因此在构建速度上会慢一些。那么有没有一个更纯净的方式来配置依赖版本呢？</p><p>今天我们来介绍一种新的方式</p><!-- more--><h2 id="自定义-plugin-includeBuild"><a href="#自定义-plugin-includeBuild" class="headerlink" title="自定义 plugin + includeBuild"></a>自定义 plugin + includeBuild</h2><p>使用 <a href="https://docs.gradle.org/current/userguide/composite_builds.html" target="_blank" rel="noopener">Gradle Composite builds</a> 可以很容易解决这一问题</p><p>我们新建一个 module，命名为 version ，并将原来的 buildSrc 的代码转移过来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependencyVersionPlugin</span> : <span class="hljs-type">Plugin</span>&lt;<span class="hljs-type">Project</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">apply</span><span class="hljs-params">(project: <span class="hljs-type">Project</span>)</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 version 的 build.gradle 文件加入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">gradlePlugin &#123;<br>    plugins &#123;<br>        version &#123;<br>            id = <span class="hljs-string">'com.flywith24.version'</span><br>            implementationClass = <span class="hljs-string">'com.flywith24.version.DependencyVersionPlugin'</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 settings.gradle 加入 <code>includeBuild(&quot;version&quot;)</code> （<strong>重点</strong>）</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">includeBuild(<span class="hljs-string">"version"</span>)<br><br>rootProject.name=<span class="hljs-string">'VersionControlDemo'</span><br>include <span class="hljs-string">':app'</span><br>include <span class="hljs-string">':lib'</span><br></code></pre></td></tr></table></figure><p>接下来在需要引用的 module 中引入该插件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">"com.flywith24.version"</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后我们就可以使用了</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200527113952.png" src="/2020/04/15/Tips-includeBuild/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="demo代码截图"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200527114023.png" src="/2020/04/15/Tips-includeBuild/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="demo代码截图"></p><p><a href="https://github.com/Flywith24/VersionControlDemo" target="_blank" rel="noopener">demo 在这</a></p><h2 id="往期文章"><a href="#往期文章" class="headerlink" title="往期文章"></a>往期文章</h2><p>该系列主要介绍一些「骚操作」，它未必适合生产环境使用，但是是一些比较新颖的思路</p><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案</a></li></ul><ul><li><a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></li></ul><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你</a></li></ul><ul><li><a href="https://juejin.im/post/5e967f35f265da47d77cd4c3" target="_blank" rel="noopener">【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转</a></li></ul><ul><li><a href="https://juejin.im/post/5ebdfb0b6fb9a0436153db22" target="_blank" rel="noopener">【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil</a></li></ul><ul><li><a href="https://juejin.im/post/5ec50ae46fb9a047a862124f" target="_blank" rel="noopener">【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化</a></li></ul><p>我的其他系列文章 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/04/15/Tips-includeBuild/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015104211.png" type="image" />
    
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
      <category term="Tips" scheme="https://flywith24.gitee.io/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>巧用 kotlin 扩展函数和 typealias 封装 LiveData</title>
    <link href="https://flywith24.gitee.io/2020/04/15/Tips-StateLiveData/"/>
    <id>https://flywith24.gitee.io/2020/04/15/Tips-StateLiveData/</id>
    <published>2020-04-15T06:11:46.000Z</published>
    <updated>2020-10-15T02:52:05.706Z</updated>
    
    <content type="html"><![CDATA[<p>巧用 kotlin 扩展函数和 typealias 封装 LiveData</p><a id="more"></a><h2 id="关于-LiveData-两个常用的姿势"><a href="#关于-LiveData-两个常用的姿势" class="headerlink" title="关于 LiveData 两个常用的姿势"></a>关于 LiveData 两个常用的姿势</h2><h3 id="使用包装类传递事件"><a href="#使用包装类传递事件" class="headerlink" title="使用包装类传递事件"></a>使用包装类传递事件</h3><p>我们在使用 LiveData 时可能会遇到「粘性」事件的问题，该问题可以使用包装类的方式解决。解决方案见 <a href="https://juejin.im/post/5b2b1b2cf265da5952314b63#heading-7" target="_blank" rel="noopener">[译] 在 SnackBar，Navigation 和其他事件中使用 LiveData（SingleLiveEvent 案例）</a></p><p>使用时是这样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListViewModel</span> : <span class="hljs-type">ViewModel &#123;</span></span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;()<br><br>    <span class="hljs-keyword">val</span> navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt;<br>        <span class="hljs-keyword">get</span>() = _navigateToDetails<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">userClicksOnButton</span><span class="hljs-params">(itemId: <span class="hljs-type">String</span>)</span></span> &#123;<br>        _navigateToDetails.value = Event(itemId)  <span class="hljs-comment">// Trigger the event by setting a new Event as a new value</span><br>    &#125;<br>&#125;<br><br>myViewModel.navigateToDetails.observe(<span class="hljs-keyword">this</span>, Observer &#123;<br>    it.getContentIfNotHandled()?.let &#123; <span class="hljs-comment">// Only proceed if the event has never been handled</span><br>        startActivity(DetailsActivity...)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>不过这样写甚是繁琐，我们可以使用更优雅的方式解决该问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//为 LiveData&lt;Event&lt;T&gt;&gt;提供类型别名，使用 EventLiveData&lt;T&gt; 即可</span><br><span class="hljs-keyword">typealias</span> EventMutableLiveData&lt;T&gt; = MutableLiveData&lt;Event&lt;T&gt;&gt;<br><br><span class="hljs-keyword">typealias</span> EventLiveData&lt;T&gt; = LiveData&lt;Event&lt;T&gt;&gt;<br></code></pre></td></tr></table></figure><p>使用 <code>typealias</code> 关键字，我们可以提供一个类型别名，可以这样使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//等价于 MutableLiveData&lt;Event&lt;Boolean&gt;&gt;(Event(false))</span><br><span class="hljs-keyword">val</span> eventContent = EventMutableLiveData&lt;<span class="hljs-built_in">Boolean</span>&gt;(Event(<span class="hljs-literal">false</span>))<br></code></pre></td></tr></table></figure><p>现在声明时不用多加一层泛型了，那么使用时还是很繁琐</p><p>我们可以借助 kotlin 的 扩展函数更优雅的使用</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605115649.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="event 扩展函数"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605121030.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="使用"></p><p>demo 中封装了两种形式的 LiveData，一种为 <code>LiveData&lt;Boolean&gt;</code>，一种为 <code>EventLiveData&lt;Boolean&gt;</code>，当屏幕旋转时，前者会再次回调结果，而后者由于事件已被处理而不执行 onChanged，我们通过 Toast 可观察到这一现象</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605121634.gif" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><a href="https://github.com/KunMinX/Jetpack-MVVM-Best-Practice" target="_blank" rel="noopener">java 版的可参考</a></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605122206.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h3 id="封装带网络状态的数据"><a href="#封装带网络状态的数据" class="headerlink" title="封装带网络状态的数据"></a>封装带网络状态的数据</h3><p>很多时候我们在获取网络数据时要封装一层网络状态，例如：加载中，成功，失败</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605115950.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>在使用时我们遇到了和上面一样的问题，多层泛型用起来很麻烦</p><p>我们依然可以使用 typealias + 扩展函数来优雅的处理该问题</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605120336.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="typealias"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605120400.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="扩展函数"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605120455.png" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="使用"></p><p>demo 截图</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200605120721.gif" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="demo"></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>demo <a href="https://github.com/Flywith24/WrapperLiveDataDemo" target="_blank" rel="noopener">在这</a>，如果感觉这个思路对你有帮助的话，点一颗小星星吧～ 😉</p><p>另外我还将它传到了 JitPack 上，引入姿势如下：</p><p><a href="https://jitpack.io/#Flywith24/WrapperLiveData" target="_blank" rel="noopener"><img class="lazyload" data-original="https://jitpack.io/v/Flywith24/WrapperLiveData.svg" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></a></p><ol><li><p>在项目根目录的 <code>build.gradle</code> 加入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">allprojects &#123;<br>  repositories &#123;<br>    <span class="hljs-comment">//...</span><br>    maven &#123; url <span class="hljs-string">'https://jitpack.io'</span> &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>添加依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  implementation <span class="hljs-string">'com.github.Flywith24:WrapperLiveData:$version'</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="往期文章"><a href="#往期文章" class="headerlink" title="往期文章"></a>往期文章</h2><p>该系列主要介绍一些「骚操作」，它未必适合生产环境使用，但是是一些比较新颖的思路</p><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】AndroidStudio Nexus3.x搭建Maven私服遇到问题及解决方案</a></li></ul><ul><li><a href="https://juejin.im/post/5e22c2ce6fb9a02ff67d41c3" target="_blank" rel="noopener">【奇技淫巧】什么？项目里gradle代码超过200行了！你可能需要 Kotlin+buildSrc Plugin</a></li></ul><ul><li><a href="https://juejin.im/post/5e481a28f265da570b3f235c" target="_blank" rel="noopener">【奇技淫巧】gradle依赖查找太麻烦？这个插件可能帮到你</a></li></ul><ul><li><a href="https://juejin.im/post/5e967f35f265da47d77cd4c3" target="_blank" rel="noopener">【奇技淫巧】Android组件化不使用 Router 如何实现组件间 activity 跳转</a></li></ul><ul><li><a href="https://juejin.im/post/5ebdfb0b6fb9a0436153db22" target="_blank" rel="noopener">【奇技淫巧】新的图片加载库？基于Kotlin协程的图片加载库——Coil</a></li></ul><ul><li><p><a href="https://juejin.im/post/5ec50ae46fb9a047a862124f" target="_blank" rel="noopener">【奇技淫巧】使用 Navigation + Dynamic Feature Module 实现模块化</a></p></li><li><p><a href="https://juejin.im/post/5ecde219e51d457841190d08" target="_blank" rel="noopener">【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</a></p></li></ul><p>我的其他系列文章 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/04/15/Tips-StateLiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;巧用 kotlin 扩展函数和 typealias 封装 LiveData&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015105155.png" type="image" />
    
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
      <category term="Tips" scheme="https://flywith24.gitee.io/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android 组件化不使用 Router 如何实现组件间 activity 跳转</title>
    <link href="https://flywith24.gitee.io/2020/04/15/Tips-Components-Jump/"/>
    <id>https://flywith24.gitee.io/2020/04/15/Tips-Components-Jump/</id>
    <published>2020-04-15T06:11:46.000Z</published>
    <updated>2020-10-15T02:40:06.941Z</updated>
    
    <content type="html"><![CDATA[<p>Android组件化不使用 Router 如何实现组件间 activity 跳转</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>越来越多的项目使用了组件化，组件之间的通信是一个比较重要的问题。<code>ARouter</code> 等路由方案为我们提供了解决办法。那么如果不使用 Router 如何实现组件间的界面跳转呢？</p><h2 id="万能的-setClassName"><a href="#万能的-setClassName" class="headerlink" title="万能的 setClassName"></a>万能的 <code>setClassName</code></h2><p>从一个 Activity 跳转到另一个Activity 的最直接方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, TestActivity::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span><br>startActivity(intent)<br></code></pre></td></tr></table></figure><p>但是，采用这种方法，当原 activity 位于一个 module（例如 <code>FeatureA</code> ）中，而目标 activity 位于另一个 module（<code>FeatureB</code>）中时，该怎么办？</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200415110401.png" src="/2020/04/15/Tips-Components-Jump/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我们可以使用 Intent 的 <code>setClassName</code> 方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent()<br>intent.setClassName(<span class="hljs-keyword">this</span>, “com.flywith24.demo.TestActivity”)<br>startActivity(intent)<br></code></pre></td></tr></table></figure><p>但是这种方式硬编码目标 activity 的完整类名，如果 activity 的类名被更改或者移动，而且没有更改硬编码，则编译可以通过，但是运行时崩溃</p><p>如果可以自动生成 activity 完整类名就好了</p><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>我们知道 activity 作为 Android 的组件之一需要在 Manifest 文件中声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">”com.flywith24.demo.MainActivity”</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">”com.flywith24.demo.TestActivity”</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>如果我们的数据是从 Manifest 中获得的，那么就解决了硬编码的问题了</p><p>有这样一个<a href="https://github.com/gaelmarhic/Quadrant" target="_blank" rel="noopener">插件</a> ，在 build 时会将所有在 Manifest 中声明的 activity 的完整类名以静态常量的形式罗列到一个静态类中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> QuadrantConstants &#123;<br>  <br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MAIN_ACTIVITY: String = <span class="hljs-string">"com.gaelmarhic.quadrant.MainActivity"</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> SECONDARY_ACTIVITY: String = <span class="hljs-string">"com.gaelmarhic.quadrant.SecondaryActivity"</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> TERTIARY_ACTIVITY: String = <span class="hljs-string">"com.gaelmarhic.quadrant.TertiaryActivity"</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样在使用时就避免了硬编码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent()<br>intent.setClassName(context, QuadrantConstants.MAIN_ACTIVITY)<br>startActivity(intent)<br></code></pre></td></tr></table></figure><h2 id="使用依赖注入"><a href="#使用依赖注入" class="headerlink" title="使用依赖注入"></a>使用依赖注入</h2><p>组件化中 <code>app</code> module 会依赖所有的功能 module ，因此如果我们使用依赖注入在 <code>app</code> 中将所有的目标 activity 的完整类名声明出来，也能达到解决硬编码的问题</p><p>这里以 <a href="https://insert-koin.io/" target="_blank" rel="noopener">koin</a> 为例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> : <span class="hljs-type">Application</span></span>() &#123;<br>    <span class="hljs-keyword">val</span> myModule = module &#123;<br>        single &#123; Feature2Activity::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>.<span class="hljs-title">name</span> &#125;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate()<br>        startKoin &#123;<br>            androidContext(<span class="hljs-keyword">this</span><span class="hljs-symbol">@MyApplication</span>)<br>            modules(myModule)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样通过 get() 方法即可拿到 <code>Feature2Activity</code> 的完整类名</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent()<br>    .setClassName(<span class="hljs-keyword">this</span><span class="hljs-symbol">@Feature1Activity</span>, <span class="hljs-keyword">get</span>())<br>    .putExtra(<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>)<br>startActivity(intent)<br></code></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/Flywith24/MultitableModuleApp" target="_blank" rel="noopener">Demo 地址</a></p><p>各位有什么想法欢迎在评论区留言</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/6/26/172ee567fb4fbf7e?w=1954&h=624&f=jpeg&s=115362" src="/2020/04/15/Tips-Components-Jump/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android组件化不使用 Router 如何实现组件间 activity 跳转&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015103958.png" type="image" />
    
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
      <category term="Tips" scheme="https://flywith24.gitee.io/tags/Tips/"/>
    
      <category term="奇技淫巧" scheme="https://flywith24.gitee.io/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>终于动手了，onActivityCreated 被弃用</title>
    <link href="https://flywith24.gitee.io/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/"/>
    <id>https://flywith24.gitee.io/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/</id>
    <published>2020-04-08T16:10:35.000Z</published>
    <updated>2020-10-15T02:23:19.324Z</updated>
    
    <content type="html"><![CDATA[<p>fragment 中的 <code>onActivityCreated()</code> 被弃用了</p><a id="more"></a><blockquote><p>本系列文章介绍 Jetpack 组件库的更新<br><br>一直以来， fragment 的 api 都非常难用，官方也承认这一点。一个月前，fragment 中的 <code>onActivityCreated()</code> 被弃用了</p></blockquote><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p><code>fragment 1.3.0-alpha02</code> 中 <code>onActivityCreated()</code> 方法被弃用了</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200421095145.png" src="/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>让我们来看一下提交 log </p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200421092105.png" src="/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>简单翻译一下</p><p><code>onActivityCreated()</code> 最初的目的是让 fragment 的逻辑与其宿主 activity 创建建立关联，我们不鼓励这种耦合</p><p>我们应该传递外部依赖来作为 <code>FragmentFactory</code> 参数。view 相关的代码应该放置在 <code>onViewCreated()</code> 完成，其他的初始化代码应该在 <code>onCreate()</code> 中完成。为了在 <code>activity onCreate()</code> 完成后接收回调，可以添加一个 activity 生命周期的 <code>LifecycleObserver</code> ，并且接收到 <code>Lifecycle.State#CREATED</code> 回调时将其移除</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttach</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onAttach(context)<br>    requireActivity().lifecycle.addObserver(<span class="hljs-keyword">object</span> : DefaultLifecycleObserver &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(owner: <span class="hljs-type">LifecycleOwner</span>)</span></span> &#123;<br>            <span class="hljs-comment">// 想做啥做点啥</span><br>            owner.lifecycle.removeObserver(<span class="hljs-keyword">this</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DialogFragment"><a href="#DialogFragment" class="headerlink" title="DialogFragment"></a>DialogFragment</h2><p>那么 <code>DialogFragment</code> 怎么办？其 <code>onActivityCreated</code> 变为可选的</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200421101629.png" src="/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>简单翻译一下</p><p><code>DialogFragment</code> 使用 <code>onActivityCreated</code>() 帮助创建 dialog。onActivityCreated() 弃用后我们应当寻找一个更好的方式来执行这部分逻辑</p><p>关于 view 相关的代码已经转移至 <code>DialogFragment</code></p><p> 的 <code>viewLifecycleOwnerLiveData</code> ，其他初始化逻辑可以放在 <code>onGetLayoutInflater</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200421103420.png" src="/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我们仍支持为自定义 dialog 在 <code>onActivityCreated()</code> 中配置 dialog</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>查看 <code>Jetpack fragment</code> 的变动，不难看出官方正致力于为 fragment 「减负」，将小的，独立的功能从 fragment 中抽离出去，降低耦合，后续文章我们介绍其他的改动</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><center><p> 欢迎关注我的公众号</p></center><div align="center"><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200429102625.jpg" src="/2020/04/09/Jetpack-fragment-onActivityCreated-Deprecated/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;fragment 中的 &lt;code&gt;onActivityCreated()&lt;/code&gt; 被弃用了&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015102314.png" type="image" />
    
    
      <category term="Jetpack 更新" scheme="https://flywith24.gitee.io/categories/Jetpack-%E6%9B%B4%E6%96%B0/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
      <category term="Fragment" scheme="https://flywith24.gitee.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>数据驱动魔法师 何时迎来翻身日？</title>
    <link href="https://flywith24.gitee.io/2020/04/09/Jetpack-DataBinding/"/>
    <id>https://flywith24.gitee.io/2020/04/09/Jetpack-DataBinding/</id>
    <published>2020-04-08T16:10:35.000Z</published>
    <updated>2020-10-15T02:33:44.558Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack DataBinding 介绍。</p><a id="more"></a><blockquote><p><a href="https://juejin.im/post/5e834bb5f265da480d61668d" target="_blank" rel="noopener">LiveData 篇</a> 我们提到 Android 开发的主要工作内容是将数据转换为 UI ，同时我们也介绍了数据驱动 UI 的思想，使用 ViewModel + LiveData，可以安全地在订阅者的生命周期内分发正确的数据。但是 activity 和 fragment 充斥着大量的模板代码，铺天盖地的 findViewById，以及各种 set （根据数据设置 UI）。如果能够消灭掉这些模板代码就好了</p></blockquote><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402101708.gif" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="他来了他来了"></p><p>他来了他来了，他欢快地走来了</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402101727.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="DataBinding"></p><p>然而，很多开发者对 DataBinding 存在偏见，「DataBinding 不是个好东西，在声明式编程中书写 UI 逻辑，既不可调试，也不便于察觉和追踪，万一出现问题就麻烦了。」</p> <img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402165235.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" style="zoom:200%;"><p>本文主要介绍 DataBinding 的解决的问题以及其背后的逻辑，带您对 DataBinding 有一个感性的认识。本文末尾会对各个 findViewById 的替代方案进行对比</p><p>DataBinding 的相关资源</p><ul><li><a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://codelabs.developers.google.com/codelabs/android-databinding/#0" target="_blank" rel="noopener">codelab</a></li><li><a href="https://github.com/android/databinding-samples" target="_blank" rel="noopener">官方示例</a></li></ul><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 数据驱动魔法师</span></h2><p>DataBinding 允许使用声明性格式而不是通过编程方式将布局中的 UI 组件与数据源绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// before</span><br>TextView textView = findViewById(R.id.sample_text);<br>textView.setText(viewModel.getUserName());<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span><br>    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@&#123;viewmodel.userName&#125;"</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>通过在布局文件中绑定组件，您可以删除 activity 中的许多设置 UI 调用，从而使它们更易于维护。 这也可以提高应用程序的性能，并有助于防止内存泄漏和空指针异常</p><blockquote><p>如果仅替换 findViewById 而不需要数据的绑定，可以使用 ViewBinding，它使用起来更简单，性能也更好。</p><p>使用方法参见 <a href="https://juejin.im/post/5e4806f3e51d4526c550a2ef" target="_blank" rel="noopener">[译]深入研究ViewBinding 在 include, merge, adapter, fragment, activity 中使用</a></p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> DataBinding 基础</span></h2><p>详细内容参见 <a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">官方文档</a> ，这里只简单介绍 DataBinding</p><h3 id="DataBinding-引入"><a href="#DataBinding-引入" class="headerlink" title="DataBinding 引入"></a>DataBinding 引入</h3><p>app build.gradle 中加入 </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    ...<br>    dataBinding &#123;<br>        enabled = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Android Studio 4.0</span><br>android &#123;<br>    ...<br>    buildFeatures &#123;<br>        dataBinding = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>必须在 app module 中声明，声明后其他子 module 可直接使用 DataBinding</p></blockquote><p>使用 DataBinding 无需开发者手动引入库，android build gradle plugin 内部已经引入了</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402115116.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>DataBinding 中使用了注解，因此在构建速度上比 ViewBinding 差些（不过功能这么强大要啥自行车）</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>DataBinding 布局文件略有不同，它们以 layout 的根标记开始，后跟一个 data 元素和一个 view 根元素。 view 元素是您的根将位于非绑定布局文件中的元素。 以下代码显示了一个示例布局文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span><br>        <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span><br>            <span class="hljs-attr">name</span>=<span class="hljs-string">"viewmodel"</span><br>            <span class="hljs-attr">type</span>=<span class="hljs-string">"com.myapp.data.ViewModel"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ConstraintLayout...</span> /&gt;</span> <span class="hljs-comment">&lt;!-- UI layout's root element --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="生成绑定类"><a href="#生成绑定类" class="headerlink" title="生成绑定类"></a>生成绑定类</h3><p>DataBinding 会为每个在布局声明 layout 标签的 xml 布局文件生成一个绑定类。 默认情况下，类的名称基于布局文件的名称。 上面的布局文件名是 activity_main.xml，因此相应的生成类是 ActivityMainBinding。 此类包含从布局属性（例如，viewmodel 变量）到布局视图的所有绑定，并且知道如何为绑定表达式分配值</p><h3 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    <span class="hljs-comment">// before</span><br>    <span class="hljs-comment">// setContentView(R.layout.activity_main)</span><br>    <br>    <span class="hljs-comment">// after</span><br>    val binding : ActivityMainBinding =<br>    DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_main)<br>&#125;<br></code></pre></td></tr></table></figure><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 使用DataBinding 解决的问题及实现原理</span></h2><p>不知道你是否有这些烦恼：activity 和 fragment 中有着大量的模板代码，即使使用 ButterKnife 等工具写起代码来也很繁琐。而且 View id 与 View 的类型不匹配时，只有在运行期才能发现；旋转屏幕后如果新的布局中不存在之前 id 的 view ，可能还导致空指针异常；项目中使用各类 bus 通知 UI 刷新，但是有时 UI 的显示并不符合预期，而排查起来特别困难，因为数据源很多…</p><p>不要慌，DataBinding 可以解决以下问题</p><ul><li><p>替换 findViewById ，减少模板代码</p></li><li><p>解决类型安全问题</p></li><li><p>解决空安全问题</p></li><li><p>保证了数据的一致性</p></li></ul><h3 id="魔法的背后"><a href="#魔法的背后" class="headerlink" title="魔法的背后"></a>魔法的背后</h3><p>com.android.tools.build:gradle 插件中封装了 DataBinding 的魔法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402162010.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>查看 com.android.tools.build:gradle:3.6.2 的源码，找到 DataBinding 配置项的类 DataBindingOptions</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DataBindingOptions.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// DataBinding 是否开启，对应上面在 build.gradle 中的配置</span><br>    <span class="hljs-keyword">return</span> enabled;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的调用者很多，在 TaskManager 中的 createDataBindingTasksIfNecessary</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TaskManager </span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createDataBindingTasksIfNecessary</span><span class="hljs-params">(@NonNull VariantScope scope)</span> </span>&#123;<br>    <span class="hljs-comment">// 是否开启 DataBinding</span><br>    <span class="hljs-keyword">boolean</span> dataBindingEnabled = extension.getDataBinding().isEnabled();<br>    <span class="hljs-keyword">boolean</span> viewBindingEnabled = extension.getViewBinding().isEnabled();<br>    <span class="hljs-keyword">if</span> (!dataBindingEnabled &amp;&amp; !viewBindingEnabled) &#123;<br>        <span class="hljs-comment">// DataBinding 和 ViewBinding 均未开启则直接 return</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    createDataBindingMergeBaseClassesTask(scope);<br>    createDataBindingMergeArtifactsTask(scope);<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">// 构建 DataBinding 相应绑定类</span><br>    taskFactory.register(<span class="hljs-keyword">new</span> DataBindingGenBaseClassesTask.CreationAction(scope));<br>&#125;<br><span class="hljs-comment">// CreationAction</span><br><span class="hljs-function">override fun <span class="hljs-title">handleProvider</span><span class="hljs-params">(taskProvider: TaskProvider&lt;out DataBindingGenBaseClassesTask&gt;)</span> </span>&#123;<br>    variantScope.artifacts.producesDir(<br>        <span class="hljs-comment">// DATA_BINDING_BASE_CLASS_SOURCE_OUT</span><br>        InternalArtifactType.DATA_BINDING_BASE_CLASS_SOURCE_OUT,<br>        BuildArtifactsHolder.OperationType.INITIAL,<br>        taskProvider,<br>        DataBindingGenBaseClassesTask::sourceOutFolder<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到生成 DataBinding 绑定类的 task 为 DataBindingGenBaseClassesTask，而InternalArtifactType.DATA_BINDING_BASE_CLASS_SOURCE_OUT 则对应着 build 目录生成的 DataBinding 类的</p><p>data_binding_base_class_source_out 目录</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200402161451.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这里可以简单看一下，感兴趣的小伙伴可以自己查看源码</p><h3 id="DataBinding-如何解决上述问题的"><a href="#DataBinding-如何解决上述问题的" class="headerlink" title="DataBinding 如何解决上述问题的"></a>DataBinding 如何解决上述问题的</h3><p>我们可以查看 DataBinding 生成的绑定类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FragmentSingleChildBinding</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewBinding</span> </span>&#123;<br>  <span class="hljs-comment">// NonNull 注解标记</span><br>  <span class="hljs-comment">// 如果存在不同配置的不同布局文件（如横竖屏）且该控件不是存在于所有布局，该处使用 Nullable注解标记</span><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> MaterialButton button;<br>    <br>  <span class="hljs-comment">// 省略...</span><br>    <br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FragmentSingleChildBinding <span class="hljs-title">bind</span><span class="hljs-params">(@NonNull View rootView)</span> </span>&#123;<br>    String missingId;<br>    missingId: &#123;<br>      <span class="hljs-comment">//其内部也是使用 findViewById</span><br>      MaterialButton button = rootView.findViewById(R.id.button);<br>      <span class="hljs-keyword">if</span> (button == <span class="hljs-keyword">null</span>) &#123;<br>        missingId = <span class="hljs-string">"button"</span>;<br>        <span class="hljs-keyword">break</span> missingId;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FragmentSingleChildBinding((MaterialButton) rootView, button);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"Missing required view with ID: "</span>.concat(missingId));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Binding 类内部的也是使用 findViewById ，因此 DataBinding 可以代替 findViewById ，并且减少模板代码</p></li><li><p>View 控件变量类型是固定的，因此不会出现类型安全问题</p></li><li><p>View 控件变量由空/非空注解修饰，（如果为 Nullable java 中会有 lint 警告，而 kotlin 直接调用时无法通过编译的）因此 不会出现空安全问题</p></li><li><p>通过声明式的配置，UI 完全来自唯一可信的数据源配置，保证了数据的一致性</p></li></ul><blockquote><p>注意：以上分析同样适用于 ViewBinding</p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 感受魔法的魅力</span></h2><p>这里简单展示一下 DataBinding 的「魔法」</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br>      <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span><br>       <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span><br>       <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>       <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span><br>           <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/firstName"</span><br>           <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span><br>           /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span><br>           <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/lastName"</span><br>           <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span><br>           /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br><br><span class="hljs-comment">// Before Data Binding</span><br><span class="hljs-comment">//setContentView(R.layout.activity_main);</span><br>        <br><span class="hljs-comment">//TextView firstName = (TextView) findViewById(R.id.firstName);</span><br><span class="hljs-comment">//TextView lastName = (TextView) findViewById(R.id.lastName);</span><br><br><span class="hljs-comment">//firstName.setText("xxx");</span><br><span class="hljs-comment">//lastName.setText("xxx");</span><br><br><br><span class="hljs-comment">// After Data Binding</span><br>        ActivityMainBinding binding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_main);<br><br>        binding.firstName.setText(<span class="hljs-string">"xxx"</span>);<br>        binding.lastName.setText(<span class="hljs-string">"xxx"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面展示了 DataBinding 的基础操作（单纯的替换 findViewById），如果仅使用 DataBinding 这部分功能，可以考虑使用 ViewBinding</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409114053.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p>在之前的布局的基础上绑定数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">variable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.example.User"</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span><br>       <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span><br>       <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>       <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <br>           <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/firstName"</span>      <br>           <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@&#123;user.firstName&#125;"</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <br>           <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/lastName"</span>      <br>           <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span><br>           <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@&#123;user.lastName&#125;"</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        ActivityMainBinding binding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_main);<br>binding.user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"xxx"</span>,<span class="hljs-string">"xxx"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式也可以用在 recyclerview adapter 中，adapter 中的代码大大减少</p><h3 id="Binding-Adapter"><a href="#Binding-Adapter" class="headerlink" title="Binding Adapter"></a>Binding Adapter</h3><p>您可能会好奇配置 <code>android:text=&quot;@{user.firstName}</code> 后内部发生了什么</p><p>DataBinding 中使用 <code>Binding Adapter</code> 来处理，它主要处理「属性」和「事件」，前者如  <code>setText()</code> ，后者如 <code>setOnClickListener()</code>。上面的 <code>android:text</code> 实际上调用的是下面的方法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409145551.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>DataBinding 中提供了很多 <code>Binding Adapter</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200410160031.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>如果官方提供的 <code>Binding Adapter</code> 不满足您的需求，您还可以自定义 <code>Binding Adapter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindingAdapter</span>(&#123;<span class="hljs-string">"imageUrl"</span>, <span class="hljs-string">"error"</span>&#125;)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadImage</span><span class="hljs-params">(ImageView view, String url, Drawable error)</span> </span>&#123;<br>  Glide.with(view).load(url).error(error).into(view);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span> <span class="hljs-attr">app:imageUrl</span>=<span class="hljs-string">"@&#123;venue.imageUrl&#125;"</span> <span class="hljs-attr">app:error</span>=<span class="hljs-string">"@&#123;@drawable/venueError&#125;"</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="DadaBinding-LiveData"><a href="#DadaBinding-LiveData" class="headerlink" title="DadaBinding + LiveData"></a>DadaBinding + LiveData</h3><p>要将 LiveData 与 DataBinding 一起使用，需要指定生命周期所有者来定义 LiveData 对象的范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        UserBinding binding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.user);<br><br>        binding.setLifecycleOwner(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>使用单向 DataBinding，可以在属性上设置一个值，并设置一个对该属性的更改做出反应的监听器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">CheckBox</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/rememberMeCheckBox"</span><br>    <span class="hljs-attr">android:checked</span>=<span class="hljs-string">"@&#123;viewmodel.rememberMe&#125;"</span><br>    <span class="hljs-attr">android:onCheckedChanged</span>=<span class="hljs-string">"@&#123;viewmodel.rememberMeChanged&#125;"</span><br>/&gt;</span><br></code></pre></td></tr></table></figure><p>使用双向绑定可以简化该过程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">CheckBox</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/rememberMeCheckBox"</span><br>    <span class="hljs-attr">android:checked</span>=<span class="hljs-string">"@=&#123;viewmodel.rememberMe&#125;"</span><br>/&gt;</span><br></code></pre></td></tr></table></figure><p>使用 <code>@={}</code> 接收对该属性的数据更改，并同时监听用户更新（注意，这里有 <code>=</code> ）</p><p>那么究竟什么是双向绑定呢？</p><p>所谓的「数据驱动」就是数据驱动视图的变化，而 DataBinding 的单向绑定就是如此。反过来讲，有些时候我们需要视图来驱动数据的变化（例如当我们在 EditText 上输入了文字，我们希望对应的 ViewModel 的 LiveData 的值能够及时响应该变化）</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409161036.jpg" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409110254.gif" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>如图，绿色部分为独立的 fragment ，内部存在两个 TextView，用于显示外部 fragment EditText 输入的文字</p><p>如果实现上述功能，传统做法可能是使用 activity 级别的 ViewModel 进行两个 fragment 之间的通信，通过监听 EditText 文字的变化改变 ViewModel 中 LiveData 的值，并在绿色 fragment 中观察 LiveData 并显示到 TextView 中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NormalViewModel</span> : <span class="hljs-type">ViewModel</span></span>() &#123;<br>    <span class="hljs-keyword">val</span> firstName = MutableLiveData&lt;String&gt;()<br>    <span class="hljs-keyword">val</span> lastName = MutableLiveData&lt;String&gt;()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NormalDetailFragment</span> : <span class="hljs-type">Fragment</span></span>(R.layout.fragment_normal_detail) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mViewModel <span class="hljs-keyword">by</span> activityViewModels&lt;NormalViewModel&gt;()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        mViewModel.firstName.observe(viewLifecycleOwner) &#123;<br>            tvFirstName.text = it<br>        &#125;<br>        mViewModel.lastName.observe(viewLifecycleOwner) &#123;<br>            tvLastName.text = it<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NormalFragment</span> : <span class="hljs-type">Fragment</span></span>(R.layout.fragment_normal) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mViewModel <span class="hljs-keyword">by</span> activityViewModels&lt;NormalViewModel&gt;()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        etFirstName.addTextChangedListener &#123;<br>            mViewModel.firstName.value = it.toString()<br>        &#125;<br>        etLastName.addTextChangedListener &#123;<br>            mViewModel.lastName.value = it.toString()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得益于 kotlin ，上面的代码以及很简洁了，如果使用 java 代码片段只会更长。</p><p>不过使用 DataBinding，还可以更简洁</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.textview.MaterialTextView</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/tvFirstName"</span><br>    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@&#123;vm.firstName&#125;"</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.textview.MaterialTextView</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/tvLastName"</span><br>    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@&#123;vm.lastName&#125;"</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.textfield.TextInputEditText</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/etFirstName"</span><br>    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@=&#123;vm.firstName&#125;"</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.textfield.TextInputEditText</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/etLastName"</span><br>    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@=&#123;vm.lastName&#125;"</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>只需配置好双向绑定（EditText 驱动 ViewModel 的 LiveData 的值变化，ViewModel 再驱动 TextView 显示数据），并在 fragment 通过固定的模板代码设置好 ViewModel 即可</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409112128.jpg" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这里的魔法还是来自 Binding Adapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TextViewBindingAdapter.java</span><br><span class="hljs-meta">@BindingAdapter</span>(value = &#123;<span class="hljs-string">"android:beforeTextChanged"</span>, <span class="hljs-string">"android:onTextChanged"</span>,<br>        <span class="hljs-string">"android:afterTextChanged"</span>, <span class="hljs-string">"android:textAttrChanged"</span>&#125;, requireAll = <span class="hljs-keyword">false</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTextWatcher</span><span class="hljs-params">(TextView view, <span class="hljs-keyword">final</span> BeforeTextChanged before,<br>        <span class="hljs-keyword">final</span> OnTextChanged on, <span class="hljs-keyword">final</span> AfterTextChanged after,<br>        <span class="hljs-keyword">final</span> InverseBindingListener textAttrChanged)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> TextWatcher newValue;<br>    <span class="hljs-keyword">if</span> (before == <span class="hljs-keyword">null</span> &amp;&amp; after == <span class="hljs-keyword">null</span> &amp;&amp; on == <span class="hljs-keyword">null</span> &amp;&amp; textAttrChanged == <span class="hljs-keyword">null</span>) &#123;<br>        newValue = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        newValue = <span class="hljs-keyword">new</span> TextWatcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeTextChanged</span><span class="hljs-params">(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">int</span> after)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (before != <span class="hljs-keyword">null</span>) &#123;<br>                    before.beforeTextChanged(s, start, count, after);<br>                &#125;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTextChanged</span><span class="hljs-params">(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> before, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (on != <span class="hljs-keyword">null</span>) &#123;<br>                    on.onTextChanged(s, start, before, count);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (textAttrChanged != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//通知发生变化</span><br>                    textAttrChanged.onChange();<br>                &#125;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterTextChanged</span><span class="hljs-params">(Editable s)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (after != <span class="hljs-keyword">null</span>) &#123;<br>                    after.afterTextChanged(s);<br>                &#125;<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">final</span> TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);<br>    <span class="hljs-keyword">if</span> (oldValue != <span class="hljs-keyword">null</span>) &#123;<br>        view.removeTextChangedListener(oldValue);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newValue != <span class="hljs-keyword">null</span>) &#123;<br>        view.addTextChangedListener(newValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用 InverseBindingListener （调用 <code>textAttrChanged.onChange()</code>）来通知 LiveData 数据发生变化</p><p>而变化后的值 通过 @InverseBindingAdapter 注解标记的方法处理，这里的 event 与上面的标记匹配（<code>android:textAttrChanged</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TextViewBindingAdapter.java</span><br><span class="hljs-meta">@InverseBindingAdapter</span>(attribute = <span class="hljs-string">"android:text"</span>, event = <span class="hljs-string">"android:textAttrChanged"</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getTextString</span><span class="hljs-params">(TextView view)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> view.getText().toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>view 层变化通知数据变化，数据变化再通知 view 层变化，仿佛是个套娃</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409163420.jpg" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>因此避免这种死循环十分重要，setText 方法判断了新旧值是否相等来避免死循环</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409163541.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 总结</span></h2><p>DataBinding 主要提供两部分功能</p><ul><li>替换 findViewById ，如果只用这部分功能可以使用 ViewBinding</li><li>进行 data 和 UI 的绑定，使用「数据驱动」的思想解决了视图的一致性问题</li></ul><h3 id="各种-findViewById-替代方案对比"><a href="#各种-findViewById-替代方案对比" class="headerlink" title="各种 findViewById 替代方案对比"></a>各种 findViewById 替代方案对比</h3><ul><li>findViewById </li><li>Butterknife</li><li>Kotlin Synthetics</li><li>Data Binding</li><li>View Binding</li></ul><h4 id="findViewById"><a href="#findViewById" class="headerlink" title="findViewById"></a>findViewById</h4><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409170514.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>findViewById 有两个问题</p><ol><li>当不能在 Activity/Fragment/ViewGroup 中定位到指定 id 的 View，会在运行期间崩溃，即非空安全</li><li>如果某个 view 为 TextView 类型，而在使用中将其指定为其他类型不会在编译器报错，即非类型安全</li></ol><p>在 compileSdk 的 API 级别 26 中，对该方法的定义稍作更改以消除强制类型转换问题</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409171139.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>现在，开发人员无需在代码中手动转换 view 类型。 如果您引用 id 指向类型 TextView 的 View 并将其指定为 Button，则 Android SDK 会尝试查找具有提供的 id 的 Button，并且它将返回 Null，因为它将无法找到它</p><p>但是在 Kotlin 中，您仍然需要提供诸如 findViewById<textview>(R.id.txtUsername) 之类的类型。 如果您不检查视图是否具有 null 安全，则可能出现 NullPointerException，但是此方法不会像以前那样抛出ClassCastException</textview></p><h4 id="Butterknife"><a href="#Butterknife" class="headerlink" title="Butterknife"></a>Butterknife</h4><p><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">Butterknife</a> 是 <a href="https://medium.com/u/8ddd94878165?source=post_page-----98b8ef5b9249----------------------" target="_blank" rel="noopener">Jake Wharton</a> 大神写的替代 findViewById 的库，该库使用注解处理并生成 findViewById 代码</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409171316.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>它具有与 findViewById 几乎相似的问题。 但是，它在运行时添加了null 安全检查以避免 NullPointerException</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409171554.jpg" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>由于 DataBinding 和 ViewBinding 的出现，沃神已经宣布弃用该库</p><h4 id="Kotlin-Synthetics"><a href="#Kotlin-Synthetics" class="headerlink" title="Kotlin Synthetics"></a>Kotlin Synthetics</h4><p>Kotlin 引入的最大功能之一是 Kotlin 扩展方法。 在它的帮助下，Kotlin Synthetics 诞生了。 Kotlin Synthetics 通过自动生成的 Kotlin 扩展方法，使开发人员可以从 xml 布局直接访问其内部的 view</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409171843.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>Kotlin Synthetics 第一次调用 findViewById 方法，然后默认情况下将 view 实例缓存在 HashMap 中。 可以通过Gradle 设置将此缓存配置更改为 SparseArray 或不缓存</p><p>总体而言，Kotlin Synthetics 是一种很好的选择，因为它类型安全，并且通过 Kotlin 的 ？进行空检查。 它不需要开发人员的额外代码。 但这仅适用于 Kotlin 项目</p><p>但是，在使用 Kotlin Synthetics 时遇到了一个小问题。 例如，如果将内容视图设置为布局，然后使用仅存在于其他布局中的 id ，则 IDE 可让您自动完成并添加新的 import 语句。 除非您专门检查以确保其 import 语句仅导入正确的 view，否则没有安全的方法来验证这不会导致运行时问题</p><h4 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h4><p>DataBinding 在功能上比其他方法优越得多，因为它不仅为您提供类型安全和空安全的 view 引用，而且还允许您直接在 xml 布局内使用数据驱动视图变化</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200409172613.png" src="/2020/04/09/Jetpack-DataBinding/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h4 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h4><p>最近在 Android Studio 3.6 中引入的 ViewBinding 是 DataBinding 库的子集。 由于不需要注解处理，因此可以缩短构建时间。详细的使用可以参见 <a href="https://juejin.im/post/5e4806f3e51d4526c550a2ef" target="_blank" rel="noopener">这篇文章</a></p><table><thead><tr><th align="center"></th><th align="center">findViewById</th><th align="center">Butterknife</th><th align="center">Kotlin Synthetics</th><th align="center">DataBinding</th><th align="center">ViewBinding</th></tr></thead><tbody><tr><td align="center">一直空安全</td><td align="center">❌</td><td align="center">部分</td><td align="center">部分</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td align="center">类型安全</td><td align="center">❌</td><td align="center">❌</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td align="center">样板代码</td><td align="center"><font color="#CA0C16">多</font></td><td align="center"><font color="#0DD613">少</font></td><td align="center"><font color="#0DD613">少</font></td><td align="center"><font color="#B77441">中等</font></td><td align="center"><font color="#0DD613">少</font></td></tr><tr><td align="center">构建时间</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td></tr><tr><td align="center">支持语音</td><td align="center">java/kotlin</td><td align="center">java/kotlin</td><td align="center">kotlin</td><td align="center">java/kotlin</td><td align="center">java/kotlin</td></tr></tbody></table><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 关于我</span></h2><p>我是 <a href="https://flywith24.gitee.io/">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jetpack DataBinding 介绍。&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015101935.png" type="image" />
    
    
      <category term="背上 Jetpack" scheme="https://flywith24.gitee.io/categories/%E8%83%8C%E4%B8%8A-Jetpack/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>更优雅地恢复 recyclerview 的滚动位置</title>
    <link href="https://flywith24.gitee.io/2020/04/09/Jetpack-Recyclerview-Scoroll/"/>
    <id>https://flywith24.gitee.io/2020/04/09/Jetpack-Recyclerview-Scoroll/</id>
    <published>2020-04-08T16:10:35.000Z</published>
    <updated>2020-10-15T02:31:43.100Z</updated>
    
    <content type="html"><![CDATA[<p>更优雅地恢复 recyclerview 的滚动位置</p><a id="more"></a><h2 id="被我忽视的更新"><a href="#被我忽视的更新" class="headerlink" title="被我忽视的更新"></a>被我忽视的更新</h2><p><code>androidx recyclerview 1.2.0-alpha02</code> 版本添加了新功能 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" target="_blank" rel="noopener">MergeAdapter</a>，帮助开发者更容易地为 RecyclerView 添加 Header 和 Footer。详情参见 <a href="https://juejin.im/post/5e86ffea51882573ba207a19" target="_blank" rel="noopener">【译】MergeAdapter 的使用 使用官方 API 为 Recyclerview 添加 Header 和 Footer</a></p><p>该版本中还有一个改动：<strong><code>RecyclerView.Adapter</code> lazy state restoration</strong>，帮助开发者恢复 RecyclerView 的状态</p><!-- more--><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512105548.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="recyclerview update"></p><p>我对这个功能并没有什么感觉。众所周知，Android 中的 View 内部是有着状态保存和恢复的方法的。RecyclerView 也是如此，它可以恢复自身已滚动的位置</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512110411.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="View 内部恢复状态"></p><p>有关状态保存的内容可以参见 <a href="https://juejin.im/post/5e738d12518825495d69cfb9" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a></p><p>真实情况也是如此</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512111315.gif" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="RecyclerView 内部可以恢复滚动位置"></p><h2 id="意外发现"><a href="#意外发现" class="headerlink" title="意外发现"></a>意外发现</h2><p>最近看到 <a href="https://medium.com/@florina.muntenescu?source=post_page-----a8fbdc9a9334----------------------" target="_blank" rel="noopener">Florina Muntenescu</a> 的 <a href="https://medium.com/androiddevelopers/restore-recyclerview-scroll-position-a8fbdc9a9334" target="_blank" rel="noopener">Restore RecyclerView scroll position</a> ，其中介绍了 <strong><code>RecyclerView.Adapter</code> lazy state restoration</strong>，这勾起了我的兴趣</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512111720.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="意外发现"></p><p>如文中描述，RecyclerView 在 activity/fragment 重建时失去滚动位置是因为 Adapter 中的数据是 <strong>异步</strong> 加载的，当 RecyclerView layout 时数据并没有加载，因此也恢复不了之前的位置状态。一个比较简单的例子是使用 Navigation 组件进行导航，返回时 fragment 中的 RecyclerView 由于再次调用接口获取数据，导致其滑动位置失去</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512113141.gif" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="延迟加载数据，无法恢复滚动位置"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有几种方法可以保证 RecyclerView 恢复到正确的滚动位置，最好的办法是借助缓存，ViewModel 或 Repository 中缓存要显示的数据，确保始终在第一个布局传入前在 Adapter 上设置数据。也有一些其他的方案，这些方案要么太复杂，要么不够优雅</p><p><code>recyclerview:1.2.0-alpha02</code> 中的解决方案是提供一个新的 Adapter 方法，该方法允许设置状态恢复策略，它有三个选项</p><ul><li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter.StateRestorationPolicy#ALLOW" target="_blank" rel="noopener">ALLOW</a></li><li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter.StateRestorationPolicy#PREVENT_WHEN_EMPTY" target="_blank" rel="noopener">PREVENT_WHEN_EMPTY</a></li><li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter.StateRestorationPolicy#PREVENT" target="_blank" rel="noopener">PREVENT</a></li></ul><h3 id="ALLOW"><a href="#ALLOW" class="headerlink" title="ALLOW"></a>ALLOW</h3><p>这是 <strong>默认</strong> 的状态，它会立即恢复 RecyclerView 的状态，该种策略无法解决延迟加载的数据的问题，可以使用 <code>PREVENT_WHEN_EMPTY</code></p><h3 id="PREVENT-WHEN-EMPTY"><a href="#PREVENT-WHEN-EMPTY" class="headerlink" title="PREVENT_WHEN_EMPTY"></a>PREVENT_WHEN_EMPTY</h3><p>仅当 Adapter 不为空（adapter.getItemCount() &gt; 0）时，才恢复 RecyclerView 状态。 如果您的数据是异步加载的，那么 RecyclerView 会一直等到数据加载完毕，然后状态才能恢复。 如果您有默认 item（例如 Header 或 加载指示器）作为适配器的一部分，则应该使用<code>PREVENT</code> 选项，除非使用 MergeAdapter 添加了默认 item。 MergeAdapter 等待所有适配器准备就绪，然后才恢复状态</p><h3 id="PREVENT"><a href="#PREVENT" class="headerlink" title="PREVENT"></a>PREVENT</h3><p>状态不会恢复，直到配置了 <code>ALLOW</code> 或者 <code>PREVENT_WHEN_EMPTY</code></p><p>使用方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">adapter.stateRestorationPolicy = PREVENT_WHEN_EMPTY<br></code></pre></td></tr></table></figure><p><strong>加入了上面的配置后即使是异步加载数据也能恢复 RecyclerView 的位置</strong></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512114332.gif" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="设置 PREVENT_WHEN_EMPTY"></p><h2 id="追踪引入过程"><a href="#追踪引入过程" class="headerlink" title="追踪引入过程"></a>追踪引入过程</h2><p>老规矩，我们沿着官方的 commit log 来看看其实现原理</p><p>首先我们看看 <a href="https://issuetracker.google.com/issues/146365793" target="_blank" rel="noopener">IssueTracker 上提的 Feature</a></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512115048.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="IssueTracker"></p><p>表达的意思也很简单，就是当加载异步数据时 RecyclerView 的位置状态无法恢复，Adapter 应该提供相关的解决方案</p><p>有意思的是，实现该功能时还重新实现了前一个版本的逻辑，我在 git commit log 中看到了 revert 操作</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512140140.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="revert操作"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512120004.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>为了防止 <code>LayoutManager#onRestore</code> 执行多次，没有采用最开始的实现方式。但 Yigit Boyar (这个提交的开发者) 仍然希望使用最开始的实现方式，但是  <code>LayoutManager#onRestoreInstance</code> 的状态时 public ，因此只能选取一个折中的方案</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512141210.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="新的实现方案"></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512141445.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="无奈之举"></p><p>过去，开发者会无意间调用 <code>onRestoreInstanceState(State)</code> 方法。例如，一些开发者已使用它来手动设置自己更新的状态，这样即使在此状态之前已恢复，在此处传递状态也将导致 LayoutManager 接收它并相应地更新其内部状态。因此，即使看起来好像很奇怪，也必须始终调用 <code>requestLayout</code> 来保留功能</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>接下来我们来分析这部分源码，内容很少，所以我们详细看下</p><p>首先是引入 <code>StateRestorationPolicy</code>的枚举</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512143600.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>然后需要提供 <code>setStateRestorationPolicy</code> 和 <code>getStateRestorationPolicy</code> 方法，此时我们还需要一个方法来判断是否要将 SavedState 传递给 LayoutManager</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512143459.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>前面的 <code>setStateRestorationPolicy</code> 方法中 调用了 <code>notifyStateRestorationPolicyChanged</code>，而 <code>notifyStateRestorationPolicyChanged</code> 为静态类 <code>AdapterDataObservable</code> 中的方法，该类中的其他方法我们也很熟悉，均是刷新 Adapter 中数据的方法。</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512143858.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="notifyStateRestorationPolicyChanged"></p><p>而 <code>notifyStateRestorationPolicyChanged</code> 中调用了 mObservers list 中元素的 <code>onStateRestorationPolicyChanged</code> 方法，通过源码我们得知该 list 中的元素类型为 <code>AdapterDataObserver</code>，因此还需要在 <code>AdapterDataObserver</code> 中加入 <code>onStateRestorationPolicyChanged</code> 方法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512144501.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="onStateRestorationPolicyChanged "></p><p>该方法是个空实现，而 <code>RecyclerViewDataObserver</code> 重写了该方法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512144716.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="RecyclerViewDataObserver "></p><p>配置恢复策略以及恢复策略变化时的监听都有了，接下来要做的就是如果之前有待恢复的装则恢复之前的状态</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200512145152.png" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="恢复状态"></p><blockquote><p>注意：发布之前 <code>StateRestorationPolicy</code> 叫做 <code>StateRestorationStrategy</code>，后来命名为 <code>StateRestorationPolicy</code>，alpha 版本的库可能随时更改 API 的命名和删除 API，因此查看这部分源码的同学请注意</p></blockquote><p>至此，相关的源码都在这里了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>StateRestorationPolicy</code> 提供了 RecyclerView 异步加载数据恢复滚动位置的解决方案。原理就是通过配置 <code>StateRestorationPolicy</code> 来改变恢复策略，同时在策略改变时调用 <code>requestLayout</code> 方法。在 <code>dispatchLayoutStep2()</code> (该方法会在 onLayout 和 measure 方法中调用) 方法中恢复状态(如果 <code>canRestoreState()</code> 返回 true)</p><p><a href="https://github.com/Flywith24/Flywith24-Jetpack-Demo/tree/master/demo_recyclerview_scroll" target="_blank" rel="noopener">demo 地址</a></p><p><strong>一点思考：我们都知道 ViewPager2 是使用 RecyclerView 实现的，那么借助本文介绍的 API 可以做点什么吗？</strong></p><p>欢迎各位小伙伴在评论区留言，说说你的想法</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是 <a href="https://flywith24.gitee.io/">Flywith24</a>，我的博客内容已经分类整理 <a href="https://github.com/Flywith24/BlogList" target="_blank" rel="noopener">在这里</a>，点击右上角的 Watch 可以及时获取我的文章更新哦 😉</p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://xiaozhuanlan.com/detail" target="_blank" rel="noopener">小专栏</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200508153754.jpg" src="/2020/04/09/Jetpack-Recyclerview-Scoroll/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更优雅地恢复 recyclerview 的滚动位置&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015103136.png" type="image" />
    
    
      <category term="Jetpack 更新" scheme="https://flywith24.gitee.io/categories/Jetpack-%E6%9B%B4%E6%96%B0/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
      <category term="RecyclerView" scheme="https://flywith24.gitee.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>ViewModel的左膀右臂 数据驱动真的香</title>
    <link href="https://flywith24.gitee.io/2020/03/31/Jetpack-LiveData/"/>
    <id>https://flywith24.gitee.io/2020/03/31/Jetpack-LiveData/</id>
    <published>2020-03-30T16:10:35.000Z</published>
    <updated>2020-10-15T02:32:53.477Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack LiveData 介绍。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>之前我们讨论过 <a href="https://juejin.im/post/5e786d415188255e00661a4e" target="_blank" rel="noopener">ViewModel 的职能边界</a> ，得益于 ViewModel 的生命周期更长，我们可以在 activity 重建后将数据传递给 activity ，也可以避免内存泄漏。但是如果不是每次需要就获取数据，而是当每次有新数据时通知我们，应该怎么办？</p></blockquote><p>本文介绍 <code>LiveData</code> ，一个 <strong>生命周期感知的，可观察的，数据持有者</strong>。同时还会简单分析 <code>LiveData</code> 的源码实现</p><h2 id="我们都是-Adapter"><a href="#我们都是-Adapter" class="headerlink" title="我们都是 Adapter"></a>我们都是 Adapter</h2><p>在谈 <code>LiveData</code> 前我们来思考一个问题</p><p><strong>Android 开发（亦或者说前端开发）的本质工作内容是什么？</strong></p><p>对于应用层 app 开发者，开发者的工作主要工作就是 Adapter </p><p>什么是 Adapter ，下图可能比较直观</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330153727.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="Adapter"></p><blockquote><p>图片来自 google image</p></blockquote><p>我们的工作本质是 <strong>将数据转换成 UI</strong> </p><p>数据可能来自网络，来自本地数据库，来自内存，而 UI 可能是 activity 或 fragment。</p><h2 id="理想的数据模型"><a href="#理想的数据模型" class="headerlink" title="理想的数据模型"></a>理想的数据模型</h2><p>上面我们提到 Android 开发者的核心工作就是将数据转换为 UI 。这个过程比较理想的状态是：当数据发生变化时，UI 跟随变化。我们还可以进一步展开：当 UI 对用户可见时，数据发生变化时 UI 跟随变化；当 UI 对用户不可见时，我们希望数据变化时什么都不做，当 UI 再次对用户可见时根据最新的数据进行 UI 的处理。</p><p>而 <code>LiveData</code> 就是我们理想中的数据模型</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330160205.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="LiveData"></p><blockquote><p>图片来自 <a href="https://www.youtube.com/watch?v=2rO4r-JOQtA&list=PLWz5rJ2EKKc_dskHzXdKHB2ZvAlMyFwZe&index=2&t=0s" target="_blank" rel="noopener">Android Dev Summit ‘18-Fun with LiveData</a></p></blockquote><p> LiveData 可以三个关键词概括</p><ul><li><p>lifecycle-aware</p></li><li><p>observable</p></li><li><p>data holder</p></li></ul><h3 id="observable"><a href="#observable" class="headerlink" title="observable"></a>observable</h3><p>Android 中不同的组件有着不同的生命周期，不同的存活时间</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321140641.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ViewModel"></p><p>因此我们不会在 <code>ViewModel</code> 中持有 <code>Activity</code> 的引用，因为这会导致当 <code>Activity</code> 重建时内存泄漏，甚至出现空指针的情况</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330161100.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="observable"></p><p>通常我们会在 <code>Activity</code> 中持有 <code>ViewModel</code> 的引用，那么如何进行二者间的通信，如何向 <code>Activity</code> 发送 <code>ViewModel</code> 中的数据？</p><p>答案是让 <code>Activity</code> 观察 <code>ViewModel</code></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330161411.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><code>LiveData</code> 是 <code>observable</code></p><h3 id="lifecycle-aware"><a href="#lifecycle-aware" class="headerlink" title="lifecycle-aware"></a>lifecycle-aware</h3><p>当观察者观察着某个数据时，该数据必须保留对观察者的引用才能调用它，为了解决这个问题，<code>LiveData</code> 被设计成可感知生命周期</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330162126.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>当 activity / fragment 被销毁后，它会自动的取消订阅</p><h3 id="data-holder"><a href="#data-holder" class="headerlink" title="data holder"></a>data holder</h3><p><code>LiveData</code> 仅持有 <strong>单个且最新</strong> 的数据</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200330214220.gif" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="data holder"></p><p>上图中，最右侧是在 <code>ViewModel</code> 中的 <code>LiveData</code>，左侧为观察这个 <code>LiveData</code> 的 activity / fragment 。一旦我们为 <code>LiveData</code> 设值，该值会传递到 activity。简而言之，<code>LiveData</code> 值改变，activity 收到最新的值的变化。但是当观察者不再处于活动状态（STARTED 到 RESUMED ），数据 C 不会被发送到 activity 。当 activity 回到前台，它将收到最新的值，数据 D。<strong>LiveData 仅持有单个且最新的数据</strong>。当 activity 执行销毁流程时，此时的数据 E 也不会产生任何影响</p><h2 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h2><p><code>LiveData</code> 提供 两种 transformation ，<code>map</code> 和 <code>switch map</code>。开发者也可以创建自定义的  <code>MediatorLiveData</code> </p><p>我们都知道 <code>LiveData</code> 可以为 View 和 ViewModel 提供通信，但如果有一个第三方组件（例如 repository ）也持有 <code>LiveData</code>。那么它应该如何在 <code>ViewModel</code> 中订阅？该组件并没有 lifecycle </p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331090310.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>一旦我们的应用愈发复杂，repository 可能会观察数据源</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331090412.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>那么 view 如何获取 repository 中的 <code>LiveData</code>？</p><h3 id="一对一的静态转换（map）"><a href="#一对一的静态转换（map）" class="headerlink" title="一对一的静态转换（map）"></a>一对一的静态转换（map）</h3><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331090941.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="one-to-one static transformation"></p><p>在上面的示例中，<code>ViewModel</code> 仅将数据从 repository 转发到 view，然后将其转换为 UI Model。 每当 repository 中有新数据时，<code>ViewModel</code> 只需 <code>map</code> </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainViewModel</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> viewModelResult = Transformations.map(repository.getDataForUser()) &#123; <span class="hljs-keyword">data</span> -&gt;<br>     convertDataToMainUIModel(<span class="hljs-keyword">data</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个参数为 <code>LiveData</code> 源（来自 repository ），第二个参数是一个转换函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这里的转换为将 X 转换为 Y</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;X, Y&gt;</span> LiveData<span class="hljs-type">&lt;X&gt;</span>.<span class="hljs-title">map</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> transform: (<span class="hljs-type">X</span>)</span></span> -&gt; Y): LiveData&lt;Y&gt; =<br>        Transformations.map(<span class="hljs-keyword">this</span>) &#123; transform(it) &#125;<br></code></pre></td></tr></table></figure><h3 id="一对一的动态转换（switchMap）"><a href="#一对一的动态转换（switchMap）" class="headerlink" title="一对一的动态转换（switchMap）"></a>一对一的动态转换（switchMap）</h3><p>假如您正在观察一个提供用户的用户管理器，并且需要提供用户的 id 才能开始观察 repository </p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331091954.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>您不能将其写到 <code>ViewModel</code> 初始化的过程中，因为此时用户的 id 还不可用</p><p>这时 <code>switchMap</code> 就派上用场了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainViewModel</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> repositoryResult = Transformations.switchMap(userManager.userId) &#123; userId -&gt;<br>     repository.getDataForUser(userId)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>switchMap</code> 在内部使用 <code>MediatorLiveData</code>，因此了解它非常重要，因为当您要组合多个 <code>LiveData</code> 源时需要使用它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这里的转换为将 X 转换为 LiveData&lt;Y&gt;</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;X, Y&gt;</span> LiveData<span class="hljs-type">&lt;X&gt;</span>.<span class="hljs-title">switchMap</span><span class="hljs-params">(<br>    <span class="hljs-keyword">crossinline</span> transform: (<span class="hljs-type">X</span>)</span></span> -&gt; LiveData&lt;Y&gt;<br>): LiveData&lt;Y&gt; = Transformations.switchMap(<span class="hljs-keyword">this</span>) &#123; transform(it) &#125;<br></code></pre></td></tr></table></figure><h3 id="一对多依赖（MediatorLiveData）"><a href="#一对多依赖（MediatorLiveData）" class="headerlink" title="一对多依赖（MediatorLiveData）"></a>一对多依赖（MediatorLiveData）</h3><p><code>MediatorLiveData</code> 允许您将一个或多个数据源添加到单个可观察的 <code>LiveData</code> 中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> liveData1: LiveData&lt;<span class="hljs-built_in">Int</span>&gt; = ...<br><span class="hljs-keyword">val</span> liveData2: LiveData&lt;<span class="hljs-built_in">Int</span>&gt; = ...<br><br><span class="hljs-keyword">val</span> result = MediatorLiveData&lt;<span class="hljs-built_in">Int</span>&gt;()<br><br>result.addSource(liveData1) &#123; value -&gt;<br>    result.setValue(value)<br>&#125;<br>result.addSource(liveData2) &#123; value -&gt;<br>    result.setValue(value)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，当任何一个数据源变化时，result 会更新。</p><blockquote><p>注意：数据并不是合并，MediatorLiveData 只是处理通知</p></blockquote><p>为了实现示例中的转换，我们需要将两个不同的 LiveData 组合为一个</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331094815.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>图片来自 <a href="https://medium.com/androiddevelopers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7" target="_blank" rel="noopener">LiveData beyond the ViewModel — Reactive patterns using Transformations and MediatorLiveData</a></p></blockquote><p>使用 <code>MediatorLiveData</code> 合并数据的一种方法是添加源并以其他方法设置值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">blogpostBoilerplateExample</span><span class="hljs-params">(newUser: <span class="hljs-type">String</span>)</span></span>: LiveData&lt;UserDataResult&gt; &#123;<br><br>    <span class="hljs-keyword">val</span> liveData1 = userOnlineDataSource.getOnlineTime(newUser)<br>    <span class="hljs-keyword">val</span> liveData2 = userCheckinsDataSource.getCheckins(newUser)<br><br>    <span class="hljs-keyword">val</span> result = MediatorLiveData&lt;UserDataResult&gt;()<br><br>    result.addSource(liveData1) &#123; value -&gt;<br>        result.value = combineLatestData(liveData1, liveData2)<br>    &#125;<br>    result.addSource(liveData2) &#123; value -&gt;<br>        result.value = combineLatestData(liveData1, liveData2)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>数据的实际组合是在 <code>combineLatestData</code> 方法中完成的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">combineLatestData</span><span class="hljs-params">(<br>        onlineTimeResult: <span class="hljs-type">LiveData</span>&lt;<span class="hljs-type">Long</span>&gt;,<br>        checkinsResult: <span class="hljs-type">LiveData</span>&lt;<span class="hljs-type">CheckinsResult</span>&gt;<br>)</span></span>: UserDataResult &#123;<br><br>    <span class="hljs-keyword">val</span> onlineTime = onlineTimeResult.value<br>    <span class="hljs-keyword">val</span> checkins = checkinsResult.value<br><br>    <span class="hljs-comment">// Don't send a success until we have both results</span><br>    <span class="hljs-keyword">if</span> (onlineTime == <span class="hljs-literal">null</span> || checkins == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> UserDataLoading()<br>    &#125;<br><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Check for errors and return UserDataError if any.</span><br><br>    <span class="hljs-keyword">return</span> UserDataSuccess(timeOnline = onlineTime, checkins = checkins)<br>&#125;<br></code></pre></td></tr></table></figure><p>检查值是否准备好并发出结果（加载中，失败或成功）</p><h2 id="LiveData-的错误用法"><a href="#LiveData-的错误用法" class="headerlink" title="LiveData 的错误用法"></a>LiveData 的错误用法</h2><h3 id="错误地使用-var-LiveData"><a href="#错误地使用-var-LiveData" class="headerlink" title="错误地使用 var LiveData"></a>错误地使用 var LiveData</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> <span class="hljs-keyword">lateinit</span> randomNumber: LiveData&lt;<span class="hljs-built_in">Int</span>&gt;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onGetNumber</span><span class="hljs-params">()</span></span> &#123;<br>   randomNumber = Transformations.map(numberGenerator.getNumber()) &#123;<br>       it<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个重要的问题需要理解：转换会在调用时（<code>map</code> 和 <code>switchMap</code>）会创建一个新的 <code>LiveData</code>。 在此示例中，randomNumber 公开给 View ，但是每次用户单击按钮时都会对其进行重新赋值。 观察者只会在订阅时收到分配给 var 的 <code>LiveData</code> 更新的信息</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 只会收到第一次分配的值</span><br>viewmodel.randomNumber.observe(<span class="hljs-keyword">this</span>, Observer &#123; number -&gt;<br>    numberTv.text = resources.getString(R.string.random_text, number)<br>&#125;)<br></code></pre></td></tr></table></figure><p>如果 viewmodel.randomNumber <code>LiveData</code> 实例发生更改，这里永远不会回调。而且这里泄漏了之前的 <code>LiveData</code> ，这些 <code>LiveData</code> 不会再发送更新</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331111630.gif" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>一言以蔽之，<strong>不要在 var 中使用 Livedata</strong></p><p>正确示例见  <a href="https://github.com/Flywith24/Flywith24-Jetpack-Demo/tree/master/demo_livedata" target="_blank" rel="noopener">demo</a></p><h3 id="LiveData-粘性事件"><a href="#LiveData-粘性事件" class="headerlink" title="LiveData 粘性事件"></a>LiveData 粘性事件</h3><p>一般来说我们使用 LiveData 持有 UI 数据和状态，但是如果通过它来发送事件，可能会出现一些问题。这些问题及解决方案 <a href="https://juejin.im/post/5b2b1b2cf265da5952314b63" target="_blank" rel="noopener">在这</a></p><h3 id="fragment-中错误地传入-LifecycleOwner"><a href="#fragment-中错误地传入-LifecycleOwner" class="headerlink" title="fragment 中错误地传入 LifecycleOwner"></a>fragment 中错误地传入 LifecycleOwner</h3><p><code>androidx fragment 1.2.0</code> 起，添加了新的 Lint 检查，以确保您在从 onCreateView()、onViewCreated() 或 onActivityCreated() 观察 <code>LiveData</code> 时使用 getViewLifecycleOwner()</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331152505.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331205402.gif" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="bug"></p><p>如图，我们有一个 fragment ，onCreate 观察 <code>LiveData</code>，通过正常的生命周期创建了 View ，接着进入了 resume 状态。此时你使用了 <code>LiveData</code>，UI 将开始展示它。之后，用户点击了按钮，由于跳转了另一个 fragment，所以要 detach 该 fragment，一旦 fragment stop 我们就不需要其中的 view 了，因此 destroyView 。之后用户点击了返回按钮回到了上一个 fragment，由于我们已经 destroyView，因此我们需要创建一个新的 view ，接着进入正常的生命周期，但此时，出现了一个 bug 。这个新 View 不会恢复 <code>LiveData</code> 的状态，因为我们使用的是 fragment 的 lifecycle observe 的 <code>LiveData</code></p><p>我们有两种选择，在 onCreate 或者在 onCreateView 中使用 fragment 的 lifecycle observe LiveData</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331171844.png" src="/2020/03/31/Jetpack-LiveData/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>前者的优点是一次注册，缺点是当 recreate 时有bug；后者优点是能够解决 recreate 的 bug，但会导致重复注册</p><p><strong>该问题的核心是 fragment 拥有两个生命周期：fragment 自身和 fragment 内部 view 的生命周期</strong></p><p><code>androidx fragment 1.0</code> 和 <code>support library 28</code> 了 viewLifecycle</p><p><strong>因此，当需要观察 view 相关的 LiveData ，可以在 onCreateView()、onViewCreated() 或 onActivityCreated()  中 LiveData observe 方法中传入 viewLifecycleOwner 而不是传入 this</strong></p><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p>首先来看 <code>LiveData</code> 主要的源码结构</p><ul><li>LiveData </li><li>MutableLiveData</li><li>Observer</li></ul><h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p><code>LiveData</code> 是可以在给定生命周期内观察到的数据持有者类。 这意味着可以将一个<code>Observer</code> 与 <code>LifecycleOwner</code> 成对添加，并且只有在配对的 <code>LifecycleOwner</code> 处于活动状态时，才会向该观察者通知有关包装数据的修改。 如果 LifecycleOwner 的状态为 <code>Lifecycle.State.STARTED</code> 或 <code>Lifecycle.State.RESUMED</code>，则将其视为活动状态。 通过 <code>observeForever</code>（Observer）添加的观察者被视为始终处于活动状态，因此将始终收到有关修改的通知。 对于那些观察者，需要手动调用 <code>removeObserver</code>（Observer）</p><p>如果相应的生命周期移至 <code>Lifecycle.State.DESTROYED</code> 状态，则添加了生命周期的观察者将被自动删除。 这对于 activity 和 fragment 可以安全地观察 <code>LiveData</code> 而不用担心泄漏</p><p>此外，<code>LiveData</code> 具有 onActive() 和 onInactive() 方法，以便在活动观察者的数量在 0 到 1 之间变化时得到通知。这使 <code>LiveData</code> 在没有任何活动观察者的情况下可以释放大量资源。</p><p>主要方法有：</p><ul><li>T getValue() 获取LiveData 包装的数据</li><li>observe(LifecycleOwner owner, Observer&lt;? super T&gt; observer) 设置观察者（主线程调用）</li><li>setValue(T value)  设值（主线程调用），可见性为 protected 无法直接使用</li><li>postValue(T value) 设置（其他线程调用），可见性为 protected 无法直接使用</li></ul><h3 id="MutableLiveData"><a href="#MutableLiveData" class="headerlink" title="MutableLiveData"></a>MutableLiveData</h3><p><code>LiveData</code> 实现类，公开了 <code>setValue</code> 和 <code>postValue</code> 方法</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>接口，内部只有 onChanged(T t) 方法，在数据变化时该方法会被调用</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们通过源码来看看 <code>LiveData</code> 如何实现它的特性的</p><ul><li><ol><li>如何控制在 activity 或 fragment 活动状态时接收回调，否则不接收？</li></ol></li><li><ol start="2"><li>如何在 activity 或 fragment 销毁时自动取消注册观察者？</li></ol></li><li><ol start="3"><li>如何保证 <code>LiveData</code> 持有最新的数据？</li></ol></li></ul><p>我们查看 <code>LiveData</code> 的 observe 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LiveData.java</span><br><span class="hljs-meta">@MainThread</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">observe</span><span class="hljs-params">(LifecycleOwner owner, Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;<br>        <span class="hljs-comment">// 如果 owner 已经是 DESTROYED 状态，则忽略</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 使用 LifecycleBoundObserver 包装 owner 和 observer</span><br>    LifecycleBoundObserver wrapper = <span class="hljs-keyword">new</span> LifecycleBoundObserver(owner, observer);<br>    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);<br>    <span class="hljs-comment">// 如果已经添加过直接 return </span><br>    <span class="hljs-keyword">if</span> (existing != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>   <br>    owner.getLifecycle().addObserver(wrapper);<br>&#125;<br><br><span class="hljs-comment">// LifecycleBoundObserver.java</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifecycleBoundObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ObserverWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LifecycleEventObserver</span> </span>&#123;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-keyword">final</span> LifecycleOwner mOwner;<br>    LifecycleBoundObserver(LifecycleOwner owner, Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer) &#123;<br>        <span class="hljs-keyword">super</span>(observer);<br>        mOwner = owner;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过源码我们知道，当我们调用 observe 方法时，内部是通过 <code>LifecycleBoundObserver</code> 将 owner 和 observer 包裹起来并通过 <code>addObserver</code> 方法添加观察者的，因而当数据变化时，会调用 <code>LifecycleBoundObserver</code> 的 <code>onStateChanged</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LiveData.LifecycleBoundObserver.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(@NonNull LifecycleOwner source,<br>        @NonNull Lifecycle.Event event)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;<br>        <span class="hljs-comment">// 自动移除观察者，问题 2 得到解释</span><br>        removeObserver(mObserver);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    activeStateChanged(shouldBeActive());<br>&#125;<br></code></pre></td></tr></table></figure><p>当什么周期所有者处于 <code>DESTROYED</code> 状态时，会调用 <code>removeObserver</code> 方法，因此问题 2  得到解释</p><p>我们继续向下看，<code>activeStateChanged</code> 方法调用时传入了 <code>shouldBeActive()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldBeActive</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 至少是 STARTED 状态 返回 true</span><br>    <span class="hljs-keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activeStateChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> newActive)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (newActive == mActive) &#123;<br>        <span class="hljs-comment">// 与上次值相同，则直接 return （两次均为活动状态或均为非活动状态）</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    mActive = newActive;<br>    <span class="hljs-keyword">boolean</span> wasInactive = LiveData.<span class="hljs-keyword">this</span>.mActiveCount == <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 根据 mActive 修改活动状态观察者的数量（加 1 或减 1 ）</span><br>    LiveData.<span class="hljs-keyword">this</span>.mActiveCount += mActive ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;<br>        onActive();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (LiveData.<span class="hljs-keyword">this</span>.mActiveCount == <span class="hljs-number">0</span> &amp;&amp; !mActive) &#123;<br>        onInactive();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mActive) &#123;<br>        <span class="hljs-comment">// 如果是活动状态，则发送数据，问题 1 得到解释</span><br>        dispatchingValue(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里牵扯了 <code>Lifecycle State</code> 比较的知识，<a href="https://juejin.im/post/5e8348bef265da47e02a6ce2#heading-11" target="_blank" rel="noopener">详情在这</a></p><p>只有 <code>STARTED</code> 和 <code>RESUMED</code> 状态 <code>shouldBeActive()</code> 才返回 true，至此问题 1 得到解释</p><p><code>dispatchingValue</code> 方法内部调用了 <code>considerNotify</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">considerNotify</span><span class="hljs-params">(ObserverWrapper observer)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!observer.mActive) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 再次判断生命周期所有者状态</span><br>    <span class="hljs-keyword">if</span> (!observer.shouldBeActive()) &#123;<br>        observer.activeStateChanged(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 比较版本号</span><br>    <span class="hljs-keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    observer.mLastVersion = mVersion;<br>    <span class="hljs-comment">// 调用我们传入的 mObserver 的 onChanged 方法</span><br>    observer.mObserver.onChanged((T) mData);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>considerNotify</code> 中比较了 observer 的版本号，如果是最新的数据，直接 return</p><p>而 <code>mVersion</code> 在 <code>setValue</code> 方法中 进行更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MainThread</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-comment">// 每次设置对 mVersion 进行++</span><br>    mVersion++;<br>    mData = value;<br>    dispatchingValue(<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此 <code>LiveData</code> 每次都持有最新的数据，问题 3 得到解释</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到本文开头的思考，Android 开发者的主要工作是将数据转换成 UI ，而 <code>LiveData</code> 本质上是一种「数据驱动」，即通过改变状态数据，来驱动视图树中绑定了相应状态数据的控件重新发生绘制。Flutter 和未来的  Jetpack Compose 采用的都是这种机制。使用 ViewModel + LiveData，可以 <strong>安全地在订阅者的生命周期内分发正确的数据</strong>，使开发者不知不觉中完成了 <code>UI -&gt; ViewModel -&gt; Data</code> 的单向依赖。</p><p><strong>所谓架构，很多时候不是使用它能做什么，更多的是不要做什么，使用它时开发者能够得到约束，以便产出更健壮的代码</strong></p><p>各位小伙伴如果有什么想法欢迎在评论区留言</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jetpack LiveData 介绍。&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015101641.png" type="image" />
    
    
      <category term="背上 Jetpack" scheme="https://flywith24.gitee.io/categories/%E8%83%8C%E4%B8%8A-Jetpack/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>万物基于Lifecycle 默默无闻大作用</title>
    <link href="https://flywith24.gitee.io/2020/03/30/Jetpack-Lifecycle/"/>
    <id>https://flywith24.gitee.io/2020/03/30/Jetpack-Lifecycle/</id>
    <published>2020-03-29T16:10:35.000Z</published>
    <updated>2020-10-15T02:32:57.036Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack Lifecycle 介绍。</p><a id="more"></a><blockquote><p> Android 中有一个比较重要的概念：「生命周期」。刚毕业去面试，总会被问到「四大组件的生命周期」这类的问题。17年的 IO 大会上，Google 推出了 Lifecycle-Aware Components（生命周期感知组件），帮助开发者组织更好，更轻量，易于维护的代码</p></blockquote><p>本文介绍 <code>Lifecycle</code> 的职责以及简单分析 lifecycle 如何感知 activity 和 fragment ，帮助您对 <code>Lifecycle</code> 有一个感性的认识</p><h2 id="万物基于-Lifecycle"><a href="#万物基于-Lifecycle" class="headerlink" title="万物基于 Lifecycle"></a>万物基于 <strong>Lifecycle</strong></h2><h3 id="手动管理生命周期的痛苦你不懂"><a href="#手动管理生命周期的痛苦你不懂" class="headerlink" title="手动管理生命周期的痛苦你不懂"></a>手动管理生命周期的痛苦你不懂</h3><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/30/1712bbbbf69f3b1e?w=2407&h=5062&f=jpeg&s=2270014" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="lifecycles"></p><blockquote><p> 鲁迅曾说过：万物基于 Lifecycle</p></blockquote><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331214314.jpeg" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>哦不对</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200331214054.jpeg" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>Android 中的视图控制器就有这么多生命周期的情况，所以处理好生命周期十分重要，否则会导致内存泄漏甚至是程序崩溃。这里引用 <a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">官方文档</a> 的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLocationListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyLocationListener</span><span class="hljs-params">(Context context, Callback callback)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 连接系统的定位服务</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 与系统的定位服务断开连接</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> MyLocationListener myLocationListener;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(...)</span> </span>&#123;<br>        myLocationListener = <span class="hljs-keyword">new</span> MyLocationListener(<span class="hljs-keyword">this</span>, (location) -&gt; &#123;<br>            <span class="hljs-comment">// 更新 UI</span><br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onStart();<br>        myLocationListener.start();<br>        <span class="hljs-comment">//管理其他需要响应 activity 生命周期的组件</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onStop();<br>        myLocationListener.stop();<br>        <span class="hljs-comment">//管理其他需要响应 activity 生命周期的组件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此示例看起来不错，在实际的应用程序中，您仍然会响应生命周期的当前状态而进行过多的调用来管理 UI 和其他组件。 管理多个组件会在生命周期方法中放置大量代码，例如 onStart() 和 onStop()，这使它们难以维护</p><p>而且，不能保证组件在 activity 或 fragment 停止之前就已启动。 如果我们需要执行长时间运行的操作（例如onStart() 中的某些配置检查），则可能会导致争用情况，其中onStop() 方法在 onStart() 之前完成，从而使组件的生存期超过了所需的生存期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> MyLocationListener myLocationListener;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(...)</span> </span>&#123;<br>        myLocationListener = <span class="hljs-keyword">new</span> MyLocationListener(<span class="hljs-keyword">this</span>, location -&gt; &#123;<br>            <span class="hljs-comment">// 更新 UI</span><br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onStart();<br>        Util.checkUserStatus(result -&gt; &#123;<br>            <span class="hljs-comment">// 如果在 activity 停止后调用此回调怎么办？</span><br>            <span class="hljs-keyword">if</span> (result) &#123;<br>                myLocationListener.start();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onStop();<br>        myLocationListener.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有所有的组件，都能感知外部的生命周期，能在相应的时机释放资源，并且在错过生命周期时能及时叫停异步的任务就好了，</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200326095005.gif" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我们不妨先思考一下，如果实现这样的想法，应该如何做</p><h3 id="按照惯例的思考"><a href="#按照惯例的思考" class="headerlink" title="按照惯例的思考"></a>按照惯例的思考</h3><p>首先我们先来整理一下我们的需求</p><ul><li>内部组件能够感知外部的生命周期</li><li>能够统一地管理，做到一处修改，处处生效</li><li>能够及时叫停错过的任务</li></ul><p>针对需求1，可以用观察者模式，内部组件能够在外部生命周期变化时做出相应</p><p>针对需求2，可以将依赖组件的代码移出生命周期方法内，然后移入组件本身，这样只需修改组件内部逻辑即可</p><p>针对需求3，可以在合适的时机移除观察者</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>关于开发者模式，我第一次比较详细的了解是在 <a href="https://juejin.im/user/552f20a7e4b060d72a89d87f" target="_blank" rel="noopener">扔物线</a> 的 <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a>。</p><blockquote><p>观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者（例如 A 不需要每过 2ms 就检查一次 B 的状态），而是采用<strong>注册</strong>(Register)<strong>或者称为</strong>订阅<strong>(Subscribe)</strong>的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 <code>OnClickListener</code> 。对设置 <code>OnClickListener</code> 来说， <code>View</code> 是被观察者， <code>OnClickListener</code> 是观察者，二者通过 <code>setOnClickListener()</code> 方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 <code>OnClickListener</code> 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷『你在作案的时候务必通知我』。</p></blockquote><p>OnClickListener 的模式大致如下图：</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200326103024.jpg" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>上述描述及图片均来自 <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></p></blockquote><p><strong>因此在生命周期组件的生命周期发生变化时告诉观察者，内部组件即可感知外部的生命周期</strong></p><h3 id="引入-Lifecycle-后"><a href="#引入-Lifecycle-后" class="headerlink" title="引入 Lifecycle 后"></a>引入 Lifecycle 后</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LifecycleObserver</span> </span>&#123;<br>    <span class="hljs-meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectListener</span><span class="hljs-params">()</span> </span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">disconnectListener</span><span class="hljs-params">()</span> </span>&#123;<br>        ...<br>    &#125;<br>&#125;<br><br>myLifecycleOwner.getLifecycle().addObserver(<span class="hljs-keyword">new</span> MyObserver());<br></code></pre></td></tr></table></figure><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200326134237.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>这是 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>  的结构，抽象类，其内部有两个枚举，分别代表着「事件」和「状态」，此外还有三个方法，添加/移除观察者，获取当前状态</p><blockquote><p><strong>注意，这里 State 中的枚举顺序是有意义的，后文详细介绍</strong></p></blockquote><p>其实现类为  <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleRegistry" target="_blank" rel="noopener">LifecycleRegistry</a> ，可以处理多个观察者</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200326135029.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="LifecycleRegistry"></p><p>其内部持有当前的状态 mState ，LifecycleOwner 以及观察者的自定义列表，同时重写了父类的添加/删除观察者的方法</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200326135636.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="LifecycleOwner"></p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a> ，具有 Android 的生命周期，定制组件可以使用这些事件来处理生命周期更改，而无需在 Activity 或 Fragment 中实现任何代码</p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="noopener">LifecycleObserver</a> ，将一个类标记为 <code>LifecycleObserver</code>。 它没有任何方法，而是依赖于 OnLifecycleEvent 注解的方法</p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver" target="_blank" rel="noopener">LifecycleEventObserver</a> ，可以接收任何生命周期更改并将其分派给接收方。</p><p><strong>如果一个类实现此接口并同时使用 OnLifecycleEvent，则注解将被忽略</strong></p><p><a href="https://developer.android.com/reference/androidx/lifecycle/DefaultLifecycleObserver" target="_blank" rel="noopener">DefaultLifecycleObserver</a> ，用于监听 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a> 状态更改的回调接口。</p><p>如果一个类同时实现了此接口和 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver" target="_blank" rel="noopener">LifecycleEventObserver</a>，则将首先调用<code>DefaultLifecycleObserver</code> 的方法，然后再调用LifecycleEventObserver.onStateChanged（LifecycleOwner，Lifecycle.Event）</p><blockquote><p>注意：使用 <a href="https://developer.android.com/reference/androidx/lifecycle/DefaultLifecycleObserver" target="_blank" rel="noopener">DefaultLifecycleObserver</a> 需引入</p><p> implementation “androidx.lifecycle:lifecycle-common-java8:$lifecycle_version”</p></blockquote><h2 id="简单的源码分析"><a href="#简单的源码分析" class="headerlink" title="简单的源码分析"></a>简单的源码分析</h2><h3 id="activity-生命周期处理"><a href="#activity-生命周期处理" class="headerlink" title="activity 生命周期处理"></a>activity 生命周期处理</h3><p>首先我们还是来看 <strong>androidx.activity.ComponentActivity</strong> ，这个类我们这个系列的文章里提到多次，第一次提及是在 <a href="https://juejin.im/post/5e738d12518825495d69cfb9#heading-2" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a> ，感兴趣的小伙伴可以看看。</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200327104836.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ComponentActivity"></p><p>其实现的接口大多数我们都已经探讨过了，今天我们来看看 LifecycleOwner</p><blockquote><p>ActivityResultCaller 为 activity 1.2.0-alpha02 推出的，旨在统一 onActivityResult ，这里暂时不讨论它</p></blockquote><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200327105352.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>既然实现了 <code>LifecycleOwner</code> 接口，必定重写 getLifecycle() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// androidx.activity.ComponentActivity.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LifecycleRegistry mLifecycleRegistry = <span class="hljs-keyword">new</span> LifecycleRegistry(<span class="hljs-keyword">this</span>);<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Lifecycle <span class="hljs-title">getLifecycle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mLifecycleRegistry;<br>&#125;<br></code></pre></td></tr></table></figure><p>其返回的 <code>Lifecycle</code> 为 实现类 <code>LifecycleRegistry</code> 的实例</p><p>而 activity 操作生命周期是通过 <code>ReportFragment</code> 处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// androidx.activity.ComponentActivity.java</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    ReportFragment.injectIfNeededIn(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// ReportFragment</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injectIfNeededIn</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">29</span>) &#123;<br>        <span class="hljs-comment">// api 29 及以上 直接注册正确的生命周期回调</span><br>        activity.registerActivityLifecycleCallbacks(<br>                <span class="hljs-keyword">new</span> LifecycleCallbacks());<br>    &#125;<br>    android.app.FragmentManager manager = activity.getFragmentManager();<br>    <span class="hljs-keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="hljs-keyword">null</span>) &#123;<br>        manager.beginTransaction().add(<span class="hljs-keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();<br>        manager.executePendingTransactions();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200327113340.png" src="/2020/03/30/Jetpack-Lifecycle/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ReportFragment.java</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(@NonNull Activity activity, @NonNull Lifecycle.Event event)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">instanceof</span> LifecycleRegistryOwner) &#123;<br>        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">instanceof</span> LifecycleOwner) &#123;<br>        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();<br>        <span class="hljs-keyword">if</span> (lifecycle <span class="hljs-keyword">instanceof</span> LifecycleRegistry) &#123;<br>            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(@NonNull Lifecycle.Event event)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">29</span>) &#123;<br>        dispatch(getActivity(), event);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onActivityCreated(savedInstanceState);<br>    dispatch(Lifecycle.Event.ON_CREATE);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onStart();<br>    dispatch(Lifecycle.Event.ON_START);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onResume();<br>    dispatch(Lifecycle.Event.ON_RESUME);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onPause();<br>    dispatch(Lifecycle.Event.ON_PAUSE);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onStop();<br>    dispatch(Lifecycle.Event.ON_STOP);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onDestroy();<br>    dispatch(Lifecycle.Event.ON_DESTROY);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LifecycleCallbacks</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifecycleCallbacks</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Application</span>.<span class="hljs-title">ActivityLifecycleCallbacks</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPostCreated</span><span class="hljs-params">(@NonNull Activity activity,<br>            @Nullable Bundle savedInstanceState)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_CREATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPostStarted</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_START);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPostResumed</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_RESUME);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPrePaused</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_PAUSE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPreStopped</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_STOP);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPreDestroyed</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>        dispatch(activity, Lifecycle.Event.ON_DESTROY);<br>    &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 activity 的 onCreate 方法中，调用了 <code>ReportFragment</code> 中的静态方法 <code>injectIfNeededIn()</code> 。而其内部，<strong>如果 api 29 及以上的设备上直接注册正确的生命周期回调，低版本通过启动 ReportFragment ，借助 fragment 各个生命周期来处理生命周期回调</strong></p><h3 id="fragment-生命周期处理"><a href="#fragment-生命周期处理" class="headerlink" title="fragment 生命周期处理"></a>fragment 生命周期处理</h3><p>在 fragment 内部，每个生命周期节点调用 <code>handleLifecycleEvent</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Fragment.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fragment</span><span class="hljs-params">()</span> </span>&#123;<br>    initLifecycle();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initLifecycle</span><span class="hljs-params">()</span> </span>&#123;<br>    mLifecycleRegistry = <span class="hljs-keyword">new</span> LifecycleRegistry(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Lifecycle <span class="hljs-title">getLifecycle</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mLifecycleRegistry;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    onCreate(savedInstanceState);<br>mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performStart</span><span class="hljs-params">()</span> </span>&#123;<br>    onStart();<br>    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performResume</span><span class="hljs-params">()</span> </span>&#123;<br>    onResume();<br>    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performPause</span><span class="hljs-params">()</span> </span>&#123;<br>    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);<br>    onPause();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performStop</span><span class="hljs-params">()</span> </span>&#123;<br>    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);<br>    onStop();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);<br>    onDestroy();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Lifecycle-State-大小比较"><a href="#Lifecycle-State-大小比较" class="headerlink" title="Lifecycle State 大小比较"></a>Lifecycle State 大小比较</h3><p><code>Lifecycle.State</code>  中有一个 <code>isAtLeast</code> 方法，用于判断当前状态是否不小于传入的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lifecycle.State</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAtLeast</span><span class="hljs-params">(@NonNull State state)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> compareTo(state) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>枚举的 compareTo 方法其实是比较的枚举声明的顺序</strong></p><p>而 State 的顺序为 DESTROYED -&gt; INITIALIZED -&gt; CREATED -&gt; STARTED -&gt; RESUMED</p><blockquote><p>如果传入的 state 为 STARTED，则当前状态为 STARTED 或 RESUMED 时返回 true ，否则返回 false</p><p>LiveData 篇会用到这个知识点</p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 关于我</span></h2><p>我是 <a href="https://flywith24.gitee.io/">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jetpack Lifecycle 介绍。&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015101301.png" type="image" />
    
    
      <category term="背上 Jetpack" scheme="https://flywith24.gitee.io/categories/%E8%83%8C%E4%B8%8A-Jetpack/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>即使您不使用MVVM也要了解ViewModel ViewModel的职能边界</title>
    <link href="https://flywith24.gitee.io/2020/03/23/Jetpack-ViewModel/"/>
    <id>https://flywith24.gitee.io/2020/03/23/Jetpack-ViewModel/</id>
    <published>2020-03-22T16:10:35.000Z</published>
    <updated>2020-10-15T02:32:26.567Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack ViewModel 的职能边界。</p><a id="more"></a><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200324083031.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="目录"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Android 开发时，我们使用 activity 和 fragment 作为视图控制器， 可能还会使用有一些类可以存储和提供 UI 数据（例如MVP中的 <code>Presenter</code> ）</p></blockquote><p>但是 当配置更改时（如旋转屏幕），activity 会重建，但对于 UI 数据的持有者呢？</p><ul><li>开发者需要重新保存相关的信息并传递给重建的 activity ，否则开发者必须再次获取数据（通过网络请求或本地数据库）</li><li>由于 UI 数据的持有者的生命周期可能比 activity 长，因此开发者还需要避免出现内存泄漏的问题</li></ul><p>如何解决上述问题？ViewModel</p><p><strong>本文重点介绍 ViewModel 的职责（what）以及重点功能的实现原理（how），即使您不使用 <code>Jetpack MVVM</code> 架构，也要了解一下 ViewModel</strong></p><p>ViewModel 的原理部分要求您了解 activity 的启动流程，这部分内容网上文章很多，本文不再赘述</p><!-- more--><h2 id="ViewModel-的职责"><a href="#ViewModel-的职责" class="headerlink" title="ViewModel 的职责"></a>ViewModel 的职责</h2><p>我先上个 <a href="https://www.bilibili.com/video/av97794796/" target="_blank" rel="noopener">视频</a> ，这个小姐姐表述的比文字更形象</p><p><a href="https://www.bilibili.com/video/av97794796/" target="_blank" rel="noopener"><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321135602.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></a></p><p><code>ViewModel</code> 主要用于存储 UI 数据以及生命周期感知的数据</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321140300.gif" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>图片来自 <a href="https://android.jlelse.eu/android-architecture-components-viewmodel-e74faddf5b94" target="_blank" rel="noopener">Android Architecture Components: ViewModel</a></p></blockquote><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321140641.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ViewModel生命周期"></p><blockquote><p><code>ViewModel</code> 的生命周期 ，图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#lifecycle" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="作为数据持有者"><a href="#作为数据持有者" class="headerlink" title="作为数据持有者"></a>作为数据持有者</h3><p><code>ViewModel</code> 能够实时进行配置更改。 这意味着即使在手机旋转后销毁并重新创建 activity 之后，您仍然拥有相同的 <code>ViewModel</code> 和相同的数据。 因此：</p><ul><li>您无需担心 UI 数据持有者的生命周期。 <code>ViewModel</code> 将由工厂自动创建，您无需自行创建和销毁</li><li>数据将始终更新，旋转手机后，您将获得与以前相同的数据。 因此，您无需手动将数据传递给新的 activity 实例或再次调用网络或数据库来获取数据。 </li></ul><h3 id="Fragment-间共享数据"><a href="#Fragment-间共享数据" class="headerlink" title="Fragment 间共享数据"></a>Fragment 间共享数据</h3><p>一个 activity 中的两个或更多 fragment 需要相互通信是很常见的。例如您有一个片段，用户在其中从列表中选择一个 item，另一个片段显示了所选 item 的内容。 传统做法两个 fragment 都需要定义一些接口，并且宿主 activity 必须将两者绑定在一起。 此外，两个 fragment 都必须处理另一个 fragment 尚未创建或不可见的情况。</p><p>可以通过使用 <code>ViewModel</code> 对象解决此问题。 这些 fragment 可以使用 activity 范围内共享一个 <code>ViewModel</code> 来处理此通信，如以下示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModel</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="hljs-keyword">new</span> MutableLiveData&lt;Item&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(Item item)</span> </span>&#123;<br>        selected.setValue(item);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LiveData&lt;Item&gt; <span class="hljs-title">getSelected</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> selected;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MasterFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> SharedViewModel model;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(@NonNull View view, Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState);<br>        model = <span class="hljs-keyword">new</span> ViewModelProvider(requireActivity()).get(SharedViewModel.class);<br>        itemSelector.setOnClickListener(item -&gt; &#123;<br>            model.select(item);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(@NonNull View view, Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState);<br>        SharedViewModel model = <span class="hljs-keyword">new</span> ViewModelProvider(requireActivity()).get(SharedViewModel.class);<br>        model.getSelected().observe(getViewLifecycleOwner(), &#123; item -&gt;<br>           <span class="hljs-comment">// Update the UI.</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于 两个 fragment 使用的都是 activity 范围的 <code>ViewModel</code> （<code>ViewModelProvider</code> 构造器传入的 activity ），因此它们获得了相同的 ViewModel 实例，自然其持有的数据也是相同的，这也 <strong>保证了数据的一致性</strong></p></blockquote><p>这种方法具有以下优点：</p><ul><li><p>宿主 activity 无需执行任何操作，也无需了解此通信。</p></li><li><p>除 <code>SharedViewModel</code> 外，fragment 不需要彼此了解。 如果其中一个 fragment 消失了，则另一个继续照常工作。</p></li><li><p>每个 fragment 都有其自己的生命周期，并且不受另一个 fragment 的生命周期影响。 如果一个 fragment 替换了另一个 fragment，则 UI 可以继续正常工作而不会出现任何问题。</p></li></ul><h3 id="代替-Loader"><a href="#代替-Loader" class="headerlink" title="代替 Loader"></a>代替 Loader</h3><p><code>CursorLoader</code> 这样的 Loader 类经常用于使应用程序 UI 中的数据与数据库保持同步。您可以使用 <code>ViewModel</code> 和其他一些类来替换 Loader。 使用 <code>ViewModel</code> 可将视图控制器与数据加载操作分开，这意味着您在类之间的强引用较少。</p><p>在使用 Loader 的一种常见方法中，应用程序可能会使用 <code>CursorLoader</code> 来观察数据库的内容。 当数据库中的值更改时，加载程序会自动触发数据的重新加载并更新 UI</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321144832.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#loaders" target="_blank" rel="noopener">官方文档</a></p></blockquote><p><code>ViewModel</code> 与 <code>Room</code> 和 <code>LiveData</code> 一起使用以替换 Loader。 <code>ViewModel</code> 确保数据在设备配置更改后仍然存在。 当数据库发生更改时，<code>Room</code> 会通知 <code>LiveData</code> ，然后 <code>LiveData</code> 会使用修改后的数据更新 UI</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321144949.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#loaders" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>ViewModel 可作为 UI 数据的持有者，在 activity/fragment 重建时 ViewModel 中的数据不受影响，同时可以避免内存泄漏</strong></li><li><strong>可以通过 ViewModel 来进行 activity 和 fragment ，fragment 和 fragment 之间的通信，无需关心通信的对方是否存在，使用 application 范围的 ViewModel 可以进行全局通信</strong></li><li><strong>可以代替 Loader</strong></li></ul><h2 id="ViewModel-源码分析"><a href="#ViewModel-源码分析" class="headerlink" title="ViewModel 源码分析"></a>ViewModel 源码分析</h2><p>分析源码时我们可以不计较细枝末节，只分析主要的逻辑即可。因此我们来思考几个问题，并从源码中寻找答案</p><ul><li><p>如何做到 activity 重建后 <code>ViewModel</code> 仍然存在？</p></li><li><p>如何做到 fragment 重建后 <code>ViewModel</code> 仍然存在？</p></li><li><p>如何控制作用域？（即保证相同作用域获取的 <code>ViewModel</code> 实例相同）</p></li><li><p>如何避免内存泄漏？</p></li></ul><p>维持我们一贯的风格，我们先来大胆地猜一猜</p><p>对于问题1 ：activity 有着 <code>saveInstanceState</code> 机制，因此可能通过该机制来处理（<strong>事实证明不是</strong>）</p><p>对于问题2：可能 fragment 通过 宿主 activity 或 父 fragment 的帮助来确保 <code>ViewModel</code> 实例在重建后仍然存在</p><p>对于问题3：实现一个类似单例的效果，相同作用域获取的对象是相同的</p><p>对于问题4：避免 <code>ViewModel</code> 持有 view 或 context 的引用</p><p>首先我们要先了解一下 <code>ViewModel</code> 的结构</p><ul><li><p><code>ViewModel</code>：抽象类，主要有 clear 方法，它是 final 级，不可修改，clear 方法中包含 onClear 钩子，开发者可重写 onClear 方法来自定义数据的清空</p></li><li><p><code>ViewModelStore</code>：内部维护一个 HashMap 以管理 <code>ViewModel</code></p></li><li><p><code>ViewModelStoreOwner</code>：接口，<code>ViewModelStore</code> 的作用域，实现类为 <code>ComponentActivity</code> 和 <code>Fragment</code>，此外还有 <code>FragmentActivity.HostCallbacks</code></p></li><li><p><code>ViewModelProvider</code>：用于创建 <code>ViewModel</code>，其构造方法有两个参数，第一个参数传入 <code>ViewModelStoreOwner</code> ，确定了 <code>ViewModelStore</code> 的作用域，第二个参数为 <code>ViewModelProvider.Factory</code>，用于初始化 <code>ViewModel</code> 对象，默认为 <code>getDefaultViewModelProviderFactory()</code> 方法获取的 factory</p></li></ul><p>简单来说 <strong>ViewModelStoreOwner 持有 ViewModelStore 持有 ViewModel</strong></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321152406.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h3 id="1-如何做到-activity-重建后-ViewModel-仍然存在？"><a href="#1-如何做到-activity-重建后-ViewModel-仍然存在？" class="headerlink" title="1. 如何做到 activity 重建后 ViewModel 仍然存在？"></a>1. 如何做到 activity 重建后 ViewModel 仍然存在？</h3><p>在 <a href="https://juejin.im/post/5e738d12518825495d69cfb9" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a> 中我们提到了 androidx.core.app.ComponentActivity 的引入并探讨了其作为中间层的作用</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200321155215.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>我们已经讲过 <code>SavedStateRegistryOwner</code> 和 <code>OnBackPressedDispatcherOwner</code> 这两种角色，而今天我们来聊一下</p><p><code>ViewModelStoreOwner</code> 和 <code>HasDefaultViewModelProviderFactory</code> 。其中前者代表着 <code>ViewModelStore</code> 的作用域，后者来标记 <code>ViewModelStoreOwner</code> 拥有默认的 <code>ViewModelProvider.Factory</code></p><p>那么 <code>ViewModel</code> 的逻辑肯定就在该类了</p><p><code>ComponentActivity</code> 实现了 <code>ViewModelStoreOwner</code>  接口，意味着需要重写 <code>getViewModelStore()</code> 方法，该方法为 <code>ComponentActivity</code>  的 <code>mViewModelStore</code> 变量赋值。<strong>activity 重建后 ViewModel 仍然存在，只要保证 activity 重建后 mViewModelStore 变量值不变即可</strong></p><p>顺着这个思路，我们来看一下 <code>getViewModelStore()</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ViewModelStore <span class="hljs-title">getViewModelStore</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mViewModelStore == <span class="hljs-keyword">null</span>) &#123;<br>        NonConfigurationInstances nc =<br>                (NonConfigurationInstances) getLastNonConfigurationInstance();<br>        <span class="hljs-keyword">if</span> (nc != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//核心，在该位置重置 mViewModelStore</span><br>            mViewModelStore = nc.viewModelStore;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mViewModelStore == <span class="hljs-keyword">null</span>) &#123;<br>            mViewModelStore = <span class="hljs-keyword">new</span> ViewModelStore();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mViewModelStore;<br>&#125;<br></code></pre></td></tr></table></figure><p>即 <code>mViewModelStore</code> 的值由 <code>getLastNonConfigurationInstance()</code> 返回的 <code>NonConfigurationInstances</code> 对象中的 <code>viewModelStore</code> 赋值，如果此时还为空才去 new ViewModelStore 对象。因此我们只需找到 </p><p><code>getLastNonConfigurationInstance</code> 中的 <code>NonConfigurationInstances</code> 在哪里保存的即可</p><p><code>getLastNonConfigurationInstance</code> 为平台 activity 中的方法，返回 <code>mLastNonConfigurationInstances.activity</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getLastNonConfigurationInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mLastNonConfigurationInstances != <span class="hljs-keyword">null</span><br>            ? mLastNonConfigurationInstances.activity : <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们看一下 <code>mLastNonConfigurationInstances</code> 的赋值位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//省略其他参数</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(NonConfigurationInstances lastNonConfigurationInstances)</span></span>&#123;<br>mLastNonConfigurationInstances = lastNonConfigurationInstances;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>了解过 activity 的启动流程的小伙伴肯定知道，这个 attach 方法是 <code>ActivityThread</code> 中的 <code>performLaunchActivity</code> 调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;<br>    Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);<br>    <span class="hljs-comment">//省略其他参数</span><br>    activity.attach(r.lastNonConfigurationInstances);<br>    r.lastNonConfigurationInstances = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>深入追踪源码我们整理一下调用流程</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200323114334.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>由于 <code>ActivityThread</code> 中的 <code>ActivityClientRecord</code> 不受 activity 重建的影响，所以 activity 重建时 <code>mLastNonConfigurationInstances</code> 能够得到上一次的值，使得 <code>ViewModelStore</code> 值不变 ，问题1就解决了</p><h3 id="2-如何做到-fragment-重建后-ViewModel-仍然存在？"><a href="#2-如何做到-fragment-重建后-ViewModel-仍然存在？" class="headerlink" title="2. 如何做到 fragment 重建后 ViewModel 仍然存在？"></a>2. 如何做到 fragment 重建后 ViewModel 仍然存在？</h3><p>对于问题2，有了上面的思路我们可以认定 fragment 重建后其内部的 <code>getViewModelStore()</code> 方法返回的对象是相同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Fragment.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ViewModelStore <span class="hljs-title">getViewModelStore</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mFragmentManager.getViewModelStore(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>getViewModelStore()</code> 内部调用的是 <code>mFragmentManager</code>（普通fragment 对应 activity 中的 <code>FragmentManager</code>，子 fragment 则对应父 fragment 的 <code>childFragmentManager</code>）的 <code>getViewModelStore()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FragmentManager.java</span><br><span class="hljs-keyword">private</span> FragmentManagerViewModel mNonConfig;<br><br><span class="hljs-function">ViewModelStore <span class="hljs-title">getViewModelStore</span><span class="hljs-params">(@NonNull Fragment f)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mNonConfig.getViewModelStore(f);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>而 FragmentManager 中的 getViewModelStore 使用的是 mNonConfig ，mNonConfig 竟然是个 ViewModel！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FragmentManagerViewModel.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashMap&lt;String, ViewModelStore&gt; mViewModelStores = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br></code></pre></td></tr></table></figure><p><code>FragmentManagerViewModel</code> 管理着内部的 <code>ViewModelStore</code> 和 child 的 <code>FragmentManagerViewModel</code> 。因此保证 mNonConfig   值不变即能确保 fragment 中的 <code>getViewModelStore()</code>  不变。那么看看 mNonConfig  赋值的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FragmentManager.java</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attachController</span><span class="hljs-params">(@NonNull FragmentHostCallback&lt;?&gt; host, @NonNull FragmentContainer container, @Nullable <span class="hljs-keyword">final</span> Fragment parent)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 嵌套 fragment 的情况，有父 fragment</span><br>        mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (host <span class="hljs-keyword">instanceof</span> ViewModelStoreOwner) &#123;<br>        <span class="hljs-comment">// host 是 FragmentActivity.HostCallbacks</span><br>        ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();<br>        mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mNonConfig = <span class="hljs-keyword">new</span> FragmentManagerViewModel(<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// FragmentManagerViewModel.java</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> FragmentManagerViewModel <span class="hljs-title">getInstance</span><span class="hljs-params">(ViewModelStore viewModelStore)</span> </span>&#123;<br>    ViewModelProvider viewModelProvider = <span class="hljs-keyword">new</span> ViewModelProvider(viewModelStore,<br>            FACTORY);<br>    <span class="hljs-keyword">return</span> viewModelProvider.get(FragmentManagerViewModel.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先看 fragment 的直接宿主是 activity （即没有嵌套）的情况，mNonConfig 由<code>FragmentManagerViewModel.getInstance(viewModelStore)</code> 赋值，而 getInstance 中使用的是 <code>ViewModelProvider</code> 获取 <code>ViewModel</code> ，根据我们上面的分析，<strong>只要保证作用域（viewModelStore）相同，即可获取相同的 <code>ViewModel</code> 实例</strong>，因此我们需要看一下 host 的 getViewModelStore 方法。经过一番寻找，host 是 <code>FragmentActivity.HostCallbacks</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FragmentActivity.java 内部类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HostCallbacks</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FragmentHostCallback</span>&lt;<span class="hljs-title">FragmentActivity</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewModelStoreOwner</span>, <span class="hljs-title">OnBackPressedDispatcherOwner</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewModelStore <span class="hljs-title">getViewModelStore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 宿主 activity 的 getViewModelStore</span><br>    <span class="hljs-keyword">return</span> FragmentActivity.<span class="hljs-keyword">this</span>.getViewModelStore();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>host 的 getViewModelStore 方法返回的是宿主 activity 的 <code>getViewModelStore()</code> ，而 activity 重建后其内部的 <code>mViewModelStore</code> 是不变的，因此即使 activity 重建，其内部的 FragmentManager 对象变化，但 FragmentManager 内部的  FragmentManagerViewModel 的实例（<code>mNonConfig</code>）不变，mNonConfig.getViewModelStore 不变，fragment 的 <code>getViewModelStore()</code> 亦不变，fragment 重建后其内部的 <code>ViewModel</code> 仍然存在</p><p>对于嵌套 fragment ，mNonConfig 通过 parent.mFragmentManager.getChildNonConfig(parent) 获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FragmentManager.java</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> FragmentManagerViewModel <span class="hljs-title">getChildNonConfig</span><span class="hljs-params">(@NonNull Fragment f)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mNonConfig.getChildNonConfig(f);<br>&#125;<br></code></pre></td></tr></table></figure><p>上文提到 <code>FragmentManagerViewModel</code> 管理着 mChildNonConfigs Map，因此子 fragment 重置后其内部的 mNonConfig 对象也是相同的</p><p>至此问题 2 就解决了</p><h3 id="3-如何控制作用域？"><a href="#3-如何控制作用域？" class="headerlink" title="3. 如何控制作用域？"></a>3. 如何控制作用域？</h3><p>对于问题3，我们知道 <code>ViewModelStoreOwner</code> 代表着作用域，其内部唯一的方法返回 <code>ViewModelStore</code> 对象，也即不同的作用域对应不同的 <code>ViewModelStore</code> ，而 <code>ViewModelStore</code>  内部维护着 <code>ViewModel</code> 的 HashMap ，因此只要保证相同作用域的 <code>ViewModelStore</code> 对象相同就能保证相同作用域获取到相同的 <code>ViewModel</code> 对象，而问题1我们已经解释了重建时如何保证 <code>ViewModelStore</code>  对象不变。</p><p>因此问题3也解决了。</p><h3 id="4-如何避免内存泄漏？"><a href="#4-如何避免内存泄漏？" class="headerlink" title="4. 如何避免内存泄漏？"></a>4. 如何避免内存泄漏？</h3><p>对于问题4，由于 <code>ViewModel</code> 的设计，使得 activity/fragment 依赖它，而 <code>ViewModel</code> 不依赖视图控制器。因此只要不让 <code>ViewModel</code> 持有 context 或 view 的引用，就不会造成内存泄漏</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>简单的总结一下：</p><ul><li><p><strong>activity 重建后 mViewModelStore 通过 ActivityThread 的一系列方法能够保持不变，从而当 activity 重建时 ViewModel 中的数据不受影响</strong></p></li><li><p><strong>通过宿主 activity 范围内共享的 FragmentManagerViewModel 来存储 fragment 的 ViewModelStore 和子fragment 的 FragmentManagerViewModel ，而 activity 重建后 FragmentManagerViewModel  中的数据不受影响，因此 fragment 内部的 ViewModel 的数据也不受影响</strong></p></li><li><p><strong>通过同一 ViewModelStoreOwner 获取的 ViewModelStore 相同，从而保证同一作用域通过 ViewModelProvider 获取的ViewModel 对象是相同的</strong></p></li><li><p><strong>通过单向依赖（视图控制器持有 ViewModel ）来解决内存泄漏的问题</strong></p></li></ul><h2 id="ViewModel-和-onSaveInstanceState"><a href="#ViewModel-和-onSaveInstanceState" class="headerlink" title="ViewModel 和 onSaveInstanceState"></a>ViewModel 和 onSaveInstanceState</h2><p><code>ViewModel</code> 和 <code>onSaveInstanceState</code> 的功能有些类似，但它们也有很多差异</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200323160417.png" src="/2020/03/23/Jetpack-ViewModel/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>从存储位置上来说，<code>ViewModel</code> 是在内存中，因此其读写速度更快，但当进程被系统杀死后，<code>ViewModel</code> 中的数据也不存在了。从数据存储的类型上来看，<code>ViewModel</code> 适合存储相对较重的数据，例如网络请求到的 list 数据，而 <code>onSaveInstanceState</code> 适合存储轻量可序列化的数据</p><p>那么我们该如何使用呢？可以使用 <code>viewmodel-savedstate</code> 库，详情参考 <a href="https://juejin.im/post/5e738d12518825495d69cfb9#heading-10" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a></p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jetpack ViewModel 的职能边界。&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015100650.png" type="image" />
    
    
      <category term="背上 Jetpack" scheme="https://flywith24.gitee.io/categories/%E8%83%8C%E4%B8%8A-Jetpack/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</title>
    <link href="https://flywith24.gitee.io/2020/03/19/Jetpack-ViewModel-SaveState/"/>
    <id>https://flywith24.gitee.io/2020/03/19/Jetpack-ViewModel-SaveState/</id>
    <published>2020-03-18T16:10:35.000Z</published>
    <updated>2020-10-15T02:32:34.571Z</updated>
    
    <content type="html"><![CDATA[<p>绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>大家都知道 activity 有着一套 <code>onSaveInstanceState-onRestoreInstanceState</code> 状态保存机制，旨在「系统资源回收」或「配置发生变化」保存状态，为用户提供更好的体验</p><p>在 androidx 下，提供了 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 库帮助 activity 和 fragment 处理状态保存和恢复</p></blockquote><p>本文默认您对状态保存机制有一定了解，这部分内容请移步 <a href="https://developer.android.com/topic/libraries/architecture/saving-states" target="_blank" rel="noopener">Saving UI States</a></p><p>此外，关于 android 下的进程管理，推荐 Ian Lake 的 <a href="https://medium.com/androiddevelopers/who-lives-and-who-dies-process-priorities-on-android-cb151f39044f" target="_blank" rel="noopener">Who lives and who dies? Process priorities on Android</a></p><p>本文介绍了 androidx 下 <code>SavedState</code> 如何帮助 activity 和 fragment 处理状态的保存和恢复，同时介绍 <code>viewmodel-savedstate</code> 库，以及在开发过程中正确使用状态保存的姿势</p><!-- more--><h2 id="软件工程中没有什么是中间层解决不了的"><a href="#软件工程中没有什么是中间层解决不了的" class="headerlink" title="软件工程中没有什么是中间层解决不了的"></a>软件工程中没有什么是中间层解决不了的</h2><p>在分析 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 库之前我们需要简单聊一聊 <code>ComponentActivity</code></p><p>androidx activity 1.0.0 时，<code>ComponentActivity</code> 成为了 <code>FragmentActivity</code> 和 <code>AppCompatActivity</code> 的基类。</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318211230.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="androidx activity 1.0.0 "></p><p>俗话说「百因必有果」，带着强烈的好奇心，我查了一下 ComponentActivity 引入的原因。</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318211823.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318211806.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>可以看到 <code>ComponentActivity</code> 继承了 androidx.core.app.ComponentActivity(在fragment库中)，并且最初仅实现了<code>LifecycleOwner</code> 接口</p><p>我们创建的 activity 的继承关系现在变成了这样：</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318213053.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>那么回到最初的问题，为什么要引入 <code>ComponentActivity</code> ？其实看看现在 <code>ComponentActivity</code> 的类结构答案就很清楚了</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318213151.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><code>ComponentActivity</code> 实现了五个接口，代表着其除了 activity 还充当着五种角色。本着职能单一原则，官方通过建立一个中间层将部分功能分别交于专门的类来负责，OnBackPressedDispatcherOwner 就是我们讲 fragment 返回栈（<a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇</a>）时提到的结构，而其中的 <code>SavedStateRegistryOwner</code> 则是我们今天要讲的主角  <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 中的成员</p><h2 id="SavedState"><a href="#SavedState" class="headerlink" title="SavedState"></a>SavedState</h2><p>引入 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">"androidx.savedstate:savedstate:1.0.0"</span><br></code></pre></td></tr></table></figure><p>其实您不需要显示地声明，因为 activity 库内部已经引入了。jetpack 组件依赖关系可参考 <a href="https://juejin.im/post/5e567ee1518825494466a938" target="_blank" rel="noopener">【背上Jetpack】Jetpack 主要组件的依赖及传递关系</a></p><p>这是一个很小的库</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318215718.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200318215746.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p>图片来自 <a href="https://proandroiddev.com/viewmodels-state-persistence-savedstate-54d015acad82" target="_blank" rel="noopener">Android ViewModels: State persistence — SavedState</a></p></blockquote><h3 id="SavedStateProvider"><a href="#SavedStateProvider" class="headerlink" title="SavedStateProvider"></a>SavedStateProvider</h3><p>保存状态的组件，此状态将在以后恢复并使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SavedStateProvider</span> </span>&#123;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-function">Bundle <span class="hljs-title">saveState</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SavedStateRegistry"><a href="#SavedStateRegistry" class="headerlink" title="SavedStateRegistry"></a>SavedStateRegistry</h3><p>管理 <code>SavedStateProvider</code> 列表的组件，此注册表绑定了其所有者的生命周期（即 activity 或 fragment）。每次创建生命周期所有者都会创建一个新的实例</p><p>创建注册表的所有者后（例如，在调用 activity 的 <code>onCreate(savedInstanceState)</code> 方法之后），将调用其 <code>performRestore(state)</code> 方法，以恢复系统杀死其所有者之前保存的任何状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performRestore</span><span class="hljs-params">(@NonNull Lifecycle lifecycle, @Nullable Bundle savedState)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (savedState != <span class="hljs-keyword">null</span>) &#123;<br>        mRestoredState = savedState.getBundle(SAVED_COMPONENTS_KEY);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每个注册表的 <code>SavedStateProvider</code> 都由用于注册它的唯一密钥标识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> SafeIterableMap&lt;String, SavedStateProvider&gt; mComponents = <span class="hljs-keyword">new</span> SafeIterableMap&lt;&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerSavedStateProvider</span><span class="hljs-params">(@NonNull String key, @NonNull SavedStateProvider provider)</span> </span>&#123;<br>    SavedStateProvider previous = mComponents.putIfAbsent(key, provider);<br>    <span class="hljs-keyword">if</span> (previous != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"SavedStateProvider with the given key is already registered"</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unregisterSavedStateProvider</span><span class="hljs-params">(@NonNull String key)</span> </span>&#123;<br>    mComponents.remove(key);<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦完成注册，就可以通过<code>consumeRestoredStateForKey(key)</code> 来使用特定密钥的还原状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Bundle <span class="hljs-title">consumeRestoredStateForKey</span><span class="hljs-params">(@NonNull String key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mRestoredState != <span class="hljs-keyword">null</span>) &#123;<br>        Bundle result = mRestoredState.getBundle(key);<br>        <span class="hljs-comment">//调用后就会清空，第二次调用返回null</span><br>        mRestoredState.remove(key);<br>        <span class="hljs-keyword">if</span> (mRestoredState.isEmpty()) &#123;<br>            mRestoredState = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>请注意，此方法检索保存的状态，然后清除其内部引用，这意味着用相同的键调用它两次将在第二次调用中返回 null</p><p>一旦注册表恢复了其保存状态，则由提供者决定是否要求其恢复的数据。 如果没有，下次注册表的所有者被系统杀死时，未使用的还原数据将再次保存到保存状态</p></blockquote><p>已注册的 provider 能够在其所有者被系统杀死之前保存状态。 发生这种情况时，将调用其 <code>Bundle saveState()</code> 方法。 对于每个已注册的 <code>SavedStateProvider</code>，都可以像这样保存状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">savedState.putBundle(savedStateProviderKey, savedStateProvider.saveState());<br></code></pre></td></tr></table></figure><p><code>performSave(outBundle)</code> 方法的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performSave</span><span class="hljs-params">(@NonNull Bundle outBundle)</span> </span>&#123;<br>    Bundle components = <span class="hljs-keyword">new</span> Bundle();<br>    <br>    <span class="hljs-comment">// 1.保存未使用的状态</span><br>    <span class="hljs-keyword">if</span> (mRestoredState != <span class="hljs-keyword">null</span>) &#123;<br>        components.putAll(mRestoredState);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 通过 SavedStateProvider 保存状态</span><br>    <span class="hljs-keyword">for</span> (Iterator&lt;Map.Entry&lt;String, SavedStateProvider&gt;&gt; it = mComponents.iteratorWithAdditions(); it.hasNext(); ) &#123;<br>        Map.Entry&lt;String, SavedStateProvider&gt; entry1 = it.next();<br>        components.putBundle(entry1.getKey(), entry1.getValue().saveState());<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 将bundle 保存到 outBundle 对象中</span><br>    outBundle.putBundle(SAVED_COMPONENTS_KEY, components);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行状态保存将所有未使用的状态与注册表提供的状态合并。 此 outBundle 是 activity 的 <code>onSaveInstanceState</code> 中传入的 bundle 。</p><h3 id="SavedStateRegistryController"><a href="#SavedStateRegistryController" class="headerlink" title="SavedStateRegistryController"></a>SavedStateRegistryController</h3><p>一个包装 <code>SavedStateRegistry</code> 并允许通过其2个主要方法对其进行控制的组件：performRestore(savedState) 和 <code>performSave(outBundle )</code>。 这两个方法将内部通过 <code>SavedStateRegistry</code> 中的方法处理 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SavedStateRegistryController</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SavedStateRegistryOwner mOwner;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SavedStateRegistry mRegistry;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performRestore</span><span class="hljs-params">(@Nullable Bundle savedState)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        mRegistry.performRestore(lifecycle, savedState);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performSave</span><span class="hljs-params">(@NonNull Bundle outBundle)</span> </span>&#123;<br>        mRegistry.performSave(outBundle);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SavedStateRegistryOwner"><a href="#SavedStateRegistryOwner" class="headerlink" title="SavedStateRegistryOwner"></a>SavedStateRegistryOwner</h3><p>持有 <code>SavedStateRegistry</code> 的组件。 默认情况下，androidx 包中的<code>ComponentActivity</code> 和 <code>Fragment</code> 都实现此接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SavedStateRegistryOwner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LifecycleOwner</span> </span>&#123;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-function">SavedStateRegistry <span class="hljs-title">getSavedStateRegistry</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Activity-的状态保存"><a href="#Activity-的状态保存" class="headerlink" title="Activity 的状态保存"></a>Activity 的状态保存</h2><p>这里我们要明确一件事情，activity 保存的状态究竟都有什么？</p><p>这部分内容可以参见 <a href="https://developer.android.com/guide/components/activities/activity-lifecycle.html#saras" target="_blank" rel="noopener">官方文档</a> </p><p>简单来说，<strong>activity 的状态保存分为 view 状态和成员状态</strong></p><p>默认情况下，系统使用 Bundle 实例状态来保存有关 activity 布局中每个 View 对象的信息（例如，输入到 EditText 中的文本值或 recyclerview 的滚动位置）。 因此，如果 activity 实例被销毁并重新创建，则布局状态将恢复为之前的状态，而无需您执行任何代码。（<strong>注意，需要恢复状态的 view 需要配置 id</strong> ）</p><p>这部分逻辑在 activity 中的 <code>onSaveInstanceState</code> 方法内实现</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319115543.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="onSaveInstanceState "></p><blockquote><p>不同平台 <code>onSaveInstanceState</code>  方法的执行时机稍有不同，android P 之前 <code>onSaveInstanceState</code> 执行在 <code>onStop</code> 之前，但不限于在 <code>onPause</code> 之前或之后。android P 及之后该方法在 <code>onStop</code> 后执行</p></blockquote><p>前面我们提到 <code>ComponentActivity</code> 实现了 <code>SavedStateRegistryOwner</code> ，下面我们来看一看 activity 如何利用该库来实现状态的保存与恢复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">androidx</span>.<span class="hljs-title">core</span>.<span class="hljs-title">app</span>.<span class="hljs-title">ComponentActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SavedStateRegistryOwner</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SavedStateRegistryController mSavedStateRegistryController = SavedStateRegistryController.create(<span class="hljs-keyword">this</span>);<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        mSavedStateRegistryController.performRestore(savedInstanceState);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(@NonNull Bundle outState)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">//这里先调用父类的 onSaveInstanceState 保存 view 状态</span><br>        <span class="hljs-keyword">super</span>.onSaveInstanceState(outState);<br>        mSavedStateRegistryController.performSave(outState);<br>    &#125;<br>  <br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> SavedStateRegistry <span class="hljs-title">getSavedStateRegistry</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mSavedStateRegistryController.getSavedStateRegistry();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其内部持有 <code>SavedStateRegistryController</code> 的实例 <code>mSavedStateRegistryController</code> ，在 activity 的 <code>onCreate</code> 方法中 通过 controller 的 <code>performRestore</code> 方法来查询已保存的状态，在 <code>onSaveInstanceState</code> 中 使用 controller  的 <code>performSave</code> 方法来保存状态</p><p><strong>除了 view 状态和成员状态，activity 还负责保存其内部的 fragment 的状态</strong>。<code>FragmentActivity</code> 的 <code>onSaveInstanceState</code> 方法有对其内部 fragment 的状态进行保存，并在 onCreate 方法中对已保存的 fragment 进行恢复。这解释了如果操作不当会导致 fragment 重叠的问题</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319140343.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319140801.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><h2 id="Fragment-的状态保存"><a href="#Fragment-的状态保存" class="headerlink" title="Fragment 的状态保存"></a>Fragment 的状态保存</h2><p>androidx fragment 使用 <code>FragmentStateManager</code> 来处理 fragment 的状态保存</p><p>其内部有四个保存相关的方法</p><ul><li><code>saveState</code></li><li><code>saveBasicState</code></li><li><code>saveViewState</code></li><li><code>saveInstanceState</code></li></ul><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319142729.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="FragmentStateManager"></p><p>其调用链为 activity 通过 <code>FragmentController</code> 间接 调用 <code>FragmentManager</code> 的 <code>saveAllState</code>，接着依次调用后面的save 方法</p><p>Fragment 的状态保存可分为 view 状态，成员状态，child fragment 状态</p><p>关于 view 状态 , <code>FragmentStateManager</code> 提供了 <code>saveViewSate</code> 方法，它的调用有两处：</p><ol><li>在 activity 或父 fragment 触发状态保存时调用，即上述流程</li><li>在 fragment 即将进入 <code>onDestroyView</code> 生命周期时调用，其位置在 <code>FragmentManager</code> moveToState 方法内部，这解释了为什么加入返回栈的 replace 操作在返回时 view 状态可以自动恢复</li></ol><p>关于成员状态，由 activity 中的状态机制处理，即上节内容</p><p>关于 child  fragment 状态，fragment 的 <code>onCreate</code> 方法会调用 <code>restoreChildFragmentState</code> 来恢复 child  fragment 的状态，并在 <code>FragmentStateManager</code>  中的 <code>saveBasicState</code> 方法中 调用 <code>performSaveInstanceState</code> 来保存 child  fragment 的状态</p><h2 id="Viewmodel-SavedState"><a href="#Viewmodel-SavedState" class="headerlink" title="Viewmodel-SavedState"></a>Viewmodel-SavedState</h2><p>2020-01-22，<code>ViewModel-SavedState 1.0.0</code> 正式版发布，02-05 发布了 <code>2.2.0</code> 正式版</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-viewmodel-savedstate:2.2.0"</span><br></code></pre></td></tr></table></figure><blockquote><p>您不需要手动引入该库，因为 fragment 库以及内部引入该库</p></blockquote><p><code>Jetpack MVVM</code> 下 UI State 通常被 <code>ViewModel</code> 持有并存储，因此该模块出现了，配置该模块后，<code>ViewModel</code> 对象将通过其构造函数接收 <code>SavedStateHandle</code> 对象（键值映射），可让您保存状态并查询已保存的状态。 这些值将在系统终止进程后继续存在，并可以通过同一对象使用。</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319165450.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ViewModel-SavedState"></p><blockquote><p>图片来自 <a href="https://proandroiddev.com/viewmodels-state-persistence-savedstate-54d015acad82" target="_blank" rel="noopener">Android ViewModels: State persistence — SavedState</a></p></blockquote><h3 id="SavedStateHandle"><a href="#SavedStateHandle" class="headerlink" title="SavedStateHandle"></a>SavedStateHandle</h3><p>内部持有已保存状态 key-value 的 map，允许读取和写入状态，这些状态在应用进程被杀死后仍然存在</p><p><code>SavedStateHandle</code> 通过 <code>ViewModel</code> 的构造器传入，下面是其主要的主要的几个方法</p><ul><li>T get(String key)</li><li>MutableLiveData<t> getLiveData(String key)</t></li><li>void set(String key, T value)</li></ul><p><code>SavedStateHandle</code> 还包含 <code>SavedStateProvider</code> 的实例，用于帮助 <code>ViewModel</code> 的 owner 保存状态</p><h3 id="AbstractSavedStateViewModelFactory"><a href="#AbstractSavedStateViewModelFactory" class="headerlink" title="AbstractSavedStateViewModelFactory"></a>AbstractSavedStateViewModelFactory</h3><p>一个实现 <code>ViewModelFactory.KeyedFactory</code> 的 <code>ViewModel Factory</code>，它会创建一个与实例化的请求的 ViewModel 关联的 <code>SavedStateHandle</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractSavedStateViewModelFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModelProvider</span>.<span class="hljs-title">KeyedFactory</span> </span>&#123;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SavedStateRegistry mSavedStateRegistry;<br>  <br>    <span class="hljs-comment">// Default state used when the saved state is empty</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bundle mDefaultArgs;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;T extends ViewModel&gt; <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;<br>        <span class="hljs-comment">// 读取保存的状态</span><br>        Bundle restoredState = mSavedStateRegistry.consumeRestoredStateForKey(key);<br>      <br>        <span class="hljs-comment">// 创建保存状态的 handle</span><br>        SavedStateHandle handle = SavedStateHandle.createHandle(restoredState, mDefaultArgs);<br>        <br>        <span class="hljs-comment">// ... </span><br>      <br>        <span class="hljs-comment">// 创建 viewModel</span><br>        T viewmodel = create(key, modelClass, handle);<br>      <br>        <span class="hljs-comment">// ... </span><br><br>        <span class="hljs-keyword">return</span> viewmodel;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SavedStateViewModelFactory"><a href="#SavedStateViewModelFactory" class="headerlink" title="SavedStateViewModelFactory"></a>SavedStateViewModelFactory</h3><p><code>AbstractSavedStateViewModelFactory</code> 的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SavedStateViewModelFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSavedStateVMFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavedStateViewModelFactory</span><span class="hljs-params">(@NonNull Application application,<br>            @NonNull SavedStateRegistryOwner owner)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(application, owner, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavedStateViewModelFactory</span><span class="hljs-params">(@NonNull Application application, @NonNull SavedStateRegistryOwner owner, @Nullable Bundle defaultArgs)</span> </span>&#123;<br>        mSavedStateRegistry = owner.getSavedStateRegistry();<br>        mLifecycle = owner.getLifecycle();<br>        mDefaultArgs = defaultArgs;<br>        mApplication = application;<br>        mFactory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);<br>    &#125;<br>    <br><span class="hljs-keyword">public</span> &lt;T extends ViewModel&gt; <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);<br>        Constructor&lt;T&gt; constructor;<br>        <span class="hljs-keyword">if</span> (isAndroidViewModel) &#123;<br>            constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);<br>        &#125;<br>        <span class="hljs-comment">// doesn't need SavedStateHandle</span><br>        <span class="hljs-keyword">if</span> (constructor == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> mFactory.create(modelClass);<br>        &#125;<br><br>        SavedStateHandleController controller = SavedStateHandleController.create(<br>                mSavedStateRegistry, mLifecycle, key, mDefaultArgs);        <br>        T viewmodel;<br>        <span class="hljs-keyword">if</span> (isAndroidViewModel) &#123;<br>            viewmodel = constructor.newInstance(mApplication, controller.getHandle());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            viewmodel = constructor.newInstance(controller.getHandle());<br>        &#125;<br>        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);<br>        <span class="hljs-keyword">return</span> viewmodel;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319174431.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewModelProvider(<span class="hljs-keyword">this</span>).get(MyViewModel::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span><br></code></pre></td></tr></table></figure><p>在 activity 中创建 ViewModel 实例，传入 this （<code>SavedStateRegistryOwner</code> ）作为参数，该参数可以访问其 <code>SavedStateRegistry</code>，如果没有传入 factory 会通过 activity 重写的 <code>getDefaultViewModelProviderFactory</code> 方法来获取默认的 factory 。然后 factory 将使用保存的状态， 将其包装在 <code>SavedStateHandle</code> 中，并将其传递给 ViewModel。 ViewModel 可以读取和写入该 handle</p><p>当 activity 的 <code>onSaveInstanceState(outState)</code> 方法被调用，其 <code>SavedStateRegistry</code> 的 <code>performSave(outState)</code> 方法将被执行，其内部的所有 <code>SavedStateProvider</code> 的 <code>saveState</code> 方法均被执行，一旦执行完毕，<code>outState</code> 就包含了已保存的状态</p><p>当 app 被重启后，activity 和新的 registry  将被创建，activity 的 <code>onCreate(savedInstanceState)</code> 方法会被调用，然后 registry 的 <code>performRestore(savedInstanceState)</code> 将被调用以便恢复之前保存的状态</p><h2 id="状态保存的正确姿势"><a href="#状态保存的正确姿势" class="headerlink" title="状态保存的正确姿势"></a>状态保存的正确姿势</h2><p><code>ViewModel</code> 构造器加入 <code>SavedStateHandle</code> 参数，并将想要保存的数据使用该 handle 保存</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithSavedStateViewModel</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> state: SavedStateHandle) : ViewModel() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> key = <span class="hljs-string">"key"</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span> = state.<span class="hljs-keyword">set</span>(key, value)<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>: LiveData&lt;String&gt; = state.getLiveData(key)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>无需重写 <code>onSaveInstanceState/onRestoreInstanceState</code>  方法</strong></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319231231.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200319231451.png" src="/2020/03/19/Jetpack-ViewModel-SaveState/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="运行示意图"></p><p><a href="https://github.com/Flywith24/Flywith24-Jetpack-Demo" target="_blank" rel="noopener">Demo 地址</a></p><blockquote><p>SavedState 仅适合保存轻量级的数据，重量级操作请考虑持sp，数据库等持久化方案</p></blockquote><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="http://www.yangyunzhao.com" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015095500.png" type="image" />
    
    
      <category term="背上 Jetpack" scheme="https://flywith24.gitee.io/categories/%E8%83%8C%E4%B8%8A-Jetpack/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>从源码的角度看 Fragment 返回栈</title>
    <link href="https://flywith24.gitee.io/2020/03/16/Jetpack-fragment-back-stack/"/>
    <id>https://flywith24.gitee.io/2020/03/16/Jetpack-fragment-back-stack/</id>
    <published>2020-03-15T16:10:35.000Z</published>
    <updated>2020-10-15T02:33:36.103Z</updated>
    
    <content type="html"><![CDATA[<p>从源码的角度看 Fragment 返回栈。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p><a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">上一篇</a> 我们介绍了 <code>OnBackPressedDispather</code> ，那么今天我们来正式地从源码的角度看看 fragment 的返回栈吧。由于其主流程和生命周期差不多，因此本文将详细地分析返回栈相关的源码，并插入大量源码。建议将生命周期流程熟悉后阅读本文。文末提供单返回栈和多返回栈的 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">demo</a></p></blockquote><p>如果您对 activity 对任务栈和返回栈不是很了解，可以移步  <a href="https://medium.com/androiddevelopers/tasks-and-the-back-stack-dbb7c3b0f6d4" target="_blank" rel="noopener">Tasks and the Back Stack</a></p><h2 id="小问号你是否有很多朋友？"><a href="#小问号你是否有很多朋友？" class="headerlink" title="小问号你是否有很多朋友？"></a>小问号你是否有很多朋友？</h2><p>在分析源码之前，我们先来思考几个问题。</p><ul><li>返回栈中的元素是什么？</li><li>谁来管理 fragment 的返回栈？</li><li>如何返回？</li></ul><h3 id="返回栈中的元素是什么？"><a href="#返回栈中的元素是什么？" class="headerlink" title="返回栈中的元素是什么？"></a>返回栈中的元素是什么？</h3><p>返回栈，顾名思义，是一个栈结构。所以我们要搞清楚，这个栈结构到底存的是什么。</p><p>我们都知道，使用 fragment 的返回栈需要调用 <code>addToBackStack(&quot;&quot;)</code> 方法</p><p>在 <a href="https://juejin.im/post/5e67523551882549003d2c4f" target="_blank" rel="noopener">从源码角度看 Fragment 生命周期</a> 一文中，我们提到了 FragmentTransaction ，它是一个「事务」的模型，事务可以回滚到之前的状态。所以当触发返回操作时，就是将之前提交的事务进行回滚。</p><p><code>FragmentTransaction</code> 的实现类为 <code>BackStackRecord</code> ，所以 <strong>fragment 的返回栈其实存放的就是 BackStackRecord</strong> </p><p>作为返回栈的元素，BackStackRecord 实现了FragmentManager.BackStackEntry 接口</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0e912bd4?w=748&h=171&f=png&s=27904" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="BackStackRecord"></p><p>从 <code>BackStackRecord</code> 的定义我们可以发现 <code>BackStackRecord</code> 有三种身份</p><ul><li>继承了 <code>FragmentTransaction</code>，即是事务，保存了整个事务的全部操作</li><li>实现了 <code>FragmentManager.BackStackEntry</code> ，作为回退栈的元素</li><li>实现了<code>OpGenerator</code> ，可以生成 <code>BackStackRecord</code> 列表，后文详细介绍</li></ul><h3 id="谁来管理-fragment-的返回栈？"><a href="#谁来管理-fragment-的返回栈？" class="headerlink" title="谁来管理 fragment 的返回栈？"></a>谁来管理 fragment 的返回栈？</h3><p>我们已经知道 fragment 的返回栈其实存放的是 BackSrackRecord , 那么谁来管理 fragment 的返回栈？</p><p><code>FragmentManager</code> 用于管理 fragment ，所以 <strong>fragment 返回栈也应该由 FragmentManager 管理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//FragmentManager.java</span><br>ArrayList&lt;BackStackRecord&gt; mBackStack;<br></code></pre></td></tr></table></figure><p>其实触发 fragment 的返回逻辑有两种途径</p><ul><li><p>开发主动调用 fragment 的返回方法</p></li><li><p>用户按返回键触发</p></li></ul><p>后文我们会从这两个角度分析一下 fragment 中的返回栈逻辑究竟是怎样的</p><h3 id="如何返回？"><a href="#如何返回？" class="headerlink" title="如何返回？"></a>如何返回？</h3><p>我们已经知道返回栈中的元素是 <code>BackStackRecord</code> ，也清楚了是 <code>FragmentManager</code> 来管理返回栈。那么如果让我们来实现「返回」逻辑，应该如何做？</p><p>首先我们要清楚所谓的「返回」是对事务的回滚，即 <strong>对 commit 事务的内部逻辑执行相应的「逆操作」</strong>。</p><p>例如</p><p>addFragment←→removeFragment</p><p>showFragment←→hideFragment</p><p>attachFragment←→detachFragment</p><p>有的小伙伴可能会疑惑 replace 呢？</p><p><code>expandReplaceOps</code> 方法会把 replace 替换(目标 fragment 已经被 add )成相应的 remove 和 add 两个操作，或者(目标 fragment 没有被 add )只替换成 add 操作</p><h2 id="popBackStack-系列方法"><a href="#popBackStack-系列方法" class="headerlink" title="popBackStack 系列方法"></a>popBackStack 系列方法</h2><p><code>FragmentManager</code> 中提供了<code>popBackStack</code> 系列方法</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0f7fecec?w=523&h=207&f=png&s=41693" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="popBackStack系列方法"></p><p>是否觉得很眼熟？提交事务也有类似的api，commit 系列方法</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0f5fe236?w=425&h=116&f=png&s=19768" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="commit系列方法"></p><p>这里分别提供了同步和异步的方法，可能有读者会疑惑，同样是对事务的操作，一个为提交，一个为回滚，为什么一个封装到了 <code>FragmentManager</code> 中，一个却在 <code>FragmentTransaction</code> 中。既然都是对事务的操作，应该都放在FragmentManager 中。我认为可能为了api使用的方便，使得 <code>FragmentManager</code> 开启事务的链式调用一气呵成。各位有什么想法欢迎在评论区留言。</p><p>这里主要介绍一下 popBackStack(String name, int flag)</p><p>name 为 addToBackStack(String name) 的参数，通过 name 能找到回退栈的特定元素，flag可以为 0 或者<code>FragmentManager.POP_BACK_STACK_INCLUSIVE</code>，0 表示只弹出该元素以上的所有元素，<code>POP_BACK_STACK_INCLUSIVE</code> 表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。如果这么说比较抽象的话，看图</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//flag 传入0，弹出 ♥2 上的所有元素</span><br>childFragmentManager.popBackStack(<span class="hljs-string">"♥"</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf111e4eca?w=544&h=968&f=gif&s=332027" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="flag为0"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//flag 为 POP_BACK_STACK_INCLUSIVE 弹出包括该元素及及以上的元素</span><br>childFragmentManager.popBackStack(<span class="hljs-string">"♥"</span>,  androidx.fragment.app.FragmentManager.POP_BACK_STACK_INCLUSIVE)<br></code></pre></td></tr></table></figure><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf11573c7e?w=544&h=968&f=gif&s=307357" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="flag为1"></p><h2 id="走进源码"><a href="#走进源码" class="headerlink" title="走进源码"></a>走进源码</h2><h3 id="1-popBackStack-逻辑"><a href="#1-popBackStack-逻辑" class="headerlink" title="1. popBackStack() 逻辑"></a>1. popBackStack() 逻辑</h3><p>在分析返回栈源码之前我们回顾一下 FragmentManager 提交事务到 fragment 各个生命周期的流程</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf128028ab?w=1137&h=1745&f=png&s=148227" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="异步"></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf3c14d698?w=1078&h=1232&f=png&s=120922" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="commitNow"></p><p>下面我们看看 popBackStack 的源码</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf3e264529?w=1111&h=744&f=png&s=152765" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="popBackStack源码"></p><p>等等，这个 enqueueAction 有些眼熟…</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf4261e2a2?w=582&h=144&f=png&s=16887" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="commit"></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf43057f36?w=792&h=404&f=png&s=74980" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="commitInternal"></p><p>看来提交事务和回滚事务的流程基本是相同的，只是传递的 action 不同</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf463c7504?w=818&h=722&f=png&s=108117" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="enqueueAction"></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170df028ee01dd57?w=1081&h=713&f=png&s=131939" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="OpGenerator"></p><p>由源码可知，<code>OpGenerator</code> 是一个接口，其内只有一个 <code>generateOps</code> 方法，用于生成事务列表以及对应的该事务是否是弹出的。有两个实现类</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf5579b571?w=1319&h=139&f=png&s=46323" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="OpGenerator实现类"></p><p>由此可见 commit 调用的为 <code>BackStackRecord</code> 的 <code>generateOps</code> 方法，<code>popBackStack</code> 调用的是 <code>PopBackStackState</code> 中的  <code>generateOps</code> </p><p>前者的逻辑很简单，向 records list 中添加数据， isRecordPop list 全部传入 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">records.add(<span class="hljs-keyword">this</span>);<br>isRecordPop.add(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>后者的逻辑稍微复杂些，其内部调用了 <code>popBackStackState</code> 方法</p><p>如果是 <code>popBackStack</code> 方法 ，则将 <code>FragmentManager</code> 的返回栈列表（<code>mBackStack</code>）的栈顶移除， <code>isRecordPop</code> list 全部传入 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> last = mBackStack.size() - <span class="hljs-number">1</span>;<br>records.add(mBackStack.remove(last));<br>isRecordPop.add(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>如果传入的 name 或 id 有值，且 flag 为 0，则找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置，并将该位置上方的所有 <code>BackStackRecord</code> 并添加到 <code>record</code> list 中，同时 <code>isRecordPop</code> list 全部传入 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">index = mBackStack.size() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>    BackStackRecord bss = mBackStack.get(index);<br>    <span class="hljs-keyword">if</span> (name != <span class="hljs-keyword">null</span> &amp;&amp; name.equals(bss.getName())) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span> &amp;&amp; id == bss.mIndex) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    index--;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mBackStack.size() - <span class="hljs-number">1</span>; i &gt; index; i--) &#123;<br>  records.add(mBackStack.remove(i));<br>  isRecordPop.add(<span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果传入的 name 或 id 有值，且 flag 为 <code>POP_BACK_STACK_INCLUSIVE</code>，则在上一条获取位置的基础上继续遍历，直至栈底或者遇到不匹配的跳出循环，接着出栈所有 <code>BackStackRecord</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//index 操作与上方相同，先找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置</span><br><span class="hljs-keyword">if</span> ((flags &amp; POP_BACK_STACK_INCLUSIVE) != <span class="hljs-number">0</span>) &#123;<br>    index--;<br>    <span class="hljs-comment">// 继续遍历 mBackStack 直至栈底或者遇到不匹配的跳出循环</span><br>    <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>        BackStackRecord bss = mBackStack.get(index);<br>        <span class="hljs-keyword">if</span> ((name != <span class="hljs-keyword">null</span> &amp;&amp; name.equals(bss.getName()))<br>                || (id &gt;= <span class="hljs-number">0</span> &amp;&amp; id == bss.mIndex)) &#123;<br>            index--;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//后续出栈逻辑与上方相同</span><br></code></pre></td></tr></table></figure><p>可以配合上面的动图理解</p><p>入栈和出栈后续的逻辑大体是相同的，只是根据 isPop 的正负出现了分支，出栈调用的是 executePopOps</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170df06c04191fff?w=972&h=682&f=png&s=132928" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>上文我们有提到，「返回」逻辑实际上就是执行提交事务内部操作逻辑的「逆操作」</p><p>那么接下的逻辑就很清晰了，根据不同的 mCmd 执行相应的逆操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">executePopOps</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> moveToState)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> opNum = mOps.size() - <span class="hljs-number">1</span>; opNum &gt;= <span class="hljs-number">0</span>; opNum--) &#123;<br>        <span class="hljs-keyword">final</span> Op op = mOps.get(opNum);<br>        Fragment f = op.mFragment;<br>        <span class="hljs-keyword">switch</span> (op.mCmd) &#123;<br>            <span class="hljs-keyword">case</span> OP_ADD:<br>                mManager.removeFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_REMOVE:<br>                mManager.addFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_HIDE:<br>                mManager.showFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_SHOW:<br>                mManager.hideFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_DETACH:<br>                mManager.attachFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_ATTACH:<br>                mManager.detachFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_SET_PRIMARY_NAV:<br>                mManager.setPrimaryNavigationFragment(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_UNSET_PRIMARY_NAV:<br>                mManager.setPrimaryNavigationFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_SET_MAX_LIFECYCLE:<br>                mManager.setMaxLifecycle(f, op.mOldMaxState);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unknown cmd: "</span> + op.mCmd);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!mReorderingAllowed &amp;&amp; op.mCmd != OP_REMOVE &amp;&amp; f != <span class="hljs-keyword">null</span>) &#123;<br>            mManager.moveFragmentToExpectedState(f);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!mReorderingAllowed &amp;&amp; moveToState) &#123;<br>        mManager.moveToState(mManager.mCurState, <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面的逻辑就完全一样了</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf65e331c7?w=1137&h=1585&f=png&s=127564" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="popBackStack"></p><h3 id="2-fragment-是怎样拦截-activity-的返回逻辑的？"><a href="#2-fragment-是怎样拦截-activity-的返回逻辑的？" class="headerlink" title="2. fragment 是怎样拦截 activity 的返回逻辑的？"></a>2. fragment 是怎样拦截 activity 的返回逻辑的？</h3><p>在 <a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇</a> 一文中我们介绍了 <code>OnBackPressedDispatcher</code> </p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf6fd444f6?w=1138&h=544&f=png&s=96482" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ComponetActivity"></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf70da7341?w=642&h=512&f=png&s=71452" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>activity 的 <code>onBackPressed</code> 的逻辑主要分为两部分，判断所有注册的 <code>OnBackPressedCallback</code> 是否有 enabled 的，如果有则拦截，不执行后续逻辑；</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170df0d07750776b?w=801&h=765&f=png&s=137606" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="fragment 拦截返回逻辑"></p><p>否则着执行 mFallbackOnBackPressed.run() ，其内部逻辑为调用 ComponentActivity 父类的 <code>onBackPressed</code> 方法</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf7443eb77?w=715&h=275&f=png&s=39938" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><strong>所以我们只需看 mOnBackPressedCallbacks（ArrayDeque&lt;OnBackPressedCallback） 是怎样被添加的以及 isEnabled 何时赋值为 true</strong></p><p>经过查找我们发现它是在 FragmentManager 的 attachController 调用 <code>addCallback</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mOnBackPressedDispatcher.addCallback(owner,mOnBackPressedCallback)<br></code></pre></td></tr></table></figure><p>进而执行了</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170df099d16ae502?w=1000&h=425&f=png&s=75605" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt><br><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf7c970039?w=822&h=233&f=png&s=41860" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>而 <code>mOnBackPressedCallback</code> 在初始化时 enabled 赋值为 false </p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf8362798b?w=954&h=194&f=png&s=42041" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="mOnBackPressedCallback"></p><p><code>isEnadbled</code> 会在返回栈数量大于 0 且其 mParent 为 <code>PrimaryNavigation</code> 时赋值为true</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9805eb1e?w=796&h=555&f=png&s=94237" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>而返回栈（<code>mBackStack</code>）的赋值在 <code>BackStackRecord</code> 的 <code>generateOps</code> 方法中，且是否添加到返回栈由 <code>mAddToBackStack</code> 这个布尔类型的属性控制</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170df0f5d77e3c7f?w=891&h=544&f=png&s=94633" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9a0dfa56?w=548&h=215&f=png&s=28095" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p><strong>mAddToBackStack 的赋值在 addToBackStack 方法中，这也解释了为何调用 addToBackStack 方法就能将事务加入返回栈</strong></p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9eb75bde?w=841&h=306&f=png&s=47458" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><blockquote><p> 我们来总结一下，fragment 拦截 activity 返回栈是通过 <code>OnBackPressedDispatcher</code> 实现的，如果开启事务调用了 <code>addToBackStack</code> 方法，则 <code>mOnBackPressedCallback</code> 的 <code>isEnabled</code> 属性会赋值为 true，进而起到拦截 activity 返回逻辑的作用。拦截后执行 <code>popBackStackImmediate</code> 方法</p><p>而 popBackStack系列方法会调用 popBackStackState 构造 <code>records</code> 和 <code>isRecordPop</code> 列表，<code>isRecordPop</code> 的内部元素的值均为true 后续流程和提交事务是一样的，根据 <code>isRecordPop</code> 值的不同选择执行 <code>executePopOps</code> 或 <code>executeOps</code> 方法</p></blockquote><h2 id="单返回栈和多返回栈的实现"><a href="#单返回栈和多返回栈的实现" class="headerlink" title="单返回栈和多返回栈的实现"></a>单返回栈和多返回栈的实现</h2><p><a href="https://medium.com/@ianhlake" target="_blank" rel="noopener">Ian Lake</a> 在 <a href="https://www.youtube.com/watch?v=RS1IACnZLy4" target="_blank" rel="noopener">Fragments: Past, Present, and Future (Android Dev Summit ‘19)</a> </p><p>有提到未来会提供多返回栈的 api</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/15/170deeafa780da77?w=1844&h=948&f=png&s=634511" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>那么以现有的 api 如何实现多返回栈呢？</p><p>首先我要弄清楚怎样才会有多返回栈，根据上文我们知道 <code>FragmentManager</code> 内部持有<code>mBackStack</code> list，这对应着一个返回栈，<strong>如果想要实现多返回栈，则需要多个 FragmentManager</strong>，而多 <code>FragmentManager</code> 则对应多个 fragment</p><p>因此我们可以创建多个宿主 frament 作为导航 fragment 这样就可以用不同的宿主 fragment 的 独立的<code>FragmentManager</code> 分别管理各自的返回栈，如果这样说比较抽象，可以参考下图</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/16/170defa88bc0e5f9?w=488&h=750&f=gif&s=4633102" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>图中有四个返回栈，其中最外部有一个宿主 fragment ，内部有四个负责导航的 fragment 管理其内部的返回栈，外部的宿主负责协调各个返回栈为空后如何切换至其他返回栈</p><p>单返回栈就很容易了，我们只需在同一个 <code>FragmentManager</code> 上添加返回栈即可</p><p><img class="lazyload" data-original="https://gitee.com/flywith24/Album/raw/master/img/20200312175950" src="/2020/03/16/Jetpack-fragment-back-stack/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p><p>详情参照 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">demo</a></p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从源码的角度看 Fragment 返回栈。&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015095213.png" type="image" />
    
    
      <category term="背上 Jetpack" scheme="https://flywith24.gitee.io/categories/%E8%83%8C%E4%B8%8A-Jetpack/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>Fragment返回栈预备篇 OnBackPressedDispatcher</title>
    <link href="https://flywith24.gitee.io/2020/03/14/Jetpack-OnBackPressedDispatcher/"/>
    <id>https://flywith24.gitee.io/2020/03/14/Jetpack-OnBackPressedDispatcher/</id>
    <published>2020-03-13T16:10:35.000Z</published>
    <updated>2020-10-15T02:32:44.883Z</updated>
    
    <content type="html"><![CDATA[<p>Fragment 处理返回键的新姿势。</p><a id="more"></a><blockquote><p>这两天在准备写 fragment 返回栈的文章，但是发现必须先介绍一下 OnBackPressedDispatcher ，所以这是一篇介绍 what 的文章，喜欢一手资料的可以移步 <a href="https://developer.android.google.cn/reference/kotlin/androidx/activity/OnBackPressedDispatcher" target="_blank" rel="noopener">官方文档</a></p></blockquote><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><blockquote><p><a href="https://juejin.im/post/5e567ee1518825494466a938" target="_blank" rel="noopener">【背上Jetpack】Jetpack 主要组件的依赖及传递关系</a><br></p><p><a href="https://juejin.im/post/5e5a0c316fb9a07cd248d29e" target="_blank" rel="noopener">【背上Jetpack】AdroidX下使用Activity和Fragment的变化</a><br></p><p><a href="https://juejin.im/post/5e5cd8686fb9a07cbc269d10" target="_blank" rel="noopener">【背上Jetpack之Fragment】你真的会用Fragment吗？Fragment常见问题以及androidx下Fragment的使用新姿势</a><br></p><p><a href="https://juejin.im/post/5e67523551882549003d2c4f" target="_blank" rel="noopener">【背上Jetpack之Fragment】从源码角度看 Fragment 生命周期 AndroidX Fragment1.2.2源码分析</a></p></blockquote><h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><p><code>OnBackPressedDispatcher</code> 在 <code>androidx activity 1.0.0</code> 加入，旨在处理返回逻辑。您不仅可以获得在 <code>Activity</code> 之外处理返回键的便捷方式。 根据您的需要，您可以在任意位置定义 <code>OnBackPressedCallback</code>，使其可复用，或根据应用程序的架构进行任何操作。 您不再需要重写<code>Activity</code> 中的 <code>onBackPressed</code> 方法，也不必提供自己的抽象的来实现需求的代码。</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/14/170d4a399942581f?w=1778&h=1246&f=png&s=339228" src="/2020/03/14/Jetpack-OnBackPressedDispatcher/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="OnBackPressedDispatcher"></p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p><code>ComponentActivity</code> 是 <code>FragmentActivity</code> 和 <code>AppCompatActivity</code> 的基类，它使您可以通过使用其 <code>OnBackPressedDispatcher</code>（可以通过调用 <code>getOnBackPressedDispatcher()</code> ）来控制返回按钮的行为。</p><p><img class="lazyload" data-original="https://user-gold-cdn.xitu.io/2020/3/14/170d4a9d225a9575?w=2168&h=1150&f=png&s=238889" src="/2020/03/14/Jetpack-OnBackPressedDispatcher/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="ComponentActivity-onBackPressed"></p><p><code>OnBackPressedDispatcher</code> 控制如何将返回按钮事件分配给一个或多个<code>OnBackPressedCallback</code> 对象。 <code>OnBackPressedCallback</code> 的构造函数将布尔值用于初始启用状态。 仅当启用了回调（即 <code>isEnabled()</code> 返回true）时，调度程序才会调用回调的<code>handleOnBackPressed()</code> 来处理返回按钮事件。 您可以通过调用 <code>setEnabled()</code> 来更改启用状态。</p><p>回调是通过 <code>addCallback</code> 方法添加的。 强烈建议使用采用 LifecycleOwner 的<code>addCallback()</code> 方法。 这样可以确保仅在 LifecycleOwner 为 Lifecycle.State.STARTED 时才添加<code>OnBackPressedCallback</code>。 当关联的 LifecycleOwner 被销毁时，该 activity 会删除已注册的回调，以防止内存泄漏，并使其适用于寿命比该 <code>activity</code> 短的 <code>fragment</code> 或其他生命周期所有者。</p><p>下面是一个示例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br><br>        <span class="hljs-comment">//此 callback 仅当 MyFragment 至少是 Started 状态下调用</span><br>        <span class="hljs-keyword">val</span> callback = requireActivity().onBackPressedDispatcher.addCallback(<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">//拦截返回事件</span><br>        &#125;<br><br>        <span class="hljs-comment">//此 callback 可以在这里或者上面的 lambda 中开启和关闭</span><br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>您可以通过 <code>addCallback()</code> 提供多个回调。 这样做时，将按照添加回调的相反顺序调用回调，即最后添加的回调是第一个给予处理返回按钮事件的机会的回调。 例如，如果您依次添加了三个分别名为1、2和3的回调，则将分别以3、2和1的顺序调用它们。</p><p>回调遵循“责任链”模式。 仅当未启用前一个回调时，才调用链中的每个回调。 这意味着在前面的示例中，仅当未启用回调3时，才会调用回调2。 仅当未启用回调2时，才调用回调1，依此类推。</p><p>请注意，通过 <code>addCallback()</code> 添加回调时，直到 LifecycleOwner 进入Lifecycle.State.STARTED 状态，才将回调添加到责任链中。</p><p>强烈建议更改 <code>OnBackPressedCallback</code> 的启用状态以进行临时更改(即更改 isEnabled 的值)，因为它可以保持上述顺序，如果您在多个不同的嵌套生命周期所有者上注册了回调，这尤其重要。</p><p>但是，如果要完全删除 <code>OnBackPressedCallback</code>，则应调用 remove()。 但是，这通常不是必需的，因为在销毁关联的 <code>LifecycleOwner</code> 时会自动删除其回调。</p><h2 id="Activity-onBackPressed"><a href="#Activity-onBackPressed" class="headerlink" title="Activity onBackPressed()"></a>Activity onBackPressed()</h2><p>如果您使用 <code>onBackPressed()</code> 处理返回按钮事件，建议您改用 <code>OnBackPressedCallback</code> 。 但是，如果您无法进行此更改，则适用以下规则：</p><ul><li><p>当您调用 <code>super.onBackPressed()</code> 时，将通过 <code>addCallback</code> 注册的所有回调。</p></li><li><p>无论 <code>OnBackPressedCallback</code> 的任何注册实例，始终会调用 <code>onBackPressed</code>。</p></li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>关于 fragment 返回栈的 demo 已经写好了，感兴趣的小伙伴可以 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">在这</a> 找到它。</p><p>我们下一篇再见。</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fragment 处理返回键的新姿势。&lt;/p&gt;
    
    </summary>
    
    <content src="https://flywith24.gitee.io/https://gitee.com/flywith24/Album/raw/master/img/20201015094956.png" type="image" />
    
    
      <category term="背上 Jetpack" scheme="https://flywith24.gitee.io/categories/%E8%83%8C%E4%B8%8A-Jetpack/"/>
    
    
      <category term="androidx" scheme="https://flywith24.gitee.io/tags/androidx/"/>
    
      <category term="Jetpack" scheme="https://flywith24.gitee.io/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="https://flywith24.gitee.io/tags/MVVM/"/>
    
  </entry>
  
</feed>
