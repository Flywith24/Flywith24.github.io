<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨云召 | 博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-10T08:49:44.485Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨云召</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【背上Jetpack之DataBinding】数据驱动魔法师 何时迎来翻身日？</title>
    <link href="http://yoursite.com/2020/04/09/%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BDataBinding%E3%80%91%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E9%AD%94%E6%B3%95%E5%B8%88%20%E4%BD%95%E6%97%B6%E8%BF%8E%E6%9D%A5%E7%BF%BB%E8%BA%AB%E6%97%A5%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/04/09/【背上Jetpack之DataBinding】数据驱动魔法师 何时迎来翻身日？/</id>
    <published>2020-04-08T16:10:35.000Z</published>
    <updated>2020-04-10T08:49:44.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://juejin.im/post/5e834bb5f265da480d61668d" target="_blank" rel="noopener">LiveData 篇</a> 我们提到 Android 开发的主要工作内容是将数据转换为 UI ，同时我们也介绍了数据驱动 UI 的思想，使用 ViewModel + LiveData，可以安全地在订阅者的生命周期内分发正确的数据。但是 activity 和 fragment 充斥着大量的模板代码，铺天盖地的 findViewById，以及各种 set （根据数据设置 UI）。如果能够消灭掉这些模板代码就好了</p></blockquote><a id="more"></a><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200402101708.gif" alt="他来了他来了"></p><p>他来了他来了，他欢快地走来了</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200402101727.png" alt="DataBinding"></p><p>然而，很多开发者对 DataBinding 存在偏见，「DataBinding 不是个好东西，在声明式编程中书写 UI 逻辑，既不可调试，也不便于察觉和追踪，万一出现问题就麻烦了。」</p> <img src="https://gitee.com/flywith24/Album/raw/master/img/20200402165235.png" style="zoom:200%;"><p>本文主要介绍 DataBinding 的解决的问题以及其背后的逻辑，带您对 DataBinding 有一个感性的认识。本文末尾会对各个 findViewById 的替代方案进行对比</p><p>DataBinding 的相关资源</p><ul><li><a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://codelabs.developers.google.com/codelabs/android-databinding/#0" target="_blank" rel="noopener">codelab</a></li><li><a href="https://github.com/android/databinding-samples" target="_blank" rel="noopener">官方示例</a></li></ul><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 数据驱动魔法师</span></h2><p>DataBinding 允许使用声明性格式而不是通过编程方式将布局中的 UI 组件与数据源绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">TextView textView = findViewById(R.id.sample_text);</span><br><span class="line">textView.setText(viewModel.getUserName());</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.userName&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>通过在布局文件中绑定组件，您可以删除 activity 中的许多设置 UI 调用，从而使它们更易于维护。 这也可以提高应用程序的性能，并有助于防止内存泄漏和空指针异常</p><blockquote><p>如果仅替换 findViewById 而不需要数据的绑定，可以使用 ViewBinding，它使用起来更简单，性能也更好。</p><p>使用方法参见 <a href="https://juejin.im/post/5e4806f3e51d4526c550a2ef" target="_blank" rel="noopener">[译]深入研究ViewBinding 在 include, merge, adapter, fragment, activity 中使用</a></p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> DataBinding 基础</span></h2><p>详细内容参见 <a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">官方文档</a> ，这里只简单介绍 DataBinding</p><h3 id="DataBinding-引入"><a href="#DataBinding-引入" class="headerlink" title="DataBinding 引入"></a>DataBinding 引入</h3><p>app build.gradle 中加入 </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android Studio 4.0</span></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        dataBinding = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>必须在 app module 中声明，声明后其他子 module 可直接使用 DataBinding</p></blockquote><p>使用 DataBinding 无需开发者手动引入库，android build gradle plugin 内部已经引入了</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200402115116.png" alt></p><p>DataBinding 中使用了注解，因此在构建速度上比 ViewBinding 差些（不过功能这么强大要啥自行车）</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>DataBinding 布局文件略有不同，它们以 layout 的根标记开始，后跟一个 data 元素和一个 view 根元素。 view 元素是您的根将位于非绑定布局文件中的元素。 以下代码显示了一个示例布局文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"viewmodel"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"com.myapp.data.ViewModel"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintLayout...</span> /&gt;</span> <span class="comment">&lt;!-- UI layout's root element --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="生成绑定类"><a href="#生成绑定类" class="headerlink" title="生成绑定类"></a>生成绑定类</h3><p>DataBinding 会为每个在布局声明 layout 标签的 xml 布局文件生成一个绑定类。 默认情况下，类的名称基于布局文件的名称。 上面的布局文件名是 activity_main.xml，因此相应的生成类是 ActivityMainBinding。 此类包含从布局属性（例如，viewmodel 变量）到布局视图的所有绑定，并且知道如何为绑定表达式分配值</p><h3 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment">// before</span></span><br><span class="line">    <span class="comment">// setContentView(R.layout.activity_main)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// after</span></span><br><span class="line">    val binding : ActivityMainBinding =</span><br><span class="line">    DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_main)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 使用DataBinding 解决的问题及实现原理</span></h2><p>不知道你是否有这些烦恼：activity 和 fragment 中有着大量的模板代码，即使使用 ButterKnife 等工具写起代码来也很繁琐。而且 View id 与 View 的类型不匹配时，只有在运行期才能发现；旋转屏幕后如果新的布局中不存在之前 id 的 view ，可能还导致空指针异常；项目中使用各类 bus 通知 UI 刷新，但是有时 UI 的显示并不符合预期，而排查起来特别困难，因为数据源很多…</p><p>不要慌，DataBinding 可以解决以下问题</p><ul><li><p>替换 findViewById ，减少模板代码</p></li><li><p>解决类型安全问题</p></li><li><p>解决空安全问题</p></li><li><p>保证了数据的一致性</p></li></ul><h3 id="魔法的背后"><a href="#魔法的背后" class="headerlink" title="魔法的背后"></a>魔法的背后</h3><p>com.android.tools.build:gradle 插件中封装了 DataBinding 的魔法</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200402162010.png" alt></p><p>查看 com.android.tools.build:gradle:3.6.2 的源码，找到 DataBinding 配置项的类 DataBindingOptions</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataBindingOptions.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DataBinding 是否开启，对应上面在 build.gradle 中的配置</span></span><br><span class="line">    <span class="keyword">return</span> enabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的调用者很多，在 TaskManager 中的 createDataBindingTasksIfNecessary</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskManager </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">createDataBindingTasksIfNecessary</span><span class="params">(@NonNull VariantScope scope)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否开启 DataBinding</span></span><br><span class="line">    <span class="keyword">boolean</span> dataBindingEnabled = extension.getDataBinding().isEnabled();</span><br><span class="line">    <span class="keyword">boolean</span> viewBindingEnabled = extension.getViewBinding().isEnabled();</span><br><span class="line">    <span class="keyword">if</span> (!dataBindingEnabled &amp;&amp; !viewBindingEnabled) &#123;</span><br><span class="line">        <span class="comment">// DataBinding 和 ViewBinding 均未开启则直接 return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    createDataBindingMergeBaseClassesTask(scope);</span><br><span class="line">    createDataBindingMergeArtifactsTask(scope);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 构建 DataBinding 相应绑定类</span></span><br><span class="line">    taskFactory.register(<span class="keyword">new</span> DataBindingGenBaseClassesTask.CreationAction(scope));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CreationAction</span></span><br><span class="line"><span class="function">override fun <span class="title">handleProvider</span><span class="params">(taskProvider: TaskProvider&lt;out DataBindingGenBaseClassesTask&gt;)</span> </span>&#123;</span><br><span class="line">    variantScope.artifacts.producesDir(</span><br><span class="line">        <span class="comment">// DATA_BINDING_BASE_CLASS_SOURCE_OUT</span></span><br><span class="line">        InternalArtifactType.DATA_BINDING_BASE_CLASS_SOURCE_OUT,</span><br><span class="line">        BuildArtifactsHolder.OperationType.INITIAL,</span><br><span class="line">        taskProvider,</span><br><span class="line">        DataBindingGenBaseClassesTask::sourceOutFolder</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到生成 DataBinding 绑定类的 task 为 DataBindingGenBaseClassesTask，而InternalArtifactType.DATA_BINDING_BASE_CLASS_SOURCE_OUT 则对应着 build 目录生成的 DataBinding 类的</p><p>data_binding_base_class_source_out 目录</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200402161451.png" alt></p><p>这里可以简单看一下，感兴趣的小伙伴可以自己查看源码</p><h3 id="DataBinding-如何解决上述问题的"><a href="#DataBinding-如何解决上述问题的" class="headerlink" title="DataBinding 如何解决上述问题的"></a>DataBinding 如何解决上述问题的</h3><p>我们可以查看 DataBinding 生成的绑定类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentSingleChildBinding</span> <span class="keyword">implements</span> <span class="title">ViewBinding</span> </span>&#123;</span><br><span class="line">  <span class="comment">// NonNull 注解标记</span></span><br><span class="line">  <span class="comment">// 如果存在不同配置的不同布局文件（如横竖屏）且该控件不是存在于所有布局，该处使用 Nullable注解标记</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> MaterialButton button;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FragmentSingleChildBinding <span class="title">bind</span><span class="params">(@NonNull View rootView)</span> </span>&#123;</span><br><span class="line">    String missingId;</span><br><span class="line">    missingId: &#123;</span><br><span class="line">      <span class="comment">//其内部也是使用 findViewById</span></span><br><span class="line">      MaterialButton button = rootView.findViewById(R.id.button);</span><br><span class="line">      <span class="keyword">if</span> (button == <span class="keyword">null</span>) &#123;</span><br><span class="line">        missingId = <span class="string">"button"</span>;</span><br><span class="line">        <span class="keyword">break</span> missingId;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FragmentSingleChildBinding((MaterialButton) rootView, button);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Missing required view with ID: "</span>.concat(missingId));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Binding 类内部的也是使用 findViewById ，因此 DataBinding 可以代替 findViewById ，并且减少模板代码</p></li><li><p>View 控件变量类型是固定的，因此不会出现类型安全问题</p></li><li><p>View 控件变量由空/非空注解修饰，（如果为 Nullable java 中会有 lint 警告，而 kotlin 直接调用时无法通过编译的）因此 不会出现空安全问题</p></li><li><p>通过声明式的配置，UI 完全来自唯一可信的数据源配置，保证了数据的一致性</p></li></ul><blockquote><p>注意：以上分析同样适用于 ViewBinding</p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 感受魔法的魅力</span></h2><p>这里简单展示一下 DataBinding 的「魔法」</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">"@+id/firstName"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">"@+id/lastName"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before Data Binding</span></span><br><span class="line"><span class="comment">//setContentView(R.layout.activity_main);</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//TextView firstName = (TextView) findViewById(R.id.firstName);</span></span><br><span class="line"><span class="comment">//TextView lastName = (TextView) findViewById(R.id.lastName);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//firstName.setText("xxx");</span></span><br><span class="line"><span class="comment">//lastName.setText("xxx");</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// After Data Binding</span></span><br><span class="line">        ActivityMainBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        binding.firstName.setText(<span class="string">"xxx"</span>);</span><br><span class="line">        binding.lastName.setText(<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面展示了 DataBinding 的基础操作（单纯的替换 findViewById），如果仅使用 DataBinding 这部分功能，可以考虑使用 ViewBinding</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409114053.png" alt></p><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p>在之前的布局的基础上绑定数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.example.User"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">"@+id/firstName"</span>      </span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">"@+id/lastName"</span>      </span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ActivityMainBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_main);</span><br><span class="line">binding.user = <span class="keyword">new</span> User(<span class="string">"xxx"</span>,<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式也可以用在 recyclerview adapter 中，adapter 中的代码大大减少</p><h3 id="Binding-Adapter"><a href="#Binding-Adapter" class="headerlink" title="Binding Adapter"></a>Binding Adapter</h3><p>您可能会好奇配置 <code>android:text=&quot;@{user.firstName}</code> 后内部发生了什么</p><p>DataBinding 中使用 <code>Binding Adapter</code> 来处理，它主要处理「属性」和「事件」，前者如  <code>setText()</code> ，后者如 <code>setOnClickListener()</code>。上面的 <code>android:text</code> 实际上调用的是下面的方法</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409145551.png" alt></p><p>DataBinding 中提供了很多 <code>Binding Adapter</code></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200410160031.png" alt></p><p>如果官方提供的 <code>Binding Adapter</code> 不满足您的需求，您还可以自定义 <code>Binding Adapter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter</span>(&#123;<span class="string">"imageUrl"</span>, <span class="string">"error"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(ImageView view, String url, Drawable error)</span> </span>&#123;</span><br><span class="line">  Glide.with(view).load(url).error(error).into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">app:imageUrl</span>=<span class="string">"@&#123;venue.imageUrl&#125;"</span> <span class="attr">app:error</span>=<span class="string">"@&#123;@drawable/venueError&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DadaBinding-LiveData"><a href="#DadaBinding-LiveData" class="headerlink" title="DadaBinding + LiveData"></a>DadaBinding + LiveData</h3><p>要将 LiveData 与 DataBinding 一起使用，需要指定生命周期所有者来定义 LiveData 对象的范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        UserBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.user);</span><br><span class="line"></span><br><span class="line">        binding.setLifecycleOwner(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>使用单向 DataBinding，可以在属性上设置一个值，并设置一个对该属性的更改做出反应的监听器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">"@&#123;viewmodel.rememberMe&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onCheckedChanged</span>=<span class="string">"@&#123;viewmodel.rememberMeChanged&#125;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>使用双向绑定可以简化该过程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/rememberMeCheckBox"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">"@=&#123;viewmodel.rememberMe&#125;"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>@={}</code> 接收对该属性的数据更改，并同时监听用户更新（注意，这里有 <code>=</code> ）</p><p>那么究竟什么是双向绑定呢？</p><p>所谓的「数据驱动」就是数据驱动视图的变化，而 DataBinding 的单向绑定就是如此。反过来讲，有些时候我们需要视图来驱动数据的变化（例如当我们在 EditText 上输入了文字，我们希望对应的 ViewModel 的 LiveData 的值能够及时响应该变化）</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409161036.jpg" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409110254.gif" alt></p><p>如图，绿色部分为独立的 fragment ，内部存在两个 TextView，用于显示外部 fragment EditText 输入的文字</p><p>如果实现上述功能，传统做法可能是使用 activity 级别的 ViewModel 进行两个 fragment 之间的通信，通过监听 EditText 文字的变化改变 ViewModel 中 LiveData 的值，并在绿色 fragment 中观察 LiveData 并显示到 TextView 中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> firstName = MutableLiveData&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> lastName = MutableLiveData&lt;String&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalDetailFragment</span> : <span class="type">Fragment</span></span>(R.layout.fragment_normal_detail) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> activityViewModels&lt;NormalViewModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        mViewModel.firstName.observe(viewLifecycleOwner) &#123;</span><br><span class="line">            tvFirstName.text = it</span><br><span class="line">        &#125;</span><br><span class="line">        mViewModel.lastName.observe(viewLifecycleOwner) &#123;</span><br><span class="line">            tvLastName.text = it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalFragment</span> : <span class="type">Fragment</span></span>(R.layout.fragment_normal) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> activityViewModels&lt;NormalViewModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        etFirstName.addTextChangedListener &#123;</span><br><span class="line">            mViewModel.firstName.value = it.toString()</span><br><span class="line">        &#125;</span><br><span class="line">        etLastName.addTextChangedListener &#123;</span><br><span class="line">            mViewModel.lastName.value = it.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得益于 kotlin ，上面的代码以及很简洁了，如果使用 java 代码片段只会更长。</p><p>不过使用 DataBinding，还可以更简洁</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textview.MaterialTextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/tvFirstName"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;vm.firstName&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textview.MaterialTextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/tvLastName"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;vm.lastName&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputEditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/etFirstName"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@=&#123;vm.firstName&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputEditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/etLastName"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@=&#123;vm.lastName&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>只需配置好双向绑定（EditText 驱动 ViewModel 的 LiveData 的值变化，ViewModel 再驱动 TextView 显示数据），并在 fragment 通过固定的模板代码设置好 ViewModel 即可</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409112128.jpg" alt></p><p>这里的魔法还是来自 Binding Adapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TextViewBindingAdapter.java</span></span><br><span class="line"><span class="meta">@BindingAdapter</span>(value = &#123;<span class="string">"android:beforeTextChanged"</span>, <span class="string">"android:onTextChanged"</span>,</span><br><span class="line">        <span class="string">"android:afterTextChanged"</span>, <span class="string">"android:textAttrChanged"</span>&#125;, requireAll = <span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTextWatcher</span><span class="params">(TextView view, <span class="keyword">final</span> BeforeTextChanged before,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> OnTextChanged on, <span class="keyword">final</span> AfterTextChanged after,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> InverseBindingListener textAttrChanged)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TextWatcher newValue;</span><br><span class="line">    <span class="keyword">if</span> (before == <span class="keyword">null</span> &amp;&amp; after == <span class="keyword">null</span> &amp;&amp; on == <span class="keyword">null</span> &amp;&amp; textAttrChanged == <span class="keyword">null</span>) &#123;</span><br><span class="line">        newValue = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newValue = <span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (before != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    before.beforeTextChanged(s, start, count, after);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (on != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    on.onTextChanged(s, start, before, count);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (textAttrChanged != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//通知发生变化</span></span><br><span class="line">                    textAttrChanged.onChange();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (after != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    after.afterTextChanged(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);</span><br><span class="line">    <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.removeTextChangedListener(oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.addTextChangedListener(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 InverseBindingListener （调用 <code>textAttrChanged.onChange()</code>）来通知 LiveData 数据发生变化</p><p>而变化后的值 通过 @InverseBindingAdapter 注解标记的方法处理，这里的 event 与上面的标记匹配（<code>android:textAttrChanged</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TextViewBindingAdapter.java</span></span><br><span class="line"><span class="meta">@InverseBindingAdapter</span>(attribute = <span class="string">"android:text"</span>, event = <span class="string">"android:textAttrChanged"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTextString</span><span class="params">(TextView view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> view.getText().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>view 层变化通知数据变化，数据变化再通知 view 层变化，仿佛是个套娃</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409163420.jpg" alt></p><p>因此避免这种死循环十分重要，setText 方法判断了新旧值是否相等来避免死循环</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409163541.png" alt></p><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 总结</span></h2><p>DataBinding 主要提供两部分功能</p><ul><li>替换 findViewById ，如果只用这部分功能可以使用 ViewBinding</li><li>进行 data 和 UI 的绑定，使用「数据驱动」的思想解决了视图的一致性问题</li></ul><h3 id="各种-findViewById-替代方案对比"><a href="#各种-findViewById-替代方案对比" class="headerlink" title="各种 findViewById 替代方案对比"></a>各种 findViewById 替代方案对比</h3><ul><li>findViewById </li><li>Butterknife</li><li>Kotlin Synthetics</li><li>Data Binding</li><li>View Binding</li></ul><h4 id="findViewById"><a href="#findViewById" class="headerlink" title="findViewById"></a>findViewById</h4><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409170514.png" alt></p><p>findViewById 有两个问题</p><ol><li>当不能在 Activity/Fragment/ViewGroup 中定位到指定 id 的 View，会在运行期间崩溃，即非空安全</li><li>如果某个 view 为 TextView 类型，而在使用中将其指定为其他类型不会在编译器报错，即非类型安全</li></ol><p>在 compileSdk 的 API 级别 26 中，对该方法的定义稍作更改以消除强制类型转换问题</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409171139.png" alt></p><p>现在，开发人员无需在代码中手动转换 view 类型。 如果您引用 id 指向类型 TextView 的 View 并将其指定为 Button，则 Android SDK 会尝试查找具有提供的 id 的 Button，并且它将返回 Null，因为它将无法找到它</p><p>但是在 Kotlin 中，您仍然需要提供诸如 findViewById<textview>(R.id.txtUsername) 之类的类型。 如果您不检查视图是否具有 null 安全，则可能出现 NullPointerException，但是此方法不会像以前那样抛出ClassCastException</textview></p><h4 id="Butterknife"><a href="#Butterknife" class="headerlink" title="Butterknife"></a>Butterknife</h4><p><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">Butterknife</a> 是 <a href="https://medium.com/u/8ddd94878165?source=post_page-----98b8ef5b9249----------------------" target="_blank" rel="noopener">Jake Wharton</a> 大神写的替代 findViewById 的库，该库使用注解处理并生成 findViewById 代码</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409171316.png" alt></p><p>它具有与 findViewById 几乎相似的问题。 但是，它在运行时添加了null 安全检查以避免 NullPointerException</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409171554.jpg" alt></p><p>由于 DataBinding 和 ViewBinding 的出现，沃神已经宣布弃用该库</p><h4 id="Kotlin-Synthetics"><a href="#Kotlin-Synthetics" class="headerlink" title="Kotlin Synthetics"></a>Kotlin Synthetics</h4><p>Kotlin 引入的最大功能之一是 Kotlin 扩展方法。 在它的帮助下，Kotlin Synthetics 诞生了。 Kotlin Synthetics 通过自动生成的 Kotlin 扩展方法，使开发人员可以从 xml 布局直接访问其内部的 view</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409171843.png" alt></p><p>Kotlin Synthetics 第一次调用 findViewById 方法，然后默认情况下将 view 实例缓存在 HashMap 中。 可以通过Gradle 设置将此缓存配置更改为 SparseArray 或不缓存</p><p>总体而言，Kotlin Synthetics 是一种很好的选择，因为它类型安全，并且通过 Kotlin 的 ？进行空检查。 它不需要开发人员的额外代码。 但这仅适用于 Kotlin 项目</p><p>但是，在使用 Kotlin Synthetics 时遇到了一个小问题。 例如，如果将内容视图设置为布局，然后使用仅存在于其他布局中的 id ，则 IDE 可让您自动完成并添加新的 import 语句。 除非您专门检查以确保其 import 语句仅导入正确的 view，否则没有安全的方法来验证这不会导致运行时问题</p><h4 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h4><p>DataBinding 在功能上比其他方法优越得多，因为它不仅为您提供类型安全和空安全的 view 引用，而且还允许您直接在 xml 布局内使用数据驱动视图变化</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200409172613.png" alt></p><h4 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h4><p>最近在 Android Studio 3.6 中引入的 ViewBinding 是 DataBinding 库的子集。 由于不需要注解处理，因此可以缩短构建时间。详细的使用可以参见 <a href="https://juejin.im/post/5e4806f3e51d4526c550a2ef" target="_blank" rel="noopener">这篇文章</a></p><table><thead><tr><th align="center"></th><th align="center">findViewById</th><th align="center">Butterknife</th><th align="center">Kotlin Synthetics</th><th align="center">DataBinding</th><th align="center">ViewBinding</th></tr></thead><tbody><tr><td align="center">一直空安全</td><td align="center">❌</td><td align="center">部分</td><td align="center">部分</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td align="center">类型安全</td><td align="center">❌</td><td align="center">❌</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td align="center">样板代码</td><td align="center"><font color="#CA0C16">多</font></td><td align="center"><font color="#0DD613">少</font></td><td align="center"><font color="#0DD613">少</font></td><td align="center"><font color="#B77441">中等</font></td><td align="center"><font color="#0DD613">少</font></td></tr><tr><td align="center">构建时间</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td></tr><tr><td align="center">支持语音</td><td align="center">java/kotlin</td><td align="center">java/kotlin</td><td align="center">kotlin</td><td align="center">java/kotlin</td><td align="center">java/kotlin</td></tr></tbody></table><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 关于我</span></h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e834bb5f265da480d61668d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LiveData 篇&lt;/a&gt; 我们提到 Android 开发的主要工作内容是将数据转换为 UI ，同时我们也介绍了数据驱动 UI 的思想，使用 ViewModel + LiveData，可以安全地在订阅者的生命周期内分发正确的数据。但是 activity 和 fragment 充斥着大量的模板代码，铺天盖地的 findViewById，以及各种 set （根据数据设置 UI）。如果能够消灭掉这些模板代码就好了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之LiveData】ViewModel的左膀右臂 数据驱动真的香</title>
    <link href="http://yoursite.com/2020/03/31/%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BLiveData%E3%80%91ViewModel%E7%9A%84%E5%B7%A6%E8%86%80%E5%8F%B3%E8%87%82%20%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9C%9F%E7%9A%84%E9%A6%99/"/>
    <id>http://yoursite.com/2020/03/31/【背上Jetpack之LiveData】ViewModel的左膀右臂 数据驱动真的香/</id>
    <published>2020-03-30T16:10:35.000Z</published>
    <updated>2020-04-20T09:10:31.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>之前我们讨论过 <a href="https://juejin.im/post/5e786d415188255e00661a4e" target="_blank" rel="noopener">ViewModel 的职能边界</a> ，得益于 ViewModel 的生命周期更长，我们可以在 activity 重建后将数据传递给 activity ，也可以避免内存泄漏。但是如果不是每次需要就获取数据，而是当每次有新数据时通知我们，应该怎么办？</p></blockquote><p>本文介绍 <code>LiveData</code> ，一个 <strong>生命周期感知的，可观察的，数据持有者</strong>。同时还会简单分析 <code>LiveData</code> 的源码实现</p><a id="more"></a><h2 id="我们都是-Adapter"><a href="#我们都是-Adapter" class="headerlink" title="我们都是 Adapter"></a>我们都是 Adapter</h2><p>在谈 <code>LiveData</code> 前我们来思考一个问题</p><p><strong>Android 开发（亦或者说前端开发）的本质工作内容是什么？</strong></p><p>对于应用层 app 开发者，开发者的工作主要工作就是 Adapter </p><p>什么是 Adapter ，下图可能比较直观</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330153727.png" alt="Adapter"></p><blockquote><p>图片来自 google image</p></blockquote><p>我们的工作本质是 <strong>将数据转换成 UI</strong> </p><p>数据可能来自网络，来自本地数据库，来自内存，而 UI 可能是 activity 或 fragment。</p><h2 id="理想的数据模型"><a href="#理想的数据模型" class="headerlink" title="理想的数据模型"></a>理想的数据模型</h2><p>上面我们提到 Android 开发者的核心工作就是将数据转换为 UI 。这个过程比较理想的状态是：当数据发生变化时，UI 跟随变化。我们还可以进一步展开：当 UI 对用户可见时，数据发生变化时 UI 跟随变化；当 UI 对用户不可见时，我们希望数据变化时什么都不做，当 UI 再次对用户可见时根据最新的数据进行 UI 的处理。</p><p>而 <code>LiveData</code> 就是我们理想中的数据模型</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330160205.png" alt="LiveData"></p><blockquote><p>图片来自 <a href="https://www.youtube.com/watch?v=2rO4r-JOQtA&list=PLWz5rJ2EKKc_dskHzXdKHB2ZvAlMyFwZe&index=2&t=0s" target="_blank" rel="noopener">Android Dev Summit ‘18-Fun with LiveData</a></p></blockquote><p> LiveData 可以三个关键词概括</p><ul><li><p>lifecycle-aware</p></li><li><p>observable</p></li><li><p>data holder</p></li></ul><h3 id="observable"><a href="#observable" class="headerlink" title="observable"></a>observable</h3><p>Android 中不同的组件有着不同的生命周期，不同的存活时间</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321140641.png" alt="ViewModel"></p><p>因此我们不会在 <code>ViewModel</code> 中持有 <code>Activity</code> 的引用，因为这会导致当 <code>Activity</code> 重建时内存泄漏，甚至出现空指针的情况</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330161100.png" alt="observable"></p><p>通常我们会在 <code>Activity</code> 中持有 <code>ViewModel</code> 的引用，那么如何进行二者间的通信，如何向 <code>Activity</code> 发送 <code>ViewModel</code> 中的数据？</p><p>答案是让 <code>Activity</code> 观察 <code>ViewModel</code></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330161411.png" alt></p><p><code>LiveData</code> 是 <code>observable</code></p><h3 id="lifecycle-aware"><a href="#lifecycle-aware" class="headerlink" title="lifecycle-aware"></a>lifecycle-aware</h3><p>当观察者观察着某个数据时，该数据必须保留对观察者的引用才能调用它，为了解决这个问题，<code>LiveData</code> 被设计成可感知生命周期</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330162126.png" alt></p><p>当 activity / fragment 被销毁后，它会自动的取消订阅</p><h3 id="data-holder"><a href="#data-holder" class="headerlink" title="data holder"></a>data holder</h3><p><code>LiveData</code> 仅持有 <strong>单个且最新</strong> 的数据</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200330214220.gif" alt="data holder"></p><p>上图中，最右侧是在 <code>ViewModel</code> 中的 <code>LiveData</code>，左侧为观察这个 <code>LiveData</code> 的 activity / fragment 。一旦我们为 <code>LiveData</code> 设值，该值会传递到 activity。简而言之，<code>LiveData</code> 值改变，activity 收到最新的值的变化。但是当观察者不再处于活动状态（STARTED 到 RESUMED ），数据 C 不会被发送到 activity 。当 activity 回到前台，它将收到最新的值，数据 D。<strong>LiveData 仅持有单个且最新的数据</strong>。当 activity 执行销毁流程时，此时的数据 E 也不会产生任何影响</p><h2 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h2><p><code>LiveData</code> 提供 两种 transformation ，<code>map</code> 和 <code>switch map</code>。开发者也可以创建自定义的  <code>MediatorLiveData</code> </p><p>我们都知道 <code>LiveData</code> 可以为 View 和 ViewModel 提供通信，但如果有一个第三方组件（例如 repository ）也持有 <code>LiveData</code>。那么它应该如何在 <code>ViewModel</code> 中订阅？该组件并没有 lifecycle </p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331090310.png" alt></p><p>一旦我们的应用愈发复杂，repository 可能会观察数据源</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331090412.png" alt></p><p>那么 view 如何获取 repository 中的 <code>LiveData</code>？</p><h3 id="一对一的静态转换（map）"><a href="#一对一的静态转换（map）" class="headerlink" title="一对一的静态转换（map）"></a>一对一的静态转换（map）</h3><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331090941.png" alt="one-to-one static transformation"></p><p>在上面的示例中，<code>ViewModel</code> 仅将数据从 repository 转发到 view，然后将其转换为 UI Model。 每当 repository 中有新数据时，<code>ViewModel</code> 只需 <code>map</code> </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> viewModelResult = Transformations.map(repository.getDataForUser()) &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">     convertDataToMainUIModel(<span class="keyword">data</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数为 <code>LiveData</code> 源（来自 repository ），第二个参数是一个转换函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的转换为将 X 转换为 Y</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;X, Y&gt;</span> LiveData<span class="type">&lt;X&gt;</span>.<span class="title">map</span><span class="params">(<span class="keyword">crossinline</span> transform: (<span class="type">X</span>)</span></span> -&gt; Y): LiveData&lt;Y&gt; =</span><br><span class="line">        Transformations.map(<span class="keyword">this</span>) &#123; transform(it) &#125;</span><br></pre></td></tr></table></figure><h3 id="一对一的动态转换（switchMap）"><a href="#一对一的动态转换（switchMap）" class="headerlink" title="一对一的动态转换（switchMap）"></a>一对一的动态转换（switchMap）</h3><p>假如您正在观察一个提供用户的用户管理器，并且需要提供用户的 id 才能开始观察 repository </p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331091954.png" alt></p><p>您不能将其写到 <code>ViewModel</code> 初始化的过程中，因为此时用户的 id 还不可用</p><p>这时 <code>switchMap</code> 就派上用场了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> repositoryResult = Transformations.switchMap(userManager.userId) &#123; userId -&gt;</span><br><span class="line">     repository.getDataForUser(userId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switchMap</code> 在内部使用 <code>MediatorLiveData</code>，因此了解它非常重要，因为当您要组合多个 <code>LiveData</code> 源时需要使用它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的转换为将 X 转换为 LiveData&lt;Y&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;X, Y&gt;</span> LiveData<span class="type">&lt;X&gt;</span>.<span class="title">switchMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">crossinline</span> transform: (<span class="type">X</span>)</span></span> -&gt; LiveData&lt;Y&gt;</span><br><span class="line">): LiveData&lt;Y&gt; = Transformations.switchMap(<span class="keyword">this</span>) &#123; transform(it) &#125;</span><br></pre></td></tr></table></figure><h3 id="一对多依赖（MediatorLiveData）"><a href="#一对多依赖（MediatorLiveData）" class="headerlink" title="一对多依赖（MediatorLiveData）"></a>一对多依赖（MediatorLiveData）</h3><p><code>MediatorLiveData</code> 允许您将一个或多个数据源添加到单个可观察的 <code>LiveData</code> 中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> liveData1: LiveData&lt;<span class="built_in">Int</span>&gt; = ...</span><br><span class="line"><span class="keyword">val</span> liveData2: LiveData&lt;<span class="built_in">Int</span>&gt; = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = MediatorLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">result.addSource(liveData1) &#123; value -&gt;</span><br><span class="line">    result.setValue(value)</span><br><span class="line">&#125;</span><br><span class="line">result.addSource(liveData2) &#123; value -&gt;</span><br><span class="line">    result.setValue(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，当任何一个数据源变化时，result 会更新。</p><blockquote><p>注意：数据并不是合并，MediatorLiveData 只是处理通知</p></blockquote><p>为了实现示例中的转换，我们需要将两个不同的 LiveData 组合为一个</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331094815.png" alt></p><blockquote><p>图片来自 <a href="https://medium.com/androiddevelopers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7" target="_blank" rel="noopener">LiveData beyond the ViewModel — Reactive patterns using Transformations and MediatorLiveData</a></p></blockquote><p>使用 <code>MediatorLiveData</code> 合并数据的一种方法是添加源并以其他方法设置值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">blogpostBoilerplateExample</span><span class="params">(newUser: <span class="type">String</span>)</span></span>: LiveData&lt;UserDataResult&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> liveData1 = userOnlineDataSource.getOnlineTime(newUser)</span><br><span class="line">    <span class="keyword">val</span> liveData2 = userCheckinsDataSource.getCheckins(newUser)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = MediatorLiveData&lt;UserDataResult&gt;()</span><br><span class="line"></span><br><span class="line">    result.addSource(liveData1) &#123; value -&gt;</span><br><span class="line">        result.value = combineLatestData(liveData1, liveData2)</span><br><span class="line">    &#125;</span><br><span class="line">    result.addSource(liveData2) &#123; value -&gt;</span><br><span class="line">        result.value = combineLatestData(liveData1, liveData2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据的实际组合是在 <code>combineLatestData</code> 方法中完成的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">combineLatestData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        onlineTimeResult: <span class="type">LiveData</span>&lt;<span class="type">Long</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">        checkinsResult: <span class="type">LiveData</span>&lt;<span class="type">CheckinsResult</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: UserDataResult &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> onlineTime = onlineTimeResult.value</span><br><span class="line">    <span class="keyword">val</span> checkins = checkinsResult.value</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't send a success until we have both results</span></span><br><span class="line">    <span class="keyword">if</span> (onlineTime == <span class="literal">null</span> || checkins == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDataLoading()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Check for errors and return UserDataError if any.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UserDataSuccess(timeOnline = onlineTime, checkins = checkins)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查值是否准备好并发出结果（加载中，失败或成功）</p><h2 id="LiveData-的错误用法"><a href="#LiveData-的错误用法" class="headerlink" title="LiveData 的错误用法"></a>LiveData 的错误用法</h2><h3 id="错误地使用-var-LiveData"><a href="#错误地使用-var-LiveData" class="headerlink" title="错误地使用 var LiveData"></a>错误地使用 var LiveData</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">lateinit</span> randomNumber: LiveData&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onGetNumber</span><span class="params">()</span></span> &#123;</span><br><span class="line">   randomNumber = Transformations.map(numberGenerator.getNumber()) &#123;</span><br><span class="line">       it</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个重要的问题需要理解：转换会在调用时（<code>map</code> 和 <code>switchMap</code>）会创建一个新的 <code>LiveData</code>。 在此示例中，randomNumber 公开给 View ，但是每次用户单击按钮时都会对其进行重新赋值。 观察者只会在订阅时收到分配给 var 的 <code>LiveData</code> 更新的信息</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只会收到第一次分配的值</span></span><br><span class="line">viewmodel.randomNumber.observe(<span class="keyword">this</span>, Observer &#123; number -&gt;</span><br><span class="line">    numberTv.text = resources.getString(R.string.random_text, number)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果 viewmodel.randomNumber <code>LiveData</code> 实例发生更改，这里永远不会回调。而且这里泄漏了之前的 <code>LiveData</code> ，这些 <code>LiveData</code> 不会再发送更新</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331111630.gif" alt></p><p>一言以蔽之，<strong>不要在 var 中使用 Livedata</strong></p><p>正确示例见  <a href="https://github.com/Flywith24/Flywith24-Jetpack-Demo/tree/master/demo_livedata" target="_blank" rel="noopener">demo</a></p><h3 id="LiveData-粘性事件"><a href="#LiveData-粘性事件" class="headerlink" title="LiveData 粘性事件"></a>LiveData 粘性事件</h3><p>一般来说我们使用 LiveData 持有 UI 数据和状态，但是如果通过它来发送事件，可能会出现一些问题。这些问题及解决方案 <a href="https://juejin.im/post/5b2b1b2cf265da5952314b63" target="_blank" rel="noopener">在这</a></p><h3 id="fragment-中错误地传入-LifecycleOwner"><a href="#fragment-中错误地传入-LifecycleOwner" class="headerlink" title="fragment 中错误地传入 LifecycleOwner"></a>fragment 中错误地传入 LifecycleOwner</h3><p><code>androidx fragment 1.2.0</code> 起，添加了新的 Lint 检查，以确保您在从 onCreateView()、onViewCreated() 或 onActivityCreated() 观察 <code>LiveData</code> 时使用 getViewLifecycleOwner()</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331152505.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331205402.gif" alt="bug"></p><p>如图，我们有一个 fragment ，onCreate 观察 <code>LiveData</code>，通过正常的生命周期创建了 View ，接着进入了 resume 状态。此时你使用了 <code>LiveData</code>，UI 将开始展示它。之后，用户点击了按钮，由于跳转了另一个 fragment，所以要 detach 该 fragment，一旦 fragment stop 我们就不需要其中的 view 了，因此 destroyView 。之后用户点击了返回按钮回到了上一个 fragment，由于我们已经 destroyView，因此我们需要创建一个新的 view ，接着进入正常的生命周期，但此时，出现了一个 bug 。这个新 View 不会恢复 <code>LiveData</code> 的状态，因为我们使用的是 fragment 的 lifecycle observe 的 <code>LiveData</code></p><p>我们有两种选择，在 onCreate 或者在 onCreateView 中使用 fragment 的 lifecycle observe LiveData</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331171844.png" alt></p><p>前者的优点是一次注册，缺点是当 recreate 时有bug；后者优点是能够解决 recreate 的 bug，但会导致重复注册</p><p><strong>该问题的核心是 fragment 拥有两个生命周期：fragment 自身和 fragment 内部 view 的生命周期</strong></p><p><code>androidx fragment 1.0</code> 和 <code>support library 28</code> 了 viewLifecycle</p><p><strong>因此，当需要观察 view 相关的 LiveData ，可以在 onCreateView()、onViewCreated() 或 onActivityCreated()  中 LiveData observe 方法中传入 viewLifecycleOwner 而不是传入 this</strong></p><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p>首先来看 <code>LiveData</code> 主要的源码结构</p><ul><li>LiveData </li><li>MutableLiveData</li><li>Observer</li></ul><h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p><code>LiveData</code> 是可以在给定生命周期内观察到的数据持有者类。 这意味着可以将一个<code>Observer</code> 与 <code>LifecycleOwner</code> 成对添加，并且只有在配对的 <code>LifecycleOwner</code> 处于活动状态时，才会向该观察者通知有关包装数据的修改。 如果 LifecycleOwner 的状态为 <code>Lifecycle.State.STARTED</code> 或 <code>Lifecycle.State.RESUMED</code>，则将其视为活动状态。 通过 <code>observeForever</code>（Observer）添加的观察者被视为始终处于活动状态，因此将始终收到有关修改的通知。 对于那些观察者，需要手动调用 <code>removeObserver</code>（Observer）</p><p>如果相应的生命周期移至 <code>Lifecycle.State.DESTROYED</code> 状态，则添加了生命周期的观察者将被自动删除。 这对于 activity 和 fragment 可以安全地观察 <code>LiveData</code> 而不用担心泄漏</p><p>此外，<code>LiveData</code> 具有 onActive() 和 onInactive() 方法，以便在活动观察者的数量在 0 到 1 之间变化时得到通知。这使 <code>LiveData</code> 在没有任何活动观察者的情况下可以释放大量资源。</p><p>主要方法有：</p><ul><li>T getValue() 获取LiveData 包装的数据</li><li>observe(LifecycleOwner owner, Observer&lt;? super T&gt; observer) 设置观察者（主线程调用）</li><li>setValue(T value)  设值（主线程调用），可见性为 protected 无法直接使用</li><li>postValue(T value) 设置（其他线程调用），可见性为 protected 无法直接使用</li></ul><h3 id="MutableLiveData"><a href="#MutableLiveData" class="headerlink" title="MutableLiveData"></a>MutableLiveData</h3><p><code>LiveData</code> 实现类，公开了 <code>setValue</code> 和 <code>postValue</code> 方法</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>接口，内部只有 onChanged(T t) 方法，在数据变化时该方法会被调用</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们通过源码来看看 <code>LiveData</code> 如何实现它的特性的</p><ul><li><ol><li>如何控制在 activity 或 fragment 活动状态时接收回调，否则不接收？</li></ol></li><li><ol start="2"><li>如何在 activity 或 fragment 销毁时自动取消注册观察者？</li></ol></li><li><ol start="3"><li>如何保证 <code>LiveData</code> 持有最新的数据？</li></ol></li></ul><p>我们查看 <code>LiveData</code> 的 observe 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LiveData.java</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(LifecycleOwner owner, Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// 如果 owner 已经是 DESTROYED 状态，则忽略</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 LifecycleBoundObserver 包装 owner 和 observer</span></span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="comment">// 如果已经添加过直接 return </span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LifecycleBoundObserver.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line">    LifecycleBoundObserver(LifecycleOwner owner, Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们知道，当我们调用 observe 方法时，内部是通过 <code>LifecycleBoundObserver</code> 将 owner 和 observer 包裹起来并通过 <code>addObserver</code> 方法添加观察者的，因而当数据变化时，会调用 <code>LifecycleBoundObserver</code> 的 <code>onStateChanged</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LiveData.LifecycleBoundObserver.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(@NonNull LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// 自动移除观察者，问题 2 得到解释</span></span><br><span class="line">        removeObserver(mObserver);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activeStateChanged(shouldBeActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当什么周期所有者处于 <code>DESTROYED</code> 状态时，会调用 <code>removeObserver</code> 方法，因此问题 2  得到解释</p><p>我们继续向下看，<code>activeStateChanged</code> 方法调用时传入了 <code>shouldBeActive()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 至少是 STARTED 状态 返回 true</span></span><br><span class="line">    <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">        <span class="comment">// 与上次值相同，则直接 return （两次均为活动状态或均为非活动状态）</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mActive = newActive;</span><br><span class="line">    <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据 mActive 修改活动状态观察者的数量（加 1 或减 1 ）</span></span><br><span class="line">    LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">        onActive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">        onInactive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">        <span class="comment">// 如果是活动状态，则发送数据，问题 1 得到解释</span></span><br><span class="line">        dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里牵扯了 <code>Lifecycle State</code> 比较的知识，<a href="https://juejin.im/post/5e8348bef265da47e02a6ce2#heading-11" target="_blank" rel="noopener">详情在这</a></p><p>只有 <code>STARTED</code> 和 <code>RESUMED</code> 状态 <code>shouldBeActive()</code> 才返回 true，至此问题 1 得到解释</p><p><code>dispatchingValue</code> 方法内部调用了 <code>considerNotify</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再次判断生命周期所有者状态</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较版本号</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    <span class="comment">// 调用我们传入的 mObserver 的 onChanged 方法</span></span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>considerNotify</code> 中比较了 observer 的版本号，如果是最新的数据，直接 return</p><p>而 <code>mVersion</code> 在 <code>setValue</code> 方法中 进行更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每次设置对 mVersion 进行++</span></span><br><span class="line">    mVersion++;</span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 <code>LiveData</code> 每次都持有最新的数据，问题 3 得到解释</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到本文开头的思考，Android 开发者的主要工作是将数据转换成 UI ，而 <code>LiveData</code> 本质上是一种「数据驱动」，即通过改变状态数据，来驱动视图树中绑定了相应状态数据的控件重新发生绘制。Flutter 和未来的  Jetpack Compose 采用的都是这种机制。使用 ViewModel + LiveData，可以 <strong>安全地在订阅者的生命周期内分发正确的数据</strong>，使开发者不知不觉中完成了 <code>UI -&gt; ViewModel -&gt; Data</code> 的单向依赖。</p><p><strong>所谓架构，很多时候不是使用它能做什么，更多的是不要做什么，使用它时开发者能够得到约束，以便产出更健壮的代码</strong></p><p>各位小伙伴如果有什么想法欢迎在评论区留言</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;之前我们讨论过 &lt;a href=&quot;https://juejin.im/post/5e786d415188255e00661a4e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ViewModel 的职能边界&lt;/a&gt; ，得益于 ViewModel 的生命周期更长，我们可以在 activity 重建后将数据传递给 activity ，也可以避免内存泄漏。但是如果不是每次需要就获取数据，而是当每次有新数据时通知我们，应该怎么办？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文介绍 &lt;code&gt;LiveData&lt;/code&gt; ，一个 &lt;strong&gt;生命周期感知的，可观察的，数据持有者&lt;/strong&gt;。同时还会简单分析 &lt;code&gt;LiveData&lt;/code&gt; 的源码实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之Lifecycle】万物基于Lifecycle 默默无闻大作用</title>
    <link href="http://yoursite.com/2020/03/30/%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BLifecycle%E3%80%91%E4%B8%87%E7%89%A9%E5%9F%BA%E4%BA%8ELifecycle%20%E9%BB%98%E9%BB%98%E6%97%A0%E9%97%BB%E5%A4%A7%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2020/03/30/【背上Jetpack之Lifecycle】万物基于Lifecycle 默默无闻大作用/</id>
    <published>2020-03-29T16:10:35.000Z</published>
    <updated>2020-04-10T08:45:39.764Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> Android 中有一个比较重要的概念：「生命周期」。刚毕业去面试，总会被问到「四大组件的生命周期」这类的问题。17年的 IO 大会上，Google 推出了 Lifecycle-Aware Components（生命周期感知组件），帮助开发者组织更好，更轻量，易于维护的代码</p></blockquote><p>本文介绍 <code>Lifecycle</code> 的职责以及简单分析 lifecycle 如何感知 activity 和 fragment ，帮助您对 <code>Lifecycle</code> 有一个感性的认识</p><a id="more"></a><h2 id="万物基于-Lifecycle"><a href="#万物基于-Lifecycle" class="headerlink" title="万物基于 Lifecycle"></a>万物基于 <strong>Lifecycle</strong></h2><h3 id="手动管理生命周期的痛苦你不懂"><a href="#手动管理生命周期的痛苦你不懂" class="headerlink" title="手动管理生命周期的痛苦你不懂"></a>手动管理生命周期的痛苦你不懂</h3><p><img src="https://user-gold-cdn.xitu.io/2020/3/30/1712bbbbf69f3b1e?w=2407&h=5062&f=jpeg&s=2270014" alt="lifecycles"></p><blockquote><p> 鲁迅曾说过：万物基于 Lifecycle</p></blockquote><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331214314.jpeg" alt></p><p>哦不对</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200331214054.jpeg" alt></p><p>Android 中的视图控制器就有这么多生命周期的情况，所以处理好生命周期十分重要，否则会导致内存泄漏甚至是程序崩溃。这里引用 <a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">官方文档</a> 的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 连接系统的定位服务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 与系统的定位服务断开连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, (location) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 更新 UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        myLocationListener.start();</span><br><span class="line">        <span class="comment">//管理其他需要响应 activity 生命周期的组件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">        <span class="comment">//管理其他需要响应 activity 生命周期的组件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此示例看起来不错，在实际的应用程序中，您仍然会响应生命周期的当前状态而进行过多的调用来管理 UI 和其他组件。 管理多个组件会在生命周期方法中放置大量代码，例如 onStart() 和 onStop()，这使它们难以维护</p><p>而且，不能保证组件在 activity 或 fragment 停止之前就已启动。 如果我们需要执行长时间运行的操作（例如onStart() 中的某些配置检查），则可能会导致争用情况，其中onStop() 方法在 onStart() 之前完成，从而使组件的生存期超过了所需的生存期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, location -&gt; &#123;</span><br><span class="line">            <span class="comment">// 更新 UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果在 activity 停止后调用此回调怎么办？</span></span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有所有的组件，都能感知外部的生命周期，能在相应的时机释放资源，并且在错过生命周期时能及时叫停异步的任务就好了，</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200326095005.gif" alt></p><p>我们不妨先思考一下，如果实现这样的想法，应该如何做</p><h3 id="按照惯例的思考"><a href="#按照惯例的思考" class="headerlink" title="按照惯例的思考"></a>按照惯例的思考</h3><p>首先我们先来整理一下我们的需求</p><ul><li>内部组件能够感知外部的生命周期</li><li>能够统一地管理，做到一处修改，处处生效</li><li>能够及时叫停错过的任务</li></ul><p>针对需求1，可以用观察者模式，内部组件能够在外部生命周期变化时做出相应</p><p>针对需求2，可以将依赖组件的代码移出生命周期方法内，然后移入组件本身，这样只需修改组件内部逻辑即可</p><p>针对需求3，可以在合适的时机移除观察者</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>关于开发者模式，我第一次比较详细的了解是在 <a href="https://juejin.im/user/552f20a7e4b060d72a89d87f" target="_blank" rel="noopener">扔物线</a> 的 <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a>。</p><blockquote><p>观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者（例如 A 不需要每过 2ms 就检查一次 B 的状态），而是采用<strong>注册</strong>(Register)<strong>或者称为</strong>订阅<strong>(Subscribe)</strong>的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 <code>OnClickListener</code> 。对设置 <code>OnClickListener</code> 来说， <code>View</code> 是被观察者， <code>OnClickListener</code> 是观察者，二者通过 <code>setOnClickListener()</code> 方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 <code>OnClickListener</code> 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷『你在作案的时候务必通知我』。</p></blockquote><p>OnClickListener 的模式大致如下图：</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200326103024.jpg" alt></p><blockquote><p>上述描述及图片均来自 <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></p></blockquote><p><strong>因此在生命周期组件的生命周期发生变化时告诉观察者，内部组件即可感知外部的生命周期</strong></p><h3 id="引入-Lifecycle-后"><a href="#引入-Lifecycle-后" class="headerlink" title="引入 Lifecycle 后"></a>引入 Lifecycle 后</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnectListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myLifecycleOwner.getLifecycle().addObserver(<span class="keyword">new</span> MyObserver());</span><br></pre></td></tr></table></figure><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200326134237.png" alt></p><p>这是 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>  的结构，抽象类，其内部有两个枚举，分别代表着「事件」和「状态」，此外还有三个方法，添加/移除观察者，获取当前状态</p><blockquote><p><strong>注意，这里 State 中的枚举顺序是有意义的，后文详细介绍</strong></p></blockquote><p>其实现类为  <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleRegistry" target="_blank" rel="noopener">LifecycleRegistry</a> ，可以处理多个观察者</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200326135029.png" alt="LifecycleRegistry"></p><p>其内部持有当前的状态 mState ，LifecycleOwner 以及观察者的自定义列表，同时重写了父类的添加/删除观察者的方法</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200326135636.png" alt="LifecycleOwner"></p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a> ，具有 Android 的生命周期，定制组件可以使用这些事件来处理生命周期更改，而无需在 Activity 或 Fragment 中实现任何代码</p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="noopener">LifecycleObserver</a> ，将一个类标记为 <code>LifecycleObserver</code>。 它没有任何方法，而是依赖于 OnLifecycleEvent 注解的方法</p><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver" target="_blank" rel="noopener">LifecycleEventObserver</a> ，可以接收任何生命周期更改并将其分派给接收方。</p><p><strong>如果一个类实现此接口并同时使用 OnLifecycleEvent，则注解将被忽略</strong></p><p><a href="https://developer.android.com/reference/androidx/lifecycle/DefaultLifecycleObserver" target="_blank" rel="noopener">DefaultLifecycleObserver</a> ，用于监听 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a> 状态更改的回调接口。</p><p>如果一个类同时实现了此接口和 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver" target="_blank" rel="noopener">LifecycleEventObserver</a>，则将首先调用<code>DefaultLifecycleObserver</code> 的方法，然后再调用LifecycleEventObserver.onStateChanged（LifecycleOwner，Lifecycle.Event）</p><blockquote><p>注意：使用 <a href="https://developer.android.com/reference/androidx/lifecycle/DefaultLifecycleObserver" target="_blank" rel="noopener">DefaultLifecycleObserver</a> 需引入</p><p> implementation “androidx.lifecycle:lifecycle-common-java8:$lifecycle_version”</p></blockquote><h2 id="简单的源码分析"><a href="#简单的源码分析" class="headerlink" title="简单的源码分析"></a>简单的源码分析</h2><h3 id="activity-生命周期处理"><a href="#activity-生命周期处理" class="headerlink" title="activity 生命周期处理"></a>activity 生命周期处理</h3><p>首先我们还是来看 <strong>androidx.activity.ComponentActivity</strong> ，这个类我们这个系列的文章里提到多次，第一次提及是在 <a href="https://juejin.im/post/5e738d12518825495d69cfb9#heading-2" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a> ，感兴趣的小伙伴可以看看。</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200327104836.png" alt="ComponentActivity"></p><p>其实现的接口大多数我们都已经探讨过了，今天我们来看看 LifecycleOwner</p><blockquote><p>ActivityResultCaller 为 activity 1.2.0-alpha02 推出的，旨在统一 onActivityResult ，这里暂时不讨论它</p></blockquote><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200327105352.png" alt></p><p>既然实现了 <code>LifecycleOwner</code> 接口，必定重写 getLifecycle() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.ComponentActivity.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回的 <code>Lifecycle</code> 为 实现类 <code>LifecycleRegistry</code> 的实例</p><p>而 activity 操作生命周期是通过 <code>ReportFragment</code> 处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.ComponentActivity.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReportFragment</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">        <span class="comment">// api 29 及以上 直接注册正确的生命周期回调</span></span><br><span class="line">        activity.registerActivityLifecycleCallbacks(</span><br><span class="line">                <span class="keyword">new</span> LifecycleCallbacks());</span><br><span class="line">    &#125;</span><br><span class="line">    android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">    <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">        manager.executePendingTransactions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200327113340.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReportFragment.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(@NonNull Activity activity, @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(@NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">        dispatch(getActivity(), event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LifecycleCallbacks</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleCallbacks</span> <span class="keyword">implements</span> <span class="title">Application</span>.<span class="title">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostCreated</span><span class="params">(@NonNull Activity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostStarted</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostResumed</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPrePaused</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPreStopped</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPreDestroyed</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 activity 的 onCreate 方法中，调用了 <code>ReportFragment</code> 中的静态方法 <code>injectIfNeededIn()</code> 。而其内部，<strong>如果 api 29 及以上的设备上直接注册正确的生命周期回调，低版本通过启动 ReportFragment ，借助 fragment 各个生命周期来处理生命周期回调</strong></p><h3 id="fragment-生命周期处理"><a href="#fragment-生命周期处理" class="headerlink" title="fragment 生命周期处理"></a>fragment 生命周期处理</h3><p>在 fragment 内部，每个生命周期节点调用 <code>handleLifecycleEvent</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Fragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initLifecycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    onCreate(savedInstanceState);</span><br><span class="line">mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    onStart();</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    onResume();</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    onPause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class="line">    onStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lifecycle-State-大小比较"><a href="#Lifecycle-State-大小比较" class="headerlink" title="Lifecycle State 大小比较"></a>Lifecycle State 大小比较</h3><p><code>Lifecycle.State</code>  中有一个 <code>isAtLeast</code> 方法，用于判断当前状态是否不小于传入的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lifecycle.State</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(@NonNull State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举的 compareTo 方法其实是比较的枚举声明的顺序</strong></p><p>而 State 的顺序为 DESTROYED -&gt; INITIALIZED -&gt; CREATED -&gt; STARTED -&gt; RESUMED</p><blockquote><p>如果传入的 state 为 STARTED，则当前状态为 STARTED 或 RESUMED 时返回 true ，否则返回 false</p><p>LiveData 篇会用到这个知识点</p></blockquote><h2 style="color: inherit; line-height: inherit; padding: 0px; margin: 1.6em 0px; font-weight: bold; border-bottom: 2px solid #9370DB; font-size: 1.3em;"><span style="font-size: inherit; line-height: inherit; margin: 0px; display: inline-block; font-weight: normal; background: #9370DB; color: rgb(255, 255, 255); padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;"> 关于我</span></h2><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; Android 中有一个比较重要的概念：「生命周期」。刚毕业去面试，总会被问到「四大组件的生命周期」这类的问题。17年的 IO 大会上，Google 推出了 Lifecycle-Aware Components（生命周期感知组件），帮助开发者组织更好，更轻量，易于维护的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文介绍 &lt;code&gt;Lifecycle&lt;/code&gt; 的职责以及简单分析 lifecycle 如何感知 activity 和 fragment ，帮助您对 &lt;code&gt;Lifecycle&lt;/code&gt; 有一个感性的认识&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之ViewModel】即使您不使用MVVM也要了解ViewModel ViewModel的职能边界</title>
    <link href="http://yoursite.com/2020/03/23/%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BViewModel%E3%80%91%E5%8D%B3%E4%BD%BF%E6%82%A8%E4%B8%8D%E4%BD%BF%E7%94%A8MVVM%E4%B9%9F%E8%A6%81%E4%BA%86%E8%A7%A3ViewModel%20ViewModel%E7%9A%84%E8%81%8C%E8%83%BD%E8%BE%B9%E7%95%8C/"/>
    <id>http://yoursite.com/2020/03/23/【背上Jetpack之ViewModel】即使您不使用MVVM也要了解ViewModel ViewModel的职能边界/</id>
    <published>2020-03-22T16:10:35.000Z</published>
    <updated>2020-03-24T01:26:41.168Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324083031.png" alt="目录"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Android 开发时，我们使用 activity 和 fragment 作为视图控制器， 可能还会使用有一些类可以存储和提供 UI 数据（例如MVP中的 <code>Presenter</code> ）</p></blockquote><p>但是 当配置更改时（如旋转屏幕），activity 会重建，但对于 UI 数据的持有者呢？</p><ul><li>开发者需要重新保存相关的信息并传递给重建的 activity ，否则开发者必须再次获取数据（通过网络请求或本地数据库）</li><li>由于 UI 数据的持有者的生命周期可能比 activity 长，因此开发者还需要避免出现内存泄漏的问题</li></ul><p>如何解决上述问题？ViewModel</p><p><strong>本文重点介绍 ViewModel 的职责（what）以及重点功能的实现原理（how），即使您不使用 <code>Jetpack MVVM</code> 架构，也要了解一下 ViewModel</strong></p><p>ViewModel 的原理部分要求您了解 activity 的启动流程，这部分内容网上文章很多，本文不再赘述</p><a id="more"></a><h2 id="ViewModel-的职责"><a href="#ViewModel-的职责" class="headerlink" title="ViewModel 的职责"></a>ViewModel 的职责</h2><p>我先上个 <a href="https://www.bilibili.com/video/av97794796/" target="_blank" rel="noopener">视频</a> ，这个小姐姐表述的比文字更形象</p><p><a href="https://www.bilibili.com/video/av97794796/" target="_blank" rel="noopener"><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321135602.png" alt></a></p><p><code>ViewModel</code> 主要用于存储 UI 数据以及生命周期感知的数据</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321140300.gif" alt></p><blockquote><p>图片来自 <a href="https://android.jlelse.eu/android-architecture-components-viewmodel-e74faddf5b94" target="_blank" rel="noopener">Android Architecture Components: ViewModel</a></p></blockquote><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321140641.png" alt="ViewModel生命周期"></p><blockquote><p><code>ViewModel</code> 的生命周期 ，图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#lifecycle" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="作为数据持有者"><a href="#作为数据持有者" class="headerlink" title="作为数据持有者"></a>作为数据持有者</h3><p><code>ViewModel</code> 能够实时进行配置更改。 这意味着即使在手机旋转后销毁并重新创建 activity 之后，您仍然拥有相同的 <code>ViewModel</code> 和相同的数据。 因此：</p><ul><li>您无需担心 UI 数据持有者的生命周期。 <code>ViewModel</code> 将由工厂自动创建，您无需自行创建和销毁</li><li>数据将始终更新，旋转手机后，您将获得与以前相同的数据。 因此，您无需手动将数据传递给新的 activity 实例或再次调用网络或数据库来获取数据。 </li></ul><h3 id="Fragment-间共享数据"><a href="#Fragment-间共享数据" class="headerlink" title="Fragment 间共享数据"></a>Fragment 间共享数据</h3><p>一个 activity 中的两个或更多 fragment 需要相互通信是很常见的。例如您有一个片段，用户在其中从列表中选择一个 item，另一个片段显示了所选 item 的内容。 传统做法两个 fragment 都需要定义一些接口，并且宿主 activity 必须将两者绑定在一起。 此外，两个 fragment 都必须处理另一个 fragment 尚未创建或不可见的情况。</p><p>可以通过使用 <code>ViewModel</code> 对象解决此问题。 这些 fragment 可以使用 activity 范围内共享一个 <code>ViewModel</code> 来处理此通信，如以下示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="keyword">new</span> MutableLiveData&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;Item&gt; <span class="title">getSelected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SharedViewModel model;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(@NonNull View view, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        model = <span class="keyword">new</span> ViewModelProvider(requireActivity()).get(SharedViewModel.class);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(@NonNull View view, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        SharedViewModel model = <span class="keyword">new</span> ViewModelProvider(requireActivity()).get(SharedViewModel.class);</span><br><span class="line">        model.getSelected().observe(getViewLifecycleOwner(), &#123; item -&gt;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于 两个 fragment 使用的都是 activity 范围的 <code>ViewModel</code> （<code>ViewModelProvider</code> 构造器传入的 activity ），因此它们获得了相同的 ViewModel 实例，自然其持有的数据也是相同的，这也 <strong>保证了数据的一致性</strong></p></blockquote><p>这种方法具有以下优点：</p><ul><li><p>宿主 activity 无需执行任何操作，也无需了解此通信。</p></li><li><p>除 <code>SharedViewModel</code> 外，fragment 不需要彼此了解。 如果其中一个 fragment 消失了，则另一个继续照常工作。</p></li><li><p>每个 fragment 都有其自己的生命周期，并且不受另一个 fragment 的生命周期影响。 如果一个 fragment 替换了另一个 fragment，则 UI 可以继续正常工作而不会出现任何问题。</p></li></ul><h3 id="代替-Loader"><a href="#代替-Loader" class="headerlink" title="代替 Loader"></a>代替 Loader</h3><p><code>CursorLoader</code> 这样的 Loader 类经常用于使应用程序 UI 中的数据与数据库保持同步。您可以使用 <code>ViewModel</code> 和其他一些类来替换 Loader。 使用 <code>ViewModel</code> 可将视图控制器与数据加载操作分开，这意味着您在类之间的强引用较少。</p><p>在使用 Loader 的一种常见方法中，应用程序可能会使用 <code>CursorLoader</code> 来观察数据库的内容。 当数据库中的值更改时，加载程序会自动触发数据的重新加载并更新 UI</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321144832.png" alt></p><blockquote><p>图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#loaders" target="_blank" rel="noopener">官方文档</a></p></blockquote><p><code>ViewModel</code> 与 <code>Room</code> 和 <code>LiveData</code> 一起使用以替换 Loader。 <code>ViewModel</code> 确保数据在设备配置更改后仍然存在。 当数据库发生更改时，<code>Room</code> 会通知 <code>LiveData</code> ，然后 <code>LiveData</code> 会使用修改后的数据更新 UI</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321144949.png" alt></p><blockquote><p>图片来自 <a href="https://developer.android.com/topic/libraries/architecture/viewmodel#loaders" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>ViewModel 可作为 UI 数据的持有者，在 activity/fragment 重建时 ViewModel 中的数据不受影响，同时可以避免内存泄漏</strong></li><li><strong>可以通过 ViewModel 来进行 activity 和 fragment ，fragment 和 fragment 之间的通信，无需关心通信的对方是否存在，使用 application 范围的 ViewModel 可以进行全局通信</strong></li><li><strong>可以代替 Loader</strong></li></ul><h2 id="ViewModel-源码分析"><a href="#ViewModel-源码分析" class="headerlink" title="ViewModel 源码分析"></a>ViewModel 源码分析</h2><p>分析源码时我们可以不计较细枝末节，只分析主要的逻辑即可。因此我们来思考几个问题，并从源码中寻找答案</p><ul><li><p>如何做到 activity 重建后 <code>ViewModel</code> 仍然存在？</p></li><li><p>如何做到 fragment 重建后 <code>ViewModel</code> 仍然存在？</p></li><li><p>如何控制作用域？（即保证相同作用域获取的 <code>ViewModel</code> 实例相同）</p></li><li><p>如何避免内存泄漏？</p></li></ul><p>维持我们一贯的风格，我们先来大胆地猜一猜</p><p>对于问题1 ：activity 有着 <code>saveInstanceState</code> 机制，因此可能通过该机制来处理（<strong>事实证明不是</strong>）</p><p>对于问题2：可能 fragment 通过 宿主 activity 或 父 fragment 的帮助来确保 <code>ViewModel</code> 实例在重建后仍然存在</p><p>对于问题3：实现一个类似单例的效果，相同作用域获取的对象是相同的</p><p>对于问题4：避免 <code>ViewModel</code> 持有 view 或 context 的引用</p><p>首先我们要先了解一下 <code>ViewModel</code> 的结构</p><ul><li><p><code>ViewModel</code>：抽象类，主要有 clear 方法，它是 final 级，不可修改，clear 方法中包含 onClear 钩子，开发者可重写 onClear 方法来自定义数据的清空</p></li><li><p><code>ViewModelStore</code>：内部维护一个 HashMap 以管理 <code>ViewModel</code></p></li><li><p><code>ViewModelStoreOwner</code>：接口，<code>ViewModelStore</code> 的作用域，实现类为 <code>ComponentActivity</code> 和 <code>Fragment</code>，此外还有 <code>FragmentActivity.HostCallbacks</code></p></li><li><p><code>ViewModelProvider</code>：用于创建 <code>ViewModel</code>，其构造方法有两个参数，第一个参数传入 <code>ViewModelStoreOwner</code> ，确定了 <code>ViewModelStore</code> 的作用域，第二个参数为 <code>ViewModelProvider.Factory</code>，用于初始化 <code>ViewModel</code> 对象，默认为 <code>getDefaultViewModelProviderFactory()</code> 方法获取的 factory</p></li></ul><p>简单来说 <strong>ViewModelStoreOwner 持有 ViewModelStore 持有 ViewModel</strong></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321152406.png" alt></p><h3 id="1-如何做到-activity-重建后-ViewModel-仍然存在？"><a href="#1-如何做到-activity-重建后-ViewModel-仍然存在？" class="headerlink" title="1. 如何做到 activity 重建后 ViewModel 仍然存在？"></a>1. 如何做到 activity 重建后 ViewModel 仍然存在？</h3><p>在 <a href="https://juejin.im/post/5e738d12518825495d69cfb9" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a> 中我们提到了 androidx.core.app.ComponentActivity 的引入并探讨了其作为中间层的作用</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200321155215.png" alt></p><p>我们已经讲过 <code>SavedStateRegistryOwner</code> 和 <code>OnBackPressedDispatcherOwner</code> 这两种角色，而今天我们来聊一下</p><p><code>ViewModelStoreOwner</code> 和 <code>HasDefaultViewModelProviderFactory</code> 。其中前者代表着 <code>ViewModelStore</code> 的作用域，后者来标记 <code>ViewModelStoreOwner</code> 拥有默认的 <code>ViewModelProvider.Factory</code></p><p>那么 <code>ViewModel</code> 的逻辑肯定就在该类了</p><p><code>ComponentActivity</code> 实现了 <code>ViewModelStoreOwner</code>  接口，意味着需要重写 <code>getViewModelStore()</code> 方法，该方法为 <code>ComponentActivity</code>  的 <code>mViewModelStore</code> 变量赋值。<strong>activity 重建后 ViewModel 仍然存在，只要保证 activity 重建后 mViewModelStore 变量值不变即可</strong></p><p>顺着这个思路，我们来看一下 <code>getViewModelStore()</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">        NonConfigurationInstances nc =</span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//核心，在该位置重置 mViewModelStore</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mViewModelStore = <span class="keyword">new</span> ViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即 <code>mViewModelStore</code> 的值由 <code>getLastNonConfigurationInstance()</code> 返回的 <code>NonConfigurationInstances</code> 对象中的 <code>viewModelStore</code> 赋值，如果此时还为空才去 new ViewModelStore 对象。因此我们只需找到 </p><p><code>getLastNonConfigurationInstance</code> 中的 <code>NonConfigurationInstances</code> 在哪里保存的即可</p><p><code>getLastNonConfigurationInstance</code> 为平台 activity 中的方法，返回 <code>mLastNonConfigurationInstances.activity</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getLastNonConfigurationInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLastNonConfigurationInstances != <span class="keyword">null</span></span><br><span class="line">            ? mLastNonConfigurationInstances.activity : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们看一下 <code>mLastNonConfigurationInstances</code> 的赋值位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略其他参数</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(NonConfigurationInstances lastNonConfigurationInstances)</span></span>&#123;</span><br><span class="line">mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解过 activity 的启动流程的小伙伴肯定知道，这个 attach 方法是 <code>ActivityThread</code> 中的 <code>performLaunchActivity</code> 调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line">    <span class="comment">//省略其他参数</span></span><br><span class="line">    activity.attach(r.lastNonConfigurationInstances);</span><br><span class="line">    r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深入追踪源码我们整理一下调用流程</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200323114334.png" alt></p><p>由于 <code>ActivityThread</code> 中的 <code>ActivityClientRecord</code> 不受 activity 重建的影响，所以 activity 重建时 <code>mLastNonConfigurationInstances</code> 能够得到上一次的值，使得 <code>ViewModelStore</code> 值不变 ，问题1就解决了</p><h3 id="2-如何做到-fragment-重建后-ViewModel-仍然存在？"><a href="#2-如何做到-fragment-重建后-ViewModel-仍然存在？" class="headerlink" title="2. 如何做到 fragment 重建后 ViewModel 仍然存在？"></a>2. 如何做到 fragment 重建后 ViewModel 仍然存在？</h3><p>对于问题2，有了上面的思路我们可以认定 fragment 重建后其内部的 <code>getViewModelStore()</code> 方法返回的对象是相同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mFragmentManager.getViewModelStore(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>getViewModelStore()</code> 内部调用的是 <code>mFragmentManager</code>（普通fragment 对应 activity 中的 <code>FragmentManager</code>，子 fragment 则对应父 fragment 的 <code>childFragmentManager</code>）的 <code>getViewModelStore()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentManager.java</span></span><br><span class="line"><span class="keyword">private</span> FragmentManagerViewModel mNonConfig;</span><br><span class="line"></span><br><span class="line"><span class="function">ViewModelStore <span class="title">getViewModelStore</span><span class="params">(@NonNull Fragment f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mNonConfig.getViewModelStore(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>而 FragmentManager 中的 getViewModelStore 使用的是 mNonConfig ，mNonConfig 竟然是个 ViewModel！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentManagerViewModel.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModelStore&gt; mViewModelStores = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p><code>FragmentManagerViewModel</code> 管理着内部的 <code>ViewModelStore</code> 和 child 的 <code>FragmentManagerViewModel</code> 。因此保证 mNonConfig   值不变即能确保 fragment 中的 <code>getViewModelStore()</code>  不变。那么看看 mNonConfig  赋值的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachController</span><span class="params">(@NonNull FragmentHostCallback&lt;?&gt; host, @NonNull FragmentContainer container, @Nullable <span class="keyword">final</span> Fragment parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 嵌套 fragment 的情况，有父 fragment</span></span><br><span class="line">        mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (host <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">        <span class="comment">// host 是 FragmentActivity.HostCallbacks</span></span><br><span class="line">        ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();</span><br><span class="line">        mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNonConfig = <span class="keyword">new</span> FragmentManagerViewModel(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// FragmentManagerViewModel.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FragmentManagerViewModel <span class="title">getInstance</span><span class="params">(ViewModelStore viewModelStore)</span> </span>&#123;</span><br><span class="line">    ViewModelProvider viewModelProvider = <span class="keyword">new</span> ViewModelProvider(viewModelStore,</span><br><span class="line">            FACTORY);</span><br><span class="line">    <span class="keyword">return</span> viewModelProvider.get(FragmentManagerViewModel.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看 fragment 的直接宿主是 activity （即没有嵌套）的情况，mNonConfig 由<code>FragmentManagerViewModel.getInstance(viewModelStore)</code> 赋值，而 getInstance 中使用的是 <code>ViewModelProvider</code> 获取 <code>ViewModel</code> ，根据我们上面的分析，<strong>只要保证作用域（viewModelStore）相同，即可获取相同的 <code>ViewModel</code> 实例</strong>，因此我们需要看一下 host 的 getViewModelStore 方法。经过一番寻找，host 是 <code>FragmentActivity.HostCallbacks</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentActivity.java 内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HostCallbacks</span> <span class="keyword">extends</span> <span class="title">FragmentHostCallback</span>&lt;<span class="title">FragmentActivity</span>&gt; <span class="keyword">implements</span> <span class="title">ViewModelStoreOwner</span>, <span class="title">OnBackPressedDispatcherOwner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 宿主 activity 的 getViewModelStore</span></span><br><span class="line">    <span class="keyword">return</span> FragmentActivity.<span class="keyword">this</span>.getViewModelStore();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>host 的 getViewModelStore 方法返回的是宿主 activity 的 <code>getViewModelStore()</code> ，而 activity 重建后其内部的 <code>mViewModelStore</code> 是不变的，因此即使 activity 重建，其内部的 FragmentManager 对象变化，但 FragmentManager 内部的  FragmentManagerViewModel 的实例（<code>mNonConfig</code>）不变，mNonConfig.getViewModelStore 不变，fragment 的 <code>getViewModelStore()</code> 亦不变，fragment 重建后其内部的 <code>ViewModel</code> 仍然存在</p><p>对于嵌套 fragment ，mNonConfig 通过 parent.mFragmentManager.getChildNonConfig(parent) 获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> FragmentManagerViewModel <span class="title">getChildNonConfig</span><span class="params">(@NonNull Fragment f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mNonConfig.getChildNonConfig(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文提到 <code>FragmentManagerViewModel</code> 管理着 mChildNonConfigs Map，因此子 fragment 重置后其内部的 mNonConfig 对象也是相同的</p><p>至此问题 2 就解决了</p><h3 id="3-如何控制作用域？"><a href="#3-如何控制作用域？" class="headerlink" title="3. 如何控制作用域？"></a>3. 如何控制作用域？</h3><p>对于问题3，我们知道 <code>ViewModelStoreOwner</code> 代表着作用域，其内部唯一的方法返回 <code>ViewModelStore</code> 对象，也即不同的作用域对应不同的 <code>ViewModelStore</code> ，而 <code>ViewModelStore</code>  内部维护着 <code>ViewModel</code> 的 HashMap ，因此只要保证相同作用域的 <code>ViewModelStore</code> 对象相同就能保证相同作用域获取到相同的 <code>ViewModel</code> 对象，而问题1我们已经解释了重建时如何保证 <code>ViewModelStore</code>  对象不变。</p><p>因此问题3也解决了。</p><h3 id="4-如何避免内存泄漏？"><a href="#4-如何避免内存泄漏？" class="headerlink" title="4. 如何避免内存泄漏？"></a>4. 如何避免内存泄漏？</h3><p>对于问题4，由于 <code>ViewModel</code> 的设计，使得 activity/fragment 依赖它，而 <code>ViewModel</code> 不依赖视图控制器。因此只要不让 <code>ViewModel</code> 持有 context 或 view 的引用，就不会造成内存泄漏</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>简单的总结一下：</p><ul><li><p><strong>activity 重建后 mViewModelStore 通过 ActivityThread 的一系列方法能够保持不变，从而当 activity 重建时 ViewModel 中的数据不受影响</strong></p></li><li><p><strong>通过宿主 activity 范围内共享的 FragmentManagerViewModel 来存储 fragment 的 ViewModelStore 和子fragment 的 FragmentManagerViewModel ，而 activity 重建后 FragmentManagerViewModel  中的数据不受影响，因此 fragment 内部的 ViewModel 的数据也不受影响</strong></p></li><li><p><strong>通过同一 ViewModelStoreOwner 获取的 ViewModelStore 相同，从而保证同一作用域通过 ViewModelProvider 获取的ViewModel 对象是相同的</strong></p></li><li><p><strong>通过单向依赖（视图控制器持有 ViewModel ）来解决内存泄漏的问题</strong></p></li></ul><h2 id="ViewModel-和-onSaveInstanceState"><a href="#ViewModel-和-onSaveInstanceState" class="headerlink" title="ViewModel 和 onSaveInstanceState"></a>ViewModel 和 onSaveInstanceState</h2><p><code>ViewModel</code> 和 <code>onSaveInstanceState</code> 的功能有些类似，但它们也有很多差异</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200323160417.png" alt></p><p>从存储位置上来说，<code>ViewModel</code> 是在内存中，因此其读写速度更快，但当进程被系统杀死后，<code>ViewModel</code> 中的数据也不存在了。从数据存储的类型上来看，<code>ViewModel</code> 适合存储相对较重的数据，例如网络请求到的 list 数据，而 <code>onSaveInstanceState</code> 适合存储轻量可序列化的数据</p><p>那么我们该如何使用呢？可以使用 <code>viewmodel-savedstate</code> 库，详情参考 <a href="https://juejin.im/post/5e738d12518825495d69cfb9#heading-10" target="_blank" rel="noopener">【背上Jetpack】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</a></p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/flywith24/Album/raw/master/img/20200324083031.png&quot; alt=&quot;目录&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Android 开发时，我们使用 activity 和 fragment 作为视图控制器， 可能还会使用有一些类可以存储和提供 UI 数据（例如MVP中的 &lt;code&gt;Presenter&lt;/code&gt; ）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是 当配置更改时（如旋转屏幕），activity 会重建，但对于 UI 数据的持有者呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发者需要重新保存相关的信息并传递给重建的 activity ，否则开发者必须再次获取数据（通过网络请求或本地数据库）&lt;/li&gt;
&lt;li&gt;由于 UI 数据的持有者的生命周期可能比 activity 长，因此开发者还需要避免出现内存泄漏的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何解决上述问题？ViewModel&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文重点介绍 ViewModel 的职责（what）以及重点功能的实现原理（how），即使您不使用 &lt;code&gt;Jetpack MVVM&lt;/code&gt; 架构，也要了解一下 ViewModel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ViewModel 的原理部分要求您了解 activity 的启动流程，这部分内容网上文章很多，本文不再赘述&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之ViewModel】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析</title>
    <link href="http://yoursite.com/2020/03/19/%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BViewModel%E3%80%91%E7%BB%9D%E4%B8%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E7%8A%B6%E6%80%81%20androidx%20SaveState%20ViewModel-SaveState%20%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/03/19/【背上Jetpack之ViewModel】绝不丢失的状态 androidx SaveState ViewModel-SaveState 分析/</id>
    <published>2020-03-18T16:10:35.000Z</published>
    <updated>2020-03-24T01:27:06.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>大家都知道 activity 有着一套 <code>onSaveInstanceState-onRestoreInstanceState</code> 状态保存机制，旨在「系统资源回收」或「配置发生变化」保存状态，为用户提供更好的体验</p><p>在 androidx 下，提供了 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 库帮助 activity 和 fragment 处理状态保存和恢复</p></blockquote><p>本文默认您对状态保存机制有一定了解，这部分内容请移步 <a href="https://developer.android.com/topic/libraries/architecture/saving-states" target="_blank" rel="noopener">Saving UI States</a></p><p>此外，关于 android 下的进程管理，推荐 Ian Lake 的 <a href="https://medium.com/androiddevelopers/who-lives-and-who-dies-process-priorities-on-android-cb151f39044f" target="_blank" rel="noopener">Who lives and who dies? Process priorities on Android</a></p><p>本文介绍了 androidx 下 <code>SavedState</code> 如何帮助 activity 和 fragment 处理状态的保存和恢复，同时介绍 <code>viewmodel-savedstate</code> 库，以及在开发过程中正确使用状态保存的姿势</p><a id="more"></a><h2 id="软件工程中没有什么是中间层解决不了的"><a href="#软件工程中没有什么是中间层解决不了的" class="headerlink" title="软件工程中没有什么是中间层解决不了的"></a>软件工程中没有什么是中间层解决不了的</h2><p>在分析 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 库之前我们需要简单聊一聊 <code>ComponentActivity</code></p><p>androidx activity 1.0.0 时，<code>ComponentActivity</code> 成为了 <code>FragmentActivity</code> 和 <code>AppCompatActivity</code> 的基类。</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318211230.png" alt="androidx activity 1.0.0 "></p><p>俗话说「百因必有果」，带着强烈的好奇心，我查了一下 ComponentActivity 引入的原因。</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318211823.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318211806.png" alt></p><p>可以看到 <code>ComponentActivity</code> 继承了 androidx.core.app.ComponentActivity(在fragment库中)，并且最初仅实现了<code>LifecycleOwner</code> 接口</p><p>我们创建的 activity 的继承关系现在变成了这样：</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318213053.png" alt></p><p>那么回到最初的问题，为什么要引入 <code>ComponentActivity</code> ？其实看看现在 <code>ComponentActivity</code> 的类结构答案就很清楚了</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318213151.png" alt></p><p><code>ComponentActivity</code> 实现了五个接口，代表着其除了 activity 还充当着五种角色。本着职能单一原则，官方通过建立一个中间层将部分功能分别交于专门的类来负责，OnBackPressedDispatcherOwner 就是我们讲 fragment 返回栈（<a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇</a>）时提到的结构，而其中的 <code>SavedStateRegistryOwner</code> 则是我们今天要讲的主角  <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> 中的成员</p><h2 id="SavedState"><a href="#SavedState" class="headerlink" title="SavedState"></a>SavedState</h2><p>引入 <a href="https://developer.android.com/jetpack/androidx/releases/savedstate" target="_blank" rel="noopener">SavedState</a> </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.savedstate:savedstate:1.0.0"</span></span><br></pre></td></tr></table></figure><p>其实您不需要显示地声明，因为 activity 库内部已经引入了。jetpack 组件依赖关系可参考 <a href="https://juejin.im/post/5e567ee1518825494466a938" target="_blank" rel="noopener">【背上Jetpack】Jetpack 主要组件的依赖及传递关系</a></p><p>这是一个很小的库</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318215718.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200318215746.png" alt></p><blockquote><p>图片来自 <a href="https://proandroiddev.com/viewmodels-state-persistence-savedstate-54d015acad82" target="_blank" rel="noopener">Android ViewModels: State persistence — SavedState</a></p></blockquote><h3 id="SavedStateProvider"><a href="#SavedStateProvider" class="headerlink" title="SavedStateProvider"></a>SavedStateProvider</h3><p>保存状态的组件，此状态将在以后恢复并使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SavedStateProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Bundle <span class="title">saveState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SavedStateRegistry"><a href="#SavedStateRegistry" class="headerlink" title="SavedStateRegistry"></a>SavedStateRegistry</h3><p>管理 <code>SavedStateProvider</code> 列表的组件，此注册表绑定了其所有者的生命周期（即 activity 或 fragment）。每次创建生命周期所有者都会创建一个新的实例</p><p>创建注册表的所有者后（例如，在调用 activity 的 <code>onCreate(savedInstanceState)</code> 方法之后），将调用其 <code>performRestore(state)</code> 方法，以恢复系统杀死其所有者之前保存的任何状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performRestore</span><span class="params">(@NonNull Lifecycle lifecycle, @Nullable Bundle savedState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (savedState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRestoredState = savedState.getBundle(SAVED_COMPONENTS_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个注册表的 <code>SavedStateProvider</code> 都由用于注册它的唯一密钥标识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SafeIterableMap&lt;String, SavedStateProvider&gt; mComponents = <span class="keyword">new</span> SafeIterableMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSavedStateProvider</span><span class="params">(@NonNull String key, @NonNull SavedStateProvider provider)</span> </span>&#123;</span><br><span class="line">    SavedStateProvider previous = mComponents.putIfAbsent(key, provider);</span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"SavedStateProvider with the given key is already registered"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterSavedStateProvider</span><span class="params">(@NonNull String key)</span> </span>&#123;</span><br><span class="line">    mComponents.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦完成注册，就可以通过<code>consumeRestoredStateForKey(key)</code> 来使用特定密钥的还原状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">consumeRestoredStateForKey</span><span class="params">(@NonNull String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRestoredState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Bundle result = mRestoredState.getBundle(key);</span><br><span class="line">        <span class="comment">//调用后就会清空，第二次调用返回null</span></span><br><span class="line">        mRestoredState.remove(key);</span><br><span class="line">        <span class="keyword">if</span> (mRestoredState.isEmpty()) &#123;</span><br><span class="line">            mRestoredState = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，此方法检索保存的状态，然后清除其内部引用，这意味着用相同的键调用它两次将在第二次调用中返回 null</p><p>一旦注册表恢复了其保存状态，则由提供者决定是否要求其恢复的数据。 如果没有，下次注册表的所有者被系统杀死时，未使用的还原数据将再次保存到保存状态</p></blockquote><p>已注册的 provider 能够在其所有者被系统杀死之前保存状态。 发生这种情况时，将调用其 <code>Bundle saveState()</code> 方法。 对于每个已注册的 <code>SavedStateProvider</code>，都可以像这样保存状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">savedState.putBundle(savedStateProviderKey, savedStateProvider.saveState());</span><br></pre></td></tr></table></figure><p><code>performSave(outBundle)</code> 方法的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSave</span><span class="params">(@NonNull Bundle outBundle)</span> </span>&#123;</span><br><span class="line">    Bundle components = <span class="keyword">new</span> Bundle();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.保存未使用的状态</span></span><br><span class="line">    <span class="keyword">if</span> (mRestoredState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        components.putAll(mRestoredState);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 通过 SavedStateProvider 保存状态</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;String, SavedStateProvider&gt;&gt; it = mComponents.iteratorWithAdditions(); it.hasNext(); ) &#123;</span><br><span class="line">        Map.Entry&lt;String, SavedStateProvider&gt; entry1 = it.next();</span><br><span class="line">        components.putBundle(entry1.getKey(), entry1.getValue().saveState());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 将bundle 保存到 outBundle 对象中</span></span><br><span class="line">    outBundle.putBundle(SAVED_COMPONENTS_KEY, components);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行状态保存将所有未使用的状态与注册表提供的状态合并。 此 outBundle 是 activity 的 <code>onSaveInstanceState</code> 中传入的 bundle 。</p><h3 id="SavedStateRegistryController"><a href="#SavedStateRegistryController" class="headerlink" title="SavedStateRegistryController"></a>SavedStateRegistryController</h3><p>一个包装 <code>SavedStateRegistry</code> 并允许通过其2个主要方法对其进行控制的组件：performRestore(savedState) 和 <code>performSave(outBundle )</code>。 这两个方法将内部通过 <code>SavedStateRegistry</code> 中的方法处理 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedStateRegistryController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SavedStateRegistryOwner mOwner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SavedStateRegistry mRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performRestore</span><span class="params">(@Nullable Bundle savedState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        mRegistry.performRestore(lifecycle, savedState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performSave</span><span class="params">(@NonNull Bundle outBundle)</span> </span>&#123;</span><br><span class="line">        mRegistry.performSave(outBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SavedStateRegistryOwner"><a href="#SavedStateRegistryOwner" class="headerlink" title="SavedStateRegistryOwner"></a>SavedStateRegistryOwner</h3><p>持有 <code>SavedStateRegistry</code> 的组件。 默认情况下，androidx 包中的<code>ComponentActivity</code> 和 <code>Fragment</code> 都实现此接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SavedStateRegistryOwner</span> <span class="keyword">extends</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">SavedStateRegistry <span class="title">getSavedStateRegistry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Activity-的状态保存"><a href="#Activity-的状态保存" class="headerlink" title="Activity 的状态保存"></a>Activity 的状态保存</h2><p>这里我们要明确一件事情，activity 保存的状态究竟都有什么？</p><p>这部分内容可以参见 <a href="https://developer.android.com/guide/components/activities/activity-lifecycle.html#saras" target="_blank" rel="noopener">官方文档</a> </p><p>简单来说，<strong>activity 的状态保存分为 view 状态和成员状态</strong></p><p>默认情况下，系统使用 Bundle 实例状态来保存有关 activity 布局中每个 View 对象的信息（例如，输入到 EditText 中的文本值或 recyclerview 的滚动位置）。 因此，如果 activity 实例被销毁并重新创建，则布局状态将恢复为之前的状态，而无需您执行任何代码。（<strong>注意，需要恢复状态的 view 需要配置 id</strong> ）</p><p>这部分逻辑在 activity 中的 <code>onSaveInstanceState</code> 方法内实现</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319115543.png" alt="onSaveInstanceState "></p><blockquote><p>不同平台 <code>onSaveInstanceState</code>  方法的执行时机稍有不同，android P 之前 <code>onSaveInstanceState</code> 执行在 <code>onStop</code> 之前，但不限于在 <code>onPause</code> 之前或之后。android P 及之后该方法在 <code>onStop</code> 后执行</p></blockquote><p>前面我们提到 <code>ComponentActivity</code> 实现了 <code>SavedStateRegistryOwner</code> ，下面我们来看一看 activity 如何利用该库来实现状态的保存与恢复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">androidx</span>.<span class="title">core</span>.<span class="title">app</span>.<span class="title">ComponentActivity</span> <span class="keyword">implements</span> <span class="title">SavedStateRegistryOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SavedStateRegistryController mSavedStateRegistryController = SavedStateRegistryController.create(<span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(@NonNull Bundle outState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">//这里先调用父类的 onSaveInstanceState 保存 view 状态</span></span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        mSavedStateRegistryController.performSave(outState);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SavedStateRegistry <span class="title">getSavedStateRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mSavedStateRegistryController.getSavedStateRegistry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部持有 <code>SavedStateRegistryController</code> 的实例 <code>mSavedStateRegistryController</code> ，在 activity 的 <code>onCreate</code> 方法中 通过 controller 的 <code>performRestore</code> 方法来查询已保存的状态，在 <code>onSaveInstanceState</code> 中 使用 controller  的 <code>performSave</code> 方法来保存状态</p><p><strong>除了 view 状态和成员状态，activity 还负责保存其内部的 fragment 的状态</strong>。<code>FragmentActivity</code> 的 <code>onSaveInstanceState</code> 方法有对其内部 fragment 的状态进行保存，并在 onCreate 方法中对已保存的 fragment 进行恢复。这解释了如果操作不当会导致 fragment 重叠的问题</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319140343.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319140801.png" alt></p><h2 id="Fragment-的状态保存"><a href="#Fragment-的状态保存" class="headerlink" title="Fragment 的状态保存"></a>Fragment 的状态保存</h2><p>androidx fragment 使用 <code>FragmentStateManager</code> 来处理 fragment 的状态保存</p><p>其内部有四个保存相关的方法</p><ul><li><code>saveState</code></li><li><code>saveBasicState</code></li><li><code>saveViewState</code></li><li><code>saveInstanceState</code></li></ul><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319142729.png" alt="FragmentStateManager"></p><p>其调用链为 activity 通过 <code>FragmentController</code> 间接 调用 <code>FragmentManager</code> 的 <code>saveAllState</code>，接着依次调用后面的save 方法</p><p>Fragment 的状态保存可分为 view 状态，成员状态，child fragment 状态</p><p>关于 view 状态 , <code>FragmentStateManager</code> 提供了 <code>saveViewSate</code> 方法，它的调用有两处：</p><ol><li>在 activity 或父 fragment 触发状态保存时调用，即上述流程</li><li>在 fragment 即将进入 <code>onDestroyView</code> 生命周期时调用，其位置在 <code>FragmentManager</code> moveToState 方法内部，这解释了为什么加入返回栈的 replace 操作在返回时 view 状态可以自动恢复</li></ol><p>关于成员状态，由 activity 中的状态机制处理，即上节内容</p><p>关于 child  fragment 状态，fragment 的 <code>onCreate</code> 方法会调用 <code>restoreChildFragmentState</code> 来恢复 child  fragment 的状态，并在 <code>FragmentStateManager</code>  中的 <code>saveBasicState</code> 方法中 调用 <code>performSaveInstanceState</code> 来保存 child  fragment 的状态</p><h2 id="Viewmodel-SavedState"><a href="#Viewmodel-SavedState" class="headerlink" title="Viewmodel-SavedState"></a>Viewmodel-SavedState</h2><p>2020-01-22，<code>ViewModel-SavedState 1.0.0</code> 正式版发布，02-05 发布了 <code>2.2.0</code> 正式版</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.lifecycle:lifecycle-viewmodel-savedstate:2.2.0"</span></span><br></pre></td></tr></table></figure><blockquote><p>您不需要手动引入该库，因为 fragment 库以及内部引入该库</p></blockquote><p><code>Jetpack MVVM</code> 下 UI State 通常被 <code>ViewModel</code> 持有并存储，因此该模块出现了，配置该模块后，<code>ViewModel</code> 对象将通过其构造函数接收 <code>SavedStateHandle</code> 对象（键值映射），可让您保存状态并查询已保存的状态。 这些值将在系统终止进程后继续存在，并可以通过同一对象使用。</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319165450.png" alt="ViewModel-SavedState"></p><blockquote><p>图片来自 <a href="https://proandroiddev.com/viewmodels-state-persistence-savedstate-54d015acad82" target="_blank" rel="noopener">Android ViewModels: State persistence — SavedState</a></p></blockquote><h3 id="SavedStateHandle"><a href="#SavedStateHandle" class="headerlink" title="SavedStateHandle"></a>SavedStateHandle</h3><p>内部持有已保存状态 key-value 的 map，允许读取和写入状态，这些状态在应用进程被杀死后仍然存在</p><p><code>SavedStateHandle</code> 通过 <code>ViewModel</code> 的构造器传入，下面是其主要的主要的几个方法</p><ul><li>T get(String key)</li><li>MutableLiveData<t> getLiveData(String key)</t></li><li>void set(String key, T value)</li></ul><p><code>SavedStateHandle</code> 还包含 <code>SavedStateProvider</code> 的实例，用于帮助 <code>ViewModel</code> 的 owner 保存状态</p><h3 id="AbstractSavedStateViewModelFactory"><a href="#AbstractSavedStateViewModelFactory" class="headerlink" title="AbstractSavedStateViewModelFactory"></a>AbstractSavedStateViewModelFactory</h3><p>一个实现 <code>ViewModelFactory.KeyedFactory</code> 的 <code>ViewModel Factory</code>，它会创建一个与实例化的请求的 ViewModel 关联的 <code>SavedStateHandle</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSavedStateViewModelFactory</span> <span class="keyword">extends</span> <span class="title">ViewModelProvider</span>.<span class="title">KeyedFactory</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SavedStateRegistry mSavedStateRegistry;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Default state used when the saved state is empty</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Bundle mDefaultArgs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读取保存的状态</span></span><br><span class="line">        Bundle restoredState = mSavedStateRegistry.consumeRestoredStateForKey(key);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 创建保存状态的 handle</span></span><br><span class="line">        SavedStateHandle handle = SavedStateHandle.createHandle(restoredState, mDefaultArgs);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 创建 viewModel</span></span><br><span class="line">        T viewmodel = create(key, modelClass, handle);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> viewmodel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SavedStateViewModelFactory"><a href="#SavedStateViewModelFactory" class="headerlink" title="SavedStateViewModelFactory"></a>SavedStateViewModelFactory</h3><p><code>AbstractSavedStateViewModelFactory</code> 的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedStateViewModelFactory</span> <span class="keyword">extends</span> <span class="title">AbstractSavedStateVMFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SavedStateViewModelFactory</span><span class="params">(@NonNull Application application,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull SavedStateRegistryOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(application, owner, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SavedStateViewModelFactory</span><span class="params">(@NonNull Application application, @NonNull SavedStateRegistryOwner owner, @Nullable Bundle defaultArgs)</span> </span>&#123;</span><br><span class="line">        mSavedStateRegistry = owner.getSavedStateRegistry();</span><br><span class="line">        mLifecycle = owner.getLifecycle();</span><br><span class="line">        mDefaultArgs = defaultArgs;</span><br><span class="line">        mApplication = application;</span><br><span class="line">        mFactory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);</span><br><span class="line">        Constructor&lt;T&gt; constructor;</span><br><span class="line">        <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// doesn't need SavedStateHandle</span></span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mFactory.create(modelClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SavedStateHandleController controller = SavedStateHandleController.create(</span><br><span class="line">                mSavedStateRegistry, mLifecycle, key, mDefaultArgs);        </span><br><span class="line">        T viewmodel;</span><br><span class="line">        <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">            viewmodel = constructor.newInstance(mApplication, controller.getHandle());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            viewmodel = constructor.newInstance(controller.getHandle());</span><br><span class="line">        &#125;</span><br><span class="line">        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);</span><br><span class="line">        <span class="keyword">return</span> viewmodel;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319174431.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewModelProvider(<span class="keyword">this</span>).get(MyViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure><p>在 activity 中创建 ViewModel 实例，传入 this （<code>SavedStateRegistryOwner</code> ）作为参数，该参数可以访问其 <code>SavedStateRegistry</code>，如果没有传入 factory 会通过 activity 重写的 <code>getDefaultViewModelProviderFactory</code> 方法来获取默认的 factory 。然后 factory 将使用保存的状态， 将其包装在 <code>SavedStateHandle</code> 中，并将其传递给 ViewModel。 ViewModel 可以读取和写入该 handle</p><p>当 activity 的 <code>onSaveInstanceState(outState)</code> 方法被调用，其 <code>SavedStateRegistry</code> 的 <code>performSave(outState)</code> 方法将被执行，其内部的所有 <code>SavedStateProvider</code> 的 <code>saveState</code> 方法均被执行，一旦执行完毕，<code>outState</code> 就包含了已保存的状态</p><p>当 app 被重启后，activity 和新的 registry  将被创建，activity 的 <code>onCreate(savedInstanceState)</code> 方法会被调用，然后 registry 的 <code>performRestore(savedInstanceState)</code> 将被调用以便恢复之前保存的状态</p><h2 id="状态保存的正确姿势"><a href="#状态保存的正确姿势" class="headerlink" title="状态保存的正确姿势"></a>状态保存的正确姿势</h2><p><code>ViewModel</code> 构造器加入 <code>SavedStateHandle</code> 参数，并将想要保存的数据使用该 handle 保存</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithSavedStateViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> state: SavedStateHandle) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> key = <span class="string">"key"</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(value: <span class="type">String</span>)</span></span> = state.<span class="keyword">set</span>(key, value)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">()</span></span>: LiveData&lt;String&gt; = state.getLiveData(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>无需重写 <code>onSaveInstanceState/onRestoreInstanceState</code>  方法</strong></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319231231.png" alt></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200319231451.png" alt="运行示意图"></p><p><a href="https://github.com/Flywith24/Flywith24-Jetpack-Demo" target="_blank" rel="noopener">Demo 地址</a></p><blockquote><p>SavedState 仅适合保存轻量级的数据，重量级操作请考虑持sp，数据库等持久化方案</p></blockquote><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="http://www.yangyunzhao.com" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></li><li><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;大家都知道 activity 有着一套 &lt;code&gt;onSaveInstanceState-onRestoreInstanceState&lt;/code&gt; 状态保存机制，旨在「系统资源回收」或「配置发生变化」保存状态，为用户提供更好的体验&lt;/p&gt;
&lt;p&gt;在 androidx 下，提供了 &lt;a href=&quot;https://developer.android.com/jetpack/androidx/releases/savedstate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SavedState&lt;/a&gt; 库帮助 activity 和 fragment 处理状态保存和恢复&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文默认您对状态保存机制有一定了解，这部分内容请移步 &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/saving-states&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Saving UI States&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此外，关于 android 下的进程管理，推荐 Ian Lake 的 &lt;a href=&quot;https://medium.com/androiddevelopers/who-lives-and-who-dies-process-priorities-on-android-cb151f39044f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Who lives and who dies? Process priorities on Android&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了 androidx 下 &lt;code&gt;SavedState&lt;/code&gt; 如何帮助 activity 和 fragment 处理状态的保存和恢复，同时介绍 &lt;code&gt;viewmodel-savedstate&lt;/code&gt; 库，以及在开发过程中正确使用状态保存的姿势&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之Fragment】从源码的角度看Fragment 返回栈</title>
    <link href="http://yoursite.com/2020/03/16/%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BFragment%E3%80%91%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BFragment%20%E8%BF%94%E5%9B%9E%E6%A0%88/"/>
    <id>http://yoursite.com/2020/03/16/【背上Jetpack之Fragment】从源码的角度看Fragment 返回栈/</id>
    <published>2020-03-15T16:10:35.000Z</published>
    <updated>2020-03-24T01:27:49.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p><a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">上一篇</a> 我们介绍了 <code>OnBackPressedDispather</code> ，那么今天我们来正式地从源码的角度看看 fragment 的返回栈吧。由于其主流程和生命周期差不多，因此本文将详细地分析返回栈相关的源码，并插入大量源码。建议将生命周期流程熟悉后阅读本文。文末提供单返回栈和多返回栈的 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">demo</a></p></blockquote><p>如果您对 activity 对任务栈和返回栈不是很了解，可以移步  <a href="https://medium.com/androiddevelopers/tasks-and-the-back-stack-dbb7c3b0f6d4" target="_blank" rel="noopener">Tasks and the Back Stack</a></p><a id="more"></a><h2 id="小问号你是否有很多朋友？"><a href="#小问号你是否有很多朋友？" class="headerlink" title="小问号你是否有很多朋友？"></a>小问号你是否有很多朋友？</h2><p>在分析源码之前，我们先来思考几个问题。</p><ul><li>返回栈中的元素是什么？</li><li>谁来管理 fragment 的返回栈？</li><li>如何返回？</li></ul><h3 id="返回栈中的元素是什么？"><a href="#返回栈中的元素是什么？" class="headerlink" title="返回栈中的元素是什么？"></a>返回栈中的元素是什么？</h3><p>返回栈，顾名思义，是一个栈结构。所以我们要搞清楚，这个栈结构到底存的是什么。</p><p>我们都知道，使用 fragment 的返回栈需要调用 <code>addToBackStack(&quot;&quot;)</code> 方法</p><p>在 <a href="https://juejin.im/post/5e67523551882549003d2c4f" target="_blank" rel="noopener">从源码角度看 Fragment 生命周期</a> 一文中，我们提到了 FragmentTransaction ，它是一个「事务」的模型，事务可以回滚到之前的状态。所以当触发返回操作时，就是将之前提交的事务进行回滚。</p><p><code>FragmentTransaction</code> 的实现类为 <code>BackStackRecord</code> ，所以 <strong>fragment 的返回栈其实存放的就是 BackStackRecord</strong> </p><p>作为返回栈的元素，BackStackRecord 实现了FragmentManager.BackStackEntry 接口</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0e912bd4?w=748&h=171&f=png&s=27904" alt="BackStackRecord"></p><p>从 <code>BackStackRecord</code> 的定义我们可以发现 <code>BackStackRecord</code> 有三种身份</p><ul><li>继承了 <code>FragmentTransaction</code>，即是事务，保存了整个事务的全部操作</li><li>实现了 <code>FragmentManager.BackStackEntry</code> ，作为回退栈的元素</li><li>实现了<code>OpGenerator</code> ，可以生成 <code>BackStackRecord</code> 列表，后文详细介绍</li></ul><h3 id="谁来管理-fragment-的返回栈？"><a href="#谁来管理-fragment-的返回栈？" class="headerlink" title="谁来管理 fragment 的返回栈？"></a>谁来管理 fragment 的返回栈？</h3><p>我们已经知道 fragment 的返回栈其实存放的是 BackSrackRecord , 那么谁来管理 fragment 的返回栈？</p><p><code>FragmentManager</code> 用于管理 fragment ，所以 <strong>fragment 返回栈也应该由 FragmentManager 管理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FragmentManager.java</span></span><br><span class="line">ArrayList&lt;BackStackRecord&gt; mBackStack;</span><br></pre></td></tr></table></figure><p>其实触发 fragment 的返回逻辑有两种途径</p><ul><li><p>开发主动调用 fragment 的返回方法</p></li><li><p>用户按返回键触发</p></li></ul><p>后文我们会从这两个角度分析一下 fragment 中的返回栈逻辑究竟是怎样的</p><h3 id="如何返回？"><a href="#如何返回？" class="headerlink" title="如何返回？"></a>如何返回？</h3><p>我们已经知道返回栈中的元素是 <code>BackStackRecord</code> ，也清楚了是 <code>FragmentManager</code> 来管理返回栈。那么如果让我们来实现「返回」逻辑，应该如何做？</p><p>首先我们要清楚所谓的「返回」是对事务的回滚，即 <strong>对 commit 事务的内部逻辑执行相应的「逆操作」</strong>。</p><p>例如</p><p>addFragment←→removeFragment</p><p>showFragment←→hideFragment</p><p>attachFragment←→detachFragment</p><p>有的小伙伴可能会疑惑 replace 呢？</p><p><code>expandReplaceOps</code> 方法会把 replace 替换(目标 fragment 已经被 add )成相应的 remove 和 add 两个操作，或者(目标 fragment 没有被 add )只替换成 add 操作</p><h2 id="popBackStack-系列方法"><a href="#popBackStack-系列方法" class="headerlink" title="popBackStack 系列方法"></a>popBackStack 系列方法</h2><p><code>FragmentManager</code> 中提供了<code>popBackStack</code> 系列方法</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0f7fecec?w=523&h=207&f=png&s=41693" alt="popBackStack系列方法"></p><p>是否觉得很眼熟？提交事务也有类似的api，commit 系列方法</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf0f5fe236?w=425&h=116&f=png&s=19768" alt="commit系列方法"></p><p>这里分别提供了同步和异步的方法，可能有读者会疑惑，同样是对事务的操作，一个为提交，一个为回滚，为什么一个封装到了 <code>FragmentManager</code> 中，一个却在 <code>FragmentTransaction</code> 中。既然都是对事务的操作，应该都放在FragmentManager 中。我认为可能为了api使用的方便，使得 <code>FragmentManager</code> 开启事务的链式调用一气呵成。各位有什么想法欢迎在评论区留言。</p><p>这里主要介绍一下 popBackStack(String name, int flag)</p><p>name 为 addToBackStack(String name) 的参数，通过 name 能找到回退栈的特定元素，flag可以为 0 或者<code>FragmentManager.POP_BACK_STACK_INCLUSIVE</code>，0 表示只弹出该元素以上的所有元素，<code>POP_BACK_STACK_INCLUSIVE</code> 表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。如果这么说比较抽象的话，看图</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag 传入0，弹出 ♥2 上的所有元素</span></span><br><span class="line">childFragmentManager.popBackStack(<span class="string">"♥"</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf111e4eca?w=544&h=968&f=gif&s=332027" alt="flag为0"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag 为 POP_BACK_STACK_INCLUSIVE 弹出包括该元素及及以上的元素</span></span><br><span class="line">childFragmentManager.popBackStack(<span class="string">"♥"</span>,  androidx.fragment.app.FragmentManager.POP_BACK_STACK_INCLUSIVE)</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf11573c7e?w=544&h=968&f=gif&s=307357" alt="flag为1"></p><h2 id="走进源码"><a href="#走进源码" class="headerlink" title="走进源码"></a>走进源码</h2><h3 id="1-popBackStack-逻辑"><a href="#1-popBackStack-逻辑" class="headerlink" title="1. popBackStack() 逻辑"></a>1. popBackStack() 逻辑</h3><p>在分析返回栈源码之前我们回顾一下 FragmentManager 提交事务到 fragment 各个生命周期的流程</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf128028ab?w=1137&h=1745&f=png&s=148227" alt="异步"></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf3c14d698?w=1078&h=1232&f=png&s=120922" alt="commitNow"></p><p>下面我们看看 popBackStack 的源码</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf3e264529?w=1111&h=744&f=png&s=152765" alt="popBackStack源码"></p><p>等等，这个 enqueueAction 有些眼熟…</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf4261e2a2?w=582&h=144&f=png&s=16887" alt="commit"></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf43057f36?w=792&h=404&f=png&s=74980" alt="commitInternal"></p><p>看来提交事务和回滚事务的流程基本是相同的，只是传递的 action 不同</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf463c7504?w=818&h=722&f=png&s=108117" alt="enqueueAction"></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170df028ee01dd57?w=1081&h=713&f=png&s=131939" alt="OpGenerator"></p><p>由源码可知，<code>OpGenerator</code> 是一个接口，其内只有一个 <code>generateOps</code> 方法，用于生成事务列表以及对应的该事务是否是弹出的。有两个实现类</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf5579b571?w=1319&h=139&f=png&s=46323" alt="OpGenerator实现类"></p><p>由此可见 commit 调用的为 <code>BackStackRecord</code> 的 <code>generateOps</code> 方法，<code>popBackStack</code> 调用的是 <code>PopBackStackState</code> 中的  <code>generateOps</code> </p><p>前者的逻辑很简单，向 records list 中添加数据， isRecordPop list 全部传入 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">records.add(<span class="keyword">this</span>);</span><br><span class="line">isRecordPop.add(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>后者的逻辑稍微复杂些，其内部调用了 <code>popBackStackState</code> 方法</p><p>如果是 <code>popBackStack</code> 方法 ，则将 <code>FragmentManager</code> 的返回栈列表（<code>mBackStack</code>）的栈顶移除， <code>isRecordPop</code> list 全部传入 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last = mBackStack.size() - <span class="number">1</span>;</span><br><span class="line">records.add(mBackStack.remove(last));</span><br><span class="line">isRecordPop.add(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>如果传入的 name 或 id 有值，且 flag 为 0，则找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置，并将该位置上方的所有 <code>BackStackRecord</code> 并添加到 <code>record</code> list 中，同时 <code>isRecordPop</code> list 全部传入 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">index = mBackStack.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    BackStackRecord bss = mBackStack.get(index);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.equals(bss.getName())) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (id &gt;= <span class="number">0</span> &amp;&amp; id == bss.mIndex) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mBackStack.size() - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">  records.add(mBackStack.remove(i));</span><br><span class="line">  isRecordPop.add(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入的 name 或 id 有值，且 flag 为 <code>POP_BACK_STACK_INCLUSIVE</code>，则在上一条获取位置的基础上继续遍历，直至栈底或者遇到不匹配的跳出循环，接着出栈所有 <code>BackStackRecord</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index 操作与上方相同，先找到返回栈（倒序遍历）中第一个符合 name 或 id 的位置</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; POP_BACK_STACK_INCLUSIVE) != <span class="number">0</span>) &#123;</span><br><span class="line">    index--;</span><br><span class="line">    <span class="comment">// 继续遍历 mBackStack 直至栈底或者遇到不匹配的跳出循环</span></span><br><span class="line">    <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        BackStackRecord bss = mBackStack.get(index);</span><br><span class="line">        <span class="keyword">if</span> ((name != <span class="keyword">null</span> &amp;&amp; name.equals(bss.getName()))</span><br><span class="line">                || (id &gt;= <span class="number">0</span> &amp;&amp; id == bss.mIndex)) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后续出栈逻辑与上方相同</span></span><br></pre></td></tr></table></figure><p>可以配合上面的动图理解</p><p>入栈和出栈后续的逻辑大体是相同的，只是根据 isPop 的正负出现了分支，出栈调用的是 executePopOps</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170df06c04191fff?w=972&h=682&f=png&s=132928" alt></p><p>上文我们有提到，「返回」逻辑实际上就是执行提交事务内部操作逻辑的「逆操作」</p><p>那么接下的逻辑就很清晰了，根据不同的 mCmd 执行相应的逆操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executePopOps</span><span class="params">(<span class="keyword">boolean</span> moveToState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> opNum = mOps.size() - <span class="number">1</span>; opNum &gt;= <span class="number">0</span>; opNum--) &#123;</span><br><span class="line">        <span class="keyword">final</span> Op op = mOps.get(opNum);</span><br><span class="line">        Fragment f = op.mFragment;</span><br><span class="line">        <span class="keyword">switch</span> (op.mCmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> OP_ADD:</span><br><span class="line">                mManager.removeFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REMOVE:</span><br><span class="line">                mManager.addFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_HIDE:</span><br><span class="line">                mManager.showFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_SHOW:</span><br><span class="line">                mManager.hideFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_DETACH:</span><br><span class="line">                mManager.attachFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ATTACH:</span><br><span class="line">                mManager.detachFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_SET_PRIMARY_NAV:</span><br><span class="line">                mManager.setPrimaryNavigationFragment(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_UNSET_PRIMARY_NAV:</span><br><span class="line">                mManager.setPrimaryNavigationFragment(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_SET_MAX_LIFECYCLE:</span><br><span class="line">                mManager.setMaxLifecycle(f, op.mOldMaxState);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.mCmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mReorderingAllowed &amp;&amp; op.mCmd != OP_REMOVE &amp;&amp; f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mManager.moveFragmentToExpectedState(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mReorderingAllowed &amp;&amp; moveToState) &#123;</span><br><span class="line">        mManager.moveToState(mManager.mCurState, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面的逻辑就完全一样了</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf65e331c7?w=1137&h=1585&f=png&s=127564" alt="popBackStack"></p><h3 id="2-fragment-是怎样拦截-activity-的返回逻辑的？"><a href="#2-fragment-是怎样拦截-activity-的返回逻辑的？" class="headerlink" title="2. fragment 是怎样拦截 activity 的返回逻辑的？"></a>2. fragment 是怎样拦截 activity 的返回逻辑的？</h3><p>在 <a href="https://juejin.im/post/5e6bae35f265da572a0d11ad" target="_blank" rel="noopener">【背上Jetpack之OnBackPressedDispatcher】Fragment 返回栈预备篇</a> 一文中我们介绍了 <code>OnBackPressedDispatcher</code> </p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf6fd444f6?w=1138&h=544&f=png&s=96482" alt="ComponetActivity"></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf70da7341?w=642&h=512&f=png&s=71452" alt></p><p>activity 的 <code>onBackPressed</code> 的逻辑主要分为两部分，判断所有注册的 <code>OnBackPressedCallback</code> 是否有 enabled 的，如果有则拦截，不执行后续逻辑；</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170df0d07750776b?w=801&h=765&f=png&s=137606" alt="fragment 拦截返回逻辑"></p><p>否则着执行 mFallbackOnBackPressed.run() ，其内部逻辑为调用 ComponentActivity 父类的 <code>onBackPressed</code> 方法</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf7443eb77?w=715&h=275&f=png&s=39938" alt></p><p><strong>所以我们只需看 mOnBackPressedCallbacks（ArrayDeque&lt;OnBackPressedCallback） 是怎样被添加的以及 isEnabled 何时赋值为 true</strong></p><p>经过查找我们发现它是在 FragmentManager 的 attachController 调用 <code>addCallback</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mOnBackPressedDispatcher.addCallback(owner,mOnBackPressedCallback)</span><br></pre></td></tr></table></figure><p>进而执行了</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170df099d16ae502?w=1000&h=425&f=png&s=75605" alt><br><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf7c970039?w=822&h=233&f=png&s=41860" alt></p><p>而 <code>mOnBackPressedCallback</code> 在初始化时 enabled 赋值为 false </p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf8362798b?w=954&h=194&f=png&s=42041" alt="mOnBackPressedCallback"></p><p><code>isEnadbled</code> 会在返回栈数量大于 0 且其 mParent 为 <code>PrimaryNavigation</code> 时赋值为true</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9805eb1e?w=796&h=555&f=png&s=94237" alt></p><p>而返回栈（<code>mBackStack</code>）的赋值在 <code>BackStackRecord</code> 的 <code>generateOps</code> 方法中，且是否添加到返回栈由 <code>mAddToBackStack</code> 这个布尔类型的属性控制</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170df0f5d77e3c7f?w=891&h=544&f=png&s=94633" alt></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9a0dfa56?w=548&h=215&f=png&s=28095" alt></p><p><strong>mAddToBackStack 的赋值在 addToBackStack 方法中，这也解释了为何调用 addToBackStack 方法就能将事务加入返回栈</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeaf9eb75bde?w=841&h=306&f=png&s=47458" alt></p><blockquote><p> 我们来总结一下，fragment 拦截 activity 返回栈是通过 <code>OnBackPressedDispatcher</code> 实现的，如果开启事务调用了 <code>addToBackStack</code> 方法，则 <code>mOnBackPressedCallback</code> 的 <code>isEnabled</code> 属性会赋值为 true，进而起到拦截 activity 返回逻辑的作用。拦截后执行 <code>popBackStackImmediate</code> 方法</p><p>而 popBackStack系列方法会调用 popBackStackState 构造 <code>records</code> 和 <code>isRecordPop</code> 列表，<code>isRecordPop</code> 的内部元素的值均为true 后续流程和提交事务是一样的，根据 <code>isRecordPop</code> 值的不同选择执行 <code>executePopOps</code> 或 <code>executeOps</code> 方法</p></blockquote><h2 id="单返回栈和多返回栈的实现"><a href="#单返回栈和多返回栈的实现" class="headerlink" title="单返回栈和多返回栈的实现"></a>单返回栈和多返回栈的实现</h2><p><a href="https://medium.com/@ianhlake" target="_blank" rel="noopener">Ian Lake</a> 在 <a href="https://www.youtube.com/watch?v=RS1IACnZLy4" target="_blank" rel="noopener">Fragments: Past, Present, and Future (Android Dev Summit ‘19)</a> </p><p>有提到未来会提供多返回栈的 api</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/15/170deeafa780da77?w=1844&h=948&f=png&s=634511" alt></p><p>那么以现有的 api 如何实现多返回栈呢？</p><p>首先我要弄清楚怎样才会有多返回栈，根据上文我们知道 <code>FragmentManager</code> 内部持有<code>mBackStack</code> list，这对应着一个返回栈，<strong>如果想要实现多返回栈，则需要多个 FragmentManager</strong>，而多 <code>FragmentManager</code> 则对应多个 fragment</p><p>因此我们可以创建多个宿主 frament 作为导航 fragment 这样就可以用不同的宿主 fragment 的 独立的<code>FragmentManager</code> 分别管理各自的返回栈，如果这样说比较抽象，可以参考下图</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/16/170defa88bc0e5f9?w=488&h=750&f=gif&s=4633102" alt></p><p>图中有四个返回栈，其中最外部有一个宿主 fragment ，内部有四个负责导航的 fragment 管理其内部的返回栈，外部的宿主负责协调各个返回栈为空后如何切换至其他返回栈</p><p>单返回栈就很容易了，我们只需在同一个 <code>FragmentManager</code> 上添加返回栈即可</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200312175950" alt></p><p>详情参照 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">demo</a></p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e6bae35f265da572a0d11ad&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇&lt;/a&gt; 我们介绍了 &lt;code&gt;OnBackPressedDispather&lt;/code&gt; ，那么今天我们来正式地从源码的角度看看 fragment 的返回栈吧。由于其主流程和生命周期差不多，因此本文将详细地分析返回栈相关的源码，并插入大量源码。建议将生命周期流程熟悉后阅读本文。文末提供单返回栈和多返回栈的 &lt;a href=&quot;https://github.com/Flywith24/Flywith24-Fragment-Demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果您对 activity 对任务栈和返回栈不是很了解，可以移步  &lt;a href=&quot;https://medium.com/androiddevelopers/tasks-and-the-back-stack-dbb7c3b0f6d4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tasks and the Back Stack&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack】Fragment返回栈预备篇 OnBackPressedDispatcher</title>
    <link href="http://yoursite.com/2020/03/14/%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BFragment%E3%80%91Fragment%E8%BF%94%E5%9B%9E%E6%A0%88%E9%A2%84%E5%A4%87%E7%AF%87%20OnBackPressedDispatcher/"/>
    <id>http://yoursite.com/2020/03/14/【背上Jetpack之Fragment】Fragment返回栈预备篇 OnBackPressedDispatcher/</id>
    <published>2020-03-13T16:10:35.000Z</published>
    <updated>2020-03-24T01:19:53.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天在准备写 fragment 返回栈的文章，但是发现必须先介绍一下 OnBackPressedDispatcher ，所以这是一篇介绍 what 的文章，喜欢一手资料的可以移步 <a href="https://developer.android.google.cn/reference/kotlin/androidx/activity/OnBackPressedDispatcher" target="_blank" rel="noopener">官方文档</a></p></blockquote><a id="more"></a><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><blockquote><p><a href="https://juejin.im/post/5e567ee1518825494466a938" target="_blank" rel="noopener">【背上Jetpack】Jetpack 主要组件的依赖及传递关系</a><br></p><p><a href="https://juejin.im/post/5e5a0c316fb9a07cd248d29e" target="_blank" rel="noopener">【背上Jetpack】AdroidX下使用Activity和Fragment的变化</a><br></p><p><a href="https://juejin.im/post/5e5cd8686fb9a07cbc269d10" target="_blank" rel="noopener">【背上Jetpack之Fragment】你真的会用Fragment吗？Fragment常见问题以及androidx下Fragment的使用新姿势</a><br></p><p><a href="https://juejin.im/post/5e67523551882549003d2c4f" target="_blank" rel="noopener">【背上Jetpack之Fragment】从源码角度看 Fragment 生命周期 AndroidX Fragment1.2.2源码分析</a></p></blockquote><h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><p><code>OnBackPressedDispatcher</code> 在 <code>androidx activity 1.0.0</code> 加入，旨在处理返回逻辑。您不仅可以获得在 <code>Activity</code> 之外处理返回键的便捷方式。 根据您的需要，您可以在任意位置定义 <code>OnBackPressedCallback</code>，使其可复用，或根据应用程序的架构进行任何操作。 您不再需要重写<code>Activity</code> 中的 <code>onBackPressed</code> 方法，也不必提供自己的抽象的来实现需求的代码。</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d4a399942581f?w=1778&h=1246&f=png&s=339228" alt="OnBackPressedDispatcher"></p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p><code>ComponentActivity</code> 是 <code>FragmentActivity</code> 和 <code>AppCompatActivity</code> 的基类，它使您可以通过使用其 <code>OnBackPressedDispatcher</code>（可以通过调用 <code>getOnBackPressedDispatcher()</code> ）来控制返回按钮的行为。</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/14/170d4a9d225a9575?w=2168&h=1150&f=png&s=238889" alt="ComponentActivity-onBackPressed"></p><p><code>OnBackPressedDispatcher</code> 控制如何将返回按钮事件分配给一个或多个<code>OnBackPressedCallback</code> 对象。 <code>OnBackPressedCallback</code> 的构造函数将布尔值用于初始启用状态。 仅当启用了回调（即 <code>isEnabled()</code> 返回true）时，调度程序才会调用回调的<code>handleOnBackPressed()</code> 来处理返回按钮事件。 您可以通过调用 <code>setEnabled()</code> 来更改启用状态。</p><p>回调是通过 <code>addCallback</code> 方法添加的。 强烈建议使用采用 LifecycleOwner 的<code>addCallback()</code> 方法。 这样可以确保仅在 LifecycleOwner 为 Lifecycle.State.STARTED 时才添加<code>OnBackPressedCallback</code>。 当关联的 LifecycleOwner 被销毁时，该 activity 会删除已注册的回调，以防止内存泄漏，并使其适用于寿命比该 <code>activity</code> 短的 <code>fragment</code> 或其他生命周期所有者。</p><p>下面是一个示例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此 callback 仅当 MyFragment 至少是 Started 状态下调用</span></span><br><span class="line">        <span class="keyword">val</span> callback = requireActivity().onBackPressedDispatcher.addCallback(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//拦截返回事件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此 callback 可以在这里或者上面的 lambda 中开启和关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以通过 <code>addCallback()</code> 提供多个回调。 这样做时，将按照添加回调的相反顺序调用回调，即最后添加的回调是第一个给予处理返回按钮事件的机会的回调。 例如，如果您依次添加了三个分别名为1、2和3的回调，则将分别以3、2和1的顺序调用它们。</p><p>回调遵循“责任链”模式。 仅当未启用前一个回调时，才调用链中的每个回调。 这意味着在前面的示例中，仅当未启用回调3时，才会调用回调2。 仅当未启用回调2时，才调用回调1，依此类推。</p><p>请注意，通过 <code>addCallback()</code> 添加回调时，直到 LifecycleOwner 进入Lifecycle.State.STARTED 状态，才将回调添加到责任链中。</p><p>强烈建议更改 <code>OnBackPressedCallback</code> 的启用状态以进行临时更改(即更改 isEnabled 的值)，因为它可以保持上述顺序，如果您在多个不同的嵌套生命周期所有者上注册了回调，这尤其重要。</p><p>但是，如果要完全删除 <code>OnBackPressedCallback</code>，则应调用 remove()。 但是，这通常不是必需的，因为在销毁关联的 <code>LifecycleOwner</code> 时会自动删除其回调。</p><h2 id="Activity-onBackPressed"><a href="#Activity-onBackPressed" class="headerlink" title="Activity onBackPressed()"></a>Activity onBackPressed()</h2><p>如果您使用 <code>onBackPressed()</code> 处理返回按钮事件，建议您改用 <code>OnBackPressedCallback</code> 。 但是，如果您无法进行此更改，则适用以下规则：</p><ul><li><p>当您调用 <code>super.onBackPressed()</code> 时，将通过 <code>addCallback</code> 注册的所有回调。</p></li><li><p>无论 <code>OnBackPressedCallback</code> 的任何注册实例，始终会调用 <code>onBackPressed</code>。</p></li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>关于 fragment 返回栈的 demo 已经写好了，感兴趣的小伙伴可以 <a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">在这</a> 找到它。</p><p>我们下一篇再见。</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这两天在准备写 fragment 返回栈的文章，但是发现必须先介绍一下 OnBackPressedDispatcher ，所以这是一篇介绍 what 的文章，喜欢一手资料的可以移步 &lt;a href=&quot;https://developer.android.google.cn/reference/kotlin/androidx/activity/OnBackPressedDispatcher&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之Fragment】从源码角度看Fragment的启动流程及生命周期 基于AndroidX Fragment1.2.2</title>
    <link href="http://yoursite.com/2020/03/10/%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BFragment%E3%80%91%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8BFragment%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%20%E5%9F%BA%E4%BA%8EAndroidX%20Fragment1.2.2/"/>
    <id>http://yoursite.com/2020/03/10/【背上Jetpack之Fragment】从源码角度看Fragment的启动流程及生命周期 基于AndroidX Fragment1.2.2/</id>
    <published>2020-03-09T16:10:35.000Z</published>
    <updated>2020-03-24T01:19:13.928Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔者看过不少源码分析类的文章，动辄贴上大段代码，这种方式很容易打断读者的思路，所以很多时候看过这类文章感叹好文好文，却感觉什么都没记住，亦或者默默加入收藏却不知何时能去细心地研读。</p><p>所以本文不会过多介绍源码的细节，更多地是抛砖引玉，如果您看过本文后能够跟着本文的思路自己翻一下源码相信您就不会有我上述的体验了。</p><p>本文默认您已对 fragment 的生命周期有所了解，并清楚fragment的缘起与职责。这部分基础内容可移步 <a href="https://developer.android.com/guide/components/fragments" target="_blank" rel="noopener">fragment 官方文档</a> </p><p><strong>也即本文不会介绍 “what”，而是介绍 “how” 并且探讨一下 “why”</strong></p></blockquote><a id="more"></a><p>这里贴一下 androidx fragment 源码地址</p><p><a href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/fragment/" target="_blank" rel="noopener">androidx fragment 官方源码地址</a></p><p>本文基于 androidx fragment 1.2.2 源码分析</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"androidx.fragment:fragment-ktx:1.2.2"</span></span><br></pre></td></tr></table></figure><p>本文主要介绍fragment的启动流程，其他内容例如返回栈，会后续更新，敬请关注。欢迎在评论区下讨论。<a href="https://github.com/Flywith24/Flywith24-Fragment-Demo" target="_blank" rel="noopener">本文demo</a></p><p>既然我们都知道 “what”，不妨我们来思考一下 “how”</p><h2 id="分析前的思考"><a href="#分析前的思考" class="headerlink" title="分析前的思考"></a>分析前的思考</h2><p>请大家思考一个问题，我们知道fragment 的生命周期是与其宿主 activity 的生命周期息息相关的，也即 activity 的每次生命周期回调都会引发每个fragment的类似回调。</p><p>那么，如果让我们来实现这样的操作，应该怎么做？</p><blockquote><p> 猜测：在activity每个生命周期的节点，去操作fragment，让其执行相应的生命周期方法。</p></blockquote><p>思路有了，下面进行一些细节的确认。</p><ol><li>activity 要能操作 fragment，fragment 亦可操作 fragment，所以需要抽象出一个管理 fragment 的模型</li><li>activity 操作 fragment 的一系列动作，应该是互为可逆一组操作。例如添加 fragment 后，也应能移除 fragment</li><li>activity 对 fragment 的每组操作不应是单一的，例如可以在一次操作中在 activity 不同位置添加两个 fragment，同时该操作还应满足 2 ，具有可逆性</li></ol><p>对于第一条，我们抽象出一个可以管理 fragment 的模型，加入上下级的关系，即 activity 可管理其内部的 fragment，fragment 亦可管理其内部的 fragment。因此 fragment 同时充当着管理者与被管理者两种角色</p><p>对于后两条，相信在大学学过数据库的人会想到一种结构：<strong>事务（Transaction）</strong></p><blockquote><p> 事务是指一组原子性的操作，这些操作是不可分割的整体，要么全完成，要么全不完成，完成后可以回滚到完成前的状态</p></blockquote><p>因此，fragment 中两个最重要的概念出现了，<code>FragmentManager</code> 和 <code>FragmentTransaction</code></p><p><code>FragmentManager</code>  封装着对 fragment 操作的各种方法，<code>addFragment</code> <code>removeFragment</code> 等等，而 <code>FragmentActivity</code> 通过 <code>FragmentController</code> 来操作 <code>FragmentManager</code>  </p><p><code>FragmentTransaction</code> 封装对 fragment 容器进行的 fragment 操作，例如在容器1内添加一个 fragment，同时在容器2内替换fragment。</p><p>它们均为抽象类，需要具体的实现类。</p><p><code>FragmentManager</code> 的实现类为 <code>FragmentManagerImpl</code>，其内部逻辑已全部移至 <code>FragmentManager</code>  中，是个空实现。</p><p><code>FragmentTransaction</code> 的实现类为 <code>BackStackRecord</code> ，其内部引用了 <code>FragmentManager</code> 的实例 ，同时重写了父类的 四个 <code>commit</code> 相关的方法。</p><h2 id="看似最简单的启动流程"><a href="#看似最简单的启动流程" class="headerlink" title="看似最简单的启动流程"></a>看似最简单的启动流程</h2><p>现在让我们看一部分代码，平时在activity中我们是这样填充一个fragment的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">       <span class="comment">//避免旋转屏幕等场景 fragment 重叠的问题</span></span><br><span class="line">       <span class="keyword">if</span> (savedInstanceState == <span class="literal">null</span>) &#123;</span><br><span class="line">           supportFragmentManager<span class="comment">//步骤1</span></span><br><span class="line">               .beginTransaction()<span class="comment">//步骤2</span></span><br><span class="line">               .add(R.id.container, BlankFragment.newInstance())<span class="comment">//步骤3</span></span><br><span class="line">               .commitNow()<span class="comment">//步骤4</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>步骤1，实例化 <code>FragmentManagerImpl</code> 对象 (内部经历了一些转换，详情参见源码或查看demo注释)</p></li><li><p>步骤2，实例化 <code>BackStackRecord</code>对象，并在构造器中传入 <code>FragmentManager</code> 实例</p></li><li><p>步骤3，调用事务方法，对 fragment 容器进行相应的操作，本例表示在 id 为 <code>container</code> 容器内添加 <code>BlankFragment</code></p></li><li><p>步骤4，提交事务，交于 <code>FragmentManager</code> 处理</p></li></ul><p>在 terminal 敲入 <code>adb shell setprop log.tag.FragmentManager VERBOSE</code> 可开启<code>FragmentManager</code>的日志功能，过滤 <code>FragmentManager</code> ，日志如下：</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084150.png" alt="单fragment启动日志"></p><p>绿色部分为笔者手动添加的log，灰色和蓝色部分为 fragment 源码中的log</p><p>根据日志显示的流程，我们的猜测看似是正确的，“在 activity 每个生命周期的节点，去操作 fragment ，让其执行相应的生命周期方法”</p><p>其实这里是有干扰的，因为我们是在activity 的 <code>onCreate</code> 方法里 创建并提交 <code>FragmentTransaction</code> ，如果在 <code>onResume</code> 里调用呢？</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084240.png" alt="单fragment启动日志2"></p><p>WTF！</p><p>或许，我们的猜测有问题？看似调用 <code>commitNow</code> 后 fragment 的生命流程是自发进行的</p><p>那如果我们把调用挪到 <code>onPause</code> 呢？</p><p>打开 activity 并按下 home 键</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084122.png" alt="单fragment启动日志-onPause"></p><p>我知道好奇的读者会尝试在 <code>onStop</code> 中尝试一下，有惊喜。手动滑稽。</p><p>从这几段日志上来看，fragment 在提交事务后会自发进入自己的生命周期流程，而当其宿主 activity  生命周期发生变化时，fragment 的生命周期也跟随变化。</p><p>如果这么说比较抽象的话，我们可以看在 onPause 中显示fragment 的日志，当 Fragment 进入 onStart 生命周期后，如果是正常流程应该进入 onResume，但由于按下 home 键 activity进入onStop，fragment 也进入了 onStop 状态</p><p>因此，我们将之前的猜测进行扩展：</p><blockquote><ol><li>在activity每个生命周期的节点，去操作fragment，让其执行相应的生命周期方法</li><li>FragmentTransaction  被提交后 fragment 会进入自己的生命周期流程，但受 1 约束</li></ol></blockquote><p>那么我们的源码解读就从两个方向入手</p><h2 id="Activity-操作-Fragment-生命周期"><a href="#Activity-操作-Fragment-生命周期" class="headerlink" title="Activity 操作 Fragment 生命周期"></a>Activity 操作 Fragment 生命周期</h2><p>activity 是通过 <code>FragmentController</code>  操作  <code>FragmentManager</code>  进而操作 fragment 的。</p><p>具体点就是在 activity 各个生命周期节点通过调用 <code>FragmentController</code> 中的各个 <code>dispatch-</code> 方法进而调用 <code>FragmentManager</code> 中的各个 <code>dispatch-</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FragmentActivity.java</span></span><br><span class="line"><span class="keyword">final</span> FragmentController mFragments = FragmentController.createController(<span class="keyword">new</span> HostCallbacks());</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码省略部分逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFragments.dispatchStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//onResume 彻底执行完毕的回调</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFragments.dispatchResume();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFragments.dispatchPause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFragments.dispatchStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    mFragments.dispatchDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样猜测 1 就被证实了</p><p><strong>activity 会在各个生命周期节点通过 <code>FragmentController</code> 间接调用 <code>FragmentManager</code>  中的 各种 <code>dispatch-</code> 方法，进而影响 fragment 的生命周期</strong></p><p>那么嵌套 fragment 呢？</p><p>嵌套 fragment 也应该是宿主使用 <code>FragmentManager</code>  中的各种 <code>dispatch-</code> 方法，基于这个想法我们可以看一下 <code>FragmentManager</code>  中 <code>dispatch-</code> 方法的调用</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084349.png" alt="dispatch-方法的引用"></p><p>可以看到这里有两处调用，第二处为activity 通过 <code>FragmentController</code> 间接调用，第一处使用的是 <code>mChildFragmentManager</code></p><p><strong>这里引出 fragment 中另外两个比较重要的概念，<code>getParentFragmentManager()</code> 和 <code>getChildFragmentManager()</code></strong></p><blockquote><p>注意：<code>requireFragmentManager()</code> 和 <code>getFragmentManager</code> 已弃用</p></blockquote><p><code>getChildFragmentManager()</code>获取的是fragment 中的 <code>mChildFragmentManager</code></p><p><code>getParentFragmentManager()</code> 获取的是fragment 中的 <code>mFragmentManager</code></p><p><code>mChildFragmentManager</code> 为fragment内部的 <code>fragmentManager</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Private fragment manager for child fragments inside of this one.</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">FragmentManager mChildFragmentManager = <span class="keyword">new</span> FragmentManagerImpl();</span><br></pre></td></tr></table></figure><p><code>mFragmentManager</code> 稍显复杂，</p><ol><li>如果 fragment 的直接宿主是 activity ，则返回的是 activity 中的<code>getSupportFragmentManager()</code> 返回的 <code>fragmentManager</code></li><li>如果 fragment 的直接宿主是 fragment，即该 fragment 是其他 fragment 的子 fragment，则返回的是其父 fragment 的 <code>getChildFragmentManager</code></li></ol><p><strong>所以 嵌套fragment 的生命周期是父 fragment 在各个生命周期节点上通过 <code>mChildFragmentManager</code> 调用 <code>dispatch-</code>  以影响其子 fragment 的生命周期</strong></p><p>这样我们第一部分的解读就告一段落了, 这里点到为止,一些细节需要您自己亲自看看源码</p><h2 id="Fragment-的生命周期自治"><a href="#Fragment-的生命周期自治" class="headerlink" title="Fragment 的生命周期自治"></a>Fragment 的生命周期自治</h2><p>在 <code>看似最简单的启动流程</code> 一节中我们分别在 activity 的 onCreate ，onResume，onPause 中分别开启并提交事务，来观察 fragment 的生命周期日志。</p><p>在没有 activity 干扰的情况下，fragment 的生命周期是自治的。</p><p>那么我们继续思考一个问题</p><p>Fragment 的生命周期是如何一环扣一环的执行的？</p><p>从上面的日志，我们看到很多 “moveto-” 的日志，</p><p><strong>我们可以继续大胆地猜测，一个生命周期节点结束后调用进入另一个生命周期节点的方法</strong></p><p>基于这个猜测，我们确认一些细节</p><p>fragment 应该有自己的状态，它可能自己管理内部的状态，也可能会有封装着状态转移的逻辑的专门管理状态的抽象</p><p>这里引出另外一个概念 <code>FragmentStateManager</code></p><p><code>FragmentStateManager</code> 中持有 fragment 的引用 <code>mFragment</code> 以及 <code>FragmentManager</code> 的状态 <code>mFragmentManagerState</code></p><p>这里fragment的状态值为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIALIZING = -<span class="number">1</span>;    <span class="comment">// Not yet attached.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTACHED = <span class="number">0</span>;         <span class="comment">// Attached to the host.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATED = <span class="number">1</span>;          <span class="comment">// Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTIVITY_CREATED = <span class="number">2</span>; <span class="comment">// Fully created, not started.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">3</span>;          <span class="comment">// Created and started, not resumed.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESUMED = <span class="number">4</span>;          <span class="comment">// Created started and resumed.</span></span><br></pre></td></tr></table></figure><p><code>FragmentStateManager</code> 还封装着 fragment 状态转移的方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"moveto ACTIVITY_CREATED: "</span> + mFragment);</span><br><span class="line">    &#125;</span><br><span class="line">    mFragment.performActivityCreated(mFragment.mSavedFragmentState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"moveto STARTED: "</span> + mFragment);</span><br><span class="line">    &#125;</span><br><span class="line">    mFragment.performStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fragment 生命周期自治的核心逻辑封装在 <code>FragmentManager</code> 中的 <code>void moveToState(@NonNull Fragment f, int newState)</code>  内，主要代码为(精简后)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(@NonNull Fragment f, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho);</span><br><span class="line"></span><br><span class="line">    newState = Math.min(newState, fragmentStateManager.computeMaxState());</span><br><span class="line">    <span class="keyword">if</span> (f.mState &lt;= newState) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> Fragment.INITIALIZING:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.INITIALIZING) &#123;</span><br><span class="line">                    fragmentStateManager.attach(mHost, <span class="keyword">this</span>, mParent);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.ATTACHED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.ATTACHED) &#123;</span><br><span class="line">                    fragmentStateManager.create();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.INITIALIZING) &#123;</span><br><span class="line">                    fragmentStateManager.ensureInflatedView();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">                    fragmentStateManager.createView(mContainer);</span><br><span class="line">                    fragmentStateManager.activityCreated();</span><br><span class="line">                    fragmentStateManager.restoreViewState();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                    fragmentStateManager.start();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.STARTED) &#123;</span><br><span class="line">                    fragmentStateManager.resume();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的switch 没有 break</p></blockquote><p>细心的读者可能发现了，fragment 中的状态怎么只到 resume ，后续的状态呢？</p><p>我们可以看一下 <code>FragmentManager</code> 中的 <code>dispatchPause</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dispatchStateChange(Fragment.STARTED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 dispatch 了 <code>STARTED</code> 的状态？其实刚刚 <code>moveToState</code> 方法我精简掉了一部分代码，留下的只有 <code>f.mState &lt;= newState</code> 的逻辑，即 <strong>dispatch 的新状态大于等于当前的状态</strong></p><p>而现在dispatch 的新状态比当前状态值小，则走了下面的逻辑，例如当前状态为 RESUMED ，新传递的状态为 STARTED，执行了 <code>fragmentStateManager.pause();</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(@NonNull Fragment f, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    FragmentStateManager fragmentStateManager = mFragmentStore.getFragmentStateManager(f.mWho);</span><br><span class="line"></span><br><span class="line">    newState = Math.min(newState, fragmentStateManager.computeMaxState());</span><br><span class="line">    <span class="keyword">if</span> (f.mState &lt;= newState) &#123;</span><br><span class="line">    <span class="comment">//省略...   </span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> Fragment.RESUMED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.RESUMED) &#123;</span><br><span class="line">                    fragmentStateManager.pause();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.STARTED) &#123;</span><br><span class="line">                    fragmentStateManager.stop();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"movefrom ACTIVITY_CREATED: "</span> + f);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mHost.onShouldSaveFragmentState(f) &amp;&amp; f.mSavedViewState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            fragmentStateManager.saveViewState();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (mExitAnimationCancellationSignals.get(f) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        destroyFragmentView(f);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        f.setStateAfterAnimating(newState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.CREATED) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> beingRemoved = f.mRemoving &amp;&amp; !f.isInBackStack();</span><br><span class="line">                    <span class="keyword">if</span> (beingRemoved || mNonConfig.shouldDestroy(f)) &#123;</span><br><span class="line">                        makeInactive(fragmentStateManager);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (f.mTargetWho != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            Fragment target = findActiveFragment(f.mTargetWho);</span><br><span class="line">                            <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; target.getRetainInstance()) &#123;</span><br><span class="line">                                f.mTarget = target;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (mExitAnimationCancellationSignals.get(f) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        f.setStateAfterAnimating(newState);</span><br><span class="line">                        newState = Fragment.CREATED;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        fragmentStateManager.destroy(mHost, mNonConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> Fragment.ATTACHED:</span><br><span class="line">                <span class="keyword">if</span> (newState &lt; Fragment.ATTACHED) &#123;</span><br><span class="line">                    fragmentStateManager.detach(mNonConfig);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的switch 还是没有 break</p></blockquote><p>这里有个细节，由于activity没有 onDestroyView 的生命周期，所以 <code>FragmentController</code> 中的 <code>dispatchDestroyView</code> 是没有调用的</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084417.png" alt="dispatchOnDestroyView"></p><p> 在 activity 中的 destroy 方法中通过 <code>fragmentController</code> 调用了 <code>dispatchDestroy</code> 内部调用 <code>dispatchStateChange(Fragment.INITIALIZING)</code> ，而此时的fragment 的 mState 为 <code>ACTIVITY_CREATED</code>，所以 <code>moveToState</code> 方法会走到 <code>ACTIVITY_CREATED</code> 的 case 并执行到底</p><p>这样 fragment 最简单场景的生命周期就结束了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们做一个总结：activity 和 fragment 会在各个生命周期节点通过被调用 fragment 的 <code>parentFragmentManager</code>（或者说父 fragment 的 <code>childFragmentManager</code> 和 activity 的 <code>supportFragmentManager</code>）中的各种 <code>dispatch-</code> 方法以影响子 fragment 的 生命周期，同时子 fragment 也拥有自己生命周期的调用链（从状态A转移至状态B）</p><p>不得不说 fragment 的很多 API 并不是很好用，从 androidx fragment 的更新频率也可以看出。比如 fragment 中的 view 和 fragment本身的生命周期是不一致的，存在onDestroyView 但 fragment没有销毁的情况</p><p><a href="https://medium.com/@ianhlake" target="_blank" rel="noopener">Ian Lake</a> 在 <a href="https://www.youtube.com/watch?v=RS1IACnZLy4" target="_blank" rel="noopener">Fragments: Past, Present, and Future (Android Dev Summit ‘19)</a> 中提到未来官方会将二者合并，届时 fragment 的使用会更加简洁</p><p>这里引用 <a href="https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iii-fragments-afc87d4f37fd" target="_blank" rel="noopener">The Android Lifecycle cheat sheet — part III : Fragments</a> 文中的图片 ，和我画的commit <code>FragmentTransaction</code>  的脑图（略简陋），帮您更好的理解</p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084444.png" alt=" [The Android Lifecycle cheat sheet — part III : Fragments](https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iii-fragments-afc87d4f37fd)"></p><p><img src="https://gitee.com/flywith24/Album/raw/master/img/20200324084515.png" alt="fragment脑图"></p><p>强烈建议您自己亲自看一看源码，不然就变为我文章开头时说的状态了。</p><hr><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;笔者看过不少源码分析类的文章，动辄贴上大段代码，这种方式很容易打断读者的思路，所以很多时候看过这类文章感叹好文好文，却感觉什么都没记住，亦或者默默加入收藏却不知何时能去细心地研读。&lt;/p&gt;
&lt;p&gt;所以本文不会过多介绍源码的细节，更多地是抛砖引玉，如果您看过本文后能够跟着本文的思路自己翻一下源码相信您就不会有我上述的体验了。&lt;/p&gt;
&lt;p&gt;本文默认您已对 fragment 的生命周期有所了解，并清楚fragment的缘起与职责。这部分基础内容可移步 &lt;a href=&quot;https://developer.android.com/guide/components/fragments&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fragment 官方文档&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也即本文不会介绍 “what”，而是介绍 “how” 并且探讨一下 “why”&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack之Fragment】你真的会用Fragment吗？Fragment常见问题以及androidx下Fragment的使用新姿势</title>
    <link href="http://yoursite.com/2020/03/02/%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E4%B9%8BFragment%E3%80%91%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8Fragment%E5%90%97%EF%BC%9FFragment%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Aandroidx%E4%B8%8BFragment%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B0%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/2020/03/02/【背上Jetpack之Fragment】你真的会用Fragment吗？Fragment常见问题以及androidx下Fragment的使用新姿势/</id>
    <published>2020-03-01T16:10:35.000Z</published>
    <updated>2020-03-24T01:17:29.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 <code>Android Jetpack</code> 组件中，<code>fragment</code>作为视图控制器之一占有很重要的位置。但由于其bug众多，暗坑无数，以至于 Square 有这样一篇博客：<a href="https://developer.squareup.com/blog/advocating-against-android-fragments/" target="_blank" rel="noopener">Advocating Against Android Fragments</a>。github上的 <a href="https://github.com/YoKeyword/Fragmentation" target="_blank" rel="noopener">Fragmentation</a> 有着 9.4k 的star。</p><p>而现在，<code>androidx fragment</code> 稳定版已来到 1.2.2，让我们总结一下<code>fragment</code>有哪些常见问题以及有哪些使用<code>fragment</code>的新姿势</p></blockquote><a id="more"></a><h2 id="Fragment-常见的问题"><a href="#Fragment-常见的问题" class="headerlink" title="Fragment 常见的问题"></a>Fragment 常见的问题</h2><ul><li><p>getSupportFragmentManager ， getParentFragmentManager 和 getChildFragmentManager</p></li><li><p>FragmentStateAdapter 和 FragmentPagerAdapter</p></li><li><p>add 和 replace </p></li><li><p>observe LiveData时传入 this 还是 viewLifecycleOwner</p></li><li><p>使用 simpleName 作为 fragment 的 tag 有何风险？</p></li><li><p>在 BottomBarNavigation 和 drawer 中如何使用Fragment多次添加？</p></li><li><p>返回栈</p></li></ul><h3 id="getSupportFragmentManager-getParentFragmentManager和getChildFragmentManager"><a href="#getSupportFragmentManager-getParentFragmentManager和getChildFragmentManager" class="headerlink" title="getSupportFragmentManager , getParentFragmentManager和getChildFragmentManager"></a>getSupportFragmentManager , getParentFragmentManager和getChildFragmentManager</h3><blockquote><p><code>FragmentManager</code>是 <code>androidx.fragment.app</code>(已弃用的不考虑)下的抽象类，创建用于 添加，移除，替换 <code>fragment</code> 的事务（<code>transaction</code>）  </p></blockquote><p>首先要确认一件事，<code>getSupportFragmentManager()</code>是 <code>FragmentActivity</code>下的方法</p><p><code>getParentFragmentManager</code> 和 <code>getChildFragmentManager</code> 是 <code>androidx.fragment.app.Fragment</code> 下的方法，<strong>其中  <code>androidx.fragment 1.2.0</code> 后 <code>getFragmentManager</code> 与  <code>requireFragmentManager</code> 已弃用</strong></p><p>明确了这件事，接下来的就很清晰了</p><ul><li><code>getSupportFragmentManager</code>与 <code>activity</code>关联，可以将其视为 <code>activity</code> 的 <code>FragmentManager</code></li><li><code>getChildFragmentManager</code> 与 <code>fragment</code>关联，可以将其视为<code>fragment</code>的<code>FragmentManager</code></li><li><code>getParentFragmentManager</code>情况稍微复杂，正常情况返回的是该<code>fragment</code> 依附的<code>activity</code>的<code>FragmentManager</code>。如果该fragment是另一个<code>fragment</code> 的子 <code>fragment</code>，则返回的是其父<code>fragment</code>的 <code>getChildFragmentManager</code></li></ul><p>如果这么说还不明白的话，我们可以做一个实践。</p><p>创建一个 <code>activity</code>,一个父<code>fragment</code> ，一个子<code>fragment</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// activity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>(R.layout.activity_main) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        supportFragmentManager.commit &#123;</span><br><span class="line">            add&lt;ParentFragment&gt;(R.id.content)</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(<span class="string">"MyActivity"</span>, <span class="string">"supportFragmentManager <span class="variable">$supportFragmentManager</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentFragment</span> : <span class="type">Fragment</span></span>(R.layout.fragment_parent) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        childFragmentManager.commit &#123;</span><br><span class="line">            add&lt;ChildFragment&gt;(R.id.content)</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(<span class="string">"ParentFragment"</span>, <span class="string">"parentFragmentManager <span class="variable">$parentFragmentManager</span>"</span>)</span><br><span class="line">        Log.i(<span class="string">"ParentFragment"</span>, <span class="string">"childFragmentManager <span class="variable">$childFragmentManager</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildFragment</span> : <span class="type">Fragment</span></span>(R.layout.fragment_child) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        Log.i(<span class="string">"ChildFragment"</span>, <span class="string">"parentFragmentManager <span class="variable">$parentFragmentManager</span>"</span>)</span><br><span class="line">        Log.i(<span class="string">"ChildFragment"</span>, <span class="string">"childFragmentManager <span class="variable">$childFragmentManager</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//log</span><br><span class="line">I/MyActivity: supportFragmentManager FragmentManager&#123;825dcef in HostCallbacks&#123;14a13fc&#125;&#125;&#125;</span><br><span class="line">I/ParentFragment: parentFragmentManager FragmentManager&#123;825dcef in HostCallbacks&#123;14a13fc&#125;&#125;&#125;</span><br><span class="line">I/ParentFragment: childFragmentManager FragmentManager&#123;df5de83 in ParentFragment&#123;7cdd800&#125;&#125;&#125;</span><br><span class="line">I/ChildFragment: parentFragmentManager FragmentManager&#123;df5de83 in ParentFragment&#123;7cdd800&#125;&#125;&#125;</span><br><span class="line">I/ChildFragment: childFragmentManager FragmentManager&#123;aba9afb in ChildFragment&#123;5cea718&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>因此</p><ul><li><p>在 <code>activity</code> 中使用 <code>ViewPager</code>，<code>BottomSheetFragment</code> 和<code>DialogFragment</code> 时，都应使用 <code>getSupportFragmentManager</code></p></li><li><p>在<code>fragment</code> 中使用 <code>ViewPager</code> 时应该使用<code>getChildFragmentManager</code></p></li></ul><p>错误的在 <code>fragment</code> 中使用 <code>activity</code> 的 <code>FragmentManager</code> 会引发内存泄露。 为什么呢？假如您的fragment中有一些依靠 <code>ViewPager</code> 管理的子 <code>fragment</code>，并且所有这些 <code>fragment</code>  都在 <code>activity</code> 中，因为您使用的是<code>activity</code> 的<code>FragmentManager</code> 。 现在，如果关闭您的父<code>fragment</code>，它将被关闭，但不会被销毁，因为所有子<code>fragment</code>都处于活动状态，并且它们仍在内存中，从而导致泄漏。 它不仅会泄漏父<code>fragment</code>，还会泄漏所有子<code>fragment</code>，因为它们都无法从堆内存中清除。 </p><h3 id="FragmentStateAdapter-和-FragmentPagerAdapter"><a href="#FragmentStateAdapter-和-FragmentPagerAdapter" class="headerlink" title="FragmentStateAdapter 和 FragmentPagerAdapter"></a>FragmentStateAdapter 和 FragmentPagerAdapter</h3><p><code>FragmentPagerAdapter</code>将整个 <code>fragment</code>存储在内存中，如果<code>ViewPager</code>中使用了大量  <code>fragment</code>，则可能导致内存开销增加。 <code>FragmentStatePagerAdapter</code>仅存储片段的<code>savedInstanceState</code>，并在失去焦点时销毁所有  <code>fragment</code>。</p><p>让我们看看常见的两个问题</p><h4 id="1-刷新ViewPager不生效"><a href="#1-刷新ViewPager不生效" class="headerlink" title="1. 刷新ViewPager不生效"></a>1. 刷新ViewPager不生效</h4><p><code>ViewPager</code> 中的 <code>fragment</code> 是通过 <code>activity</code>或 <code>fragment</code>的 <code>FragmentManager</code> 管理的，<code>FragmentManager</code> 包含了<code>viewpager</code>的所有<code>fragment</code>的实例</p><p>因此，当<code>ViewPager</code>没有刷新时，它只是<code>FragmentManager</code>仍保留的旧 <code>fragment</code> 实例。 您需要找出为什么<code>FragmentManger</code>持有<code>fragment</code>实例的原因。</p><h4 id="2-在Viewpager中访问当前fragment"><a href="#2-在Viewpager中访问当前fragment" class="headerlink" title="2. 在Viewpager中访问当前fragment"></a>2. 在Viewpager中访问当前fragment</h4><p>这也是我们遇到的一个非常普遍的问题。 如果遇到这种情况，我们一般在 <code>adapter</code> 内部创建 <code>fragment</code> 的数组列表，或者尝试使用某些标签访问<code>fragment</code>。 不过还有另一种选择。 <code>FragmentStateAdapter</code> 和<code>FragmentPagerAdapter</code>都提供方法<code>setPrimaryItem</code>。 可以用来设置当前<code>fragment</code>，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> fragment: ChildFragment? = <span class="literal">null</span></span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setPrimaryItem</span><span class="params">(container: <span class="type">ViewGroup</span>, position: <span class="type">Int</span>, any: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (getChildFragment() != any)</span><br><span class="line">   fragment = any <span class="keyword">as</span> ChildFragment</span><br><span class="line">   <span class="keyword">super</span>.setPrimaryItem(container, position, any)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getChildFragment</span><span class="params">()</span></span>: ChildFragment? = fragment</span><br><span class="line"></span><br><span class="line"><span class="comment">//use</span></span><br><span class="line">mAapter.getChildFragment()</span><br></pre></td></tr></table></figure><h3 id="add-和-replace-如何选择？"><a href="#add-和-replace-如何选择？" class="headerlink" title="add 和 replace 如何选择？"></a>add 和 replace 如何选择？</h3><p>在我们的<code>activity</code>中，我们有一个容器，其中装有<code>fragment</code>。</p><p><code>add</code>只会将一个<code>fragment</code>添加到容器中。 假设您将<code>FragmentA</code>和<code>FragmentB</code>添加到容器中。 容器将具有<code>FragmentA</code>和<code>FragmentB</code>，如果容器是<code>FrameLayout</code>，则将<code>fragment</code>一个添加在另一个之上。</p><p><code>replace</code>将简单地替换容器顶部的一个<code>fragment</code>，因此，如果我创建了 <code>FragmentC</code>并 <code>replace</code> 顶部的 <code>FragmentB</code>，则<code>FragmentB</code>将被从容器中删除（执行<code>onDestroy</code>，除非您调用<code>addToBackStack</code>，仅执行<code>onDestroyView</code>），而<code>FragmentC</code>将位于顶部。</p><p>那么如何选择呢？ <code>replace</code>删除现有<code>fragment</code>并添加一个新<code>fragment</code>。 这意味着当您按下返回按钮时，将创建被替换的<code>fragment</code>，并调用其<code>onCreateView</code>。 另一方面，<code>add</code>保留现有<code>fragment</code>，并添加一个新<code>fragment</code>，这意味着现有<code>fragment</code>将处于活动状态，并且它们不会处于 “paused” 状态。 因此，按下返回按钮时，现有<code>fragment</code>（添加新<code>fragment</code>之前的<code>fragment</code>）不会调用<code>onCreateView</code>。 就<code>fragment</code>的生命周期事件而言，在<code>replace</code>的情况下将调用<code>onPause</code>，<code>onResume</code>，<code>onCreateView</code>和其他生命周期事件，在<code>add</code>的情况下则不会。</p><p>如果不需要重新访问当前<code>fragment</code>并且不再需要当前<code>fragment</code>，请使用<code>replace</code>。 另外，如果您的应用有内存限制，请考虑使用<code>replace</code>。</p><h3 id="observe-LiveData时传入-this-还是-viewLifecycleOwner"><a href="#observe-LiveData时传入-this-还是-viewLifecycleOwner" class="headerlink" title="observe LiveData时传入 this 还是 viewLifecycleOwner"></a>observe LiveData时传入 this 还是 viewLifecycleOwner</h3><p><code>androidx fragment 1.2.0</code> 起，添加了新的 Lint 检查，以确保您在从 <code>onCreateView()</code>、<code>onViewCreated()</code> 或 <code>onActivityCreated()</code> 观察 <code>LiveData</code> 时使用 <code>getViewLifecycleOwner()</code></p><h3 id="使用-simpleName-作为-fragment-的-tag-有何风险？"><a href="#使用-simpleName-作为-fragment-的-tag-有何风险？" class="headerlink" title="使用 simpleName 作为 fragment 的 tag 有何风险？"></a>使用 simpleName 作为 fragment 的 tag 有何风险？</h3><p>一般情况下我们会使用calss的<code>simpleName</code> 作为<code>fragment</code> 的tag</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">supportFragmentManager.commit &#123;</span><br><span class="line">replace(R.id.content,MyFragment.newInstance(<span class="string">"Fragment"</span>),</span><br><span class="line">            MyFragment::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span>)</span></span><br><span class="line">    addToBackStack(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做不会出现什么问题，但是…</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fragment = supportFragmentManager.findFragmentByTag(tag)</span><br></pre></td></tr></table></figure><p>这样获取到的fragment可能不是想要的结果。</p><p>为什么呢？</p><p>加入有两个 fragment，经过混淆，它们变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.mypackage.FragmentA → com.mypackage.c.a</span><br><span class="line">com.mypackage.FragmentB → com.mypackage.c.a.a</span><br></pre></td></tr></table></figure><p>上面是混淆了 full name，如果是simpleName 呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.mypackage.FragmentA → a</span><br><span class="line">com.mypackage.FragmentB → a</span><br></pre></td></tr></table></figure><p>WTF！</p><p><strong>所以在设置tag时尽量用全名或者常量</strong></p><h3 id="在-BottomBarNavigation-和-drawer-中如何使用Fragment多次添加？"><a href="#在-BottomBarNavigation-和-drawer-中如何使用Fragment多次添加？" class="headerlink" title="在 BottomBarNavigation 和 drawer 中如何使用Fragment多次添加？"></a>在 BottomBarNavigation 和 drawer 中如何使用Fragment多次添加？</h3><p>当我们使用<code>BottomBarNavigation</code>和 <code>NavigationDrawer</code>时，通常会看到诸如<code>fragment</code> 重建或多次添加相同<code>fragment</code>之类的问题。</p><p>在这种情况下，您可以使用<code>show / hide</code> 而不是 <code>add</code> 或 <code>replace</code>。</p><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>如果您想在<code>fragment</code>的一系列跳转中按返回键返回上一个<code>fragment</code>，应该在<code>commit</code> <code>transaction</code>之前调用<code>addToBackStack</code>方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用该扩展 androidx.fragment:fragment-ktx:1.2.0 以上</span></span><br><span class="line">parentFragmentManager.commit &#123;</span><br><span class="line">addToBackStack(<span class="literal">null</span>)</span><br><span class="line">  add&lt;SecondFragment&gt;(R.id.content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fragment的使用新姿势"><a href="#Fragment的使用新姿势" class="headerlink" title="Fragment的使用新姿势"></a>Fragment的使用新姿势</h2><ul><li><p>fragment-ktx 有哪些好用的扩展函数</p></li><li><p>fragment 之间和与 activity 通信</p></li><li><p>使用 FragmentContainerView 作为 fragment 容器</p></li><li><p>FragmentFactory 的使用</p></li><li><p>Fragment 返回键拦截</p></li><li><p>Fragment 使用 ViewBinding</p></li><li><p>Fragment 使用 ViewPager2</p></li><li><p>不需要重写 onCreateView 了？</p></li><li><p>使用require_()方法</p></li></ul><h3 id="fragment-ktx-有哪些好用的扩展函数"><a href="#fragment-ktx-有哪些好用的扩展函数" class="headerlink" title="fragment-ktx 有哪些好用的扩展函数"></a>fragment-ktx 有哪些好用的扩展函数</h3><h4 id="1-FragmentManagerKt"><a href="#1-FragmentManagerKt" class="headerlink" title="1. FragmentManagerKt"></a>1. FragmentManagerKt</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line">supportFragmentManager</span><br><span class="line">    .beginTransaction()</span><br><span class="line">    .add(R.id.content,Fragment1())</span><br><span class="line">    .commit()</span><br><span class="line"></span><br><span class="line"><span class="comment">//after</span></span><br><span class="line">supportFragmentManager.commit &#123;</span><br><span class="line">add&lt;Fragment1&gt;(R.id.content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-FragmentViewModelLazyKt"><a href="#2-FragmentViewModelLazyKt" class="headerlink" title="2. FragmentViewModelLazyKt"></a>2. FragmentViewModelLazyKt</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="comment">//共享范围activity</span></span><br><span class="line"><span class="keyword">val</span> mViewMode1l = ViewModelProvider(requireActivity()).<span class="keyword">get</span>(UpdateAppViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="comment">//共享范围fragment 内部</span></span><br><span class="line"><span class="keyword">val</span> mViewMode1l = ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(UpdateAppViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//after</span></span><br><span class="line"><span class="comment">//共享范围activity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> activityViewModels&lt;MyViewModel&gt;()</span><br><span class="line"><span class="comment">//共享范围fragment 内部</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mViewModel <span class="keyword">by</span> viewModel&lt;MyViewModel&gt;()</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：ViewModelProviders.of(this).get(MyViewModel.class); 的方式已弃用</strong> </p><p><strong><code>lifecycle-extensions</code> 依赖包已弃用</strong></p></blockquote><h3 id="fragment-之间和与-activity-通信"><a href="#fragment-之间和与-activity-通信" class="headerlink" title="fragment 之间和与 activity 通信"></a>fragment 之间和与 activity 通信</h3><p>fragment 和 fragment之间，fragment 和 activity 之间的通信有很多方法，android jetpack 推荐我们使用 ViewModel + LiveData 处理</p><p>同一个activity 内的 fragment 之间通信，可以使用作用范围为activity的ViewModel，activity与 fragment通信同理。详情可移步 <a href="https://developer.android.com/jetpack/docs/guide" target="_blank" rel="noopener">Android官方应用架构指南</a></p><h3 id="使用-FragmentContainerView-作为-fragment-容器"><a href="#使用-FragmentContainerView-作为-fragment-容器" class="headerlink" title="使用 FragmentContainerView 作为 fragment 容器"></a>使用 FragmentContainerView 作为 fragment 容器</h3><p>过去我们使用 <code>FrameLayout</code> 作为 <code>Fragment</code> 的容器，在 <code>AndroidX Fragment 1.2.0</code> 后，可以使用 <code>FragmentContainerView</code> 代替 <code>Fragment</code> 。</p><p>它修复了一些动画 z轴索引顺序问题和窗口插入调度，这意味着两个<code>fragment</code>之间的退出和进入过渡不会互相重叠。使用<code>FragmentContainerView</code>将先开启退出动画然后才是进入动画。</p><p><code>FragmentContainerView</code>  是专门为 fragment设计的自定义View，它继承自 FrameLayout</p><p><code>android:name</code> 属性允许您添加<code>fragment</code>，<code>android:tag</code> 属性可以为<code>fragment</code>设置tag</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/fragment_container_view"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:name</span>=<span class="string">"com.example.MyFragment"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:tag</span>=<span class="string">"my_tag"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.fragment.app.FragmentContainerView</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="FragmentFactory-的使用"><a href="#FragmentFactory-的使用" class="headerlink" title="FragmentFactory 的使用"></a>FragmentFactory 的使用</h3><p>过去，我们只能使用其默认的空构造函数实例化Fragment实例。 这是因为在某些情况下，例如配置更改和应用程序的流程重新创建，系统需要重新初始化。 如果不是默认的构造方法，系统将不知道如何重新初始化Fragment实例。</p><p>创建FragmentFactory来解决此限制。 通过向其提供实例化Fragment所需的必要参数/依赖关系，它可以帮助系统创建Fragment实例。</p><p>过去我们实例化fragment并传递参数会使用类似下面的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> arg: String</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        arguments?.getString(ARG) ?: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">(arg: <span class="type">String</span>)</span></span> =</span><br><span class="line">            MyFragment().apply &#123;</span><br><span class="line">                arguments = Bundle().apply &#123;</span><br><span class="line">                    putString(ARG, arg)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//use</span></span><br><span class="line"><span class="keyword">val</span> fragment = MyFragment.newInstance(<span class="string">"my argument"</span>)</span><br></pre></td></tr></table></figure><p>如果您的Fragment有一个非空的构造函数，则需要创建一个FragmentFactory来处理它的初始化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragmentFactory</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> arg: String) : FragmentFactory() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">instantiate</span><span class="params">(classLoader: <span class="type">ClassLoader</span>, className: <span class="type">String</span>)</span></span>: Fragment &#123;</span><br><span class="line">        <span class="keyword">if</span> (className == MyFragment::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">name</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> MyFragment(arg)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.instantiate(classLoader, className)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fragment</code>由<code>FragmentManager</code> 管理，因此很自然，<code>FragmentFactory</code>需要添加到<code>FragmentManager</code>才能使用。</p><p>那么什么时候把<code>FragmentFactory</code> 添加到<code>FragmentManager</code>呢？</p><p><strong>父类调用 <code>Activity#onCreate()</code>  和 <code>Fragment#onCreate()</code>之前</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HostActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> customFragmentFactory = CustomFragmentFactory(Dependency())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        supportFragmentManager.fragmentFactory = customFragmentFactory</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> customFragmentFactory = CustomFragmentFactory(Dependency())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        childFragmentManager.fragmentFactory = customFragmentFactory</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您的<code>Fragment</code>具有默认的空构造函数，则无需使用<code>FragmentFactory</code>。 但是，如果您的<code>Fragment</code>在其构造函数中接受参数，则必须使用<code>FragmentFactory</code>，否则将抛出<code>Fragment.InstantiationException</code>，因为将使用的默认<code>FragmentFactory</code>将不知道如何实例化<code>Fragment</code>的实例。</p><h3 id="Fragment-返回键拦截"><a href="#Fragment-返回键拦截" class="headerlink" title="Fragment 返回键拦截"></a>Fragment 返回键拦截</h3><p>有时候，您需要阻止用户返回上一级。 在这种情况下，您需要在 <code>Activity</code> 中重写 <code>onBackPressed()</code> 方法。 但是，当您使用 <code>Fragment</code> 时，没有直接的方法来拦截返回。 在 <code>Fragment</code> 类中没有可用的 <code>onBackPressed()</code> 方法，这是为了防止同时存在多个 <code>Fragment</code> 时发生意外行为。</p><p>但是，从 <code>AndroidX</code> <code>Activity 1.0.0</code> 开始，您可以使用 <code>OnBackPressedDispatcher</code> 在您可以访问该 <code>Activity</code> 的代码的任何位置（例如，在 <code>Fragment</code> 中）注册 <code>OnBackPressedCallback</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttach(context)</span><br><span class="line">    <span class="keyword">val</span> callback = <span class="keyword">object</span> : OnBackPressedCallback(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleOnBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    requireActivity().onBackPressedDispatcher.addCallback(<span class="keyword">this</span>, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fragment-使用-ViewBinding"><a href="#Fragment-使用-ViewBinding" class="headerlink" title="Fragment 使用 ViewBinding"></a>Fragment 使用 ViewBinding</h3><p><code>Android Studio 3.6.0</code> 后提供了 <code>ViewBindind</code>的支持，完整使用流程参见 <a href="https://juejin.im/post/5e4806f3e51d4526c550a2ef" target="_blank" rel="noopener">[译]深入研究ViewBinding 在 include, merge, adapter, fragment, activity 中使用</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _binding: FragmentHomeBinding? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        _binding = FragmentHomeBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _binding = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fragment-使用-ViewPager2"><a href="#Fragment-使用-ViewPager2" class="headerlink" title="Fragment 使用 ViewPager2"></a>Fragment 使用 ViewPager2</h3><p><code>ViewPager</code>使用了三个<code>adapter</code>的抽象类，而<code>ViewPager2</code>中只有两个</p><ul><li>ViewPager 中使用 <code>PagerAdaper</code>，ViewPager2 中使用 <strong><code>Recyclerview.Adapter</code></strong></li><li>ViewPager 中使用 <code>FragmentPagerAdapter</code> ，ViewPager2中使用 <strong><code>FragmentStateAdapter</code></strong></li><li>ViewPager 中使用 <code>FragmentStatePagerAdapter</code> ，ViewPager2中使用 <strong><code>FragmentStateAdapter</code></strong></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simple ViewPager adapter class for paging through fragments</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenSlidePagerAdapter</span></span>(fm: FragmentManager) : FragmentStatePagerAdapter(fm) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = NUM_PAGES</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(position: <span class="type">Int</span>)</span></span>: Fragment = ScreenSlidePageFragment()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An equivalent ViewPager2 adapter class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenSlidePagerAdapter</span></span>(fa: FragmentActivity) : FragmentStateAdapter(fa) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = NUM_PAGES</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFragment</span><span class="params">(position: <span class="type">Int</span>)</span></span>: Fragment = ScreenSlidePageFragment()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>TabLayout</code>的变化，<code>TabLayout</code> 已从<code>ViewPager2</code>中解耦，如果使用<code>TabLayout</code>，需要引入依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"com.google.android.material:material:1.1.0"</span></span><br></pre></td></tr></table></figure><p>对于<code>ViewPager2</code> ，<code>TabLayout</code>布局应与<code>ViewPager2</code>在同一级别</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A ViewPager element with a TabLayout --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.viewpager.widget.ViewPager</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/pager"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.tabs.TabLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tab_layout"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.viewpager.widget.ViewPager</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- A ViewPager2 element with a TabLayout --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.tabs.TabLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tab_layout"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.viewpager2.widget.ViewPager2</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/pager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>ViewPager</code>时，<code>TabLayout</code>与<code>ViewPager</code>联动需要调用 <code>setupWithViewPager</code>，并重写<code>getPageTitle</code>方法，而<code>ViewPager2</code>改为使用<code>TabLayoutMediator</code>对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integrating TabLayout with ViewPager</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionDemoFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tabLayout = view.findViewById(R.id.tab_layout)</span><br><span class="line">        tabLayout.setupWithViewPager(viewPager)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoCollectionPagerAdapter</span></span>(fm: FragmentManager) : FragmentStatePagerAdapter(fm) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCount</span><span class="params">()</span></span>: <span class="built_in">Int</span>  = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPageTitle</span><span class="params">(position: <span class="type">Int</span>)</span></span>: CharSequence &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OBJECT <span class="subst">$&#123;(position + <span class="number">1</span>)&#125;</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integrating TabLayout with ViewPager2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionDemoFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> tabLayout = view.findViewById(R.id.tab_layout)</span><br><span class="line">        TabLayoutMediator(tabLayout, viewPager) &#123; tab, position -&gt;</span><br><span class="line">            tab.text = <span class="string">"OBJECT <span class="subst">$&#123;(position + <span class="number">1</span>)&#125;</span>"</span></span><br><span class="line">        &#125;.attach()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不需要重写-onCreateView-了？"><a href="#不需要重写-onCreateView-了？" class="headerlink" title="不需要重写 onCreateView 了？"></a>不需要重写 onCreateView 了？</h3><p><code>androidx fragment 1.1.0</code> 后，您可以使用将 <code>layoutId</code> 作为参数的构造函数，这样就无需重写 <code>onCreateView</code> 方法了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>(R.layout.my_activity)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragmentActivity</span>: <span class="type">FragmentActivity</span></span>(R.layout.my_fragment_activity)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>(R.layout.my_fragment)</span><br></pre></td></tr></table></figure><h3 id="使用require-方法"><a href="#使用require-方法" class="headerlink" title="使用require_()方法"></a>使用require_()方法</h3><p><code>androidx fragment 1.2.2</code> 起，新增了一项lint检查，<code>fragment</code> 建议使用关联的<code>require_()</code>方法获取更多描述性错误消息，而不是使用<code>checkNotNull(get_())</code>，<code>requireNonNull(get_())</code> 或<code>get()！</code> 适用于所有包含 get 和 require Fragment API</p><p>例如：使用 <code>requireActivity()</code> 替代 <code>getActivity()</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 &lt;code&gt;Android Jetpack&lt;/code&gt; 组件中，&lt;code&gt;fragment&lt;/code&gt;作为视图控制器之一占有很重要的位置。但由于其bug众多，暗坑无数，以至于 Square 有这样一篇博客：&lt;a href=&quot;https://developer.squareup.com/blog/advocating-against-android-fragments/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Advocating Against Android Fragments&lt;/a&gt;。github上的 &lt;a href=&quot;https://github.com/YoKeyword/Fragmentation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fragmentation&lt;/a&gt; 有着 9.4k 的star。&lt;/p&gt;
&lt;p&gt;而现在，&lt;code&gt;androidx fragment&lt;/code&gt; 稳定版已来到 1.2.2，让我们总结一下&lt;code&gt;fragment&lt;/code&gt;有哪些常见问题以及有哪些使用&lt;code&gt;fragment&lt;/code&gt;的新姿势&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【背上Jetpack】AdroidX下使用Activity和Fragment的变化</title>
    <link href="http://yoursite.com/2020/02/29/%E3%80%90%E8%83%8C%E4%B8%8AJetpack%E3%80%91AdroidX%E4%B8%8B%E4%BD%BF%E7%94%A8Activity%E5%92%8CFragment%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/02/29/【背上Jetpack】AdroidX下使用Activity和Fragment的变化/</id>
    <published>2020-02-28T16:10:35.000Z</published>
    <updated>2020-03-24T01:12:04.110Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://medium.com/@miloszlewandowski/how-androidx-changes-the-way-we-work-with-activities-and-fragments-73b88d157678" target="_blank" rel="noopener">How AndroidX changes the way we work with Activities and Fragments</a></p><p>作者：<a href="https://medium.com/@miloszlewandowski" target="_blank" rel="noopener">Miłosz Lewandowski</a></p><p>译者：<a href="http://www.yangyunzhao.com/" target="_blank" rel="noopener">Fly_with24</a></p></blockquote><p>过去的一段时间，<code>AndroidX</code> 软件包下的 <code>Activity/Fragmet</code> 的 API 发生了很多变化。让我们看看它们是如何提升Android 的开发效率以及如何适应当下流行的编程规则和模式。</p><p>本文中描述的所有功能现在都可以在稳定的 <code>AndroidX</code> 软件包中使用，它们在去年均已发布或移至稳定版本。</p><a id="more"></a><h3 id="在构造器中传入布局-ID"><a href="#在构造器中传入布局-ID" class="headerlink" title="在构造器中传入布局 ID"></a>在构造器中传入布局 ID</h3><p>从 <code>AndroidX</code>  <code>AppCompat 1.1.0</code> 和 <code>Fragment 1.1.0</code> ( 译者注：AppCompat 包含 Fragment，且 Fragment 包含 Activity，详情见<a href="https://juejin.im/post/5e567ee1518825494466a938" target="_blank" rel="noopener">【整理】Jetpack 主要组件的依赖及传递关系</a> )开始，您可以使用将 <code>layoutId</code> 作为参数的构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>(R.layout.my_activity)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragmentActivity</span>: <span class="type">FragmentActivity</span></span>(R.layout.my_fragment_activity)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>(R.layout.my_fragment)</span><br></pre></td></tr></table></figure><p>这种方法可以减少 <code>Activity/Fragment</code> 中方法重写的数量，并使类更具可读性。 无需在 <code>Activity</code> 中重写 <code>onCreate()</code> 即可调用 <code>setContentView()</code> 方法。 另外，无需手动在<code>Fragment</code> 中重写 <code>onCreateView</code> 即可手动调用 <code>Inflater</code> 来扩展视图。</p><h3 id="扩展-Activity-Fragment-的灵活性"><a href="#扩展-Activity-Fragment-的灵活性" class="headerlink" title="扩展 Activity/Fragment 的灵活性"></a>扩展 <code>Activity/Fragment</code> 的灵活性</h3><p>借助 <code>AndroidX</code> 新的 API ，可以减少在 <code>Activity/Fragment</code> 处理某些功能的情况。通常，您可以获取提供某些功能的对象并向其注册您的处理逻辑，而不是重写 <code>Activity / Fragment</code> 中的方法。 这样，您现在可以在屏幕上组成几个独立的类，获得更高的灵活性，复用代码，并且通常在不引入自己的抽象的情况下，对代码结构具有更多控制。 让我们看看这在两个示例中如何工作。</p><h4 id="1-OnBackPressedDispatcher"><a href="#1-OnBackPressedDispatcher" class="headerlink" title="1. OnBackPressedDispatcher"></a>1. OnBackPressedDispatcher</h4><p>有时，您需要阻止用户返回上一级。 在这种情况下，您需要在 <code>Activity</code> 中重写 <code>onBackPressed()</code> 方法。 但是，当您使用 <code>Fragment</code> 时，没有直接的方法来拦截返回。 在 <code>Fragment</code> 类中没有可用的 <code>onBackPressed()</code> 方法，这是为了防止同时存在多个 <code>Fragment</code> 时发生意外行为。</p><p>但是，从 <code>AndroidX</code> <code>Activity 1.0.0</code> 开始，您可以使用 <code>OnBackPressedDispatcher</code> 在您可以访问该 <code>Activity</code> 的代码的任何位置（例如，在 <code>Fragment</code> 中）注册 <code>OnBackPressedCallback</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttach(context)</span><br><span class="line">    <span class="keyword">val</span> callback = <span class="keyword">object</span> : OnBackPressedCallback(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleOnBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    requireActivity().onBackPressedDispatcher.addCallback(<span class="keyword">this</span>, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可能会在这里注意到另外两个有用的功能：</p><ul><li><code>OnBackPressedCallback</code> 的构造函数中的布尔类型的参数有助于根据当前状态动态 打开/关闭按下的行为</li><li><code>addCallback()</code> 方法的可选第一个参数是 <code>LifecycleOwner</code>，以确保仅在您的生命周期感知对象（例如，<code>Fragment</code>）至少处于 <code>STARTED</code> 状态时才使用回调。</li></ul><p>通过使用 <code>OnBackPressedDispatcher</code> ，您不仅可以获得在 <code>Activity</code> 之外处理返回键的便捷方式。 根据您的需要，您可以在任意位置定义 <code>OnBackPressedCallback</code>，使其可复用，或根据应用程序的架构进行任何操作。 您不再需要重写<code>Activity</code> 中的 <code>onBackPressed</code> 方法，也不必提供自己的抽象的来实现需求的代码。</p><h4 id="2-SavedStateRegistry"><a href="#2-SavedStateRegistry" class="headerlink" title="2. SavedStateRegistry"></a>2. SavedStateRegistry</h4><p>如果您希望 <code>Activity</code> 在终止并重启后恢复之前的状态，则可能要使用 <code>saved state</code> 功能。 过去，您需要在 <code>Activity</code> 中重写两个方法：<code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code>。 您还可以在 <code>onCreate</code> 方法中访问恢复的状态。 同样，在 <code>Fragment</code> 中，您可以使用<code>onSaveInstanceState</code> 方法（并且可以在 <code>onCreate</code>，<code>onCreateView</code> 和<code>onActivityCreated</code>方法中恢复状态）。</p><p>从 <code>AndroidX</code>  <code>SavedState 1.0.0</code>（它是 <code>AndroidX</code> <code>Activity</code> 和 <code>AndroidX</code>  <code>Fragment</code> 内部的依赖。译者注：您不需要单独声明它）开始，您可以访问 <code>SavedStateRegistry</code>，它使用了与前面描述的 <code>OnBackPressedDispatcher</code> 类似的机制：您可以从 <code>Activity / Fragment</code> 中获取 <code>SavedStateRegistry</code>，然后 注册您的 <code>SavedStateProvider</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> MY_SAVED_STATE_KEY = <span class="string">"my_saved_state"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SOME_VALUE_KEY = <span class="string">"some_value"</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> someValue: String</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> savedStateProvider = SavedStateRegistry.SavedStateProvider &#123;    </span><br><span class="line">    Bundle().apply &#123;</span><br><span class="line">      putString(SOME_VALUE_KEY, someValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;    </span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    savedStateRegistry</span><br><span class="line">      .registerSavedStateProvider(MY_SAVED_STATE_KEY, savedStateProvider)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    someValue = savedStateRegistry</span><br><span class="line">      .consumeRestoredStateForKey(MY_SAVED_STATE_KEY)</span><br><span class="line">      ?.getString(SOME_VALUE_KEY)</span><br><span class="line">      ?: <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，<code>SavedStateRegistry</code> 强制您将密钥用于数据。 这样可以防止您的数据被 attach 到同一个 <code>Activity/Fragment</code>的另一个 <code>SavedStateProvider</code> 破坏。 就像在 <code>OnBackPressedDispatcher</code> 中一样，您可以例如将 <code>SavedStateProvider</code> 提取到另一个类，通过使用所需的任何逻辑使其与数据一起使用，从而在应用程序中实现清晰的保存状态行为。</p><p>此外，如果您在应用程序中使用 <code>ViewModel</code>，请考虑使用 <code>AndroidX</code>  <code>ViewModel-SavedState</code> 使你的<code>ViewModel</code> 可以保存其状态。 为了方便起见，从 <code>AndroidX</code>  <code>Activity 1.1.0</code> 和 <code>AndroidX</code> <code>Fragment 1.2.0</code> 开始，启用 <code>SavedState</code> 的<code>SavedStateViewModelFactory</code> 是在获取 <code>ViewModel</code> 的所有方式中使用的默认工厂：委托 <code>ViewModelProvider</code> 构造函数和 <code>ViewModelProviders.of()</code> 方法。</p><h3 id="FragmentFactory"><a href="#FragmentFactory" class="headerlink" title="FragmentFactory"></a>FragmentFactory</h3><p><code>Fragment</code> 最常提及的问题之一是不能使用带有参数的构造函数。 例如，如果您使用 <code>Dagger2</code> 进行依赖项注入，则无法使用 <code>Inject</code> 注解 <code>Fragment</code> 构造函数并指定参数。 现在，您可以通过指定 <code>FragmentFactory</code> 类来减少 <code>Fragment</code> 创建过程中的类似问题。 通过在 <code>FragmentManager</code> 中注册 <code>FragmentFactory</code>，可以重写实例化 <code>Fragment</code> 的默认方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragmentFactory</span> : <span class="type">FragmentFactory</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">instantiate</span><span class="params">(classLoader: <span class="type">ClassLoader</span>, className: <span class="type">String</span>)</span></span>: Fragment &#123;</span><br><span class="line">    <span class="comment">// Call loadFragmentClass() to obtain the Class object</span></span><br><span class="line">    <span class="keyword">val</span> fragmentClass = loadFragmentClass(classLoader, className)</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Now you can use className/fragmentClass to determine your prefered way </span></span><br><span class="line">    <span class="comment">// of instantiating the Fragment object and just do it here.</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Or just call regular FragmentFactory to instantiate the Fragment using</span></span><br><span class="line">    <span class="comment">// no arguments constructor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.instantiate(classLoader, className)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，该API非常通用，因此您可以执行想要创建 <code>Fragment</code> 实例的所有操作。 回到 <code>Dagger2</code> 示例，例如，您可以注入<code>FragmentFactory Provider &lt;Fragment&gt;</code> 并使用它来获取 <code>Fragment</code> 对象。</p><h3 id="测试-Fragment"><a href="#测试-Fragment" class="headerlink" title="测试 Fragment"></a>测试 Fragment</h3><p>从<code>AndroidX</code>  <code>Fragment 1.1.0</code> 开始，可以使用 <code>Fragment</code> 测试组件提供 <code>FragmentScenario</code> 类，该类可以帮助在测试中实例化 <code>Fragment</code> 并进行单独测试：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// To launch a Fragment with a user interface:</span></span><br><span class="line"><span class="keyword">val</span> scenario = launchFragmentInContainer&lt;FirstFragment&gt;()</span><br><span class="line">        </span><br><span class="line"><span class="comment">// To launch a headless Fragment:</span></span><br><span class="line"><span class="keyword">val</span> scenario = launchFragment&lt;FirstFragment&gt;()</span><br><span class="line">        </span><br><span class="line"><span class="comment">// To move the fragment to specific lifecycle state:</span></span><br><span class="line">scenario.moveToState(CREATED)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now you can e.g. perform actions using Espresso:</span></span><br><span class="line">onView(withId(R.id.refresh)).perform(click())</span><br><span class="line"></span><br><span class="line"><span class="comment">// To obtain a Fragment instance:</span></span><br><span class="line">scenario.onFragment &#123; fragment -&gt;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="More-Kotlin"><a href="#More-Kotlin" class="headerlink" title="More Kotlin!"></a>More Kotlin!</h3><p>很高兴看到 <code>-ktx</code> <code>AndroidX</code> 软件包中提供了许多有用的 <code>Kotlin</code> 扩展方法，并且定期添加了新的方法。 例如，在<code>AndroidX</code> <code>Fragment-KTX 1.2.0</code> 中，使用片段化类型的扩展名可用于 <code>FragmentTransaction</code> 上的 <code>replace()</code> 方法。 将其与 <code>commit()</code> 扩展方法结合使用，我们可以获得以下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line">supportFragmentManager</span><br><span class="line">  .beginTransaction()</span><br><span class="line">  .add(R.id.container, MyFragment::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">null)</span></span></span><br><span class="line">  .commit()</span><br><span class="line"></span><br><span class="line"><span class="comment">// After</span></span><br><span class="line">supportFragmentManager.commit &#123;</span><br><span class="line">  replace&lt;MyFragment&gt;(R.id.container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FragmentContainerView"><a href="#FragmentContainerView" class="headerlink" title="FragmentContainerView"></a>FragmentContainerView</h3><p>一件小而重要的事情。 如果您将 <code>FrameLayout</code> 用作 <code>Fragment</code> 的容器，则应改用 <code>FragmentContainerView</code> 。 它修复了一些动画 z轴索引顺序问题和窗口插入调度。 从 <code>AndroidX</code> <code>Fragment 1.2.0</code> 开始可以使用 <code>FragmentContainerView</code>。</p><hr><h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><hr><p>我是 <a href="https://flywith24.gitee.io/" target="_blank" rel="noopener">Fly_with24</a></p><ul><li><p><a href="https://juejin.im/user/57c7f6870a2b58006b1cfd6c" target="_blank" rel="noopener">掘金</a></p></li><li><p><a href="https://www.jianshu.com/u/3d5ad6043d66" target="_blank" rel="noopener">简书</a></p></li><li><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">Github</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@miloszlewandowski/how-androidx-changes-the-way-we-work-with-activities-and-fragments-73b88d157678&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How AndroidX changes the way we work with Activities and Fragments&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://medium.com/@miloszlewandowski&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Miłosz Lewandowski&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;http://www.yangyunzhao.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fly_with24&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;过去的一段时间，&lt;code&gt;AndroidX&lt;/code&gt; 软件包下的 &lt;code&gt;Activity/Fragmet&lt;/code&gt; 的 API 发生了很多变化。让我们看看它们是如何提升Android 的开发效率以及如何适应当下流行的编程规则和模式。&lt;/p&gt;
&lt;p&gt;本文中描述的所有功能现在都可以在稳定的 &lt;code&gt;AndroidX&lt;/code&gt; 软件包中使用，它们在去年均已发布或移至稳定版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Jetpack/"/>
    
    
      <category term="androidx" scheme="http://yoursite.com/tags/androidx/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>【重学Android读书笔记】Activity的任务栈与返回栈</title>
    <link href="http://yoursite.com/2019/11/29/%E3%80%90%E9%87%8D%E5%AD%A6Android%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91Activity%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%A0%88%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%A0%88/"/>
    <id>http://yoursite.com/2019/11/29/【重学Android读书笔记】Activity的任务栈与返回栈/</id>
    <published>2019-11-29T09:42:00.000Z</published>
    <updated>2019-11-29T09:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>订阅 <a href="https://xiaozhuanlan.com/topic/9074561823" target="_blank" rel="noopener">重学安卓</a> 很久了，最近在整理读书笔记，在此记录之。</p><p>在此隆重推荐这位大佬 KunMinX</p><p>本文记录Activity任务栈与返回栈相关内容的疑问与探索</p></blockquote><a id="more"></a><p>该专栏的代码地址： <a href="https://github.com/KunMinX/Relearn-Android" target="_blank" rel="noopener">https://github.com/KunMinX/Relearn-Android</a> </p><h4 id="疑惑产生"><a href="#疑惑产生" class="headerlink" title="疑惑产生"></a>疑惑产生</h4><p>根据大佬的代码以及文章描述，有个地方让我很疑惑。</p><p><img src="/2019/11/29/【重学Android读书笔记】Activity的任务栈与返回栈/%E9%97%AE%E9%A2%98.png" alt="问题"></p><p>我这里没有过滤当前使用的app，所以app1和app2产生的日志都显示了出来。</p><p>大佬在评论区关于此的回答</p><blockquote><p><a href="https://xiaozhuanlan.com/u/kunminx" target="_blank" rel="noopener">KunMinX</a></p><p>#40</p><p><a href="https://xiaozhuanlan.com/topic/7812045693#reply2" target="_blank" rel="noopener">#2楼</a> <a href="https://xiaozhuanlan.com/u/2711412979" target="_blank" rel="noopener"><em>@</em>Sky63</a><br>大概明白你提到的、造成困扰的地方了。<br>D 和 C 是由 app1 启动，在 IDE 中可通过 app1 的视角观察到。同理，当 app2 的 B 唤起 D 时，你在回退 D 的时候能在 app2 和 app1 的视角中同时观察到 D 的销毁。而紧随其后再回退一次， 便能在 app1 中观察到 C 被销毁。再下一次才轮到 app2 中 B 被销毁。</p></blockquote><p>但是根据我操作看到的现象，D的销毁不是在不同app视角观察到的同一次销毁。通过上图可以看出两次销毁是有时间差的，而且经过我的二次确认，的确是关闭两次界面才出现了两次销毁Log。</p><h4 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h4><p>通过 <code>adb shell</code> 中的 <code>dumpsys activity activities</code> 命令可以查看 activity 栈信息，故我截取了相关的输出，以下堆栈信息均经过精简。</p><h5 id="1-app1-依次打开-SingleTaskOne-SingleTaskTwo"><a href="#1-app1-依次打开-SingleTaskOne-SingleTaskTwo" class="headerlink" title="1. app1 依次打开 SingleTaskOne SingleTaskTwo"></a>1. <code>app1</code> 依次打开 <code>SingleTaskOne</code> <code>SingleTaskTwo</code></h5><p><img src="/2019/11/29/【重学Android读书笔记】Activity的任务栈与返回栈/log1.png" alt="log1"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">➜  Relearn-Android (master) adb shell</span><br><span class="line">sagit:/ $ dumpsys activity activities</span><br><span class="line">ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)</span><br><span class="line">Display #0 (activities from top to bottom):</span><br><span class="line"></span><br><span class="line">  Stack #2: type=standard mode=fullscreen</span><br><span class="line">    Task id #3</span><br><span class="line"></span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125;</span><br><span class="line"></span><br><span class="line">    mResumedActivity: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;</span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125;</span><br><span class="line"></span><br><span class="line">  Stack #1: type=standard mode=fullscreen</span><br><span class="line">    Task id #2</span><br><span class="line"></span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;d91b3e8 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;d76e9a5 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;</span><br><span class="line"></span><br><span class="line">  Stack #0: type=home mode=fullscreen</span><br><span class="line"></span><br><span class="line">    Task id #1</span><br><span class="line"></span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;94a7a01 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125;</span><br><span class="line"></span><br><span class="line">  ResumedActivity:ActivityRecord&#123;</span><br><span class="line">93c0c72u0com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;</span><br><span class="line">  </span><br><span class="line">  mFocusedStack=ActivityStack&#123;</span><br><span class="line">  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks</span><br><span class="line">  &#125; </span><br><span class="line">  mLastFocusedStack=ActivityStack&#123;</span><br><span class="line">  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks</span><br><span class="line">  &#125;</span><br><span class="line">  mCurTaskIdForUser=&#123;0=3&#125;</span><br><span class="line">  mUserStackInFront=&#123;&#125;</span><br><span class="line">  displayId=0 stacks=3</span><br><span class="line">   mHomeStack=ActivityStack&#123;</span><br><span class="line">   76ebae7 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks</span><br><span class="line">   &#125;</span><br><span class="line">  isHomeRecentsComponent=false  KeyguardController:</span><br><span class="line">    mKeyguardShowing=false</span><br><span class="line">    mAodShowing=false</span><br><span class="line">    mKeyguardGoingAway=false</span><br><span class="line">    mOccluded=false</span><br><span class="line">    mDismissingKeyguardActivity=null</span><br><span class="line">    mDismissalRequested=false</span><br><span class="line">    mVisibilityTransactionDepth=0</span><br><span class="line">  LockTaskController</span><br><span class="line">    mLockTaskModeState=NONE</span><br><span class="line">    mLockTaskModeTasks=</span><br><span class="line">    mLockTaskPackages (userId:packages)=</span><br><span class="line">      u0:[]</span><br></pre></td></tr></table></figure><p>此时看到堆栈顺序为：<strong>Stack #2 -&lt; Stack #1 -&lt; Stack #0</strong> 其中 <code>Stack #0</code> 为 <code>launcher</code></p><p>获取焦点的 <code>ActivityStack</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mFocusedStack=ActivityStack&#123;</span><br><span class="line">  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; </span><br><span class="line">mLastFocusedStack=ActivityStack&#123;</span><br><span class="line">  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;</span><br></pre></td></tr></table></figure><h5 id="2-按下HOME键，打开-app2-依次打开-StandardOneActivity-StandardTwoActivity"><a href="#2-按下HOME键，打开-app2-依次打开-StandardOneActivity-StandardTwoActivity" class="headerlink" title="2. 按下HOME键，打开 app2 依次打开 StandardOneActivity StandardTwoActivity"></a>2. 按下HOME键，打开 <code>app2</code> 依次打开 <code>StandardOneActivity</code> <code>StandardTwoActivity</code></h5><p><img src="/2019/11/29/【重学Android读书笔记】Activity的任务栈与返回栈/log2.png" alt="log2"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Display #0 (activities from top to bottom):</span><br><span class="line"></span><br><span class="line">  Stack #3: type=standard mode=fullscreen</span><br><span class="line">    Task id #4</span><br><span class="line"></span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;718157f #4 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125;</span><br><span class="line">        Run #3: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125;</span><br><span class="line">        Run #2: ActivityRecord&#123;648188e u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;f39ebe9 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;f02fff8 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t4&#125;</span><br><span class="line"></span><br><span class="line">    mResumedActivity: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125;</span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;648188e u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125;</span><br><span class="line"></span><br><span class="line">  Stack #0: type=home mode=fullscreen</span><br><span class="line">    Task id #1</span><br><span class="line"></span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;2094d95 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;a7fed1a u0 com.miui.home/.launcher.Launcher t1&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;a7fed1a u0 com.miui.home/.launcher.Launcher t1&#125;</span><br><span class="line"></span><br><span class="line">  Stack #2: type=standard mode=fullscreen</span><br><span class="line">    Task id #3</span><br><span class="line">    </span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;9d79eaa #3 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;15d3e09 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;20d177c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;15d3e09 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;</span><br><span class="line"></span><br><span class="line">  Stack #1: type=standard mode=fullscreen</span><br><span class="line">  isSleeping=false</span><br><span class="line">  mBounds=Rect(0, 0 - 0, 0)</span><br><span class="line"></span><br><span class="line">    Task id #2</span><br><span class="line"></span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;e526e38 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;19055b2 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;5a647a6 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;19055b2 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;</span><br><span class="line"></span><br><span class="line">  ResumedActivity: ActivityRecord&#123;137a584 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125;</span><br><span class="line"></span><br><span class="line">  mFocusedStack=ActivityStack&#123;</span><br><span class="line">      dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; </span><br><span class="line">mLastFocusedStack=ActivityStack&#123;</span><br><span class="line">    dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;</span><br><span class="line">  mCurTaskIdForUser=&#123;0=4&#125;</span><br><span class="line">  mUserStackInFront=&#123;&#125;</span><br><span class="line">  displayId=0 stacks=4</span><br><span class="line">   mHomeStack=ActivityStack&#123;968fb76 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125;</span><br><span class="line">  isHomeRecentsComponent=false  KeyguardController:</span><br><span class="line">    mKeyguardShowing=false</span><br><span class="line">    mAodShowing=false</span><br><span class="line">    mKeyguardGoingAway=false</span><br><span class="line">    mOccluded=false</span><br><span class="line">    mDismissingKeyguardActivity=null</span><br><span class="line">    mDismissalRequested=false</span><br><span class="line">    mVisibilityTransactionDepth=0</span><br><span class="line">  LockTaskController</span><br><span class="line">    mLockTaskModeState=NONE</span><br><span class="line">    mLockTaskModeTasks=</span><br><span class="line">    mLockTaskPackages (userId:packages)=</span><br><span class="line">      u0:[]</span><br></pre></td></tr></table></figure><p><strong>这里的堆栈顺序为 Stack #3 -&lt; Stack #0 -&lt; Stack #2 -&lt; Stack #1</strong></p><p><code>Stack #0</code> 为home ，这里反应出点击home键，打开app2 的操作。此时 <code>Stack #3</code> 中有 4 个 <code>ActivityRecord</code></p><p>当前获取焦点的 <code>ActivityStack</code> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  mFocusedStack=ActivityStack&#123;</span><br><span class="line">      dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; </span><br><span class="line">mLastFocusedStack=ActivityStack&#123;</span><br><span class="line">    dfe2e11 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;</span><br><span class="line">  mCurTaskIdForUser=&#123;0=4&#125;</span><br></pre></td></tr></table></figure><h5 id="3-接下来启动-SingleTaskTwoActivity"><a href="#3-接下来启动-SingleTaskTwoActivity" class="headerlink" title="3. 接下来启动 SingleTaskTwoActivity"></a>3. 接下来启动 <code>SingleTaskTwoActivity</code></h5><p><img src="/2019/11/29/【重学Android读书笔记】Activity的任务栈与返回栈/log3.png" alt="log3"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">sagit:/ $ dumpsys activity activities</span><br><span class="line">ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)</span><br><span class="line">Display #0 (activities from top to bottom):</span><br><span class="line"></span><br><span class="line">  Stack #2: type=standard mode=fullscreen</span><br><span class="line">    Task id #3</span><br><span class="line"></span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=3&#125;</span><br><span class="line">        Run #2: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125;</span><br><span class="line"></span><br><span class="line">    mResumedActivity: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;</span><br><span class="line"></span><br><span class="line">  Stack #3: type=standard mode=fullscreen</span><br><span class="line">    Task id #4</span><br><span class="line"></span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;f14a51a #4 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125;</span><br><span class="line">        Run #3: ActivityRecord&#123;1838862 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125;</span><br><span class="line">        Run #2: ActivityRecord&#123;bdb3180 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;7b21450 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t4&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;ff57abb u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t4&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;1838862 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t4&#125;</span><br><span class="line"></span><br><span class="line">  Stack #0: type=home mode=fullscreen</span><br><span class="line">    Task id #1</span><br><span class="line"></span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;94a7a01 #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;7d6409 u0 com.miui.home/.launcher.Launcher t1&#125;</span><br><span class="line"></span><br><span class="line">  Stack #1: type=standard mode=fullscreen</span><br><span class="line"></span><br><span class="line">    Task id #2</span><br><span class="line">        </span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;d91b3e8 #2 A=com.kunminx.relearn_android U=0 StackId=1 sz=2&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;d76e9a5 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t2&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;8b59240 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t2&#125;</span><br><span class="line"></span><br><span class="line">  ResumedActivity: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;</span><br><span class="line"></span><br><span class="line">  mFocusedStack=ActivityStack&#123;</span><br><span class="line">    3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; </span><br><span class="line">  mLastFocusedStack=ActivityStack&#123;</span><br><span class="line">    3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;</span><br><span class="line">  mCurTaskIdForUser=&#123;0=4&#125;</span><br><span class="line"></span><br><span class="line">  mUserStackInFront=&#123;&#125;</span><br><span class="line">  displayId=0 stacks=4</span><br><span class="line">   mHomeStack=ActivityStack&#123;</span><br><span class="line">       76ebae7 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125;</span><br><span class="line">  isHomeRecentsComponent=false  KeyguardController:</span><br><span class="line">    mKeyguardShowing=false</span><br><span class="line">    mAodShowing=false</span><br><span class="line">    mKeyguardGoingAway=false</span><br><span class="line">    mOccluded=false</span><br><span class="line">    mDismissingKeyguardActivity=null</span><br><span class="line">    mDismissalRequested=false</span><br><span class="line">    mVisibilityTransactionDepth=0</span><br><span class="line">  LockTaskController</span><br><span class="line">    mLockTaskModeState=NONE</span><br><span class="line">    mLockTaskModeTasks=</span><br><span class="line">    mLockTaskPackages (userId:packages)=</span><br><span class="line">      u0:[]</span><br></pre></td></tr></table></figure><p><strong>当前的堆栈顺序 Stack #2 -&lt; Stack #3 -&lt; Stack #0 -&lt;Stack #1</strong></p><p>当前获取焦点的 <code>ActivityStack</code> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mFocusedStack=ActivityStack&#123;</span><br><span class="line">  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125; </span><br><span class="line">mLastFocusedStack=ActivityStack&#123;</span><br><span class="line">  3a870a6 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;</span><br><span class="line">mCurTaskIdForUser=&#123;0=4&#125;</span><br></pre></td></tr></table></figure><p><code>Stack #2</code> 中 <code>TaskRecord</code>信息为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TaskRecord&#123;4920da #3 A=com.kunminx.task.c U=0 StackId=2 sz=3&#125;</span><br><span class="line">  Run #2: ActivityRecord&#123;55f799d u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;</span><br><span class="line">  Run #1: ActivityRecord&#123;93c0c72 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t3&#125;</span><br><span class="line">  Run #0: ActivityRecord&#123;999111 u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t3&#125;</span><br></pre></td></tr></table></figure><h4 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h4><p><strong>关键的地方来了</strong></p><p>的确有两个 <code>SingleTaskTwoActivity</code> 的 <code>ActivityRecord</code> ，栈顶的属于 <code>app2</code> 第二个属于 <code>app1</code></p><p>由此看出这两个<code>ActivityRecord</code> 不是一个实例，所以这里 <code>app2</code> 启动的 <code>SingleTaskTwoActivity</code> 应该是 <code>app2</code> 自己的activity</p><p>废话不说，翻代码！这里截取了 <code>BaseTaskActivity</code> 中的部分代码，<code>app1</code> 和 <code>app2</code>中的 <code>activity</code> 都继承了<code>BaseTaskActivity</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = v.getId();</span><br><span class="line">        <span class="keyword">if</span> (i == R.id.btn_standard_one) &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, StandardOneActivity.class);</span><br><span class="line">            startActivityWithCheck(intent);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == R.id.btn_standard_two) &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, StandardTwoActivity.class);</span><br><span class="line">            startActivityWithCheck(intent);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == R.id.btn_singletask_one) &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SingleTaskOneActivity.class);</span><br><span class="line">            startActivityWithCheck(intent);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == R.id.btn_singletask_two) &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SingleTaskTwoActivity.class);</span><br><span class="line">            startActivityWithCheck(intent);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//以下测试结果证实：</span></span><br><span class="line">            <span class="comment">//1.在 App2 中启动 App1 的 standard Activity，仍然遵守 standard 的特点：在启动它的 Activity 所在的任务中启动，也即跟随 App2。</span></span><br><span class="line">            <span class="comment">//2.在 App2 中启动 App1 的 singleTop Activity，跟随状况同 standard。</span></span><br><span class="line">            <span class="comment">//3.在 App2 中启动 App1 的 singleTask Activity，仍然处于 App1 的任务中，并不跟随 App2。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == R.id.btn_singletask_a) &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">            ComponentName name = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                    <span class="string">"com.kunminx.relearn_android"</span>,</span><br><span class="line">                    <span class="string">"com.kunminx.relearn_android.SingleTaskAActivity"</span>);</span><br><span class="line">            intent.setComponent(name);</span><br><span class="line">            startActivityWithCheck(intent);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == R.id.btn_singletask_b) &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">            ComponentName name = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                    <span class="string">"com.kunminx.relearn_android"</span>,</span><br><span class="line">                    <span class="string">"com.kunminx.relearn_android.SingleTaskBActivity"</span>);</span><br><span class="line">            intent.setComponent(name);</span><br><span class="line">            startActivityWithCheck(intent);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看出这里 <code>app2</code> 启动<code>SingleTaskTwoActivity</code> 的确是自己的 <code>activity</code></p><p><strong>那么它为什么和<code>app1</code> 中的  <code>SingleTaskTwoActivity</code>  是同一个 <code>TaskRecord</code> 呢？</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".test03_task_test.SingleTaskOneActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">"com.kunminx.task.c"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".test03_task_test.SingleTaskTwoActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">"com.kunminx.task.c"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>它们有着共同的 <code>taskAffinity</code>。至此，我的疑惑已经得到了答案。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>我试了以下 <code>app2</code> 中启动 <code>app1</code> 中的Activity的情况</p><p><code>app1</code> 依次启动 <code>StandardOneActivity</code> -&lt; <code>SingleTaskOneActivity</code>  -&lt; <code>SingleTaskTwoActivity</code>  -&lt; <code>SingleTaskAActivity</code></p><p>其中 <code>SingleTaskOneActivity</code>  与 <code>SingleTaskTwoActivity</code> 设置了相同的 <code>taskAffinity</code> ,<code>StandardOneActivity</code> <code>与 SingleTaskAActivity</code> 未设置 <code>taskAffinity</code></p><p><img src="/2019/11/29/【重学Android读书笔记】Activity的任务栈与返回栈/log4.png" alt="log4"></p><p>接着按 HOME 键，打开 <code>app2</code> ，依次打开 <code>StandardOneActivity</code> -&lt; <code>StandardOneActivity</code> -&lt; <code>StandardTwoActivity</code></p><p><img src="/2019/11/29/【重学Android读书笔记】Activity的任务栈与返回栈/log5.png" alt="log5"></p><p>此时堆栈信息</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">➜  Relearn-Android (master) adb shell</span><br><span class="line">sagit:/ $ dumpsys activity activities</span><br><span class="line">ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)</span><br><span class="line">Display #0 (activities from top to bottom):</span><br><span class="line"></span><br><span class="line">  Stack #3: type=standard mode=fullscreen</span><br><span class="line">  isSleeping=false</span><br><span class="line">  mBounds=Rect(0, 0 - 0, 0)</span><br><span class="line">    Task id #48</span><br><span class="line"></span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;3b07175 #48 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125;</span><br><span class="line">        Run #3: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125;</span><br><span class="line">        Run #2: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;71254 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;7c135cf u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t48&#125;</span><br><span class="line"></span><br><span class="line">    mResumedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125;</span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125;</span><br><span class="line"></span><br><span class="line">  Stack #0: type=home mode=fullscreen</span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;185017b #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125;</span><br><span class="line"></span><br><span class="line">  Stack #1: type=standard mode=fullscreen</span><br><span class="line">    Task id #46</span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;c374b98 #46 A=com.kunminx.relearn_android U=0 StackId=1 sz=3&#125;</span><br><span class="line">        Run #2: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;bb0363c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t46&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;510711c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t46&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125;</span><br><span class="line"></span><br><span class="line">  Stack #2: type=standard mode=fullscreen</span><br><span class="line">    Task id #47</span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;3387d6 #47 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;e9850ca u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t47&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125;</span><br><span class="line"></span><br><span class="line">  ResumedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125;</span><br><span class="line"></span><br><span class="line">  mFocusedStack=ActivityStack&#123;ed83a57 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;</span><br><span class="line">  mLastFocusedStack=ActivityStack&#123;ed83a57 stackId=3 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;</span><br><span class="line">  mCurTaskIdForUser=&#123;0=48&#125;</span><br><span class="line"></span><br><span class="line">  mUserStackInFront=&#123;&#125;</span><br><span class="line">  displayId=0 stacks=4</span><br><span class="line">   mHomeStack=ActivityStack&#123;a218944 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125;</span><br><span class="line">  isHomeRecentsComponent=false  KeyguardController:</span><br><span class="line">    mKeyguardShowing=false</span><br><span class="line">    mAodShowing=false</span><br><span class="line">    mKeyguardGoingAway=false</span><br><span class="line">    mOccluded=false</span><br><span class="line">    mDismissingKeyguardActivity=null</span><br><span class="line">    mDismissalRequested=false</span><br><span class="line">    mVisibilityTransactionDepth=0</span><br><span class="line">  LockTaskController</span><br><span class="line">    mLockTaskModeState=NONE</span><br><span class="line">    mLockTaskModeTasks=</span><br><span class="line">    mLockTaskPackages (userId:packages)=</span><br><span class="line">      u0:[]</span><br></pre></td></tr></table></figure><p>最后在 <code>app2</code> 中启动  <code>app1</code> 的 <code>SingleTaskAActivity</code> </p><p><img src="/2019/11/29/【重学Android读书笔记】Activity的任务栈与返回栈/log6.png" alt="log6"></p><p>此时堆栈信息</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">➜  Relearn-Android (master) adb shell</span><br><span class="line">sagit:/ $ dumpsys activity activities</span><br><span class="line">ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)</span><br><span class="line">Display #0 (activities from top to bottom):</span><br><span class="line"></span><br><span class="line">  Stack #1: type=standard mode=fullscreen</span><br><span class="line">    Task id #46</span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;c374b98 #46 A=com.kunminx.relearn_android U=0 StackId=1 sz=3&#125;</span><br><span class="line">        Run #2: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;bb0363c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t46&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;510711c u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.TestMainActivity t46&#125;</span><br><span class="line"></span><br><span class="line">    mResumedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125;</span><br><span class="line"></span><br><span class="line">  Stack #3: type=standard mode=fullscreen</span><br><span class="line">    Task id #48</span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;3b07175 #48 A=com.kunminx.relearn_android_2 U=0 StackId=3 sz=4&#125;</span><br><span class="line">        Run #3: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125;</span><br><span class="line">        Run #2: ActivityRecord&#123;83db884 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;71254 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardOneActivity t48&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;7c135cf u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.TestMainActivity t48&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;9cdafc6 u0 com.kunminx.relearn_android_2/com.kunminx.basicfacttesting.test03_task_test.StandardTwoActivity t48&#125;</span><br><span class="line"></span><br><span class="line">  Stack #0: type=home mode=fullscreen</span><br><span class="line">    Task id #1</span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;185017b #1 I=com.miui.home/.launcher.Launcher U=0 StackId=0 sz=1&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;9fd4f88 u0 com.miui.home/.launcher.Launcher t1&#125;</span><br><span class="line"></span><br><span class="line">  Stack #2: type=standard mode=fullscreen</span><br><span class="line">    Task id #47</span><br><span class="line">    Running activities (most recent first):</span><br><span class="line">      TaskRecord&#123;3387d6 #47 A=com.kunminx.task.c U=0 StackId=2 sz=2&#125;</span><br><span class="line">        Run #1: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125;</span><br><span class="line">        Run #0: ActivityRecord&#123;e9850ca u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskOneActivity t47&#125;</span><br><span class="line"></span><br><span class="line">    mLastPausedActivity: ActivityRecord&#123;6375a1b u0 com.kunminx.relearn_android/com.kunminx.basicfacttesting.test03_task_test.SingleTaskTwoActivity t47&#125;</span><br><span class="line"></span><br><span class="line">  ResumedActivity: ActivityRecord&#123;5afc3da u0 com.kunminx.relearn_android/.SingleTaskAActivity t46&#125;</span><br><span class="line"></span><br><span class="line">  mFocusedStack=ActivityStack&#123;50922c2 stackId=1 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;</span><br><span class="line">  mLastFocusedStack=ActivityStack&#123;50922c2 stackId=1 type=standard mode=fullscreen visible=true translucent=false, 1 tasks&#125;</span><br><span class="line"></span><br><span class="line">  mCurTaskIdForUser=&#123;0=48&#125;</span><br><span class="line">  mUserStackInFront=&#123;&#125;</span><br><span class="line">  displayId=0 stacks=4</span><br><span class="line">   mHomeStack=ActivityStack&#123;a218944 stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks&#125;</span><br><span class="line">  isHomeRecentsComponent=false  KeyguardController:</span><br><span class="line">    mKeyguardShowing=false</span><br><span class="line">    mAodShowing=false</span><br><span class="line">    mKeyguardGoingAway=false</span><br><span class="line">    mOccluded=false</span><br><span class="line">    mDismissingKeyguardActivity=null</span><br><span class="line">    mDismissalRequested=false</span><br><span class="line">    mVisibilityTransactionDepth=0</span><br><span class="line">  LockTaskController</span><br><span class="line">    mLockTaskModeState=NONE</span><br><span class="line">    mLockTaskModeTasks=</span><br><span class="line">    mLockTaskPackages (userId:packages)=</span><br><span class="line">      u0:[]</span><br></pre></td></tr></table></figure><p>此时 <code>app1</code> 的 <code>taskid</code> 46 的<code>TaskRecord</code> 转移到了 栈顶</p><p>接下来返回销毁的逻辑就很清晰了。</p><p><img src="/2019/11/29/【重学Android读书笔记】Activity的任务栈与返回栈/log7.png" alt="log7"></p><p>最后退到 <code>launcher</code> 界面</p><p><strong><code>app1</code> 的 <code>TaskRecord</code> 转移到了 <code>app2</code> 的返回栈中</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;订阅 &lt;a href=&quot;https://xiaozhuanlan.com/topic/9074561823&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;重学安卓&lt;/a&gt; 很久了，最近在整理读书笔记，在此记录之。&lt;/p&gt;
&lt;p&gt;在此隆重推荐这位大佬 KunMinX&lt;/p&gt;
&lt;p&gt;本文记录Activity任务栈与返回栈相关内容的疑问与探索&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="app" scheme="http://yoursite.com/categories/app/"/>
    
    
      <category term="app" scheme="http://yoursite.com/tags/app/"/>
    
      <category term="重学Android" scheme="http://yoursite.com/tags/%E9%87%8D%E5%AD%A6Android/"/>
    
  </entry>
  
  <entry>
    <title>【流水账】Xposed模块开发</title>
    <link href="http://yoursite.com/2019/08/30/%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91Xposed%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/08/30/【流水账】Xposed模块开发/</id>
    <published>2019-08-30T09:18:57.000Z</published>
    <updated>2019-12-02T09:45:48.614Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 <code>how to</code> 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。</p><p>本篇博客是记录一些学习 <code>Xposed</code>模块开发时知识的整理。</p></blockquote><a id="more"></a><h3 id="开发前的准备工作"><a href="#开发前的准备工作" class="headerlink" title="开发前的准备工作"></a>开发前的准备工作</h3><p>查看 <a href="https://github.com/rovo89/XposedBridge/wiki/Using-the-Xposed-Framework-API" target="_blank" rel="noopener">Xposed-Framework-API</a> 根据文档进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">'de.robv.android.xposed:api:82'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AndroidManifest.xml</code> 中 <code>application</code> 标签下加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 应用为模块 --&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=<span class="string">"xposedmodule"</span></span><br><span class="line">    android:value=<span class="string">"true"</span> /&gt;</span><br><span class="line">&lt;!-- 版本信息 该版本号与引用的依赖版本相同--&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=<span class="string">"xposedminversion"</span></span><br><span class="line">    android:value=<span class="string">"82"</span> /&gt;</span><br><span class="line">&lt;!-- 模块描述 --&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=<span class="string">"xposeddescription"</span></span><br><span class="line">    android:value=<span class="string">"Xposed Test"</span> /&gt;</span><br></pre></td></tr></table></figure><p>创建 <code>Hook</code> 类，该类是 <code>Xposed</code> 的入口类，用于拦截加载的 <code>package</code> ，实现 <code>IXposedHookLoadPackage</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yyz.xposedtest;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> hook逻辑  </span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在 <code>src/main</code> 目录下创建assets目录，在该目录中创建 <code>xposed_ini</code> t文件，写入上面创建的 <code>Xposed</code> 的入口类，如下：</p><p><img src="/2019/08/30/【流水账】Xposed模块开发/%E5%85%A5%E5%8F%A3.png" alt="Xposed模块入口"></p><h3 id="XposedHelpers-常用方法"><a href="#XposedHelpers-常用方法" class="headerlink" title="XposedHelpers 常用方法"></a>XposedHelpers 常用方法</h3><h3 id="findAndHookMethod"><a href="#findAndHookMethod" class="headerlink" title="findAndHookMethod"></a>findAndHookMethod</h3><blockquote><p>Look up a method and hook it. The last argument must be the callback for the hook.</p></blockquote><p>最后一个参数主要有两种</p><p><code>XC_MethodHook</code> 在原有方法逻辑上添加逻辑，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在原有方法逻辑上添加逻辑</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 包名 2. classLoader 3. 方法名 4. 参数类型（没有则不添加） 5.Callback</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">XposedHelpers.findAndHookMethod(<span class="string">"cn.bcbook.kaixuetest.MainActivity"</span>,</span><br><span class="line">        lpparam.classLoader, <span class="string">"printViewId"</span>, View.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.beforeHookedMethod(param);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.afterHookedMethod(param);</span><br><span class="line">                Log.i(<span class="string">"yyz"</span>, <span class="string">"afterHookedMethod hook success!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><code>XC_MethodReplacement</code> 替换原有方法逻辑，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换原有方法</span></span><br><span class="line">XposedHelpers.findAndHookMethod(<span class="string">"cn.bcbook.kaixuetest.MainActivity"</span>,</span><br><span class="line">        lpparam.classLoader, <span class="string">"printViewId"</span>, View.class, <span class="keyword">new</span> XC_MethodReplacement() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">replaceHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"yyz"</span>, <span class="string">"hook success!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 &lt;code&gt;how to&lt;/code&gt; 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。&lt;/p&gt;
&lt;p&gt;本篇博客是记录一些学习 &lt;code&gt;Xposed&lt;/code&gt;模块开发时知识的整理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Xposed" scheme="http://yoursite.com/categories/Xposed/"/>
    
    
      <category term="Hook" scheme="http://yoursite.com/tags/Hook/"/>
    
      <category term="Xposed" scheme="http://yoursite.com/tags/Xposed/"/>
    
      <category term="流水账" scheme="http://yoursite.com/tags/%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
  </entry>
  
  <entry>
    <title>【流水账】iptables 常用指令</title>
    <link href="http://yoursite.com/2019/08/29/%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91iptabels%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/08/29/【流水账】iptabels 常用指令/</id>
    <published>2019-08-29T02:10:35.000Z</published>
    <updated>2019-12-02T09:45:48.640Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 <code>how to</code> 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。</p><p>该文总结了 <code>iptables</code> 常用的指令。<code>iptables</code> 详细内容请看双印大佬 <a href="http://www.zsythink.net/archives/tag/iptables/page/2/" target="_blank" rel="noopener">iptables 详解系列</a></p></blockquote><a id="more"></a><h2 id="规则查询"><a href="#规则查询" class="headerlink" title="规则查询"></a>规则查询</h2><h3 id="查看指定表中的规则"><a href="#查看指定表中的规则" class="headerlink" title="查看指定表中的规则"></a>查看指定表中的规则</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -L</span><br></pre></td></tr></table></figure><p>使用 <code>-t</code> 选项，指定要操作的表，使用 <code>-L</code> 选项，查看-t选项对应的表的规则， <code>-L</code> 选项的意思是，列出规则。所以，上述命令的含义为列出filter表的所有规则。</p><p><code>filter</code> 可替换为 <code>raw</code> <code>mangle</code> <code>nat</code></p><p>如果仅查看 <code>filter</code> 可以省略 <code>-t filter</code> ，当没有使用 <code>-t</code> 选项指定表时，默认为操作 <code>filter</code> 表，即 <code>iptables -L</code> 表示列出 <code>filter</code> 表中的所有规则。</p><h3 id="查看指定表中的指定链的规则"><a href="#查看指定表中的指定链的规则" class="headerlink" title="查看指定表中的指定链的规则"></a>查看指定表中的指定链的规则</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L INPUT</span><br></pre></td></tr></table></figure><p>只查看 <code>filter</code> 表中 <code>INPUT</code> 链的规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -vL INPUT</span><br></pre></td></tr></table></figure><p>使用 <code>-v</code> 查看更多，更详细的信息</p><h3 id="不让ip进行反解"><a href="#不让ip进行反解" class="headerlink" title="不让ip进行反解"></a>不让ip进行反解</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -nvL</span><br></pre></td></tr></table></figure><p><code>iptables</code> 默认进行了名称解析，但是在规则非常多的情况下如果进行名称解析，效率会比较低。使用 <code>-n</code> 选项，表示不对 <code>ip</code> 地址进行名称反解，直接显示 <code>ip</code> 地址</p><p>只查看某个链的规则，并且不让 <code>ip</code> 进行反解，<code>iptables -nvL INPUT</code></p><h3 id="显示规则编号"><a href="#显示规则编号" class="headerlink" title="显示规则编号"></a>显示规则编号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables --line-number -nvL INPUT</span><br><span class="line">或</span><br><span class="line">iptables --line -nvL INPUT</span><br></pre></td></tr></table></figure><h2 id="规则管理"><a href="#规则管理" class="headerlink" title="规则管理"></a>规则管理</h2><h3 id="添加规则"><a href="#添加规则" class="headerlink" title="添加规则"></a>添加规则</h3><p><font color="#ff0000">注意：添加规则时，规则的顺序非常重要</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在指定表的指定链的尾部添加一条规则，-A选项表示在对应链的末尾添加规则</span><br><span class="line">命令语法：iptables -t 表名 -A 链名 匹配条件 -j 动作</span><br><span class="line">示例：iptables -t filter -A OUTPUT -s 192.168.10.225 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在指定表的指定链的首部添加一条规则，-I选型表示在对应链的开头添加规则</span><br><span class="line">命令语法：iptables -t 表名 -I 链名 匹配条件 -j 动作</span><br><span class="line">示例： iptables -t filter -I OUTPUT -s 192.168.10.225 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在指定表的指定链的指定位置添加一条规则</span><br><span class="line">命令语法：iptables -t 表名 -I 链名 规则序号 匹配条件 -j 动作</span><br><span class="line">示例： iptables -t filter -I OUTPUT 3 -s 192.168.10.225 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置指定表的指定链的默认策略（默认动作），并非添加规则</span><br><span class="line">命令语法：iptables -t 表名 -P 链名 动作</span><br><span class="line">示例：iptables -t filter -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><h3 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h3><p><font color="ff0000">注意：如果没有保存规则，删除规则时请慎重</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 按照规则序号删除规则，删除指定表的指定链的指定规则，-D选项表示删除对应链中的规则</span><br><span class="line">命令语法：iptables -t 表名 -D 链名 规则序号</span><br><span class="line">示例：iptables -t filter -D INPUT 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按照具体的匹配条件与动作删除规则，删除指定表的指定链的指定规则</span><br><span class="line">命令语法：iptables -t 表名 -D 链名 匹配条件 -j 动作</span><br><span class="line">示例：iptables -t filter -D INPUT -s 192.168.10.225 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除指定表的指定链中的所有规则，-F选项表示清空对应链中的规则</span><br><span class="line">命令语法：iptables -t 表名 -F 链名</span><br><span class="line">示例：iptables -t filter -F INPUT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除指定表中的所有规则</span><br><span class="line">命令语法：iptables -t 表名 -F</span><br><span class="line">示例：iptables -t filter -F OUTPUT</span><br></pre></td></tr></table></figure><h3 id="修改规则"><a href="#修改规则" class="headerlink" title="修改规则"></a>修改规则</h3><p><font color="ff0000">注意：如果使用-R选项修改规则中的动作，那么必须指明原规则中的原匹配条件，例如源ip，目标ip等</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 修改指定表中指定链的指定规则，-R选项表示修改对应链中的规则，使用-R选项时要同时指定对应的链以及规则对应的序号，并且规则中原本的匹配条件不可省略</span><br><span class="line">命令语法：iptables -t 表名 -R 链名 规则序号 规则原本的匹配条件 -j 动作</span><br><span class="line">示例：iptables -t filter -R INPUT 3 -s 192.168.10.225 -j ACCEPT</span><br></pre></td></tr></table></figure><p>上述示例表示修改 <code>filter</code> 表中 <code>INPUT</code> 链的第3条规则，将这条规则的动作修改为 <code>ACCEPT</code> ， <code>-s</code>  <code>192.168.10.225</code> 为这条规则中原本的匹配条件，如果省略此匹配条件，修改后的规则中的源地址可能会变为 <code>0.0.0.0/0</code></p><p>其他修改规则的方法：先通过编号删除规则，再在原编号位置添加一条规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 修改指定表的指定链的默认策略（默认动作），并非修改规则</span><br><span class="line">命令语法：iptables -t 表名 -P 链名 动作</span><br><span class="line">示例：iptables -t filter -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><h3 id="保存规则"><a href="#保存规则" class="headerlink" title="保存规则"></a>保存规则</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 保存规则命令，表示将iptables规则保存至/etc/sysconfig/iptables文件中</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure><h2 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h2><h3 id="基本匹配条件"><a href="#基本匹配条件" class="headerlink" title="基本匹配条件"></a>基本匹配条件</h3><p><code>-s</code> 用于匹配报文的源地址,可以同时指定多个源地址，每个 <code>ip</code> 之间用逗号隔开，也可以指定为一个网段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I INPUT -s 192.168.10.111,192.168.10.225 -j DROP</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.10.0/24 -j ACCEPT</span><br><span class="line">iptables -t filter -I INPUT ! -s 192.168.10.0/24 -j ACCEPT</span><br></pre></td></tr></table></figure><p><code>-d</code> 用于匹配报文的目标地址,可以同时指定多个目标地址，每个 <code>ip</code> 之间用逗号隔开，也可以指定为一个网段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I OUTPUT -d 192.168.10.111,192.168.10.225 -j DROP</span><br><span class="line">iptables -t filter -I INPUT -d 192.168.10.0/24 -j ACCEPT</span><br><span class="line">iptables -t filter -I INPUT ! -d 192.168.10.0/24 -j ACCEPT</span><br></pre></td></tr></table></figure><p><code>-p</code> 用于匹配报文的协议类型,可以匹配的协议类型 <code>tcp</code> 、<code>udp</code> 、<code>udplite</code> 、<code>icmp</code> 、<code>esp</code> 、<code>ah</code> 、<code>sctp</code> 等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp -s 192.168.10.146 -j ACCEPT</span><br><span class="line">iptables -t filter -I INPUT ! -p udp -s 192.168.10.146 -j ACCEPT</span><br></pre></td></tr></table></figure><h3 id="扩展匹配条件"><a href="#扩展匹配条件" class="headerlink" title="扩展匹配条件"></a>扩展匹配条件</h3><ol><li><p><code>tcp</code> 扩展模块</p><p><code>-p tcp -m tcp --sport</code> 用于匹配 <code>tcp</code> 协议报文的源端口，可以使用冒号指定一个连续的端口范围<br><code>-p tcp -m tcp --dport</code> 用于匹配 <code>tcp</code> 协议报文的目标端口，可以使用冒号指定一个连续的端口范围</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp --sport 22 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 22:25 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport :22 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m tcp --dport 80: -j REJECT</span><br><span class="line">iptables -t filter -I OUTPUT -d 192.168.10.225 -p tcp -m tcp ! --sport 22 -j ACCEPT</span><br></pre></td></tr></table></figure></li><li><p><code>multiport</code> 扩展模块</p><p><code>-p tcp -m multiport --sports</code> 用于匹配报文的源端口，可以指定离散的多个端口号,端口之间用”逗号”隔开<br><code>-p udp -m multiport --dports</code> 用于匹配报文的目标端口，可以指定离散的多个端口号，端口之间用”逗号”隔开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I OUTPUT -d 192.168.10.225 -p udp -m multiport --sports 137,138 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport ! --dports 22,80 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 80:88 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.10.225 -p tcp -m multiport --dports 22,80:88 -j REJECT</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><code>udp</code> 模块</p><p><code>--sport</code> 匹配 <code>udp</code> 报文的源地址<br><code>--dport</code> 匹配 <code>udp</code> 报文的目标地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 可以结合multiport模块指定多个离散的端口</span><br><span class="line">iptables -t filter -I INPUT -p udp -m udp --dport 137 -j ACCEPT</span><br><span class="line">iptables -t filter -I INPUT -p udp -m udp --dport 137:157 -j ACCEPT</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p><code>icmp</code> 模块</p><p><code>--icmp-type</code> 匹配 <code>icmp</code> 报文的具体类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p icmp --icmp-type 8 -j REJECT</span><br><span class="line">iptables -t filter -I OUTPUT -p icmp -m icmp --icmp-type 0/0 -j REJECT</span><br><span class="line">iptables -t filter -I OUTPUT -p icmp --icmp-type 0 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p icmp --icmp-type "echo-request" -j REJECT</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p><code>iprange</code> 模块</p><p><code>--src-range</code> 指定连续的源地址范围<br><code>--dst-range</code> 指定连续的目标地址范围</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I INPUT -m iprange --src-range 192.168.10.127-192.168.10.146 -j DROP</span><br><span class="line">iptables -t filter -I OUTPUT -m iprange --dst-range 192.168.10.127-192.168.10.146 -j DROP</span><br><span class="line">iptables -t filter -I INPUT -m iprange ! --src-range 192.168.10.127-192.168.10.146 -j DROP</span><br></pre></td></tr></table></figure></li><li><p><code>stirng</code> 模块</p><p><code>--algo</code> 指定对应的匹配算法，可用算法为 <code>bm</code> 、<code>kmp</code>，此选项为必需选项。<br><code>--string</code> 指定需要匹配的字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string "baidu" -j REJECT</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p><code>time</code> 模块 </p><p><code>--timestart</code> 用于指定时间范围的开始时间，不可取反<br><code>--timestop</code> 用于指定时间范围的结束时间，不可取反<br><code>--weekdays</code> 用于指定”星期几”，可取反<br><code>--monthdays</code> 用于指定”几号”，可取反<br><code>--datestart</code> 用于指定日期范围的开始日期，不可取反<br><code>--datestop</code> 用于指定日期范围的结束时间，不可取反</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I OUTPUT -p tcp --dport 80 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECT</span><br><span class="line">iptables -t filter -I OUTPUT -p tcp --dport 443 -m time --timestart 09:00:00 --timestop 19:00:00 -j REJECT</span><br><span class="line">iptables -t filter -I OUTPUT -p tcp --dport 80  -m time --weekdays 6,7 -j REJECT</span><br><span class="line">iptables -t filter -I OUTPUT -p tcp --dport 80  -m time --monthdays 22,23 -j REJECT</span><br><span class="line">iptables -t filter -I OUTPUT -p tcp --dport 80  -m time ! --monthdays 22,23 -j REJECT</span><br><span class="line">iptables -t filter -I OUTPUT -p tcp --dport 80  -m time --timestart 09:00:00 --timestop 18:00:00 --weekdays 6,7 -j REJECT</span><br><span class="line">iptables -t filter -I OUTPUT -p tcp --dport 80  -m time --weekdays 5 --monthdays 22,23,24,25,26,27,28 -j REJECT</span><br><span class="line">iptables -t filter -I OUTPUT -p tcp --dport 80  -m time --datestart 2017-12-24 --datestop 2017-12-27 -j REJECT</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p><code>connlimit</code> 模块</p><p><code>--connlimit-above</code> 单独使用此选项时，表示限制每个 <code>ip</code> 的链接数量。<br><code>--connlimit-mask</code>  此选项不能单独使用，在使用 <code>--connlimit-above</code> 选项时，配合此选项，则可以针对”某类 <code>ip</code> 段内的一定数量的 <code>ip</code> “进行连接数量的限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT</span><br><span class="line">iptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 20 --connlimit-mask 24 -j REJECT</span><br><span class="line">iptables -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 10 --connlimit-mask 27 -j REJECT</span><br></pre></td></tr></table></figure></li></ol><ol start="9"><li><p><code>limit</code> 模块</p><p><code>--limit-burst</code> 此选项用于指定令牌桶中令牌的最大数量<br><code>--limit</code> 此选项用于指定令牌桶中生成新令牌的频率，可用时间单位有second、minute 、hour、day</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -m limit --limit-burst 3 --limit 10/minute -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p icmp -j REJECT</span><br></pre></td></tr></table></figure></li></ol><h2 id="自定义链"><a href="#自定义链" class="headerlink" title="自定义链"></a>自定义链</h2><h3 id="创建自定义链"><a href="#创建自定义链" class="headerlink" title="创建自定义链"></a>创建自定义链</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在filter表中创建yyz自定义链</span><br><span class="line">iptables -N yyz</span><br></pre></td></tr></table></figure><h3 id="引用自定义链"><a href="#引用自定义链" class="headerlink" title="引用自定义链"></a>引用自定义链</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在OUTPUT链中引用刚才创建的自定义链</span><br><span class="line">iptables -I OUTPUT -j yyz</span><br></pre></td></tr></table></figure><h3 id="重命名自定义链"><a href="#重命名自定义链" class="headerlink" title="重命名自定义链"></a>重命名自定义链</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 将yyz自定义链重命名为test</span><br><span class="line">iptabels -E yyz test</span><br></pre></td></tr></table></figure><h3 id="删除自定义链"><a href="#删除自定义链" class="headerlink" title="删除自定义链"></a>删除自定义链</h3><p>删除自定义链需要满足两个条件</p><ol><li>自定义链中没有被引用</li><li>自定义链中没有任何规则</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 删除引用计数为0且不包含任何规则的test链</span><br><span class="line">iptabels -X test</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 &lt;code&gt;how to&lt;/code&gt; 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。&lt;/p&gt;
&lt;p&gt;该文总结了 &lt;code&gt;iptables&lt;/code&gt; 常用的指令。&lt;code&gt;iptables&lt;/code&gt; 详细内容请看双印大佬 &lt;a href=&quot;http://www.zsythink.net/archives/tag/iptables/page/2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iptables 详解系列&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ROM" scheme="http://yoursite.com/categories/ROM/"/>
    
    
      <category term="流水账" scheme="http://yoursite.com/tags/%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
      <category term="ROM" scheme="http://yoursite.com/tags/ROM/"/>
    
      <category term="framework" scheme="http://yoursite.com/tags/framework/"/>
    
      <category term="iptables" scheme="http://yoursite.com/tags/iptables/"/>
    
      <category term="网络黑白名单" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>【流水账】记录Framework开发的常用指令</title>
    <link href="http://yoursite.com/2019/08/16/%E3%80%90%E6%B5%81%E6%B0%B4%E8%B4%A6%E3%80%91%E8%AE%B0%E5%BD%95Framework%E5%BC%80%E5%8F%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/08/16/【流水账】记录Framework开发的常用指令/</id>
    <published>2019-08-16T06:11:46.000Z</published>
    <updated>2019-12-02T09:45:48.662Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 <code>how to</code> 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。</p><p>本篇博客是记录一些学习 <code>framework</code> 开发时知识的整理。</p></blockquote><a id="more"></a><h3 id="源码全盘编译指令"><a href="#源码全盘编译指令" class="headerlink" title="源码全盘编译指令"></a>源码全盘编译指令</h3><ol><li><code>source build/envsetup.sh</code></li><li>输入 <code>lunch</code> 同时选择欲编译的源码</li><li>编译指令：<code>make -j32 2&gt;&amp;1 | tee build_20190717_1724.log</code></li><li>编译后out目录可查看编译出的镜像</li></ol><p>前两步执行完毕即可执行 <code>mmm</code> 等命令，使用 <code>make clean</code>可以在编译前clean源码，该操作会导致编译时间边长。</p><h3 id="ROM烧录（mtk）"><a href="#ROM烧录（mtk）" class="headerlink" title="ROM烧录（mtk）"></a>ROM烧录（mtk）</h3><ol><li>打开 <code>flash_tool.exe</code></li><li>选择源码的配置文件</li><li>切换下载/全部格式化和下</li><li>点击下载，同时将已关机的设备连接电脑</li><li>等待红条，绿条，黄条走完烧录成功</li></ol><h3 id="ROM写号"><a href="#ROM写号" class="headerlink" title="ROM写号"></a>ROM写号</h3><ol><li>打开 <code>SN Writer.exe</code></li><li>点击 <code>System Config</code> 配置欲写哪些号，点击AP_DB进行配置文件，点击 <code>Save</code></li><li>点击 <code>Start</code> 将关机的设备连入电脑</li></ol><h3 id="源码检出"><a href="#源码检出" class="headerlink" title="源码检出"></a>源码检出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo-local init -u git://&#123;ip&#125;/shupai_android7.1/manifests.git &amp;&amp; repo-local sync -j8 &amp;&amp; repo-local start --all master</span><br></pre></td></tr></table></figure><p>{ip} 使用源码地址替换</p><h3 id="开机动画"><a href="#开机动画" class="headerlink" title="开机动画"></a>开机动画</h3><p><code>/system/media/</code></p><h3 id="重新打包-System-生成镜像"><a href="#重新打包-System-生成镜像" class="headerlink" title="重新打包 System 生成镜像"></a>重新打包 <code>System</code> 生成镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8 snod</span><br></pre></td></tr></table></figure><h3 id="对-Settings-部分的修改"><a href="#对-Settings-部分的修改" class="headerlink" title="对 Settings 部分的修改"></a>对 <code>Settings</code> 部分的修改</h3><ol><li>移除某项（removePreference方法）</li><li>禁用某项 （配置enabled属性）</li><li>隐藏 <code>Settings</code> 主界面选项：<code>TileUtils</code></li></ol><h3 id="三大金刚键"><a href="#三大金刚键" class="headerlink" title="三大金刚键"></a>三大金刚键</h3><ol><li><code>HOME</code> 和  <code>BACK</code><br><code>PhoneWindowManager</code> 类 <code>interceptKeyBeforeDispatching</code> 方法<br>修改 <code>KEYCODE_HOME</code>  <code>KEYCODE_BACK</code> case 中的逻辑 </li><li><code>RECENT</code><br><code>src/com/android/systemui/recents/RecentsImpl</code> 类 <code>startRecentsActivity</code> 方法</li></ol><h3 id="预装应用"><a href="#预装应用" class="headerlink" title="预装应用"></a>预装应用</h3><p><code>device/mediatek/common device.mk</code></p><h3 id="关机-重启操作"><a href="#关机-重启操作" class="headerlink" title="关机 重启操作"></a>关机 重启操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base/services/core/java/com/android/server/policy/GloablActions PowerAction</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写博客是个好习惯，但是写的人水平参差不齐，我见过最搞笑的就是博文的内容是其他博客的链接。本着不误人子弟的原则，我写博客一向很克制。流水账系列是我平时的一些记录，是 &lt;code&gt;how to&lt;/code&gt; 类型的文章，网上相关的资料一搜一大把，仅供自己记录查找。&lt;/p&gt;
&lt;p&gt;本篇博客是记录一些学习 &lt;code&gt;framework&lt;/code&gt; 开发时知识的整理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ROM" scheme="http://yoursite.com/categories/ROM/"/>
    
    
      <category term="流水账" scheme="http://yoursite.com/tags/%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
      <category term="ROM" scheme="http://yoursite.com/tags/ROM/"/>
    
      <category term="framework" scheme="http://yoursite.com/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>多个项目添加依赖同一个模块</title>
    <link href="http://yoursite.com/2019/04/13/%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%90%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/04/13/多个项目添加依赖同一个模块/</id>
    <published>2019-04-13T07:05:24.000Z</published>
    <updated>2019-12-02T09:45:48.739Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>android Studio  中的项目在正常引用module的时候是用复制到项目中的方式进行，单个项目调用还能适用，但是如果多个项目要引用同一个module的时候，如果module中进行了修改，那么每个项目中的module都要进行修改，这样增加了工作量，并且容易出现bug</p><p>因此我们需要引用module ，而不是复制module，实现方法如下</p></blockquote><a id="more"></a><p>新建项目 <code>TestBase</code>，在其 <code>app build.gradle</code> 中将 <code>apply plugin: &#39;com.android.application&#39;</code> 改为<code>apply plugin: &#39;com.android.library&#39;</code> 删除<code>applicationId</code> 配置项，将<code>module</code>名修改为<code>baselib</code>。</p><p>新建项目 <code>TestA</code> 在其<code>settings.gradle</code> 文件中加入下列代码。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">':app'</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">':baselib'</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">':baselib'</span>).projectDir=<span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"../TestBase"</span>, <span class="string">'baselib'</span>)</span><br></pre></td></tr></table></figure><p>引用依赖时正常引用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation project(&apos;:baselib&apos;)</span><br></pre></td></tr></table></figure><p>同步<code>gradle</code> ，此时我们发现<code>baselib</code>出现在<code>TestA</code>项目中。</p><p><img src="/2019/04/13/多个项目添加依赖同一个模块/TestA%E7%9B%AE%E5%BD%95.png" alt="TestA目录.png"></p><p>打开<code>TestA</code> 项目文件夹，我们发现了 <code>baselib</code> 文件夹，下面只有一个<code>baselib.iml</code>文件</p><p><img src="/2019/04/13/多个项目添加依赖同一个模块/TesA%E5%8E%9F%E7%9B%AE%E5%BD%95.png" alt="TesA原目录.png"></p><p>在<code>baselib</code>中加入<code>Utils</code> 工具类</p><p><img src="/2019/04/13/多个项目添加依赖同一个模块/baselib.png" alt="baselib.png"></p><p>切换到<code>TestBase</code>中查看，代码是相同的。</p><p><img src="/2019/04/13/多个项目添加依赖同一个模块/baselib.png" alt="TestBase目录.png"></p><p>这样就达到了<code>baselib</code>被修改后所有引用<code>baselib</code>的项目会同步变化。</p><h4 id="git-同步管理"><a href="#git-同步管理" class="headerlink" title="git 同步管理"></a>git 同步管理</h4><blockquote><p>上述操作都是基于本地的，那么如何加入git管理呢</p></blockquote><p>将<code>TestA</code>和<code>TestBase</code>分别传至<code>github</code></p><p>在<code>TestA</code>项目中打开<code>settings</code>，找到如下位置并将<code>TestBase</code>加入到<code>git</code>管理</p><p><img src="/2019/04/13/多个项目添加依赖同一个模块/%E6%B7%BB%E5%8A%A0git.png" alt="添加git.png"></p><p>然后就可以同步管理这两个项目啦<br><img src="/2019/04/13/多个项目添加依赖同一个模块/%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86.png" alt="同步管理.png"><br><img src="/2019/04/13/多个项目添加依赖同一个模块/gitlog.png" alt="git log.png"></p><p>参考：<br><a href="https://www.jianshu.com/p/47156a6be8ce" target="_blank" rel="noopener">https://www.jianshu.com/p/47156a6be8ce</a><br><a href="https://blog.csdn.net/saintcs/article/details/78567612" target="_blank" rel="noopener">https://blog.csdn.net/saintcs/article/details/78567612</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;android Studio  中的项目在正常引用module的时候是用复制到项目中的方式进行，单个项目调用还能适用，但是如果多个项目要引用同一个module的时候，如果module中进行了修改，那么每个项目中的module都要进行修改，这样增加了工作量，并且容易出现bug&lt;/p&gt;
&lt;p&gt;因此我们需要引用module ，而不是复制module，实现方法如下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="app" scheme="http://yoursite.com/categories/app/"/>
    
    
      <category term="Android Studio" scheme="http://yoursite.com/tags/Android-Studio/"/>
    
      <category term="app" scheme="http://yoursite.com/tags/app/"/>
    
      <category term="gradle" scheme="http://yoursite.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Mac下Android反编译初探</title>
    <link href="http://yoursite.com/2017/07/06/Mac%E4%B8%8BAndroid%E5%8F%8D%E7%BC%96%E8%AF%91%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2017/07/06/Mac下Android反编译初探/</id>
    <published>2017-07-06T08:46:14.000Z</published>
    <updated>2017-07-06T08:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>工作第四天，被要求学习逆向开发方面的知识，于是先将自己之前写的未经混淆的apk反编译，记录之。</p></blockquote><p><a href="http://blog.csdn.net/wj_november/article/details/51527286" target="_blank" rel="noopener">感谢该博文提供的思路</a></p><a id="more"></a><h3 id="1-工具准备"><a href="#1-工具准备" class="headerlink" title="1. 工具准备"></a>1. 工具准备</h3><p><img src="http://upload-images.jianshu.io/upload_images/3155702-569189364ef992cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工具"></p><p>需要的三件套，<a href="http://download.csdn.net/detail/wj_november/9657372" target="_blank" rel="noopener">下载请戳</a></p><ol><li>AndroidCrackTool 用于反编译apk文件<br>与直接解压apk不同，用该工具获得的文件资源可以直接打开阅读，而直接解压得到的是字节码。</li><li>dex2jar 用于将.dex文件转为jar文件<br> 传统的Java程序经过编译，生成Java字节码保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Davik字节码，所有的Davik字节码由Java字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中，Dalvik虚拟机通过解释DEX文件来执行这些字节码。</li><li>jd-gui 用于阅读源码</li></ol><h3 id="2-开始工作"><a href="#2-开始工作" class="headerlink" title="2. 开始工作"></a>2. 开始工作</h3><p>使用AndroidCrackTool反编译apk，设置好目录点击执行按钮，出现end字样即成功。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-9dde0fe67fd84a07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反编译apk"><br>在这里可以查看一些资源文件</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-33d7aeb6f6b20770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看资源文件"><br>将apk以普通解压的方式解压出来，找到其中的classes.dex文件，<br><img src="http://upload-images.jianshu.io/upload_images/3155702-46a0928132602efb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="classes.dex位置"><br>将其复制到dex2jar目录，使用终端进入dex2jar目录并执行如下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh dex2jar.sh classes.dex</span><br></pre></td></tr></table></figure><p>可以看到在dex2jar目录下生成了classes_dex2jar.jar的文件。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-a489b4dd84c84ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终端下操作"></p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-6c746a8c946c3275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成的classes_dex2jar.jar"><br>使用  jd-gui打开classes_dex2jar.jar即可看到源码，可以看到我的apk并没有混淆，所以名字都是正常的命名，经过混淆的名字大都是些字母。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-b7afdfda627a9e6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阅读源码"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;工作第四天，被要求学习逆向开发方面的知识，于是先将自己之前写的未经混淆的apk反编译，记录之。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/wj_november/article/details/51527286&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;感谢该博文提供的思路&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="app" scheme="http://yoursite.com/categories/app/"/>
    
    
      <category term="反编译" scheme="http://yoursite.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Handler深入分析</title>
    <link href="http://yoursite.com/2017/07/04/Handler%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/07/04/Handler深入分析/</id>
    <published>2017-07-03T23:46:14.000Z</published>
    <updated>2017-07-03T23:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在android中我们可以有很多方式去实现异步，比如AsyncTask，Rxjava。不过它们底层都是使用的Handler，所以我们来研究一下Handelr的实现。</p></blockquote><a id="more"></a><h3 id="1-TreadLocal的使用"><a href="#1-TreadLocal的使用" class="headerlink" title="1. TreadLocal的使用"></a>1. TreadLocal的使用</h3><p>下面我们来写一个小demo，创建两个子线程，在两个子线程中分别为字符串result2，result3赋值，在主线程中调用两个子线程，并且为字符串result1赋值，最后打印输出结果。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-2e352e80d8f708cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主线程"></p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-3593c9860a191e71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子线程1"></p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-106032139bef8248.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子线程2"></p><p>最后我们看一下打印结果</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-0fded8b582305652.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试结果"></p><p>很明显，这不是我们想要的结果。看来线程之间相互影响了，那么有没有办法实现上述的功能呢？</p><p>当然有，我们可以使用 TreadLocal</p><blockquote><p>我们可以把TreadLocal看做成一个容器，调用其中的set和get方法，可以设值和取值。下面我们看看是如何实现的。</p></blockquote><p>首先创建一个ThreadLocal对象，并设置泛型为String<br><img src="http://upload-images.jianshu.io/upload_images/3155702-b274968c0d87042d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ThreadLocal"><br>这里不同的是首先将要打印的字串放入ThreadLocal中，然后从ThreadLocal中取出。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-b8a37fcc57787a3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主线程"></p><p>子线程的操作也是类似的。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-9b8b4a3c8f495526.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子线程"></p><p>下面我们看一下打印结果</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-71885237f2c74d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p><p>这样就完成了上述功能。那么这里说的ThreadLocal与Handler有什么关系呢？别急，往下看。</p><h3 id="2-在子线程中创建Handelr"><a href="#2-在子线程中创建Handelr" class="headerlink" title="2. 在子线程中创建Handelr"></a>2. 在子线程中创建Handelr</h3><p>我们在子线程中创建一个Handler对象，然后运行程序。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-4673d3b294d1ff08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子线程中创建Handler对象"></p><p>可以看到运行时出现了异常</p><blockquote><p> java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3155702-42a0e89fbd6cfe2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常"><br>看字面意思是不能在调用Looper.prepare()之前在线程中创建handler。<br>那么我们在创建handler之前去调用Looper.prepare()。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-036e11a4312a1dd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用Looper.prepare()"><br>之后就能成功运行了。</p><p>那么我们来研究一下为什么会这样。<br>鼠标放在Handler()上，win按住control+鼠标左键，Mac按住command+鼠标左键。进入Handler的构造器。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-ddcf57bb316f4d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler构造器"><br>点击this</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-322cff8f6407b3f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更进一步"></p><p>我们找到了源头，如果looper为空则抛出这个异常。</p><p>在这里从looper里取出mQueue赋值给mQueue</p><p>然后我们看一下这个Looper.prepare方法，<br><img src="http://upload-images.jianshu.io/upload_images/3155702-8092676c88450ad6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="prepare"></p><p>上方的注释说得很清楚，在真正开始这个loop之前，该方法为你提供了创建引用这个looper的handelr的机会。在调用完该方法后，应该确保调用了loop()方法，并且使用quit()方法去结束它。</p><p>我们还看到如果多次调用prepare方法会抛出Only one Looper may be created per thread异常。<br>在这里我们看到了熟悉的身影，ThreadLocal。在这里使用ThreadLocal来存looper。</p><p>看到这我们不禁要问，在主线程我们并没有调用prepare方法啊，没错，在主线程使用的是prepareMainLooper<br><img src="http://upload-images.jianshu.io/upload_images/3155702-28263341bcc4e038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="prepareMainLooper"><br>可以看到这个main looper已经被android environment创建了，所以不需要自己调用该方法。</p><p>下面我们来看一下在子线程中创建Handler的标准写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLooper</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            Looper.prepare();</span><br><span class="line">            mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Message的发送和处理过程"><a href="#3-Message的发送和处理过程" class="headerlink" title="3. Message的发送和处理过程"></a>3. Message的发送和处理过程</h3><p>Handler里提供了几个消息入队的方法</p><blockquote><p>post()<br>postAtTime()<br>postDelayed()<br>postAtFrontOfQueue()<br>sendMessageAtTime(Message msg , long uptimeMillis)</p></blockquote><p>其中post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-8f15bc3b507a098f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="post"><br><img src="http://upload-images.jianshu.io/upload_images/3155702-1b8a08501a2a9251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="postAtTime"><br><img src="http://upload-images.jianshu.io/upload_images/3155702-c5ef6085b80726ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="postDelayed"><br><img src="http://upload-images.jianshu.io/upload_images/3155702-dbe0fccf4cc81722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sendMessageDelayed"><br>下面我们看一下sendMessageAtTime方法</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-678aac95b1c8ad85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sendMessageAtTime"></p><p>有两个参数，msg 和uptimeMillis ，如果消息队列为空，则打印警告，同时返回false。反之则调用enqueueMessage方法。</p><p>下面看一下enqueueMessage</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-ba4cd0593a2e8df7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enqueueMessage"><br>这里有两个比较重要的操作。<br>msg.target赋值为this，有两层含义，一是message的来源是当前handler，二是当前的handler来处理消息。<br>将消息加入到消息队列中，既然是队列就有顺序，那么根据什么来判断顺序呢？就是根据uptimeMillis,这个时间，时间短就在前面，长就在后面。</p><p>细心的你可能发现刚刚我提到post()，postAtTime()，postDelayed()都会直接或间接调用sendMessageAtTime方法，那postAtFrontOfQueue()呢？<br>从字面上看该方法是将消息置于消息队列的最前边。是不是这样呢？我们看一下源码。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-76f2c74c7c0a3e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="postAtFrontOfQueue"><br>这里将入队的时间参数直接写死为0，那么肯定就是消息队列的最前边啦。</p><p>我们再来分析下入队之后的过程，上文提到调用Looper.prepare()方法后应调用Looper.loop()方法开始消息的轮询。那么我们看看loop方法做了些什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3155702-5797c552356958b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="looper"><br>首先从ThreadLocal中取出looper并判断是否为空，之后将looper中的消息队列赋值，再然后进入一个死循环，循环内去不断寻找消息队列的下一项，没有消息发生阻塞。</p><p>找到 msg.target.dispatchMessage(msg);这一行，<br>之前我们提到target就是handler对象，这里handler把消息派发出去，接下来就进入消息的处理了。</p><p>进入到msg.target.dispatchMessage方法，<br><img src="http://upload-images.jianshu.io/upload_images/3155702-3d37b2fa8bb03c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatchMessage"><br>这里分三步<br>1.判断msg的回调是否为空<br> 如果不为空则直接该回调自己处理，反之判断自己的回调</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-5cabf5368375e861.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="message的回调"><br>把Runnable 封装成msg的callback</p><p>2.判断自己的回调是否为空<br>3.调用handleMessage方法</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-ad49dc188525989f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="handleMessage"><br>这里由子类重写来处理message</p><h3 id="4-Handler机制的总结"><a href="#4-Handler机制的总结" class="headerlink" title="4. Handler机制的总结"></a>4. Handler机制的总结</h3><blockquote><p>Thread 负责业务逻辑<br>Handler 负责发送消息和处理消息<br>MessageQueue 负责保存消息<br>Looper 负责轮询消息队列</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在android中我们可以有很多方式去实现异步，比如AsyncTask，Rxjava。不过它们底层都是使用的Handler，所以我们来研究一下Handelr的实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="app" scheme="http://yoursite.com/categories/app/"/>
    
    
      <category term="handler" scheme="http://yoursite.com/tags/handler/"/>
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>2.2从教务系统查询成绩并计算绩点——山东建筑大学为例</title>
    <link href="http://yoursite.com/2017/06/18/2-2%E4%BB%8E%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9F%A5%E8%AF%A2%E6%88%90%E7%BB%A9%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%BB%A9%E7%82%B9%E2%80%94%E2%80%94%E5%B1%B1%E4%B8%9C%E5%BB%BA%E7%AD%91%E5%A4%A7%E5%AD%A6%E4%B8%BA%E4%BE%8B/"/>
    <id>http://yoursite.com/2017/06/18/2-2从教务系统查询成绩并计算绩点——山东建筑大学为例/</id>
    <published>2017-06-18T15:57:00.000Z</published>
    <updated>2017-06-18T15:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前两天面试时被问到绩点是多少，但学校教务系统不提供绩点查询的功能，那么能不能写一个爬虫程序并计算出绩点呢？答案是肯定的！</p></blockquote><p> <a href="http://blog.csdn.net/pleasecallmewhy/article/details/9305229" target="_blank" rel="noopener">感谢该博客提供的思路</a></p><a id="more"></a><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h3><p>HttpFox插件，是一款http协议分析插件，分析页面请求和响应的时间、内容、以及浏览器用到的COOKIE等。是火狐浏览器的插件。谷歌浏览器和Safari都有自带的分析工具，可是感觉太复杂，没有这款好用。不过火狐浏览器对学校的教务系统兼容性不是很好，我还下载了IE tab插件。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-79a8f42d306c605c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插件的安装"></p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-fdddcc6520d47f18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>可以非常直观的查看相应的信息。<br>点击start是开始检测，点击stop暂停检测，点击clear清除内容。</p><h3 id="2-探究过程"><a href="#2-探究过程" class="headerlink" title="2. 探究过程"></a>2. 探究过程</h3><p>下面就去山东建筑大学官网登录到数字校园综合信息门户，看一看在登录的时候，到底发送了那些信息。<br>先来到登录页面，把httpfox打开，clear之后，点击start开启检测：</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-0a6c714e2c2ff3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开启检测"><br>输入完账号密码，确保httpfox处于开启状态，然后点击登录。<br>这个时候可以看到，httpfox检测到了好多信息：<br><img src="http://upload-images.jianshu.io/upload_images/3155702-d757be497cda18ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="捕捉到的信息"></p><p>那么我们来分析一下这些数据</p><p>看起来红框里的两条数据比较有意思，先看看这个post</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-f72b7d8e3375dafc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="post数据"></p><p>PostData中我们看到了比较熟悉的词，username和password，学过java web的我们很清楚这段数据的含义，点击登录后将这用户名和你们提交到服务器比对。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-2a025613cb9cd840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重定向到这里"></p><p>可以看到这里使用get的方式在链接上以?的方式显示的加上了参数，跳转到信息门户。<br>我们的post的数据就发送到了这个地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal</span><br></pre></td></tr></table></figure><p>需要的post数据是用户名密码，也就是说我们需要输入这两种数据来模拟登录过程。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-40ea67af08eb6ab1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进入到教务系统"></p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-c30fa7de450e5621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击成绩查询"><br>进入教务系统后点击成绩查询，我们看到请求的地址为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690</span><br></pre></td></tr></table></figure><p>我们整理一下整个过程的思路。</p><ol><li>POST学号和密码—&gt;然后返回cookie的值</li><li>发送cookie给服务器—&gt;返回页面信息。</li><li>获取到成绩页面的数据，用正则表达式将成绩和学分单独取出并计算加权平均数。</li></ol><p>ok，理顺思路后剩下的就只有编码问题了。</p><h3 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h3><p>我们先来实验下是否能够获得查询成绩界面的源码</p><p>我们先准备一个POST的数据，再准备一个cookie的接收，然后写出源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">import urllib</span><br><span class="line">import urllib2</span><br><span class="line">import cookielib</span><br><span class="line"></span><br><span class="line">cookie = cookielib.CookieJar()</span><br><span class="line">opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))</span><br><span class="line"></span><br><span class="line"># 需要的POST数据</span><br><span class="line">postdata = urllib.urlencode(&#123;</span><br><span class="line">    &apos;userName&apos;: &apos;20140216064&apos;,</span><br><span class="line">    &apos;password&apos;: &apos;*********&apos;</span><br><span class="line">&#125;)</span><br><span class="line"># 自定义一个请求</span><br><span class="line">req1 = urllib2.Request(</span><br><span class="line">    url=&apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos;,</span><br><span class="line">    data=postdata</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">req2 = urllib2.Request(</span><br><span class="line">    url=&apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 访问登录链接</span><br><span class="line">opener.open(req1)</span><br><span class="line">result = opener.open(req2)</span><br><span class="line"># 打印返回的内容</span><br><span class="line">print result.read()</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3155702-c2476106a0e29a70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p><p>很棒呦，看来跟我们预期的一样。</p><h3 id="4-整理数据"><a href="#4-整理数据" class="headerlink" title="4. 整理数据"></a>4. 整理数据</h3><blockquote><p>获得了成绩查询界面的源码后我们需要将数据进行整理，获得我们想要的数据，课程名称，学分，成绩。</p></blockquote><p>将网页源码贴到Sublime Text中，方便我们查看源码</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-480626d6803e99fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分析源码"><br><img src="http://upload-images.jianshu.io/upload_images/3155702-6a978cc4d4c27ba1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分析源码"><br>通过查看源码我们看到从这个<div>开始到3640行都是关于成绩的代码，而成绩是存放在这个table标签下。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-b1573f6441632f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要提取的信息"><br>红色框中分别为课程名，学分，以及成绩。这些是我们需要抽取出来的数据。<br>看到这里竟然有意外收获！注意黄色框被注释的部分，看来学校的教务系统有计算绩点的功能的，不知由于何种原因不用呢？</div></p><p>这里是这段程序中最困难的部分，我也踩了很多坑。我参照的博客是使用正则表达式来抽取想要的信息的，但我对正则表达式掌握的并不好，弄了好久也没写出合适的表达式，于是我果断放弃了使用正则表达式，采用BeautifulSoup来进行信息的筛选。<br><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">BeautifulSoup用法参考</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 将内容从页面源码中提取出来</span><br><span class="line">   def deal_data(self, myPage):</span><br><span class="line"></span><br><span class="line">       soup = BeautifulSoup(myPage)</span><br><span class="line"></span><br><span class="line">       # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签)</span><br><span class="line">       trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;)</span><br><span class="line"></span><br><span class="line">       # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩</span><br><span class="line">       for tr in trs:</span><br><span class="line">           for index, td in enumerate(tr.findAll(&apos;td&apos;)):  # enumerate能在for循环中使用下标</span><br><span class="line"></span><br><span class="line">               if index == 3:</span><br><span class="line">                   print td.text</span><br><span class="line">               elif index == 7:</span><br><span class="line">                   self.weights.append(td.text.encode(&apos;utf8&apos;))</span><br><span class="line">                   print td.text</span><br><span class="line">               elif index == 8:</span><br><span class="line">                   self.points.append(td.text.encode(&apos;utf8&apos;))</span><br><span class="line">                   print td.text</span><br><span class="line"></span><br><span class="line">           print</span><br></pre></td></tr></table></figure><p>整个逻辑我简单说一下，我觉得还可以改进。<br>首先查找title属性为”有效成绩“的标签，通过上文的截图我们可以知道这是那个div标签，之后在该div标签中定位class为t_con的tr标签。你也许会问为什么不直接定位到tr标签，因为后面的网页代码中还存在class 为t_con的tr标签，但不是我们需要的成绩。然后在每个tr标签下抽取下标为3，7，8的标签，这里我是把它存到数组里了。<br>接下来就清晰了，先打印成绩信息，然后计算绩点。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-f6d0aff398d0089a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行截图"></p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-3d48f5287d16407e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行截图"><br>学渣一个，绩点低请忽略。</p><p>源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># encoding=utf8</span><br><span class="line">import urllib</span><br><span class="line">import urllib2</span><br><span class="line">import cookielib</span><br><span class="line">import re</span><br><span class="line">import string</span><br><span class="line">from BeautifulSoup import BeautifulSoup</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;utf8&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SDJZU_Crawler:</span><br><span class="line">    # 声明相关的属性</span><br><span class="line">    def __init__(self):</span><br><span class="line"></span><br><span class="line">        self.loginUrl = &apos;http://urpe.sdjzu.edu.cn/loginPortalUrlForIndexLogin.portal&apos;  # 登录的url</span><br><span class="line">        self.resultUrl = &apos;http://jwfw1.sdjzu.edu.cn/ssfw/jwnavmenu.do?menuItemWid=1E057E24ABAB4CAFE0540010E0235690&apos;  # 查询成绩的url</span><br><span class="line">        self.cookieJar = cookielib.CookieJar()  # 初始化一个CookieJar来处理Cookie的信息</span><br><span class="line">        self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: &apos;&apos;, &apos;password&apos;: &apos;&apos;&#125;)  # 登录需要POST的数据</span><br><span class="line">        self.weights = []  # 存储权重，也就是学分</span><br><span class="line">        self.points = []  # 存储分数，也就是成绩</span><br><span class="line">        self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.cookieJar))</span><br><span class="line"></span><br><span class="line">    def sdjzu_init(self):</span><br><span class="line">        username = raw_input(&apos;请输入学号:&apos;)  # 这里不要用input，二者区别请自行查询</span><br><span class="line">        password = raw_input(&apos;请输入密码:&apos;)</span><br><span class="line">        self.postdata = urllib.urlencode(&#123;&apos;userName&apos;: username, &apos;password&apos;: password&#125;)  # 将用户名密码加入到POST中</span><br><span class="line">        # 初始化链接并且获取cookie</span><br><span class="line">        myRequest = urllib2.Request(url=self.loginUrl, data=self.postdata)  # 自定义一个请求</span><br><span class="line">        result = self.opener.open(myRequest)  # 访问登录页面，获取到必须的cookie的值</span><br><span class="line">        result = self.opener.open(self.resultUrl)  # 访问成绩页面，获得成绩的数据</span><br><span class="line">        self.deal_data(result.read())</span><br><span class="line">        self.calculate_gpa()</span><br><span class="line"></span><br><span class="line">    # 将内容从页面源码中提取出来</span><br><span class="line">    def deal_data(self, myPage):</span><br><span class="line"></span><br><span class="line">        soup = BeautifulSoup(myPage)</span><br><span class="line"></span><br><span class="line">        # 从title属性为有效成绩的标签中获取所有class属性为t_con的TAG(tr标签)</span><br><span class="line">        trs = soup.find(attrs=&#123;&quot;title&quot;: &quot;有效成绩&quot;&#125;).findAll(attrs=&#123;&quot;class&quot;: &quot;t_con&quot;&#125;)</span><br><span class="line"></span><br><span class="line">        # 从tr标签中的td标签中获取需要的信息。下标为3，7，8的分别为课程名，学分，成绩</span><br><span class="line">        for tr in trs:</span><br><span class="line">            for index, td in enumerate(tr.findAll(&apos;td&apos;)):  # enumerate能在for循环中使用下标</span><br><span class="line"></span><br><span class="line">                if index == 3:</span><br><span class="line">                    print td.text</span><br><span class="line">                elif index == 7:</span><br><span class="line">                    self.weights.append(td.text.encode(&apos;utf8&apos;))</span><br><span class="line">                    print td.text</span><br><span class="line">                elif index == 8:</span><br><span class="line">                    self.points.append(td.text.encode(&apos;utf8&apos;))</span><br><span class="line">                    print td.text</span><br><span class="line"></span><br><span class="line">            print</span><br><span class="line"></span><br><span class="line">    # 计算绩点，如果成绩还没出来，就不算该成绩，</span><br><span class="line">    def calculate_gpa(self):</span><br><span class="line">        point = 0.0  # 成绩</span><br><span class="line">        weight = 0.0  # 学分</span><br><span class="line">        for i in range(len(self.points)):</span><br><span class="line">            if self.points[i].isdigit() and (self.weights[i] != 0):</span><br><span class="line">                point += string.atof(self.points[i]) * string.atof(self.weights[i])  # 成绩*学分累加求和</span><br><span class="line">                weight += string.atof(self.weights[i])  # 学分累加求和</span><br><span class="line"></span><br><span class="line">        print &quot;绩点为：&quot;</span><br><span class="line">        print point / weight  # 输出绩点 值成绩*学分累加求和 / 学分累加求和</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line">mySpider = SDJZU_Crawler()</span><br><span class="line">mySpider.sdjzu_init()</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Flywith24" target="_blank" rel="noopener">我的github地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前两天面试时被问到绩点是多少，但学校教务系统不提供绩点查询的功能，那么能不能写一个爬虫程序并计算出绩点呢？答案是肯定的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;a href=&quot;http://blog.csdn.net/pleasecallmewhy/article/details/9305229&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;感谢该博客提供的思路&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>2.1开始第一个爬虫程序</title>
    <link href="http://yoursite.com/2017/06/18/2-1%E5%BC%80%E5%A7%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/06/18/2-1开始第一个爬虫程序/</id>
    <published>2017-06-18T02:05:00.000Z</published>
    <updated>2017-06-18T02:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装IDE以及hello-world"><a href="#1-安装IDE以及hello-world" class="headerlink" title="1. 安装IDE以及hello world"></a>1. 安装IDE以及hello world</h3><blockquote><p>一个优秀的IDE可以极大地提高工作效率，在这里我选择使用JetBrains公司的PyCharm。是不是有些眼熟？没错，IDEA 和Android Studio就是他们做的，JetBrains出品，必属精品。</p></blockquote><a id="more"></a><p><a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">点击进入下载链接</a></p><p>点击download选择相应平台及版本，我这里选择的是社区版。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-752e691985633d3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载界面"></p><p>安装过程，切换主题，调整字体之类的都跟跟IDEA类似，不需赘述。</p><p>那么开始我们的hello world程序吧。<br>新建一个Python file ，然后写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print (&quot;hello world&quot;)</span><br></pre></td></tr></table></figure><p>第一次运行在工作区右击 run即可</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-4ffc1a9c05699113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右击运行"><br>之后就会在Toolbar上显示run按钮了</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-a540d17991f6282d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行截图"><br>很棒有木有</p><h3 id="2-1-先爬他一个网页下来"><a href="#2-1-先爬他一个网页下来" class="headerlink" title="2.1 先爬他一个网页下来"></a>2.1 先爬他一个网页下来</h3><p>敲入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line"></span><br><span class="line">response = urllib2.urlopen(&quot;http://www.baidu.com&quot;)</span><br><span class="line">print response.read()</span><br></pre></td></tr></table></figure><p>点击运行，我们可以得到结果</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-165b12f5711bcd47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这个网页的源码被我们爬下来了，是不是很简单！</p><h3 id="2-2-分析代码"><a href="#2-2-分析代码" class="headerlink" title="2.2 分析代码"></a>2.2 分析代码</h3><p>下面我们来分析下这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br></pre></td></tr></table></figure><p>urllib2库是学习Python爬虫最基本的模块，利用这个模块我们可以得到网页的内容，并对内容用正则表达式提取分析，得到我们想要的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = urllib2.urlopen(&quot;http://www.baidu.com&quot;)</span><br></pre></td></tr></table></figure><p>首先我们调用的是urllib2库里面的urlopen方法，传入一个URL，这个网址是百度首页，协议是HTTP协议，urlopen一般接受三个参数，它的参数如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-f03abc16265de8dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="urlopen参数"></p><p>第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。</p><p>第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT</p><p>第一个参数URL是必须要传送的，在这个例子里面我们传送了百度的URL，执行urlopen方法之后，返回一个response对象，返回信息便保存在这里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print response.read()</span><br></pre></td></tr></table></figure><p>response对象有一个read方法，可以返回获取到的网页内容</p><h3 id="2-3-构造Request"><a href="#2-3-构造Request" class="headerlink" title="2.3 构造Request"></a>2.3 构造Request</h3><p>上面的urlopen参数可以传入一个request请求,它其实就是一个Request类的实例，构造时需要传入Url,Data等等的内容。我们可以将上面的代码改写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line"></span><br><span class="line">request = urllib2.Request(&quot;http://www.baidu.com&quot;)</span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">print response.read()</span><br></pre></td></tr></table></figure><p>运行结果是完全一样的，只不过中间多了一个request对象，推荐大家这么写，因为在构建请求时还需要加入好多内容，通过构建一个request，服务器响应请求得到应答，这样显得逻辑上清晰明确。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-安装IDE以及hello-world&quot;&gt;&lt;a href=&quot;#1-安装IDE以及hello-world&quot; class=&quot;headerlink&quot; title=&quot;1. 安装IDE以及hello world&quot;&gt;&lt;/a&gt;1. 安装IDE以及hello world&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个优秀的IDE可以极大地提高工作效率，在这里我选择使用JetBrains公司的PyCharm。是不是有些眼熟？没错，IDEA 和Android Studio就是他们做的，JetBrains出品，必属精品。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>1.1使用函数</title>
    <link href="http://yoursite.com/2017/06/05/1-1%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/06/05/1-1使用函数/</id>
    <published>2017-06-05T13:58:00.000Z</published>
    <updated>2017-06-05T13:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们编程时很容易疲劳，所以让我们来设计一个可以在一段时间后提醒你休息的小程序。比如每隔两个小时打开<a href="http://lines.frvr.com" target="_blank" rel="noopener">http://lines.frvr.com</a> 此网站来玩一会儿小游戏。</p></blockquote><a id="more"></a><p>让我们来分析下需要哪些步骤<br>我们首先要让程序等待两个小时，在需要休息的时候打开浏览器并转到这个小游戏的网站。也许我们一天要休息多次，所以我们需要一个循环来让其实现多次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 等待两小时</span><br><span class="line">2. 打开浏览器</span><br><span class="line">重复</span><br></pre></td></tr></table></figure><p>现在，让我们开始吧~</p><p>首先让我们google一下如何用Python来打开浏览器<br><img src="http://upload-images.jianshu.io/upload_images/3155702-ec11c33f9934a657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查询Pyhon如何打开浏览器"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webbrowser.open(&quot;http://lines.frvr.com&quot;)</span><br></pre></td></tr></table></figure><p>可以看到上述代码可以使用默认浏览器打开指定网页。</p><p>让我们试试吧~<br><img src="http://upload-images.jianshu.io/upload_images/3155702-ebeadc44e9ed109a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="保存"><br>保存并执行</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-07994ea86762efd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行截图"></p><p>出现了错误，不过学过java的你肯定能看懂是什么原因。</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-5f2951beae5bec8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修正"><br>导入webbrowser模块就可以正常运行了，不要被这个网站的小游戏吸引走哦，我们还没有结束。</p><p>下面我们看看Python如何能让程序等待2小时，为了方便测试，我们把等待时间设置为3秒</p><p><img src="http://upload-images.jianshu.io/upload_images/3155702-0690b4988c6f6ae1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Python让程序等待"></p><p>可以看到使用time.sleep()方法可以是程序等待一段时间执行，参数以秒为单位<br>所以我们在程序中添加以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure><p>当然也要导入相应模块。<br><img src="http://upload-images.jianshu.io/upload_images/3155702-3d2bb6b60a4ff0e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>很简单有没有？</p><p>接下来我们来让其循环3次</p><p>输入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import webbrowser</span><br><span class="line">import time</span><br><span class="line">total_breaks = 3</span><br><span class="line">break_count = 0</span><br><span class="line"></span><br><span class="line">print(&quot;This program started on&quot; + time.ctime())</span><br><span class="line">while(break_count &lt; total_breaks):</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    webbrowser.open(&quot;http://lines.frvr.com&quot;)</span><br><span class="line">    break_count = break_count + 1</span><br></pre></td></tr></table></figure><p>代码很简单，首先我们定义了总的休息次数为3，我们又定义了已休息次数初始值为0。接下来是一个while循环，当已休息次数小于总休息次数时执行循环体。最后将已休息次数加1。</p><p>值得注意的是while循环并没有花括号。</p><p>学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。<br>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if True:</span><br><span class="line">    print &quot;True&quot;</span><br><span class="line">else:</span><br><span class="line">  print &quot;False&quot;</span><br></pre></td></tr></table></figure><p>以下代码将会执行错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"># 文件名：test.py</span><br><span class="line"> if True:</span><br><span class="line">    print &quot;Answer&quot;</span><br><span class="line">    print &quot;True&quot;</span><br><span class="line">else:</span><br><span class="line">    print &quot;Answer&quot;</span><br><span class="line">    # 没有严格缩进，在执行时会报错</span><br><span class="line">  print &quot;False&quot;</span><br></pre></td></tr></table></figure><p>执行以上代码，会出现如下错误提醒：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py  </span><br><span class="line">  File &quot;test.py&quot;, line 5</span><br><span class="line">    if True:</span><br><span class="line">    ^</span><br><span class="line">IndentationError: unexpected indent</span><br></pre></td></tr></table></figure><p> IndentationError: unexpected indent 错误是 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有 python 对格式要求非常严格。<br>如果是 IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。<br>因此，在 Python 的代码块中必须使用相同数目的行首缩进空格数。<br>建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们编程时很容易疲劳，所以让我们来设计一个可以在一段时间后提醒你休息的小程序。比如每隔两个小时打开&lt;a href=&quot;http://lines.frvr.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://lines.frvr.com&lt;/a&gt; 此网站来玩一会儿小游戏。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
